{"id": "geeksforgeeks_2645_A", "java": ["public class Improve { static int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ ] = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } public static void main ( String args [ ] ) { int n = 6 ; System . out . println ( \" Sum \u2581 of \u2581 squares \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \u2581 \" + calculateSquareSum ( n ) ) ; } }"], "python": ["def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( \" Sum \u2581 of \u2581 squares \u2581 of \u2581 Fibonacci \u2581 numbers \u2581 is \u2581 : \" , calculateSquareSum ( n ) ) ; NEW_LINE"]}
{"id": "codeforces_176_B", "java": ["import java . util . Scanner ; public class NewProblem { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; String start = s . next ( ) ; String end = s . next ( ) ; int n = start . length ( ) ; int k = s . nextInt ( ) ; int amount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { String str = start . substring ( i , n ) + start . substring ( 0 , i ) ; if ( str . equals ( end ) ) amount ++ ; } if ( amount == 0 && ! start . equals ( end ) ) { System . out . println ( 0 ) ; System . exit ( 0 ) ; } long x = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( i % 2 == 0 ) x = ( x * ( n - 1 ) + 1 ) % 1000000007 ; else x = ( x * ( n - 1 ) - 1 ) % 1000000007 ; } long ans = amount * x ; if ( start . equals ( end ) ) { if ( k % 2 == 0 ) ans += x + 1 ; else ans += x - 1 ; } System . out . println ( ans % 1000000007 ) ; } }"], "python": ["start , end , k = input ( ) , input ( ) , int ( input ( ) ) NEW_LINE n , mod = len ( end ) , 10 ** 9 + 7 NEW_LINE dp = [ 1 , 0 ] NEW_LINE psum = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT dp [ 0 ] = psum - dp [ 0 ] NEW_LINE dp [ 1 ] = psum - dp [ 1 ] NEW_LINE psum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if start [ i : ] + start [ : i ] == end : NEW_LINE INDENT if i == 0 : ans += dp [ 0 ] NEW_LINE else : ans += dp [ 1 ] NEW_LINE DEDENT DEDENT print ( ans % mod ) NEW_LINE", "MOD = int ( 1e9 ) + 7 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = input ( ) NEW_LINE b = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE if ( len ( a ) != len ( b ) ) : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT a = a + a NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( len ( a ) // 2 ) : NEW_LINE INDENT flag = 1 NEW_LINE for j in range ( len ( b ) ) : NEW_LINE INDENT if ( a [ j + i ] != b [ j ] ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT DEDENT u = 1 NEW_LINE v = 0 NEW_LINE if ( flag == 1 ) : NEW_LINE INDENT v = 1 NEW_LINE u = 0 NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT uu = ( u * ( x - 1 ) ) % MOD + ( v * ( x ) ) % MOD NEW_LINE vv = ( u * ( y ) ) % MOD + ( v * ( y - 1 ) ) % MOD NEW_LINE u = uu % MOD NEW_LINE v = vv % MOD NEW_LINE DEDENT print ( u ) NEW_LINE DEDENT", "MOD = int ( 1e9 ) + 7 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , k = input ( ) , input ( ) , int ( input ( ) ) NEW_LINE x , y = ( 1 , 0 ) if a == b else ( 0 , 1 ) NEW_LINE n = len ( b ) NEW_LINE b += b NEW_LINE same = sum ( a == b [ i : i + n ] for i in range ( n ) ) NEW_LINE diff = n - same NEW_LINE for _ in range ( k ) : NEW_LINE INDENT x , y = ( ( x * ( same - 1 ) ) % MOD + ( y * same ) % MOD ) % MOD , ( ( x * ( diff ) ) % MOD + ( y * ( diff - 1 ) ) % MOD ) % MOD NEW_LINE DEDENT print ( x ) NEW_LINE DEDENT", "def main ( ) : NEW_LINE INDENT MOD = int ( 1e9 + 7 ) NEW_LINE a = input ( ) NEW_LINE b = input ( ) NEW_LINE n = int ( input ( ) ) NEW_LINE ca , cb = 0 , 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT s = a [ i : ] + a [ : i ] NEW_LINE if s == b : NEW_LINE INDENT ca += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cb += 1 NEW_LINE DEDENT DEDENT if ca == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT da = [ 0 ] * ( n + 1 ) NEW_LINE db = da [ : ] NEW_LINE da [ 0 ] = 1 if a == b else 0 NEW_LINE db [ 0 ] = 1 - da [ 0 ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT da [ i ] = da [ i - 1 ] * ( ca - 1 ) + db [ i - 1 ] * ca NEW_LINE db [ i ] = da [ i - 1 ] * cb + db [ i - 1 ] * ( cb - 1 ) NEW_LINE da [ i ] %= MOD NEW_LINE db [ i ] %= MOD NEW_LINE DEDENT print ( da [ n ] ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "aizu_p00124_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; boolean go = false ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; if ( go == true ) System . out . println ( ) ; go = true ; int max = 0 ; int [ ] sum = new int [ n ] ; String [ ] name = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { name [ i ] = sc . next ( ) ; sum [ i ] = sc . nextInt ( ) * 3 + sc . nextInt ( ) * 0 + sc . nextInt ( ) * 1 ; max = Math . max ( max , sum [ i ] ) ; } for ( int i = max ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( sum [ j ] == i ) System . out . println ( name [ j ] + \" , \" + sum [ j ] ) ; } } } } }", "import static java . util . Arrays . deepToString ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void tr ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } Scanner sc = new Scanner ( System . in ) ; public void run ( ) { boolean first = true ; for ( ; sc . hasNext ( ) ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; if ( first ) first = false ; else System . out . println ( ) ; T [ ] ts = new T [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { T t = new T ( ) ; t . id = i ; t . name = sc . next ( ) ; int win = sc . nextInt ( ) ; int lose = sc . nextInt ( ) ; int draw = sc . nextInt ( ) ; t . point = win * 3 + draw * 1 ; ts [ i ] = t ; } Arrays . sort ( ts ) ; for ( T t : ts ) { System . out . println ( t . name + \" , \" + t . point ) ; } } } class T implements Comparable < T > { String name ; int id ; int point ; @ Override public int compareTo ( T o ) { if ( point != o . point ) return - ( point - o . point ) ; return ( id - o . id ) ; } } }", "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; boolean control = false ; int num ; while ( ( num = Integer . valueOf ( br . readLine ( ) ) ) != 0 ) { if ( control ) System . out . println ( ) ; Table [ ] table = new Table [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { String [ ] input = br . readLine ( ) . split ( \" \u2581 \" , 4 ) ; String country = input [ 0 ] ; int score = Integer . valueOf ( input [ 1 ] ) * 3 + Integer . valueOf ( input [ 3 ] ) ; table [ i ] = new Table ( country , score ) ; } Arrays . sort ( table ) ; for ( Table a : table ) { System . out . println ( a ) ; } control = true ; } } } class Table implements Comparable { String country ; int score ; Table ( String c , int s ) { this . country = c ; this . score = s ; } public String toString ( ) { return this . country + \" , \" + this . score ; } public int compareTo ( Object object ) { Table comp = ( Table ) object ; if ( this . score < comp . score ) return 1 ; else if ( this . score > comp . score ) return - 1 ; else return 0 ; } }", "import java . util . ArrayList ; import java . util . Collections ; import java . util . LinkedHashMap ; import java . util . List ; import java . util . Map ; import java . util . Map . Entry ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int count = 0 ; while ( true ) { int n = scanner . nextInt ( ) ; if ( n == 0 ) break ; if ( count != 0 ) { System . out . println ( ) ; } Map < String , Integer > map = new LinkedHashMap < String , Integer > ( ) ; List < Integer > list = new ArrayList < Integer > ( ) ; while ( n -- > 0 ) { String str = scanner . next ( ) ; int a = scanner . nextInt ( ) ; scanner . next ( ) ; int b = scanner . nextInt ( ) ; int c = a * 3 + b ; map . put ( str , c ) ; list . add ( c ) ; } Collections . sort ( list ) ; for ( int i = list . size ( ) - 1 ; i >= 0 ; i -- ) { String delete = \" \" ; for ( Entry < String , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) == list . get ( i ) ) { System . out . println ( entry . getKey ( ) + \" , \" + entry . getValue ( ) ) ; delete = entry . getKey ( ) ; break ; } } map . remove ( delete ) ; } count ++ ; } } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int n ; int [ ] w , d ; String [ ] name ; int i , j , tmp ; String st ; n = sc . nextInt ( ) ; for ( ; ; ) { w = new int [ n ] ; d = new int [ n ] ; name = new String [ n ] ; for ( i = 0 ; i < n ; i ++ ) { name [ i ] = sc . next ( ) ; w [ i ] = sc . nextInt ( ) ; d [ i ] = sc . nextInt ( ) ; d [ i ] = sc . nextInt ( ) ; d [ i ] += 3 * w [ i ] ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = 0 ; j < n - 1 - i ; j ++ ) { if ( d [ j ] < d [ j + 1 ] ) { st = name [ j ] ; name [ j ] = name [ j + 1 ] ; name [ j + 1 ] = st ; tmp = d [ j ] ; d [ j ] = d [ j + 1 ] ; d [ j + 1 ] = tmp ; } } } for ( i = 0 ; i < n ; i ++ ) System . out . println ( name [ i ] + \" , \" + d [ i ] ) ; n = sc . nextInt ( ) ; if ( n == 0 ) break ; else System . out . println ( ) ; } sc . close ( ) ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }"], "python": ["import sys NEW_LINE from operator import itemgetter NEW_LINE def solve ( data ) : NEW_LINE INDENT result = [ ] NEW_LINE for name , win , lose , draw in data : NEW_LINE INDENT score = win * 3 + draw * 1 NEW_LINE result . append ( [ name , score ] ) NEW_LINE DEDENT result . sort ( key = itemgetter ( 1 ) , reverse = True ) NEW_LINE return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT first_data_set = True NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT name , win , lose , draw = input ( ) . split ( ) NEW_LINE data . append ( [ name , int ( win ) , int ( lose ) , int ( draw ) ] ) NEW_LINE DEDENT result = solve ( data ) NEW_LINE if first_data_set : NEW_LINE INDENT first_data_set = False NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT for r in result : NEW_LINE INDENT print ( ' , ' . join ( map ( str , r ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT", "first = False NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if first : NEW_LINE INDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT first = True NEW_LINE DEDENT data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT country , win , lose , draw = map ( str , input ( ) . split ( ) ) NEW_LINE point = int ( win ) * 3 + int ( draw ) NEW_LINE data . append ( [ country , point ] ) NEW_LINE DEDENT data . sort ( key = lambda item : - item [ 1 ] ) NEW_LINE for country , point in data : NEW_LINE INDENT print ( country + \" , \" + str ( point ) ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE import os NEW_LINE import math NEW_LINE for i , s in enumerate ( sys . stdin ) : NEW_LINE INDENT n = int ( s ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT elif i != 0 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT A = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lst = input ( ) . split ( ) NEW_LINE name = lst [ 0 ] NEW_LINE w = int ( lst [ 1 ] ) NEW_LINE l = int ( lst [ 2 ] ) NEW_LINE d = int ( lst [ 3 ] ) NEW_LINE score = 3 * w + d NEW_LINE A . append ( ( score , - i , name ) ) NEW_LINE DEDENT A . sort ( reverse = True ) NEW_LINE for a in A : NEW_LINE INDENT score = a [ 0 ] NEW_LINE name = a [ 2 ] NEW_LINE print ( ' { } , { } ' . format ( name , score ) ) NEW_LINE DEDENT DEDENT", "import bisect NEW_LINE cnt = 0 NEW_LINE while 1 : NEW_LINE INDENT outs = [ ] NEW_LINE outn = [ ] NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE elif cnt > 0 : print ( ) NEW_LINE names = [ ] NEW_LINE scores = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = list ( input ( ) . split ( ) ) NEW_LINE name = line [ 0 ] NEW_LINE names . append ( name ) NEW_LINE w = line [ 1 ] NEW_LINE l = line [ 2 ] NEW_LINE d = line [ 3 ] NEW_LINE score = 3 * int ( w ) + int ( d ) NEW_LINE tm = bisect . bisect_left ( outs , score ) NEW_LINE outs . insert ( tm , score ) NEW_LINE outn . insert ( tm , name ) NEW_LINE DEDENT for i , j in zip ( reversed ( outn ) , reversed ( outs ) ) : NEW_LINE INDENT print ( f ' { i } , { j } ' ) NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT", "c = 0 NEW_LINE while True : NEW_LINE INDENT c += 1 NEW_LINE L = [ ] NEW_LINE num = int ( input ( ) ) NEW_LINE if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( num ) : NEW_LINE INDENT name , w , l , d = input ( ) . split ( ) NEW_LINE w = int ( w ) NEW_LINE d = int ( d ) NEW_LINE L . append ( ( i , name , w * 3 + d ) ) NEW_LINE DEDENT L . sort ( key = lambda x : ( - x [ 2 ] , x [ 0 ] ) ) NEW_LINE if c > 1 : NEW_LINE INDENT print ( ) NEW_LINE DEDENT for l in L : NEW_LINE INDENT print ( \" { } , { } \" . format ( l [ 1 ] , l [ 2 ] ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1077_B", "java": ["import java . util . Scanner ; import java . util . Arrays ; public class MainClass { public static void main ( String [ ] agrs ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] lst = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lst [ i ] = sc . nextInt ( ) ; int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( lst [ i ] == 0 && lst [ i - 1 ] == 1 && lst [ i + 1 ] == 1 ) { res += 1 ; if ( i <= n - 4 ) { if ( lst [ i + 2 ] == 0 && lst [ i + 3 ] == 1 ) { i += 3 ; } } } } System . out . println ( res ) ; } }", "import java . io . * ; import java . math . BigDecimal ; import java . math . MathContext ; import java . util . * ; public class ProblemB { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String line [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = Integer . parseInt ( line [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 && i - 1 >= 0 && arr [ i - 1 ] == 1 && i + 1 < n && arr [ i + 1 ] == 1 ) { arr [ i + 1 ] = 0 ; ans ++ ; } } System . out . println ( ans ) ; } public static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } public static void sort ( int arr [ ] ) { ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int it : arr ) list . add ( it ) ; Collections . sort ( list ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) arr [ i ] = list . get ( i ) ; } }", "import java . util . Scanner ; public class DistributedPeople { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = input . nextInt ( ) ; } int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 1 && arr [ i + 1 ] == 1 ) { ans ++ ; arr [ i + 1 ] = 0 ; } } System . out . println ( ans ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE lights = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if lights [ i - 1 ] == 1 and lights [ i ] == 0 and lights [ i + 1 ] == 1 : NEW_LINE INDENT lights [ i + 1 ] = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "import sys NEW_LINE rd = sys . stdin . readline NEW_LINE n = int ( rd ( ) ) NEW_LINE a = list ( map ( int , rd ( ) . split ( ) ) ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if a [ i - 1 ] == 1 and a [ i ] == 0 and a [ i + 1 ] == 1 : NEW_LINE INDENT res += 1 NEW_LINE a [ i + 1 ] = 0 NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE", "flats_in_the_house = int ( input ( ) ) NEW_LINE state_of_lights = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE need_to_turn_off = 0 NEW_LINE i = 0 NEW_LINE while i < flats_in_the_house - 2 : NEW_LINE INDENT if state_of_lights [ i ] == state_of_lights [ i + 2 ] == 1 and state_of_lights [ i + 1 ] == 0 : NEW_LINE INDENT need_to_turn_off += 1 NEW_LINE i += 2 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( need_to_turn_off ) NEW_LINE", "a = int ( input ( ) ) NEW_LINE sp = [ ] NEW_LINE p = [ ] NEW_LINE n = 0 NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for r in range ( 1 , len ( b ) - 1 ) : NEW_LINE INDENT if b [ r ] == 0 and b [ r - 1 ] == 1 and b [ r + 1 ] == 1 : NEW_LINE INDENT n += 1 NEW_LINE b [ r + 1 ] = 0 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT ans += 1 NEW_LINE k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT if not arr [ 0 ] and arr [ 1 ] : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_441_A", "java": ["class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; } static void checkCorrespond ( String [ ] str , int x ) { int counter = 0 ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 ; j <= 36 ; j ++ ) { if ( toDeci ( str [ i ] , j ) == x ) { counter ++ ; break ; } } } if ( counter == n ) System . out . print ( \" YES \" + \" \\n \" ) ; else System . out . print ( \" NO \" + \" \\n \" ) ; } public static void main ( String [ ] args ) { int x = 16 ; String [ ] str = { \"10000\" , \"20\" , \"16\" } ; checkCorrespond ( str , x ) ; } }"], "python": ["def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - ' A ' + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( strr , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 37 ) : NEW_LINE INDENT if ( toDeci ( strr [ i ] , j ) == x ) : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( counter == n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT x = 16 NEW_LINE strr = [ \"10000\" , \"20\" , \"16\" ] NEW_LINE checkCorrespond ( strr , x ) NEW_LINE"]}
{"id": "codeforces_770_B", "java": ["import java . util . Scanner ; public class B770 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; char [ ] S = in . next ( ) . toCharArray ( ) ; long maxNumber = Long . parseLong ( new String ( S ) ) ; long max = sumOfDigits ( maxNumber ) ; S [ S . length - 1 ] = '9' ; for ( int pos = S . length - 2 ; pos >= 0 ; pos -- ) { if ( S [ pos ] != '0' ) { S [ pos ] -- ; long number = Long . parseLong ( new String ( S ) ) ; int sum = sumOfDigits ( number ) ; if ( sum > max ) { max = sum ; maxNumber = number ; } } S [ pos ] = '9' ; } System . out . println ( maxNumber ) ; } static int sumOfDigits ( long number ) { int result = 0 ; while ( number != 0 ) { result += number % 10 ; number /= 10 ; } return result ; } }", "import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long max = sc . nextLong ( ) ; long cur = max ; long div = 10 ; while ( cur >= div ) { long mod = cur % div ; if ( mod != div - 1 ) cur -= ( mod + 1 ) ; if ( sum ( cur ) > sum ( max ) ) max = cur ; div *= 10 ; } System . out . println ( max ) ; } private static int sum ( long x ) { int sum = 0 ; while ( x > 0 ) { sum += x % 10 ; x /= 10 ; } return sum ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE li = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE res = [ n ] NEW_LINE p = n // 10 NEW_LINE i = 1 NEW_LINE while p > 0 : NEW_LINE INDENT rem = p % 10 NEW_LINE p //= 10 NEW_LINE j = li . index ( rem ) NEW_LINE if j == 0 : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT j = li [ j - 1 ] NEW_LINE res . append ( p * 10 ** ( i + 1 ) + j * 10 ** i + int ( '9' * i ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT maxsum = 0 NEW_LINE maxi = 0 NEW_LINE def getsum ( n ) : NEW_LINE INDENT res = 0 NEW_LINE while n > 0 : NEW_LINE INDENT res += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT for i in res : NEW_LINE INDENT if getsum ( i ) > maxsum : NEW_LINE INDENT maxsum = getsum ( i ) NEW_LINE maxi = i NEW_LINE DEDENT DEDENT print ( maxi ) NEW_LINE", "x = input ( ) NEW_LINE l = len ( x ) NEW_LINE if x . count ( '9' ) == l : NEW_LINE INDENT print ( x ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if x [ i ] != '9' : NEW_LINE INDENT sr = ' ' NEW_LINE for j in range ( l - i ) : NEW_LINE INDENT sr += '9' NEW_LINE DEDENT xxx = int ( str ( x [ : i ] ) ) - 1 NEW_LINE temp = str ( xxx ) + sr NEW_LINE t1 = 0 NEW_LINE t2 = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT t1 += int ( x [ i ] ) NEW_LINE t2 += int ( temp [ i ] ) NEW_LINE DEDENT if t1 >= t2 : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( temp ) ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT DEDENT print ( x ) NEW_LINE", "t = input ( ) NEW_LINE p = [ t ] + [ int ( t ) - int ( t [ - k : ] ) - 1 for k in range ( 1 , len ( t ) ) ] NEW_LINE print ( max ( p , key = lambda variant : sum ( map ( int , str ( variant ) ) ) ) ) NEW_LINE", "def digits ( k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( k ) ) : NEW_LINE INDENT sum += int ( k [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT for i in range ( 1 ) : NEW_LINE INDENT k = input ( ) NEW_LINE s = int ( k ) NEW_LINE n = len ( k ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT elif k [ 1 : : ] == ( '9' * ( n - 1 ) ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT elif ( k [ 1 : - 1 ] == ( '9' * ( n - 2 ) ) ) & ( k [ - 1 ] == '8' ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT elif ( k [ 1 ] == '8' ) & ( k [ 2 : : ] == ( '9' * ( n - 2 ) ) ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT m = k [ 1 : : ] NEW_LINE r = int ( m ) NEW_LINE u = s - r - 1 NEW_LINE u = str ( u ) NEW_LINE if ( k [ 1 ] == '9' ) : NEW_LINE INDENT t = 1 NEW_LINE m = k [ 0 ] NEW_LINE while ( k [ t + 1 ] == '9' ) : NEW_LINE INDENT m += '9' NEW_LINE t += 1 NEW_LINE DEDENT m = m + '8' + ( '9' * ( n - 1 - t ) ) NEW_LINE if ( k [ t + 2 : : ] == '9' * ( n - t - 2 ) ) & ( k [ t + 1 ] == '8' ) : NEW_LINE INDENT m = k NEW_LINE DEDENT a = digits ( m ) NEW_LINE b = digits ( u ) NEW_LINE if ( a >= b ) : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( u ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( u ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "codeforces_297_B", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) , k = sc . nextInt ( ) ; if ( n > m ) { System . out . println ( \" YES \" ) ; return ; } int [ ] a = new int [ n ] , b = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int j = 0 ; j < m ; j ++ ) { b [ j ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; for ( int i = n - 1 , j = m - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) { if ( a [ i ] > b [ j ] ) { System . out . println ( \" YES \" ) ; return ; } } System . out . println ( \" NO \" ) ; } }", "import java . util . Arrays ; import java . util . HashMap ; import java . util . PriorityQueue ; import java . util . Scanner ; import java . util . TreeMap ; import java . util . TreeSet ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr1 = new int [ n ] ; int [ ] arr2 = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr1 [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { arr2 [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; int t1 = 0 ; int t2 = 0 ; int p2 = m - 1 ; for ( int p1 = n - 1 ; p1 >= 0 ; p1 -- ) { t1 ++ ; while ( p2 >= 0 && arr2 [ p2 ] >= arr1 [ p1 ] ) { t2 ++ ; p2 -- ; } if ( t1 > t2 ) { System . out . println ( \" YES \" ) ; return ; } } System . out . println ( \" NO \" ) ; } }", "import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; public class Cl297 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( new InputStreamReader ( System . in ) ) ; while ( sc . hasNext ( ) ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr1 = new int [ n ] ; int [ ] arr2 = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr1 [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { arr2 [ i ] = sc . nextInt ( ) ; } if ( n > m ) System . out . println ( \" YES \" ) ; else { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; boolean success = false ; for ( int i = n - 1 , j = m - 1 ; i >= 0 && j >= 0 ; i -- , j -- ) { if ( arr1 [ i ] > arr2 [ j ] ) { success = true ; break ; } } System . out . println ( success ? \" YES \" : \" NO \" ) ; } } } }"], "python": ["def solve ( ) : NEW_LINE INDENT n , m , k = input ( ) . split ( \" \u2581 \" ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = \" NO \" NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT ans = \" YES \" NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if len ( a ) > len ( b ) : NEW_LINE INDENT ans = \" YES \" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT main ( ) NEW_LINE", "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , m , k = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE a , b = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) , list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE if n > m or a [ 0 ] > b [ 0 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( \" NO \" ) NEW_LINE DEDENT", "def day_725 ( ) : NEW_LINE INDENT input ( ) NEW_LINE a = [ int ( v ) for v in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE b = [ int ( v ) for v in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE if len ( a ) > len ( b ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE i , j = len ( a ) - 1 , len ( b ) - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT day_725 ( ) NEW_LINE DEDENT", "def fish ( ) : NEW_LINE INDENT [ n , m , k ] = [ int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE b = [ int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE if len ( a ) > len ( b ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] > b [ i ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT fish ( ) NEW_LINE DEDENT", "from operator import itemgetter NEW_LINE from typing import * NEW_LINE from collections import deque , Counter , defaultdict NEW_LINE from bisect import * NEW_LINE import heapq , math NEW_LINE from functools import cmp_to_key , reduce NEW_LINE from itertools import groupby , islice , zip_longest NEW_LINE def main ( ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n > m : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i , it in enumerate ( a ) : NEW_LINE INDENT if it > b [ i ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"]}
{"id": "aizu_p00487_A", "java": ["import java . io . IOException ; import java . util . Arrays ; import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; Pair [ ] pairs = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; pairs [ i ] = new Pair ( a , b ) ; } Arrays . sort ( pairs ) ; PriorityQueue < Pair > pq = new PriorityQueue < Pair > ( ) ; long sum = 0 ; long ret = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pq . offer ( new Pair ( pairs [ i ] . s , pairs [ i ] . f ) ) ; sum += pairs [ i ] . f ; while ( ! pq . isEmpty ( ) && pq . peek ( ) . f * pq . size ( ) < sum ) sum -= pq . poll ( ) . s ; ret = Math . max ( ret , pq . size ( ) ) ; } System . out . println ( ret ) ; } class Pair implements Comparable < Pair > { long f , s ; @ Override public String toString ( ) { return \" Pair \u2581 [ f = \" + f + \" , \u2581 s = \" + s + \" ] \" ; } public Pair ( long f , long s ) { super ( ) ; this . f = f ; this . s = s ; } @ Override public int compareTo ( Pair o ) { return ( int ) ( f - o . f ) ; } } }", "import java . io . IOException ; import java . util . Arrays ; import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; Pair [ ] pairs = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; int b = scanner . nextInt ( ) ; pairs [ i ] = new Pair ( a , b ) ; } Arrays . sort ( pairs ) ; PriorityQueue < Pair > pq = new PriorityQueue < Pair > ( ) ; long sum = 0 ; long ret = 0 ; for ( Pair p : pairs ) { pq . offer ( new Pair ( p . s , p . f ) ) ; sum += p . f ; while ( ! pq . isEmpty ( ) ) { Pair pair = pq . peek ( ) ; long a = pair . f * pq . size ( ) ; if ( a >= sum ) break ; sum -= pq . poll ( ) . s ; } ret = Math . max ( ret , pq . size ( ) ) ; } System . out . println ( ret ) ; } class Pair implements Comparable < Pair > { long f , s ; @ Override public String toString ( ) { return \" Pair \u2581 [ f = \" + f + \" , \u2581 s = \" + s + \" ] \" ; } public Pair ( long f , long s ) { super ( ) ; this . f = f ; this . s = s ; } @ Override public int compareTo ( Pair o ) { return ( int ) ( f - o . f ) ; } } }", "import java . util . Arrays ; import java . util . Comparator ; import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { class B implements Comparable < B > { int a , b ; public B ( int a , int b ) { this . a = a ; this . b = b ; } public int compareTo ( B o ) { return o . b - b ; } } int n ; B [ ] r ; boolean ok ( int x ) { if ( x == 0 ) return true ; PriorityQueue < B > q = new PriorityQueue < B > ( x , new Comparator < B > ( ) { public int compare ( B o1 , B o2 ) { return o2 . a - o1 . a ; } } ) ; long A = 0 ; for ( int i = 0 ; i < x - 1 ; i ++ ) { A += r [ i ] . a ; q . add ( r [ i ] ) ; } for ( int i = x - 1 ; i < n ; i ++ ) { long w = ( long ) x * r [ i ] . b - r [ i ] . a ; if ( A <= w ) return true ; A += r [ i ] . a ; q . add ( r [ i ] ) ; A -= q . poll ( ) . a ; } return false ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; r = new B [ n ] ; for ( int i = 0 ; i < n ; i ++ ) r [ i ] = new B ( sc . nextInt ( ) , sc . nextInt ( ) ) ; Arrays . sort ( r ) ; int L = 0 , R = n ; while ( R - L > 1 ) { int m = ( L + R ) / 2 ; if ( ok ( m ) ) L = m ; else R = m ; } System . out . println ( ok ( R ) ? R : L ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }"], "python": ["import heapq NEW_LINE tbl = [ ] NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl . append ( ( a , b ) ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE Q = [ ] NEW_LINE ans = s = sz = 0 NEW_LINE for t in tbl : NEW_LINE INDENT s += t [ 0 ] NEW_LINE heapq . heappush ( Q , ( t [ 1 ] , t [ 0 ] ) ) NEW_LINE sz += 1 NEW_LINE while sz and sz * Q [ 0 ] [ 0 ] < s : NEW_LINE INDENT s -= Q [ 0 ] [ 1 ] NEW_LINE heapq . heappop ( Q ) NEW_LINE sz -= 1 NEW_LINE DEDENT if sz > ans : ans = sz NEW_LINE DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_3313_A", "java": ["class GFG { static int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; } static int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } static int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; } public static void main ( String args [ ] ) { int no = getNthUglyNo ( 150 ) ; System . out . println ( \"150th \u2581 ugly \u2581 \" + \" no . \u2581 is \u2581 \" + no ) ; } }"], "python": ["def maxDivide ( a , b ) : NEW_LINE INDENT while a % b == 0 : NEW_LINE INDENT a = a / b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return 1 if no == 1 else 0 NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while n > count : NEW_LINE INDENT i += 1 NEW_LINE if isUgly ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( \"150th \u2581 ugly \u2581 no . \u2581 is \u2581 \" , no ) NEW_LINE"]}
{"id": "codeforces_1157_B", "java": ["import java . util . * ; import java . io . * ; public class _1157B { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] num = sc . next ( ) . toCharArray ( ) ; int [ ] map = new int [ 10 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) map [ i ] = sc . nextInt ( ) ; int idx = n ; for ( int i = 0 ; i < n ; i ++ ) { int digit = num [ i ] - '0' ; if ( map [ digit ] > digit ) { idx = i ; break ; } } for ( int i = idx ; i < num . length ; i ++ ) { int digit = num [ i ] - '0' ; if ( map [ digit ] < digit ) break ; num [ i ] = ( char ) ( map [ digit ] + '0' ) ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( num [ i ] ) ; } public static int gcd ( int a , int b ) { return ( a == 0 ) ? b : gcd ( b % a , a ) ; } static int power ( int x , int y ) { int ans = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) ans *= x ; y = y >> 1 ; x *= x ; } return ans ; } public static List < Integer > sieve ( int n ) { List < Integer > primes = new LinkedList < > ( ) ; boolean [ ] composite = new boolean [ n + 1 ] ; for ( int i = 2 ; i * i <= n ; i ++ ) for ( int j = i * i ; j <= n && ! composite [ i ] ; j += i ) composite [ j ] = true ; for ( int j = 2 ; j < composite . length ; j ++ ) if ( ! composite [ j ] ) primes . add ( j ) ; return primes ; } }", "import java . io . * ; import java . util . * ; public class ProblemB { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; char s [ ] = br . readLine ( ) . toCharArray ( ) ; int arr [ ] = new int [ 10 ] ; String line [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 1 ; i < 10 ; i ++ ) arr [ i ] = Integer . parseInt ( line [ i - 1 ] ) ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] - '0' ; if ( curr < arr [ curr ] ) { while ( i < n && s [ i ] - '0' <= arr [ s [ i ] - '0' ] ) { s [ i ] = ( char ) ( arr [ s [ i ] - '0' ] + '0' ) ; i ++ ; } break ; } } System . out . println ( String . copyValueOf ( s ) ) ; } public static void sort ( int arr [ ] ) { ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int it : arr ) list . add ( it ) ; Collections . sort ( list ) ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = list . get ( i ) ; } }", "import java . io . * ; import java . util . * ; public class ProblemB { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s = br . readLine ( ) ; int arr [ ] = new int [ 10 ] ; String line [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 1 ; i < 10 ; i ++ ) arr [ i ] = Integer . parseInt ( line [ i - 1 ] ) ; boolean ok = true ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s . charAt ( i ) - '0' ; if ( curr < arr [ curr ] && ok ) { while ( i < n && curr <= arr [ curr ] ) { sb . append ( arr [ curr ] ) ; i ++ ; curr = i < n ? ( s . charAt ( i ) - '0' ) : - 1 ; } i -- ; ok = false ; } else { sb . append ( s . charAt ( i ) ) ; } } System . out . println ( sb ) ; } public static void sort ( int arr [ ] ) { ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int it : arr ) list . add ( it ) ; Collections . sort ( list ) ; for ( int i = 0 ; i < arr . length ; i ++ ) arr [ i ] = list . get ( i ) ; } }", "import java . util . * ; import java . io . * ; public class Problem1 { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int n = Integer . parseInt ( f . readLine ( ) ) ; String str = f . readLine ( ) ; int [ ] func = new int [ 10 ] ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; for ( int i = 0 ; i < 9 ; i ++ ) { func [ i + 1 ] = Integer . parseInt ( st . nextToken ( ) ) ; } StringBuilder nstr = new StringBuilder ( ) ; boolean on = false ; for ( int i = 0 ; i < n ; i ++ ) { int val = str . charAt ( i ) - '0' ; if ( on == false ) { if ( func [ val ] > val ) { on = true ; nstr . append ( func [ val ] ) ; } else { nstr . append ( val ) ; } } else { if ( func [ val ] >= val ) { nstr . append ( func [ val ] ) ; } else { int j = i ; while ( j < n ) { nstr . append ( str . charAt ( j ) ) ; j ++ ; } break ; } } } out . println ( nstr ) ; out . close ( ) ; } }", "import java . util . * ; public class Solution16 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] arr = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int id1 = 0 ; int id2 = s . length ( ) ; StringBuilder str = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; int x = Character . getNumericValue ( ch ) ; if ( x < arr [ x - 1 ] ) { id1 = i ; break ; } } for ( int i = id1 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; int x = Character . getNumericValue ( ch ) ; if ( x > arr [ x - 1 ] ) { id2 = i ; break ; } } for ( int i = 0 ; i < id1 ; i ++ ) { char ch = s . charAt ( i ) ; int x = Character . getNumericValue ( ch ) ; str . append ( x ) ; } for ( int i = id1 ; i < id2 ; i ++ ) { char ch = s . charAt ( i ) ; int x = Character . getNumericValue ( ch ) ; str . append ( arr [ x - 1 ] ) ; } for ( int i = id2 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; int x = Character . getNumericValue ( ch ) ; str . append ( x ) ; } System . out . println ( str . toString ( ) ) ; } }"], "python": ["import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE lst = list ( _input ( ) ) NEW_LINE fi = la = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = int ( s [ i ] ) NEW_LINE if lst [ k - 1 ] > k : NEW_LINE INDENT if fi == - 1 : fi = i NEW_LINE else : la = i NEW_LINE DEDENT elif lst [ k - 1 ] == k : NEW_LINE INDENT if fi != - 1 : la = i NEW_LINE DEDENT else : NEW_LINE INDENT if fi != - 1 : la = i - 1 ; break NEW_LINE DEDENT DEDENT if fi == la and fi == - 1 : print ( s ) NEW_LINE else : NEW_LINE INDENT print ( s [ : fi ] , end = ' ' ) NEW_LINE if la == - 1 : la = n - 1 NEW_LINE for i in range ( fi , la + 1 ) : NEW_LINE INDENT print ( lst [ int ( s [ i ] ) - 1 ] , end = ' ' ) NEW_LINE DEDENT print ( s [ la + 1 : ] ) NEW_LINE DEDENT", "_ = int ( input ( ) ) NEW_LINE a = list ( map ( int , list ( input ( ) ) ) ) NEW_LINE f = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE started = False NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] < f [ a [ i ] ] : NEW_LINE INDENT started = True NEW_LINE a [ i ] = f [ a [ i ] ] NEW_LINE DEDENT elif a [ i ] == f [ a [ i ] ] : NEW_LINE INDENT continue NEW_LINE DEDENT elif started : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ' ' . join ( map ( str , a ) ) ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = int ( s [ i ] ) NEW_LINE if w [ a - 1 ] > a : NEW_LINE INDENT c = i NEW_LINE break NEW_LINE DEDENT DEDENT if c == - 1 : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT d = ' ' NEW_LINE e = - 1 NEW_LINE for i in range ( c , n ) : NEW_LINE INDENT a = int ( s [ i ] ) NEW_LINE if w [ a - 1 ] >= a : NEW_LINE INDENT d += str ( w [ a - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT DEDENT if e == - 1 : NEW_LINE INDENT print ( s [ : c ] + d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ : c ] + d + s [ e : ] ) NEW_LINE DEDENT DEDENT", "input ( ) ; t = [ * map ( int , input ( ) ) ] ; f = 0 , * input ( ) . split ( ) ; c = 0 ; a = 0 NEW_LINE for b in t : NEW_LINE INDENT n = int ( f [ b ] ) NEW_LINE if n > b or n == b and c : c = 1 ; t [ a ] = n NEW_LINE elif c : break NEW_LINE a += 1 NEW_LINE DEDENT print ( * t , sep = ' ' ) NEW_LINE", "input ( ) ; t = [ * map ( int , input ( ) ) ] ; f = 0 , * input ( ) . split ( ) ; c = 0 ; a = 0 NEW_LINE for b in t : NEW_LINE INDENT n = int ( f [ b ] ) NEW_LINE if n > b or n == b and c : c = 1 ; t [ a ] = n NEW_LINE elif c : break NEW_LINE a += 1 NEW_LINE DEDENT print ( * t , sep = ' ' ) NEW_LINE"]}
{"id": "atcoder_ABC128_F", "java": ["import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; FFrogJump solver = new FFrogJump ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class FFrogJump { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; long [ ] arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = in . nextLong ( ) ; long res = solveMeOk ( n , arr ) ; out . println ( res ) ; } private long solveMeOk ( int n , long [ ] arr ) { HashSet < Integer > used = new HashSet < > ( ) ; long res = 0 ; for ( int c = 1 ; c < n ; c ++ ) { used = new HashSet < > ( ) ; long score = 0 ; res = Math . max ( res , score ) ; used . add ( 0 ) ; used . add ( n - 1 ) ; for ( int k = 1 ; k * c < n - 1 ; k ++ ) { if ( n - 1 - k * c < c ) break ; if ( k * c == n - 1 - k * c ) break ; if ( used . contains ( k * c ) || used . contains ( n - 1 - k * c ) ) break ; score += arr [ k * c ] + arr [ n - 1 - k * c ] ; used . add ( k * c ) ; used . add ( n - 1 - k * c ) ; res = Math . max ( score , res ) ; } } return res ; } } }", "import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ) { int n = scanner . nextInt ( ) ; int [ ] s = IntStream . range ( 0 , n ) . map ( i -> scanner . nextInt ( ) ) . toArray ( ) ; long max = 0L ; for ( int c = 1 ; c < n - 1 ; c ++ ) { Set < Integer > set = new HashSet < > ( ) ; long sum = 0L ; for ( int k = 1 ; k * c < n - 1 ; k ++ ) { if ( ( n - 1 - c * k <= c ) || set . contains ( n - 1 - k * c ) || set . contains ( k * c ) || n - 1 - k * c == k * c ) { break ; } sum = sum + s [ n - 1 - k * c ] + s [ k * c ] ; max = Math . max ( max , sum ) ; set . add ( n - 1 - k * c ) ; set . add ( k * c ) ; } } System . out . println ( max ) ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; ArrayList < Integer > s = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { s . add ( sc . nextInt ( ) ) ; } long score = 0 ; for ( int c = 1 ; c <= N - 1 ; c ++ ) { long tmp = 0 ; Set < Integer > t = new HashSet < Integer > ( ) ; for ( int k = 0 ; k * c < N - 1 ; k ++ ) { if ( ( N - 1 ) - k * c <= c ) break ; if ( t . contains ( k * c ) ) break ; tmp += s . get ( k * c ) ; t . add ( k * c ) ; if ( t . contains ( ( N - 1 ) - k * c ) ) break ; tmp += s . get ( ( N - 1 ) - k * c ) ; t . add ( ( N - 1 ) - k * c ) ; score = Math . max ( score , tmp ) ; } } System . out . println ( score ) ; sc . close ( ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; FFrogJump solver = new FFrogJump ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class FFrogJump { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; long [ ] arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = in . nextLong ( ) ; long res = solveMe2 ( n , arr ) ; out . println ( res ) ; } private long solveMe2 ( int n , long [ ] s ) { long max = 0 ; long [ ] dp = new long [ n + 1 ] ; for ( int d = 1 ; d < n ; d ++ ) { int maxn = n - d ; if ( ( n - 1 ) % d == 0 ) maxn = n / 2 ; for ( int k = 1 ; k * d < maxn ; k ++ ) { dp [ k ] = dp [ k - 1 ] + s [ k * d ] + s [ n - 1 - k * d ] ; max = Math . max ( max , dp [ k ] ) ; } } return max ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; long [ ] s = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) s [ i ] = scanner . nextInt ( ) ; long [ ] u = new long [ N ] ; long [ ] v = new long [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { long t = s [ i ] + s [ N - i - 1 ] ; for ( int j = 1 ; ( long ) j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( ( i < N / 2 || ( N - 1 ) % j != 0 ) && N - i - 1 > j ) { u [ j ] += t ; v [ j ] = Math . max ( v [ j ] , u [ j ] ) ; } if ( i != j * j ) { int k = i / j ; if ( ( i < N / 2 || ( N - 1 ) % k != 0 ) && N - i - 1 > k ) { u [ k ] += t ; v [ k ] = Math . max ( v [ k ] , u [ k ] ) ; } } } } } long max = 0 ; for ( int i = 0 ; i < N ; i ++ ) max = Math . max ( max , v [ i ] ) ; System . out . println ( max ) ; } }"], "python": ["def make_divisors ( n ) : NEW_LINE INDENT lower_divisors , upper_divisors = [ ] , [ ] NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT lower_divisors . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT upper_divisors . append ( n // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return lower_divisors + upper_divisors [ : : - 1 ] NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE D = [ [ ] ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT DD = [ ] NEW_LINE T = [ 0 ] NEW_LINE for j in range ( i , N , i ) : NEW_LINE INDENT T . append ( T [ - 1 ] + s [ j ] ) NEW_LINE DEDENT DD . append ( T ) NEW_LINE T = [ 0 ] NEW_LINE start = ( N - 1 ) % i NEW_LINE if start == 0 : start += i NEW_LINE for j in range ( start , N , i ) : NEW_LINE INDENT T . append ( T [ - 1 ] + s [ j ] ) NEW_LINE DEDENT DD . append ( T ) NEW_LINE D . append ( DD ) NEW_LINE DEDENT ans = s [ - 1 ] NEW_LINE cnt = 0 NEW_LINE for n in range ( 2 , N - 1 ) : NEW_LINE INDENT end = N - 1 - n NEW_LINE for m in make_divisors ( end ) : NEW_LINE INDENT if n <= m : break NEW_LINE if n % m == 0 and end >= n : continue NEW_LINE k = end // m NEW_LINE a = D [ m ] [ 0 ] [ k ] NEW_LINE l = len ( D [ m ] [ 1 ] ) NEW_LINE b = D [ m ] [ 1 ] [ - 1 ] - D [ m ] [ 1 ] [ l - k - 2 ] NEW_LINE ans = max ( ans , a + b ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : NEW_LINE INDENT res = list ( sys . stdin . readline ( ) ) NEW_LINE if res [ - 1 ] == \" \\n \" : NEW_LINE INDENT return res [ : - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE s = LI ( ) NEW_LINE ans = 0 NEW_LINE for c in range ( 1 , n + 1 ) : NEW_LINE INDENT K = ( n - 1 ) // c NEW_LINE dp = 0 NEW_LINE S = set ( [ 0 , n - 1 ] ) NEW_LINE for k in range ( 1 , K + 1 ) : NEW_LINE INDENT a = i = n - 1 - k * c NEW_LINE if i in S : NEW_LINE INDENT break NEW_LINE DEDENT b = a - c NEW_LINE if b >= a or b <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT S . add ( i ) NEW_LINE j = k * c NEW_LINE if j in S : NEW_LINE INDENT break NEW_LINE DEDENT S . add ( j ) NEW_LINE cost = s [ i ] + s [ j ] NEW_LINE dp += cost NEW_LINE if ans < dp : NEW_LINE INDENT ans = dp NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT", "from itertools import accumulate NEW_LINE N , * S = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for dx in range ( 1 , N - 1 ) : NEW_LINE INDENT k , r = divmod ( N - 1 , dx ) NEW_LINE if r == 0 : NEW_LINE INDENT k = ( k + 1 ) // 2 NEW_LINE DEDENT ans = max ( ans , max ( accumulate ( a + b for a , b in zip ( S [ : dx * k : dx ] , S [ N - 1 : ( N - 1 ) - dx * k : - dx ] ) ) ) ) NEW_LINE DEDENT print ( ans ) NEW_LINE", "import sys NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE import numpy as np NEW_LINE N = int ( readline ( ) ) NEW_LINE S = np . array ( read ( ) . split ( ) , np . int64 ) NEW_LINE def F ( d ) : NEW_LINE INDENT L = S [ : - d : d ] . cumsum ( ) NEW_LINE R = S [ : : - 1 ] [ : - d : d ] . cumsum ( ) NEW_LINE if ( N - 1 ) % d == 0 : NEW_LINE INDENT n = ( N - 1 ) // d NEW_LINE x = np . arange ( 1 , n + 1 ) NEW_LINE bl = ( x + x <= n + 1 ) NEW_LINE L = L [ bl ] ; R = R [ bl ] NEW_LINE DEDENT return ( L + R ) . max ( ) NEW_LINE DEDENT def G ( n ) : NEW_LINE INDENT D = ( N - 1 - n ) // n NEW_LINE L = np . zeros ( D + 1 , np . int64 ) NEW_LINE R = np . zeros ( D + 1 , np . int64 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT L += S [ : i * ( D + 1 ) : i ] NEW_LINE R += S [ : : - 1 ] [ : i * ( D + 1 ) : i ] NEW_LINE DEDENT ok = np . ones ( D + 1 , np . bool ) NEW_LINE overlap = ( np . arange ( D + 1 ) * ( n + n ) >= N - 1 ) NEW_LINE overlap [ 1 : ] &= ( ( N - 1 ) % np . arange ( 1 , D + 1 ) == 0 ) NEW_LINE x = L + R NEW_LINE x [ overlap ] = 0 NEW_LINE return x . max ( ) NEW_LINE DEDENT L = int ( ( N - 1 ) ** .5 + 10 ) NEW_LINE L = min ( N - 1 , L ) NEW_LINE x = max ( F ( n ) for n in range ( 1 , L + 1 ) ) NEW_LINE y = max ( G ( n ) for n in range ( 1 , L + 1 ) ) NEW_LINE answer = max ( x , y ) NEW_LINE print ( answer ) NEW_LINE", "import sys NEW_LINE import itertools NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 100000 ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def read_values ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def read_index ( ) : return map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) NEW_LINE def read_list ( ) : return list ( read_values ( ) ) NEW_LINE def read_lists ( N ) : return [ read_list ( ) for n in range ( N ) ] NEW_LINE class V : NEW_LINE INDENT def __init__ ( self , f , v = None ) : NEW_LINE INDENT self . f = f NEW_LINE self . v = v NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return str ( self . v ) NEW_LINE DEDENT def ud ( self , n ) : NEW_LINE INDENT if self . v is None : NEW_LINE INDENT self . v = n NEW_LINE DEDENT else : NEW_LINE INDENT self . v = self . f ( self . v , n ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = read_list ( ) NEW_LINE res = V ( max , 0 ) NEW_LINE for c in range ( 1 , N ) : NEW_LINE INDENT r = 0 NEW_LINE t1 = 0 NEW_LINE t2 = N - 1 NEW_LINE while True : NEW_LINE INDENT t1 += c NEW_LINE t2 -= c NEW_LINE if t2 < c : NEW_LINE INDENT break NEW_LINE DEDENT if ( N - 1 ) % c == 0 and 2 * t2 <= N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT r += S [ t1 ] + S [ t2 ] NEW_LINE res . ud ( r ) NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1094_A", "java": ["class GFG { static void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + \" \u2581 \" ) ; n2 = n2 + number ; number += 2 ; } } public static void main ( String [ ] args ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; } }"], "python": ["from math import ceil , sqrt NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = \" \u2581 \" ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 2 ; r = 24 ; NEW_LINE perfectSquares ( l , r ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_674_A", "java": ["import java . util . ArrayList ; class GFG { static boolean CheckArray ( int arr [ ] , int n ) { int prod = 1 ; ArrayList < Integer > freq = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . contains ( root ) & freq . lastIndexOf ( root ) != ( freq . size ( ) ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = arr . length ; if ( CheckArray ( arr , n ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = math . sqrt ( prod ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if root in freq : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1257_A", "java": ["import java . util . * ; class GFG { static void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + \" \u2581 \" ) ; i ++ ; } } public static void main ( String [ ] args ) { int N = 4 ; findNumbers ( N ) ; } }"], "python": ["def findNumbers ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i <= N ) : NEW_LINE INDENT print ( ( i * i * i ) , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT"]}
{"id": "aizu_p01028_A", "java": ["import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int n = stdIn . nextInt ( ) ; int m = stdIn . nextInt ( ) ; int [ ] money = new int [ 10 ] ; int [ ] ans = new int [ n ] ; int min = 10000 ; int minNumber = - 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { money [ i ] = stdIn . nextInt ( ) ; if ( money [ i ] < min ) { min = money [ i ] ; minNumber = i ; } } Arrays . fill ( ans , minNumber ) ; if ( ( m -= money [ minNumber ] * n ) < 0 ) { System . out . println ( \" NA \" ) ; return ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( m - money [ i ] + money [ ans [ j ] ] ) >= 0 ) && ( i < ans [ j ] ) ) { m = m - money [ i ] + money [ ans [ j ] ] ; ans [ j ] = i ; } } } Arrays . sort ( ans ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] ) ; } System . out . println ( ) ; } }"], "python": ["from itertools import combinations_with_replacement as cwr NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE c_lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for t in cwr ( ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) , n ) : NEW_LINE INDENT out = \" \" NEW_LINE cost = 0 NEW_LINE for n in t : NEW_LINE INDENT cost += c_lst [ n ] NEW_LINE out += str ( n ) NEW_LINE DEDENT if cost <= m : NEW_LINE INDENT print ( out ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NA \" ) NEW_LINE DEDENT"]}
{"id": "codeforces_1406_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class SubsetMex { public static void main ( String [ ] args ) { Scanner iScanner = new Scanner ( System . in ) ; int test = iScanner . nextInt ( ) ; while ( test > 0 ) { test -- ; int n = iScanner . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = iScanner . nextInt ( ) ; } Arrays . sort ( arr ) ; int min = arr [ 0 ] ; int max = arr [ n - 1 ] ; int count = 0 ; int [ ] arr2 = new int [ max + 2 ] ; for ( int i = 0 ; i < max + 2 ; i ++ ) arr2 [ i ] = 0 ; if ( min == 0 ) { for ( int i = 0 ; i < n ; i ++ ) arr2 [ arr [ i ] ] ++ ; int a = 0 ; int b = 0 ; for ( int i = 0 ; i < max + 2 ; i ++ ) { if ( arr2 [ i ] == 0 ) { a = i ; break ; } arr2 [ i ] = arr2 [ i ] - 1 ; } for ( int i = 0 ; i < max + 2 ; i ++ ) { if ( arr2 [ i ] == 0 ) { b = i ; break ; } } System . out . println ( a + b ) ; } else System . out . println ( 0 ) ; } } }", "import java . util . Scanner ; public class SubMex { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) , i , j = 0 , k = 0 , a [ ] = new int [ 101 ] ; for ( i = 0 ; i < n ; i ++ ) a [ in . nextInt ( ) ] ++ ; while ( a [ j ] > 0 ) a [ j ++ ] -- ; while ( a [ k ] > 0 ) a [ k ++ ] -- ; System . out . println ( j + k ) ; } in . close ( ) ; } }", "import java . util . Scanner ; public class SubsetMex { public static void main ( String args [ ] ) { Scanner scanner = new Scanner ( System . in ) ; String num = scanner . nextLine ( ) ; int n = Integer . parseInt ( num ) ; int count = 0 ; String arr [ ] = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { scanner . nextLine ( ) ; arr [ i ] = scanner . nextLine ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { String numsAsStringArr [ ] = arr [ i ] . split ( \" \u2581 \" ) ; int [ ] numArr = new int [ numsAsStringArr . length ] ; int index = 0 ; for ( String str : numsAsStringArr ) { numArr [ index ++ ] = Integer . parseInt ( str ) ; } System . out . println ( calculateMex ( numArr ) ) ; } } static int calculateMex ( int [ ] arr ) { int mex = 0 ; int count [ ] = new int [ 101 ] ; for ( int val : arr ) { count [ val ] ++ ; } boolean addToFirstSubSet = true , addToSecondSubset = true ; for ( int i = 0 ; i < count . length ; i ++ ) { if ( addToFirstSubSet ) { if ( count [ i ] >= 1 ) { count [ i ] -- ; } else { mex += i ; addToFirstSubSet = false ; } } if ( addToSecondSubset ) { if ( count [ i ] >= 1 ) { count [ i ] -- ; } else { mex += i ; addToSecondSubset = false ; } } } return mex ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ 0 ] * 101 NEW_LINE for i in l : NEW_LINE INDENT c [ i ] += 1 NEW_LINE DEDENT n1 , n2 = 0 , 0 NEW_LINE i = 0 NEW_LINE while i < len ( l ) and c [ i ] >= 2 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n1 = i NEW_LINE while i < len ( l ) and c [ i ] >= 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT n2 = i NEW_LINE print ( n1 + n2 ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE a = input ( ) . split ( ) NEW_LINE l = [ ] NEW_LINE p = [ ] NEW_LINE for o in range ( 0 , m ) : NEW_LINE INDENT if int ( a [ o ] ) not in l : NEW_LINE INDENT l . append ( int ( a [ o ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT p . append ( int ( a [ o ] ) ) NEW_LINE DEDENT DEDENT b = False NEW_LINE for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT if i not in l : NEW_LINE INDENT b = True NEW_LINE break NEW_LINE DEDENT DEDENT if b : NEW_LINE INDENT s = ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT s = ( len ( l ) ) NEW_LINE DEDENT if p == [ ] : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT b = False NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if i not in p : NEW_LINE INDENT b = True NEW_LINE break NEW_LINE DEDENT DEDENT if b : NEW_LINE INDENT print ( s + i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s + len ( p ) ) NEW_LINE DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = input ( ) . split ( ) NEW_LINE c = [ ] NEW_LINE for j in a : NEW_LINE INDENT c . append ( int ( j ) ) NEW_LINE DEDENT ans = 0 NEW_LINE a = c NEW_LINE bl = False NEW_LINE bl2 = False NEW_LINE bl3 = False NEW_LINE for k in range ( 0 , len ( a ) ) : NEW_LINE INDENT if a [ k ] != k : NEW_LINE INDENT bl3 = True NEW_LINE DEDENT DEDENT if bl3 : NEW_LINE INDENT for j in range ( 0 , max ( c ) + 2 ) : NEW_LINE INDENT if a . count ( j ) == 0 : NEW_LINE INDENT bl2 = True NEW_LINE if bl : NEW_LINE INDENT ans = ans + j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + 2 * j NEW_LINE break NEW_LINE DEDENT DEDENT elif a . count ( j ) == 1 and bl == False : NEW_LINE INDENT ans = ans + j NEW_LINE bl = True NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( c ) + 1 ) NEW_LINE DEDENT DEDENT", "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = [ 0 ] * 101 NEW_LINE for x in s . split ( ) : a [ int ( x ) ] += 1 NEW_LINE i = a . index ( 0 ) ; a [ i ] = 1 ; print ( i + a . index ( 1 ) ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE d = { i : 0 for i in range ( 101 ) } NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if arr . count ( 0 ) == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for v in arr : NEW_LINE INDENT d [ v ] += 1 NEW_LINE DEDENT r1 = 0 NEW_LINE r2 = 0 NEW_LINE for i in range ( 100 , - 1 , - 1 ) : NEW_LINE INDENT if d [ i ] == 0 : NEW_LINE INDENT r1 = i NEW_LINE DEDENT if d [ i ] <= 1 : NEW_LINE INDENT r2 = i NEW_LINE DEDENT DEDENT print ( r1 + r2 ) NEW_LINE DEDENT DEDENT"]}
{"id": "atcoder_AGC039_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int len = s . length ; char prev = s [ 0 ] ; int cnt = 1 ; ArrayList < Integer > li = new ArrayList < Integer > ( ) ; long n = sc . nextLong ( ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( prev == s [ i ] ) { cnt ++ ; } else { li . add ( cnt ) ; cnt = 1 ; prev = s [ i ] ; } } li . add ( cnt ) ; long ans = 0 ; if ( li . size ( ) == 1 ) { ans = ( li . get ( 0 ) * n ) / 2 ; } else if ( s [ 0 ] == s [ len - 1 ] ) { int cf = li . get ( 0 ) ; int cl = li . get ( li . size ( ) - 1 ) ; for ( int i = 1 ; i < li . size ( ) - 1 ; i ++ ) { ans += li . get ( i ) / 2 * n ; } ans += cf / 2 + cl / 2 + ( cf + cl ) / 2 * ( n - 1 ) ; } else { for ( int i : li ) { ans += i / 2 * n ; } } System . out . println ( ans ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; AConnectionAndDisconnection solver = new AConnectionAndDisconnection ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class AConnectionAndDisconnection { public void solve ( int testNumber , Scanner in , PrintWriter out ) { String s = in . next ( ) ; int k = in . nextInt ( ) ; int from = - 1 ; int to = s . length ( ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( 0 ) ) { from = i ; break ; } } if ( from == - 1 ) { long ans = 1L * s . length ( ) * k / 2 ; out . println ( ans ) ; return ; } for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( 0 ) ) { to = i + 1 ; } } long ans = 0 ; for ( int i = from ; i < to ; i ++ ) { if ( i < s . length ( ) && s . charAt ( i ) == s . charAt ( i - 1 ) ) { ans += k ; i ++ ; } } int pref = from ; int suff = ( s . length ( ) - to ) ; ans += pref / 2 ; ans += suff / 2 ; ans += 1L * ( pref + suff ) / 2 * ( k - 1 ) ; out . println ( ans ) ; } } }", "import java . io . * ; import java . util . * ; class Main { static Scanner scanner = new Scanner ( ) ; static long mod = 1000000007 ; public static void main ( String [ ] $ ) { char [ ] s = scanner . next ( ) . toCharArray ( ) ; char [ ] s2 = Arrays . copyOf ( s , s . length ) ; long k = scanner . nextInt ( ) ; long count = 0 ; char first = s [ 0 ] ; boolean all = true ; for ( int i = 1 ; i < s . length ; i ++ ) { all &= first == s [ i ] ; } if ( all ) { System . out . println ( s . length * k / 2 ) ; } else { int start = 0 ; if ( s [ 0 ] == s [ s . length - 1 ] ) { start ++ ; while ( s [ start ] == s [ start - 1 ] ) { start ++ ; } } for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ ( i + start ) % s . length ] == s [ ( i + start + 1 ) % s . length ] ) { s [ ( i + start + 1 ) % s . length ] = ' \\ 0' ; count ++ ; } } count *= k - 1 ; for ( int i = 1 ; i < s . length ; i ++ ) { if ( s2 [ i - 1 ] == s2 [ i ] ) { s2 [ i ] = ' \\ 0' ; count ++ ; } } System . out . println ( count ) ; } } static class Scanner { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) , 1 << 15 ) ; StringTokenizer tokenizer ; String next ( ) { try { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } } catch ( IOException ignored ) { } return tokenizer . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }", "import java . io . InputStream ; import java . io . PrintStream ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { solve ( System . in , System . out ) ; } static void solve ( InputStream is , PrintStream os ) { Scanner scan = new Scanner ( is ) ; String S = scan . next ( ) ; long K = scan . nextLong ( ) ; char sChar [ ] = S . toCharArray ( ) ; char prevChar = sChar [ 0 ] ; long count = 0 ; long tempCount = 1 ; long tempFirstGpCount = 0 ; boolean lastChanged = false ; boolean isAllSame = true ; for ( int i = 1 ; i < sChar . length ; i ++ ) { if ( prevChar == sChar [ i ] ) { tempCount ++ ; if ( i == sChar . length - 1 ) { if ( ( tempCount ) % 2 == 0 ) lastChanged = true ; count += Math . floor ( ( tempCount ) / 2.0 ) ; } } else { if ( isAllSame ) { tempFirstGpCount = tempCount ; } isAllSame = false ; prevChar = sChar [ i ] ; count += Math . floor ( ( tempCount ) / 2.0 ) ; tempCount = 1 ; } } if ( sChar . length != 1 ) { if ( ! lastChanged && sChar [ 0 ] == sChar [ sChar . length - 1 ] ) { if ( isAllSame ) { if ( K % 2 == 0 ) { count = ( count + 1 ) * 2 - 1 ; os . println ( count * ( K / 2 ) ) ; } else { long originCount = count ; count = ( count + 1 ) * 2 - 1 ; os . println ( count * Double . valueOf ( Math . floor ( K / 2.0 ) ) . intValue ( ) + originCount ) ; } } else { if ( tempFirstGpCount % 2 == 1 ) { count ++ ; os . println ( count * K - 1 ) ; } else { os . println ( count * K ) ; } } } else os . println ( count * K ) ; } else os . println ( Double . valueOf ( Math . floor ( K / 2.0 ) ) . intValue ( ) ) ; } }", "import java . util . Random ; import java . util . Scanner ; public class Main { static long minChange ( String S ) { long c = 0 ; for ( int i = S . length ( ) - 1 ; i > 0 ; -- i ) { if ( S . charAt ( i ) == S . charAt ( i - 1 ) ) { ++ c ; -- i ; } } return c ; } static long solve ( String S , long T ) { long ret = 0 ; if ( S . charAt ( S . length ( ) - 1 ) == S . charAt ( 0 ) ) { char c = S . charAt ( 0 ) ; boolean oneChar = true ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { if ( S . charAt ( i ) != c ) { oneChar = false ; } } if ( oneChar ) { T = T * S . length ( ) ; ret = T / 2 ; } else { String S_n = ' _ ' + S . substring ( 1 ) ; long l1 = minChange ( S ) + minChange ( S_n ) * ( T - 1 ) + T - 1 ; String S_n2 = S . substring ( 0 , S . length ( ) - 1 ) + ' _ ' ; long l2 = minChange ( S ) + minChange ( S_n2 ) * ( T - 1 ) + T - 1 ; ret = Math . min ( l1 , l2 ) ; } } else { ret = minChange ( S ) * T ; } return ret ; } static long solveSmall ( String S , long T ) { String r = \" \" ; for ( int t = 0 ; t < T ; ++ t ) { r = r + S ; } return minChange ( r ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String S = sc . next ( ) ; long T = sc . nextLong ( ) ; long ret = solve ( S , T ) ; System . out . println ( ret ) ; } }"], "python": ["def p ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE tc = 1 NEW_LINE ac = 0 NEW_LINE p = s [ 0 ] NEW_LINE for i in range ( 1 , l ) : NEW_LINE INDENT if st [ i ] == p : NEW_LINE INDENT tc += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ac += tc // 2 NEW_LINE tc = 1 NEW_LINE p = st [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ac += tc // 2 NEW_LINE DEDENT return ac NEW_LINE DEDENT s = input ( ) NEW_LINE k = int ( input ( ) ) NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( k // 2 ) NEW_LINE exit ( ) NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT if s [ 0 ] == s [ 1 ] : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT exit ( ) NEW_LINE DEDENT ac = p ( s ) NEW_LINE if k > 1 : NEW_LINE INDENT ac4 = p ( s + s + s + s ) NEW_LINE if ac * 4 == ac4 : NEW_LINE INDENT print ( ac * k ) NEW_LINE DEDENT elif ac4 - ac * 4 == 3 : NEW_LINE INDENT print ( ac * k + ( k - 1 ) ) NEW_LINE DEDENT elif ac4 - ac * 4 == 2 : NEW_LINE INDENT print ( ac * k + ( k // 2 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ac ) NEW_LINE DEDENT", "S = list ( input ( ) ) NEW_LINE K = int ( input ( ) ) NEW_LINE if K % 2 == 0 : NEW_LINE INDENT A = S . copy ( ) NEW_LINE S = S + S NEW_LINE ans = 0 NEW_LINE x = 0 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if S [ i ] == S [ i + 1 ] : NEW_LINE INDENT S [ i + 1 ] = \" : \" NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT if S [ 0 ] == S [ - 1 ] and K > 3 : NEW_LINE INDENT x = ( 1 ) * ( K // 2 - 1 ) NEW_LINE DEDENT print ( ( K // 2 ) * ans + x ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE A = S . copy ( ) NEW_LINE S = S + S NEW_LINE x = 0 NEW_LINE for i in range ( len ( S ) - 1 ) : NEW_LINE INDENT if S [ i ] == S [ i + 1 ] : NEW_LINE INDENT S [ i + 1 ] = \" : \" NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT if S [ i ] != \" : \" and K != 1 : NEW_LINE INDENT A = list ( S [ - 1 ] ) + A NEW_LINE DEDENT for i in range ( len ( A ) - 1 ) : NEW_LINE INDENT if A [ i ] == A [ i + 1 ] : NEW_LINE INDENT A [ i + 1 ] = \" : \" NEW_LINE x += 1 NEW_LINE DEDENT DEDENT print ( ( K // 2 ) * ans + x ) NEW_LINE DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def f ( s ) : NEW_LINE INDENT i = 0 NEW_LINE n = 0 NEW_LINE while i < len ( s ) - 1 : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT n += 1 NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT S = input ( ) . strip ( ) NEW_LINE K = int ( input ( ) ) NEW_LINE a1 = f ( S ) NEW_LINE a2 = f ( S * 2 ) NEW_LINE a3 = f ( S * 3 ) NEW_LINE if K == 1 : NEW_LINE INDENT print ( a1 ) NEW_LINE return NEW_LINE DEDENT if K == 2 : NEW_LINE INDENT print ( a2 ) NEW_LINE return NEW_LINE DEDENT r1 = a2 - a1 NEW_LINE r2 = a3 - a2 NEW_LINE ans = a1 + r1 * ( K // 2 ) + r2 * ( ( K - 1 ) // 2 ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE import numpy as np NEW_LINE from itertools import groupby NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE sys . setrecursionlimit ( 500000 ) NEW_LINE S = list ( readline ( ) . decode ( ) . rstrip ( ) ) NEW_LINE K = int ( readline ( ) ) NEW_LINE g = [ len ( list ( g ) ) for _ , g in groupby ( S ) ] NEW_LINE if len ( g ) == 1 : NEW_LINE INDENT print ( len ( S ) * K // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT acc = sum ( l // 2 for l in g ) * K NEW_LINE if S [ 0 ] == S [ - 1 ] and g [ 0 ] % 2 == 1 and g [ - 1 ] % 2 == 1 : NEW_LINE INDENT acc += K - 1 NEW_LINE DEDENT print ( acc ) NEW_LINE DEDENT", "a = [ input ( ) for i in range ( 2 ) ] NEW_LINE text = a [ 0 ] NEW_LINE iter = int ( a [ 1 ] ) NEW_LINE text_list = list ( text ) NEW_LINE ren = [ ] NEW_LINE start = text_list [ 0 ] NEW_LINE a = 0 NEW_LINE for i in range ( 1 , len ( text_list ) ) : NEW_LINE INDENT if text_list [ i ] == start : NEW_LINE INDENT a += 1 NEW_LINE if i == len ( text_list ) - 1 : NEW_LINE INDENT ren . append ( a ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT start = text_list [ i ] NEW_LINE ren . append ( a ) NEW_LINE a = 0 NEW_LINE DEDENT DEDENT for i in range ( len ( ren ) ) : NEW_LINE INDENT ren [ i ] += 1 NEW_LINE DEDENT if ren == [ ] : NEW_LINE INDENT ren = [ 1 ] NEW_LINE DEDENT ans = 0 NEW_LINE if len ( ren ) == 1 : NEW_LINE INDENT ans = ren [ 0 ] * iter // 2 NEW_LINE DEDENT elif text_list [ 0 ] == text_list [ - 1 ] : NEW_LINE INDENT if ren [ 0 ] % 2 == 1 and ren [ - 1 ] % 2 == 1 : NEW_LINE INDENT for r in ren : NEW_LINE INDENT ans += ( r // 2 ) NEW_LINE DEDENT ans *= iter NEW_LINE ans += iter - 1 NEW_LINE DEDENT else : NEW_LINE INDENT for r in ren : NEW_LINE INDENT ans += ( r // 2 ) NEW_LINE DEDENT ans *= iter NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for r in ren : NEW_LINE INDENT ans += ( r // 2 ) NEW_LINE DEDENT ans *= iter NEW_LINE DEDENT print ( ans ) NEW_LINE"]}
{"id": "codeforces_1397_B", "java": ["import java . util . * ; import java . io . * ; import java . math . * ; public class Contest666B { public static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; long [ ] test = Arrays . stream ( br . readLine ( ) . split ( \" \u2581 \" ) ) . mapToLong ( Long :: parseLong ) . toArray ( ) ; Arrays . sort ( test ) ; long ans1 = 0 , ans2 = 0 , ans3 = 0 ; long c1 = ( long ) Math . ceil ( Math . pow ( ( double ) test [ n - 1 ] , ( double ) 1 / ( n - 1 ) ) ) ; long c2 = ( long ) Math . floor ( Math . pow ( ( double ) test [ n - 1 ] , ( double ) 1 / ( n - 1 ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( test [ i ] != ( long ) Math . pow ( c1 , i ) ) { ans1 += Math . abs ( test [ i ] - ( long ) Math . pow ( c1 , i ) ) ; } if ( test [ i ] != ( long ) Math . pow ( c2 , i ) ) { ans2 += Math . abs ( test [ i ] - ( long ) Math . pow ( c2 , i ) ) ; } } if ( ans1 < 0 ) { pw . println ( ans2 ) ; } else if ( ans2 < 0 ) { pw . println ( ans1 ) ; } else { pw . println ( Math . min ( ans1 , ans2 ) ) ; } pw . close ( ) ; } }"], "python": ["n , s = open ( 0 ) ; print ( min ( sum ( abs ( x - c ** i ) for i , x in enumerate ( sorted ( map ( int , s . split ( ) ) ) ) ) for c in range ( 2 + 9 ** 6 // int ( n ) ** 2 ) ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE inf = 10 ** 18 NEW_LINE if n <= 2 : NEW_LINE INDENT print ( a [ 0 ] - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = sum ( a ) - n NEW_LINE for x in range ( 1 , 10 ** 9 ) : NEW_LINE INDENT curPow = 1 NEW_LINE curCost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curCost += abs ( a [ i ] - curPow ) NEW_LINE curPow *= x NEW_LINE if curPow > inf : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if curPow > inf : NEW_LINE INDENT break NEW_LINE DEDENT if curPow / x > ans + a [ n - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , curCost ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE inf = 10 ** 18 NEW_LINE if n <= 2 : NEW_LINE INDENT print ( a [ 0 ] - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = sum ( a ) - n NEW_LINE for x in range ( 1 , 10 ** 9 ) : NEW_LINE INDENT curPow = 1 NEW_LINE curCost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curCost += abs ( a [ i ] - curPow ) NEW_LINE curPow *= x NEW_LINE if curPow > inf : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if curPow > inf : NEW_LINE INDENT break NEW_LINE DEDENT if curPow / x > ans + a [ n - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT ans = min ( ans , curCost ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( sorted ( a ) ) NEW_LINE if n >= 60 : NEW_LINE INDENT print ( sum ( a ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT min_dif = - 1 NEW_LINE for c in range ( 1 , 10 ** 6 ) : NEW_LINE INDENT dif = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT dif += abs ( c ** i - a [ i ] ) NEW_LINE DEDENT if dif < min_dif or min_dif == - 1 : NEW_LINE INDENT min_dif = dif NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( min_dif ) NEW_LINE DEDENT", "import math NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE k = math . floor ( pow ( a [ - 1 ] , 1 / ( len ( a ) - 1 ) ) ) NEW_LINE a1 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a1 += abs ( k ** i - a [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE a2 = a1 NEW_LINE if n < 40 : NEW_LINE INDENT a2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a2 += abs ( k ** i - a [ i ] ) NEW_LINE DEDENT DEDENT print ( min ( a1 , a2 ) ) NEW_LINE"]}
{"id": "codeforces_930_B", "java": ["import static java . lang . Math . max ; import static java . lang . Math . min ; import static java . lang . Math . abs ; import static java . lang . System . out ; import java . util . * ; import java . io . * ; import java . math . * ; public class x930B { public static void main ( String hi [ ] ) throws Exception { BufferedReader infile = new BufferedReader ( new InputStreamReader ( System . in ) ) ; char [ ] arr = infile . readLine ( ) . toCharArray ( ) ; int N = arr . length ; int [ ] [ ] [ ] guesses = new int [ 26 ] [ N ] [ 26 ] ; for ( int head = 0 ; head < N ; head ++ ) for ( int i = 1 ; i < N ; i ++ ) { int loc = ( head + i ) % N ; guesses [ arr [ head ] - ' a ' ] [ i ] [ arr [ loc ] - ' a ' ] ++ ; } int [ ] freq = new int [ 26 ] ; for ( char c : arr ) freq [ c - ' a ' ] ++ ; double res = 0.0 ; for ( int a = 0 ; a < 26 ; a ++ ) { int [ ] [ ] grid = guesses [ a ] ; double temp = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { int cnt = 0 ; int total = 0 ; for ( int b = 0 ; b < 26 ; b ++ ) { if ( grid [ i ] [ b ] == 1 ) cnt ++ ; total += grid [ i ] [ b ] ; } if ( total > 0 ) temp = max ( temp , 1.0 * cnt / total ) ; } res += ( 1.0 * freq [ a ] / N ) * temp ; } System . out . println ( res ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . HashMap ; public class Problem { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; char [ ] arr = reader . readLine ( ) . toCharArray ( ) ; int n = arr . length ; HashMap < Character , ArrayList < Integer > > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char x = arr [ i ] ; map . putIfAbsent ( x , new ArrayList < > ( ) ) ; ArrayList < Integer > list = map . get ( x ) ; list . add ( i ) ; map . replace ( x , list ) ; } double res = 0 ; for ( char elem : map . keySet ( ) ) { int most = 0 , sum = map . get ( elem ) . size ( ) ; for ( int j = 1 ; j < n ; j ++ ) { HashMap < Character , Integer > amount = new HashMap < > ( ) ; for ( int i : map . get ( elem ) ) { int ind = ( i + j ) % n ; char x = arr [ ind ] ; amount . putIfAbsent ( x , 0 ) ; amount . replace ( x , amount . get ( x ) + 1 ) ; } int ones = 0 ; for ( char item : amount . keySet ( ) ) { if ( amount . get ( item ) == 1 ) ones ++ ; } most = Math . max ( most , ones ) ; } res += ( ( most / ( double ) sum ) * ( sum / ( double ) n ) ) ; } System . out . println ( res ) ; } }"], "python": ["s = input ( ) NEW_LINE def uniq ( iii ) : NEW_LINE INDENT tmp = 0 NEW_LINE for jj in range ( 1 , len ( s ) ) : NEW_LINE INDENT bb = { } NEW_LINE for ii in iii : NEW_LINE INDENT bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) NEW_LINE DEDENT tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) NEW_LINE DEDENT return tmp NEW_LINE DEDENT aa = { } NEW_LINE for ii , ss in enumerate ( s ) : NEW_LINE INDENT aa . setdefault ( ss , [ ] ) . append ( ii ) NEW_LINE DEDENT ans = 0 NEW_LINE for iii in aa . values ( ) : NEW_LINE INDENT ans += uniq ( iii ) NEW_LINE DEDENT print ( ans / len ( s ) ) NEW_LINE", "str = input ( ) NEW_LINE l = len ( str ) NEW_LINE a = [ 0 ] * ( 2 * l ) NEW_LINE pos = [ [ ] for i in range ( 26 ) ] NEW_LINE for i , c in enumerate ( str ) : NEW_LINE INDENT t = ord ( c ) - ord ( ' a ' ) NEW_LINE a [ i ] = t NEW_LINE a [ i + l ] = t NEW_LINE pos [ t ] . append ( i ) NEW_LINE DEDENT ans = 0 NEW_LINE for c in range ( 26 ) : NEW_LINE INDENT cur = 0 NEW_LINE for k in range ( 1 , l ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for i in pos [ c ] : NEW_LINE INDENT cnt [ a [ i + k ] ] += 1 NEW_LINE DEDENT cur = max ( cur , len ( [ 1 for x in cnt if x == 1 ] ) ) NEW_LINE DEDENT ans += cur NEW_LINE DEDENT print ( ans / l ) NEW_LINE", "s = input ( ) NEW_LINE l = len ( s ) NEW_LINE instances = [ [ ] for x in range ( 26 ) ] NEW_LINE s_i = [ ord ( c ) - 97 for c in s ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT instances [ s_i [ i ] ] . append ( i ) NEW_LINE DEDENT sum_probability = 0 NEW_LINE for c in range ( 0 , 26 ) : NEW_LINE INDENT if not instances [ c ] : NEW_LINE INDENT continue NEW_LINE DEDENT if len ( instances [ c ] ) == 0 : NEW_LINE INDENT sum_probability += 1 NEW_LINE continue NEW_LINE DEDENT max_probability = 0 NEW_LINE for guess in range ( 1 , l ) : NEW_LINE INDENT num_seen = [ 0 ] * 26 NEW_LINE probability = 0 NEW_LINE for index in instances [ c ] : NEW_LINE INDENT num_seen [ s_i [ ( index + guess ) % l ] ] += 1 NEW_LINE DEDENT for x in num_seen : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT probability += 1 NEW_LINE DEDENT DEDENT max_probability = max ( max_probability , probability ) NEW_LINE DEDENT sum_probability += max_probability NEW_LINE DEDENT print ( sum_probability / l ) NEW_LINE", "s = input ( ) NEW_LINE def uniq ( iii ) : NEW_LINE INDENT tmp = 0 NEW_LINE for jj in range ( 1 , len ( s ) ) : NEW_LINE INDENT bb = { } NEW_LINE for ii in iii : NEW_LINE INDENT bb . setdefault ( s [ ii - jj ] , [ ] ) . append ( ii ) NEW_LINE DEDENT tmp = max ( tmp , sum ( 1 for vvv in bb . values ( ) if len ( vvv ) == 1 ) ) NEW_LINE DEDENT return tmp NEW_LINE DEDENT aa = { } NEW_LINE for ii , ss in enumerate ( s ) : NEW_LINE INDENT aa . setdefault ( ss , [ ] ) . append ( ii ) NEW_LINE DEDENT ans = 0 NEW_LINE for iii in aa . values ( ) : NEW_LINE INDENT ans += uniq ( iii ) NEW_LINE DEDENT print ( ans / len ( s ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1564_A", "java": ["import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int countIntervals ( int [ ] [ ] arr , int V , int N ) { int count = 0 ; int li , ri ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; ri = arr [ i ] [ 1 ] ; if ( V >= li && V <= ri ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int [ ] [ ] arr = { { 1 , 10 } , { 5 , 10 } , { 15 , 25 } , { 7 , 12 } , { 20 , 25 } } ; int V = 7 ; int N = arr . length ; System . out . println ( countIntervals ( arr , V , N ) ) ; } }"], "python": ["def countIntervals ( arr , V , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE if ( V >= li and V <= ri ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( ( countIntervals ( arr , V , N ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_712_A", "java": ["class GFG { static int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } static long andOperator ( long x , long y ) { long res = 0 ; while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } public static void main ( String [ ] args ) { long x = 10 , y = 15 ; System . out . print ( andOperator ( x , y ) ) ; } }"], "python": ["def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT res = 0 NEW_LINE while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4656_A", "java": ["public class GFG { public int lengthOfLastWord ( final String a ) { boolean char_flag = false ; int len = 0 ; for ( int i = a . length ( ) - 1 ; i >= 0 ; i -- ) { if ( Character . isLetter ( a . charAt ( i ) ) ) { char_flag = true ; len ++ ; } else { if ( char_flag == true ) return len ; } } return len ; } public static void main ( String [ ] args ) { String input = \" Geeks \u2581 For \u2581 Geeks \u2581 \u2581 \" ; GFG gfg = new GFG ( ) ; System . out . println ( \" The \u2581 length \u2581 of \u2581 last \u2581 word \u2581 is \u2581 \" + gfg . lengthOfLastWord ( input ) ) ; } }"], "python": ["def length ( str ) : NEW_LINE INDENT count = 0 ; NEW_LINE flag = False ; NEW_LINE length = len ( str ) - 1 ; NEW_LINE while ( length != 0 ) : NEW_LINE INDENT if ( str [ length ] == ' \u2581 ' ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT length -= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT str = \" Geeks \u2581 for \u2581 Geeks \" ; NEW_LINE print ( \" The \u2581 length \u2581 of \u2581 last \u2581 word \u2581 is \" , length ( str ) ) ; NEW_LINE"]}
{"id": "aizu_p01638_A", "java": ["import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int R = sc . nextInt ( ) ; double X = sc . nextInt ( ) ; double Y = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int P = sc . nextInt ( ) ; double x1 = R * Math . cos ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double y1 = R * Math . sin ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; sum += P ; double x2 = R * Math . cos ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double y2 = R * Math . sin ( Math . PI / 2 - sum / 100.0 * Math . PI * 2 ) ; double SO = Math . PI * R * R * P / 100.0 ; double DS1 = area ( 0 , 0 , x2 , y2 , X , Y ) ; double DS2 = area ( 0 , 0 , X , Y , x1 , y1 ) ; double SN = SO + DS1 + DS2 ; if ( i != 0 ) System . out . print ( \" \u2581 \" ) ; System . out . print ( ( int ) ( 100 * SN / SO ) ) ; } System . out . println ( ) ; } static double area ( double x0 , double y0 , double x1 , double y1 , double x2 , double y2 ) { double dx1 = x1 - x0 ; double dy1 = y1 - y0 ; double dx2 = x2 - x0 ; double dy2 = y2 - y0 ; return ( - dy2 * dx1 + dy1 * dx2 ) / 2 ; } }"], "python": ["from math import pi , cos , sin NEW_LINE r , _x , _y , n = map ( int , input ( ) . split ( ) ) NEW_LINE _m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x , y = _x / r , _y / r NEW_LINE m = sum ( _m ) NEW_LINE t = [ 0.0 ] * ( n + 1 ) NEW_LINE _t = 0 NEW_LINE a = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT _t += _m [ i ] / m * 2 * pi NEW_LINE t [ i + 1 ] = _t NEW_LINE a . append ( int ( ( 1 + ( ( sin ( t [ i ] ) * y - cos ( t [ i ] ) * x ) + ( x * cos ( t [ i + 1 ] ) - y * sin ( t [ i + 1 ] ) ) ) / ( t [ i + 1 ] - t [ i ] ) ) * 100 ) ) NEW_LINE DEDENT print ( * a ) NEW_LINE"]}
{"id": "geeksforgeeks_1098_A", "java": ["import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void partSort ( int [ ] arr , int N , int a , int b ) { int l = Math . min ( a , b ) ; int r = Math . max ( a , b ) ; int [ ] temp = new int [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } Arrays . sort ( temp ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } public static void main ( String args [ ] ) { int [ ] arr = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = arr . length ; partSort ( arr , N , a , b ) ; } }"], "python": ["def partSort ( arr , N , a , b ) : NEW_LINE INDENT l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT temp . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT"]}
{"id": "codeforces_914_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( a ) ; for ( int j = n - 1 ; j >= 0 ; j -- ) { int t = ( int ) Math . sqrt ( a [ j ] ) ; if ( ( t * t ) != a [ j ] ) { System . out . println ( a [ j ] ) ; break ; } } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long number = sc . nextLong ( ) ; long maxNumber = Long . MIN_VALUE ; while ( number -- != 0 ) { long temp = sc . nextLong ( ) ; if ( ! getNumber ( temp ) ) { maxNumber = Math . max ( maxNumber , temp ) ; } } System . out . print ( maxNumber ) ; } private static boolean getNumber ( long n ) { return Math . sqrt ( n ) % 1 == 0 ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int size = Integer . valueOf ( in . nextLine ( ) ) ; int [ ] arr = new int [ size ] ; String [ ] s = in . nextLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < s . length ; i ++ ) { arr [ i ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( arr ) ; int index = 0 ; int cur = 1 ; int max = Integer . MIN_VALUE ; while ( index < arr . length ) { while ( index < arr . length && cur * cur > arr [ index ] ) { if ( arr [ index ] != ( cur - 1 ) * ( cur - 1 ) ) { max = Math . max ( max , arr [ index ] ) ; } index ++ ; } cur ++ ; } System . out . println ( max ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE num = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = num [ i ] NEW_LINE if ( x < 0 or x ** 0.5 % 1 != 0 ) : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = set ( x * x for x in range ( 1001 ) ) NEW_LINE print ( max ( a - b ) ) NEW_LINE", "import math NEW_LINE n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mx = - 10000000 NEW_LINE for i in l : NEW_LINE INDENT x = math . sqrt ( abs ( i ) ) NEW_LINE y = math . floor ( x ) ** 2 NEW_LINE if y != i : NEW_LINE INDENT mx = max ( mx , i ) NEW_LINE DEDENT DEDENT print ( mx ) NEW_LINE", "import math NEW_LINE ans = - 1e18 NEW_LINE n = int ( input ( ) ) NEW_LINE a = input ( ) . split ( ) NEW_LINE for i in a : NEW_LINE INDENT u = int ( i ) NEW_LINE if ( u >= 0 ) : NEW_LINE INDENT if ( math . floor ( math . sqrt ( u ) ) * math . floor ( math . sqrt ( u ) ) != u ) : NEW_LINE INDENT ans = max ( u , ans ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = max ( ans , u ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE squares = set ( ) NEW_LINE for i in range ( 0 , 1000 + 1 ) : NEW_LINE INDENT squares . add ( i * i ) NEW_LINE DEDENT ans = - float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in squares : NEW_LINE INDENT ans = max ( ans , arr [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_3738_A", "java": ["import java . io . * ; class GFG { static int countSolutions ( int a ) { int count = Integer . bitCount ( a ) ; count = ( int ) Math . pow ( 2 , count ) ; return count ; } public static void main ( String [ ] args ) { int a = 3 ; System . out . println ( countSolutions ( a ) ) ; } }"], "python": ["def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1700_A", "java": ["import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Solution { static PrintWriter pw ; static FastScanner s ; public static void main ( String [ ] args ) throws Exception { pw = new PrintWriter ( System . out ) ; s = new FastScanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { long n = s . nextLong ( ) ; long m = s . nextLong ( ) ; long ans = ( n * ( n + 1 ) ) / 2 ; ans -- ; ans *= m ; ans += ( m * ( m + 1 ) ) / 2 ; pw . println ( ans ) ; } pw . flush ( ) ; } } class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public FastScanner ( String s ) throws Exception { br = new BufferedReader ( new FileReader ( new File ( s ) ) ) ; } public String next ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws Exception { return Long . parseLong ( next ( ) ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int tc = input . nextInt ( ) ; work : while ( tc -- > 0 ) { long n = input . nextLong ( ) ; long m = input . nextLong ( ) - 1L ; long first = ( m * ( m + 1 ) ) / 2 ; m ++ ; first += ( ( n * ( n + 1L ) ) / 2L ) * m ; System . out . println ( first ) ; } } }", "import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { long n = sc . nextLong ( ) ; long m = sc . nextLong ( ) ; long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += ( i + 1 ) ; } for ( int i = 1 ; i < n ; i ++ ) { sum += ( i + 1 ) * m ; } System . out . println ( sum ) ; } } }", "import java . io . * ; import java . util . * ; public class cdf802a { public static void main ( String args [ ] ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { String s = br . readLine ( ) ; String str [ ] = s . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; long ans = 0 ; ans += ( m * ( m + 1 ) ) / 2 ; for ( int j = 2 ; j <= n ; j ++ ) ans += m * j ; System . out . println ( ans ) ; } } }"], "python": ["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( m * ( m + 1 ) // 2 ) NEW_LINE DEDENT elif m == 1 : NEW_LINE INDENT print ( n * ( n + 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT p = m * ( m - 1 ) // 2 NEW_LINE q = n * ( n + 1 ) // 2 NEW_LINE q *= m NEW_LINE print ( p + q ) NEW_LINE DEDENT DEDENT", "_n = int ( input ( ) ) NEW_LINE for i in range ( 1 , _n + 1 ) : NEW_LINE INDENT _x , _y = input ( ) . split ( ) NEW_LINE _x = int ( _x ) NEW_LINE _y = int ( _y ) NEW_LINE _ans = ( 1 + _y ) * _y / 2 NEW_LINE _ans += ( _y + _x * _y ) * _x / 2 NEW_LINE _ans -= _y NEW_LINE print ( int ( _ans ) ) NEW_LINE DEDENT", "for i in [ * open ( 0 ) ] [ 1 : ] : num , x = map ( int , i . split ( ) ) ; print ( x * ( x - 1 + num * num + num ) // 2 ) NEW_LINE", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans0 = m * ( m + 1 ) // 2 + m * n * ( n + 1 ) // 2 - m NEW_LINE ans . append ( ans0 ) NEW_LINE DEDENT sys . stdout . write ( \" \\n \" . join ( map ( str , ans ) ) ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( m * ( m - 1 + n * ( n + 1 ) ) ) // 2 ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_153_A", "java": ["import java . util . * ; class GFG { static int N = 1000005 ; static long MAX = ( long ) 1e18 ; static Vector < Long > powers = new Vector < > ( ) ; static TreeSet < Long > squares = new TreeSet < > ( ) ; static TreeSet < Long > s = new TreeSet < > ( ) ; static void powersPrecomputation ( ) { for ( long i = 2 ; i < N ; i ++ ) { squares . add ( i * i ) ; if ( squares . contains ( i ) ) continue ; long temp = i ; while ( i * i <= MAX / temp ) { temp *= ( i * i ) ; s . add ( temp ) ; } } for ( long x : s ) powers . add ( x ) ; } static long calculateAnswer ( long L , long R ) { powersPrecomputation ( ) ; long perfectSquares = ( long ) ( Math . floor ( Math . sqrt ( R ) ) - Math . floor ( Math . sqrt ( L - 1 ) ) ) ; long high = Collections . binarySearch ( powers , R ) ; long low = Collections . binarySearch ( powers , L ) ; long perfectPowers = perfectSquares + ( high - low ) ; long ans = ( R - L + 1 ) - perfectPowers ; return ans ; } public static void main ( String [ ] args ) { long L = 13 , R = 20 ; System . out . println ( calculateAnswer ( L , R ) ) ; } }"], "python": ["from bisect import bisect as upper_bound NEW_LINE from bisect import bisect_left as lower_bound NEW_LINE from math import floor NEW_LINE N = 1000005 NEW_LINE MAX = 10 ** 18 NEW_LINE powers = [ ] NEW_LINE squares = dict ( ) NEW_LINE s = dict ( ) NEW_LINE def powersPrecomputation ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT squares [ i * i ] = 1 NEW_LINE if ( i not in squares . keys ( ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = i NEW_LINE while ( i * i <= ( MAX // temp ) ) : NEW_LINE INDENT temp *= ( i * i ) NEW_LINE s [ temp ] = 1 NEW_LINE DEDENT DEDENT for x in s : NEW_LINE INDENT powers . append ( x ) NEW_LINE DEDENT DEDENT def calculateAnswer ( L , R ) : NEW_LINE INDENT powersPrecomputation ( ) NEW_LINE perfectSquares = floor ( ( R ) ** ( .5 ) ) - floor ( ( L - 1 ) ** ( .5 ) ) NEW_LINE high = upper_bound ( powers , R ) NEW_LINE low = lower_bound ( powers , L ) NEW_LINE perfectPowers = perfectSquares + ( high - low ) NEW_LINE ans = ( R - L + 1 ) - perfectPowers NEW_LINE return ans NEW_LINE DEDENT L = 13 NEW_LINE R = 20 NEW_LINE print ( calculateAnswer ( L , R ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4642_A", "java": ["import java . io . * ; import java . math . * ; class GFG { static long dp [ ] [ ] = new long [ 1000 ] [ 1000 ] ; static long sum ( int a [ ] , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } static long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; } static void intialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 40 , 60 , 20 } ; int n = a . length ; intialize ( n ) ; System . out . println ( solve ( a , 0 , n - 1 ) ) ; } }"], "python": ["import numpy as np NEW_LINE import sys NEW_LINE dp = np . zeros ( ( 1000 , 1000 ) ) NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def intialize ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 40 , 60 , 20 ] NEW_LINE n = len ( a ) NEW_LINE intialize ( n ) NEW_LINE print ( int ( solve ( a , 0 , n - 1 ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_294_A", "java": ["class GfG { static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; System . out . println ( ) ; return ; } static void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } static void printSequences ( int n , int k ) { int arr [ ] = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; } }"], "python": ["def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE"]}
{"id": "aizu_p00032_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int chohoke = 0 ; int hisi = 0 ; for ( String str ; ( str = br . readLine ( ) ) != null ; ) { String [ ] data = str . split ( \" , \" ) ; int a = Integer . parseInt ( data [ 0 ] ) ; int b = Integer . parseInt ( data [ 1 ] ) ; int c = Integer . parseInt ( data [ 2 ] ) ; if ( a * a + b * b == c * c ) chohoke ++ ; if ( a == b ) hisi ++ ; } System . out . println ( chohoke ) ; System . out . println ( hisi ) ; } }", "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = null ; try { sc = new Scanner ( System . in ) ; int countRectangle = 0 ; int countRhombus = 0 ; while ( sc . hasNextLine ( ) ) { String [ ] input = sc . nextLine ( ) . split ( \" , \" ) ; int [ ] sides = convertToInt ( input ) ; if ( isRectangle ( sides ) ) { countRectangle ++ ; } else if ( isRhombus ( sides ) ) { countRhombus ++ ; } } System . out . println ( countRectangle ) ; System . out . println ( countRhombus ) ; } finally { sc . close ( ) ; } } public static boolean isRectangle ( int [ ] side ) { return square ( side [ 0 ] ) + square ( side [ 1 ] ) == square ( side [ 2 ] ) ; } public static boolean isRhombus ( int [ ] side ) { return side [ 0 ] == side [ 1 ] ; } public static int square ( int n ) { return n * n ; } public static int [ ] convertToInt ( String [ ] strings ) { int [ ] ints = new int [ 3 ] ; for ( int i = 0 ; i < ints . length ; i ++ ) { ints [ i ] = Integer . parseInt ( strings [ i ] ) ; } return ints ; } }", "import java . io . * ; import java . util . * ; import java . math . * ; import java . util . regex . Pattern ; import java . util . regex . Matcher ; class Main { public static int calc_plastic ( int l1 , int l2 , int d ) { int l1a , l2a , da ; l1a = ( int ) Math . pow ( l1 , 2 ) ; l2a = ( int ) Math . pow ( l2 , 2 ) ; da = ( int ) Math . pow ( d , 2 ) ; if ( l1 == l2 ) return 2 ; else if ( l1a + l2a == da ) return 1 ; return 0 ; } public static void plastic ( ArrayList < Integer > list ) { int oblong = 0 , diamond = 0 ; int len1 , len2 , diag , res ; for ( int i = 0 ; i < list . size ( ) / 3 ; i ++ ) { len1 = list . get ( i * 3 ) ; len2 = list . get ( i * 3 + 1 ) ; diag = list . get ( i * 3 + 2 ) ; res = calc_plastic ( len1 , len2 , diag ) ; if ( res == 1 ) oblong ++ ; else if ( res == 2 ) diamond ++ ; } System . out . println ( oblong ) ; System . out . println ( diamond ) ; } public static void main ( String args [ ] ) throws IOException { String str ; ArrayList < Integer > inp = new ArrayList < Integer > ( ) ; Scanner scan = new Scanner ( System . in ) ; while ( scan . hasNext ( ) ) { str = scan . next ( ) ; String [ ] strAry = new String [ str . length ( ) ] ; strAry = str . split ( \" , \" ) ; for ( int j = 0 ; j < strAry . length ; j ++ ) { Pattern p = Pattern . compile ( \" [ 0-9 ] * \" ) ; Matcher m = p . matcher ( strAry [ j ] ) ; if ( m . find ( ) ) { int x = Integer . valueOf ( m . group ( 0 ) ) . intValue ( ) ; inp . add ( x ) ; } } } plastic ( inp ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { private static BufferedReader br = null ; static { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public static void main ( String [ ] args ) { int [ ] aParam = null ; int nSquare = 0 ; int nDia = 0 ; while ( ( aParam = parseParam ( ) ) != null ) { if ( aParam [ 0 ] != 0 && aParam [ 1 ] != 0 && aParam [ 2 ] != 0 ) { if ( aParam [ 0 ] == aParam [ 1 ] ) { nDia ++ ; } if ( ( aParam [ 0 ] * aParam [ 0 ] + aParam [ 1 ] * aParam [ 1 ] ) == aParam [ 2 ] * aParam [ 2 ] ) { nSquare ++ ; } } } System . out . println ( nSquare ) ; System . out . println ( nDia ) ; } private static int [ ] parseParam ( ) { int [ ] aParam = null ; String strIn = null ; if ( ( strIn = parseStdin ( ) ) != null ) { String [ ] aN = strIn . split ( \" , \" ) ; aParam = new int [ 3 ] ; aParam [ 0 ] = Integer . parseInt ( aN [ 0 ] ) ; aParam [ 1 ] = Integer . parseInt ( aN [ 1 ] ) ; aParam [ 2 ] = Integer . parseInt ( aN [ 2 ] ) ; } return aParam ; } private static String parseStdin ( ) { String strNum = null ; try { String line = br . readLine ( ) ; if ( line != null ) { if ( ! line . isEmpty ( ) ) { strNum = line ; } } } catch ( IOException e ) { } return strNum ; } }", "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int rectangle , rhomboid ; static String line ; static String [ ] input = new String [ 3 ] ; public static void main ( String [ ] args ) { while ( read ( ) ) { slove ( ) ; } System . out . println ( rectangle ) ; System . out . println ( rhomboid ) ; } static boolean read ( ) { line = sc . nextLine ( ) ; if ( sc . hasNext ( ) == false ) return false ; input = line . split ( \" , \" ) ; return true ; } static void slove ( ) { int w , h , diagonal ; String tmp ; tmp = input [ 0 ] ; w = Integer . parseInt ( tmp ) ; tmp = input [ 1 ] ; h = Integer . parseInt ( tmp ) ; tmp = input [ 2 ] ; diagonal = Integer . parseInt ( tmp ) ; if ( w == h ) { if ( w * w + h * h != diagonal * diagonal ) rhomboid ++ ; } else { if ( w * w + h * h == diagonal * diagonal ) rectangle ++ ; } } }"], "python": ["import sys NEW_LINE rhombus = rectangle = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c = map ( int , line . split ( \" , \" ) ) NEW_LINE if c ** 2 == a ** 2 + b ** 2 : NEW_LINE INDENT rectangle += 1 NEW_LINE DEDENT elif a == b : NEW_LINE INDENT rhombus += 1 NEW_LINE DEDENT DEDENT print ( rectangle ) NEW_LINE print ( rhombus ) NEW_LINE", "def main ( ) : NEW_LINE INDENT Rec = 0 NEW_LINE Dia = 0 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( \" , \" ) ) NEW_LINE if a == b : NEW_LINE INDENT Dia += 1 NEW_LINE DEDENT elif a != b and c > a and c > b : NEW_LINE INDENT Rec += 1 NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( Rec ) NEW_LINE print ( Dia ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from __future__ import ( division , absolute_import , print_function , unicode_literals ) NEW_LINE from sys import stdin NEW_LINE rectangle = diamond = 0 NEW_LINE for line in stdin : NEW_LINE INDENT try : NEW_LINE INDENT a , b , c = ( int ( s ) for s in line . split ( ' , ' ) ) NEW_LINE DEDENT except ValueError : NEW_LINE INDENT break NEW_LINE DEDENT diamond += a == b NEW_LINE rectangle += a ** 2 + b ** 2 == c ** 2 NEW_LINE DEDENT print ( rectangle , diamond , sep = ' \\n ' ) NEW_LINE", "import sys NEW_LINE def is_rectangle ( a , b , c ) : NEW_LINE INDENT return a ** 2 + b ** 2 == c ** 2 NEW_LINE DEDENT def is_rhombus ( a , b , c ) : NEW_LINE INDENT return a == b NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT rectangle_count = 0 NEW_LINE rhombus_count = 0 NEW_LINE for line in sys . stdin : NEW_LINE INDENT a , b , c = [ int ( x ) for x in line . strip ( ) . split ( ' , ' ) ] NEW_LINE if is_rectangle ( a , b , c ) : NEW_LINE INDENT rectangle_count += 1 NEW_LINE DEDENT if is_rhombus ( a , b , c ) : NEW_LINE INDENT rhombus_count += 1 NEW_LINE DEDENT DEDENT print ( ' { 0 } \\n { 1 } ' . format ( rectangle_count , rhombus_count ) ) NEW_LINE DEDENT", "def get_input ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT try : NEW_LINE INDENT yield ' ' . join ( input ( ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT N = list ( get_input ( ) ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for l in range ( len ( N ) ) : NEW_LINE INDENT a , b , c = [ int ( i ) for i in N [ l ] . split ( \" , \" ) ] NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT if a == b : NEW_LINE INDENT ans2 += 1 NEW_LINE DEDENT DEDENT print ( ans1 ) NEW_LINE print ( ans2 ) NEW_LINE"]}
{"id": "geeksforgeeks_4713_A", "java": ["import java . io . * ; import java . util . * ; class GFG { static int maxValue ( int a [ ] , int n ) { HashMap < Integer , Integer > first = new HashMap < > ( ) ; HashMap < Integer , Integer > last = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { first . put ( a [ i ] , 0 ) ; last . put ( a [ i ] , 0 ) ; } int [ ] pr = new int [ n ] ; pr [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pr [ i ] = pr [ i - 1 ] + a [ i ] ; if ( Integer . parseInt ( String . valueOf ( first . get ( a [ i ] ) ) ) == 0 ) first . put ( a [ i ] , i ) ; last . put ( a [ i ] , i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int start = Integer . parseInt ( String . valueOf ( first . get ( a [ i ] ) ) ) ; int end = Integer . parseInt ( String . valueOf ( last . get ( a [ i ] ) ) ) ; if ( start != 0 ) ans = Math . max ( ans , pr [ end ] - pr [ start - 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 3 , 5 , 2 , 4 , 18 , 2 , 3 } ; int n = arr . length ; System . out . print ( maxValue ( arr , n ) ) ; } }"], "python": ["from collections import defaultdict NEW_LINE def maxValue ( a , n ) : NEW_LINE INDENT first = defaultdict ( lambda : 0 ) NEW_LINE last = defaultdict ( lambda : 0 ) NEW_LINE pr = [ None ] * n NEW_LINE pr [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pr [ i ] = pr [ i - 1 ] + a [ i ] NEW_LINE if first [ a [ i ] ] == 0 : NEW_LINE INDENT first [ a [ i ] ] = i NEW_LINE DEDENT last [ a [ i ] ] = i NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT start = first [ a [ i ] ] NEW_LINE end = last [ a [ i ] ] NEW_LINE ans = max ( ans , pr [ end ] - pr [ start - 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 2 , 4 , 18 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxValue ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_667_A", "java": ["import java . util . HashSet ; public class GFG { static int getPairs ( int a [ ] , int n ) { HashSet < Integer > visited1 = new HashSet < Integer > ( ) ; int un [ ] = new int [ n ] ; un [ n - 1 ] = 0 ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( visited1 . contains ( a [ i ] ) ) un [ i - 1 ] = count ; else un [ i - 1 ] = ++ count ; visited1 . add ( a [ i ] ) ; } HashSet < Integer > visited2 = new HashSet < Integer > ( ) ; int answer = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( visited2 . contains ( a [ i ] ) ) continue ; answer += un [ i ] ; visited2 . add ( a [ i ] ) ; } return answer ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 } ; int n = a . length ; System . out . println ( getPairs ( a , n ) ) ; } }"], "python": ["def getPairs ( a , n ) : NEW_LINE INDENT visited1 = set ( ) NEW_LINE un = [ 0 ] * n NEW_LINE un [ n - 1 ] = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited1 ) : NEW_LINE INDENT un [ i - 1 ] = count NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE un [ i - 1 ] = count NEW_LINE DEDENT visited1 . add ( a [ i ] ) NEW_LINE DEDENT visited2 = set ( ) NEW_LINE answer = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] in visited2 ) : NEW_LINE INDENT continue NEW_LINE DEDENT answer += un [ i ] NEW_LINE visited2 . add ( a [ i ] ) NEW_LINE DEDENT return answer NEW_LINE DEDENT a = [ 1 , 2 , 2 , 4 , 2 , 5 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( getPairs ( a , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4121_A", "java": ["import java . io . * ; class GFG { static boolean isTwoAlter ( String s ) { for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 2 ) ) { return false ; } } if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) return false ; return true ; } public static void main ( String [ ] args ) { String str = \" ABAB \" ; if ( isTwoAlter ( str ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"], "python": ["def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" ABAB \" NEW_LINE if ( isTwoAlter ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_799_A", "java": ["class GFG { static void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; System . out . println ( remainder ) ; } public static void main ( String [ ] args ) { int n = 5223 ; findRemainder ( n ) ; } }"], "python": ["def findRemainder ( n ) : NEW_LINE INDENT l = n % 10 NEW_LINE while ( n >= 10 ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT f = n NEW_LINE remainder = f % l NEW_LINE print ( remainder ) NEW_LINE DEDENT n = 5223 NEW_LINE findRemainder ( n ) NEW_LINE"]}
{"id": "codeforces_82_A", "java": ["import java . util . * ; import java . io . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; String [ ] names = new String [ ] { \" Sheldon \" , \" Leonard \" , \" Penny \" , \" Rajesh \" , \" Howard \" } ; long N = in . nextLong ( ) ; long round = 5 ; while ( N > round ) { N -= round ; round *= 2 ; } long sectionLength = round / 5 ; int person = ( int ) ( ( N - 1 ) / sectionLength ) ; pw . println ( names [ person ] ) ; pw . close ( ) ; } }", "import java . util . Scanner ; public class DoubleCola { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; long n = s . nextLong ( ) ; long m = 5 ; long k = 0 ; while ( k + m < n ) { k += m ; m *= 2 ; } long x = n - k ; long y = m / 5 ; if ( x <= y ) System . out . println ( \" Sheldon \" ) ; else if ( x <= 2 * y ) System . out . println ( \" Leonard \" ) ; else if ( x <= 3 * y ) System . out . println ( \" Penny \" ) ; else if ( x <= 4 * y ) System . out . println ( \" Rajesh \" ) ; else System . out . println ( \" Howard \" ) ; } }"], "python": ["name = [ ' Sheldon ' , ' Leonard ' , ' Penny ' , ' Rajesh ' , ' Howard ' ] NEW_LINE n = int ( input ( ) ) NEW_LINE p = 0 NEW_LINE if n <= 5 : NEW_LINE INDENT print ( name [ n % 5 - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while 5 * ( 2 ** p ) <= n : NEW_LINE INDENT n -= ( 5 * ( 2 ** p ) ) NEW_LINE p += 1 NEW_LINE DEDENT res = n // ( 2 ** p ) NEW_LINE print ( name [ res ] ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE m = 5 NEW_LINE i = 1 NEW_LINE q = [ \" Sheldon \" , \" Leonard \" , \" Penny \" , \" Rajesh \" , \" Howard \" ] NEW_LINE while ( m * i < n ) : NEW_LINE INDENT n -= m * i NEW_LINE i *= 2 NEW_LINE DEDENT print ( q [ ( n - 1 ) // ( i ) ] ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE m = 5 NEW_LINE i = 1 NEW_LINE q = [ \" Sheldon \" , \" Leonard \" , \" Penny \" , \" Rajesh \" , \" Howard \" ] NEW_LINE while ( m * i < n ) : NEW_LINE INDENT n -= m * i NEW_LINE i *= 2 NEW_LINE DEDENT print ( q [ ( n - 1 ) // ( i ) ] ) NEW_LINE", "import math NEW_LINE n = int ( input ( ) ) NEW_LINE if math . log ( ( n / 5 + 1 ) , 2 ) % 1 == 0 : NEW_LINE INDENT print ( ' Howard ' ) NEW_LINE DEDENT else : NEW_LINE INDENT x = 1 NEW_LINE while 5 * ( 2 ** x - 1 ) < n : NEW_LINE INDENT x += 1 NEW_LINE DEDENT x = x - 1 NEW_LINE p = 5 * ( 2 ** x - 1 ) NEW_LINE d = n - p NEW_LINE if d <= 2 ** x : NEW_LINE INDENT print ( ' Sheldon ' ) NEW_LINE DEDENT elif 2 ** x < d <= ( 2 ** x ) * 2 : NEW_LINE INDENT print ( ' Leonard ' ) NEW_LINE DEDENT elif ( 2 ** x ) * 2 < d <= ( 2 ** x ) * 3 : NEW_LINE INDENT print ( ' Penny ' ) NEW_LINE DEDENT elif ( 2 ** x ) * 3 < d <= ( 2 ** x ) * 4 : NEW_LINE INDENT print ( ' Rajesh ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Howard ' ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE while 5 * ( 2 ** x - 1 ) < n : NEW_LINE INDENT x += 1 NEW_LINE DEDENT x = x - 1 NEW_LINE p = 5 * ( 2 ** x - 1 ) NEW_LINE d = n - p NEW_LINE if d <= 2 ** x : NEW_LINE INDENT print ( ' Sheldon ' ) NEW_LINE DEDENT elif 2 ** x < d <= ( 2 ** x ) * 2 : NEW_LINE INDENT print ( ' Leonard ' ) NEW_LINE DEDENT elif ( 2 ** x ) * 2 < d <= ( 2 ** x ) * 3 : NEW_LINE INDENT print ( ' Penny ' ) NEW_LINE DEDENT elif ( 2 ** x ) * 3 < d <= ( 2 ** x ) * 4 : NEW_LINE INDENT print ( ' Rajesh ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Howard ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1126_A", "java": ["class GFG { static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 1 , 2 , 3 , 4 , 7 , 9 } ; int [ ] arr2 = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m = arr1 . length ; int n = arr2 . length ; System . out . println ( findSumofEle ( arr1 , m , arr2 , n , k ) ) ; } }"], "python": ["def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n , k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3496_A", "java": ["import java . io . * ; class GFG { static int CountWays ( int n , boolean flag ) { if ( n == 0 ) return 1 ; int sum = 0 ; if ( flag == false && n > 1 ) sum = sum + CountWays ( n - 1 , false ) + CountWays ( n - 2 , true ) ; else sum = sum + CountWays ( n - 1 , false ) ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n , false ) ) ; } }"], "python": ["def CountWays ( n , flag ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE if flag == False and n > 1 : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n , False ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4898_A", "java": ["import java . io . * ; import java . util . * ; public class GFG { static int MaxSumDifference ( Integer [ ] a , int n ) { List < Integer > finalSequence = new ArrayList < Integer > ( ) ; Arrays . sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . add ( a [ i ] ) ; finalSequence . add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( i ) - finalSequence . get ( i + 1 ) ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence . get ( n - 1 ) - finalSequence . get ( 0 ) ) ; return MaximumSum ; } public static void main ( String args [ ] ) { Integer [ ] a = { 1 , 2 , 4 , 8 } ; int n = a . length ; System . out . print ( MaxSumDifference ( a , n ) ) ; } }"], "python": ["import numpy as np NEW_LINE class GFG : NEW_LINE INDENT def MaxSumDifference ( a , n ) : NEW_LINE INDENT np . sort ( a ) ; NEW_LINE j = 0 NEW_LINE finalSequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT finalSequence [ j ] = a [ i ] NEW_LINE finalSequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE INDENT finalSequence [ n - 1 ] = a [ n / 2 ] NEW_LINE DEDENT MaximumSum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) NEW_LINE DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) ; NEW_LINE print ( MaximumSum ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE GFG . MaxSumDifference ( a , n ) ; NEW_LINE"]}
{"id": "geeksforgeeks_662_A", "java": ["class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; } static boolean isPalin ( int n ) { return ( n == reverse ( n ) ) ; } static int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; } static int countPalinDigits ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; } public static void main ( String [ ] args ) { int [ ] arr = { 121 , 56 , 434 } ; int n = arr . length ; System . out . println ( countPalinDigits ( arr , n ) ) ; } }"], "python": ["def reverse ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 10 ; NEW_LINE rev = rev * 10 + d ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalin ( n ) : NEW_LINE INDENT return ( n == reverse ( n ) ) ; NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE c += 1 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def countPalinDigits ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 10 or isPalin ( arr [ i ] ) ) : NEW_LINE INDENT s += countDigits ( arr [ i ] ) ; NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT arr = [ 121 , 56 , 434 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPalinDigits ( arr , n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_2757_A", "java": ["import java . util . Arrays ; import java . lang . Math ; class GFG { public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; else len ++ ; max1 = Math . max ( max1 , len + 1 ) ; } if ( max1 == 1 ) return 0 ; else return max1 ; } public static void main ( String [ ] args ) { String s = \" synapse \" ; System . out . println ( lenoflongestnonpalindrome ( s ) ) ; } }"], "python": ["def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE DEDENT else : NEW_LINE INDENT length += 1 NEW_LINE DEDENT max1 = max ( max1 , length + 1 ) NEW_LINE DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" synapse \" NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1516_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; import java . util . stream . Collectors ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int tc = 0 ; tc < t ; ++ tc ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < a . length ; ++ i ) { a [ i ] = sc . nextInt ( ) ; } System . out . println ( solve ( a , k ) ) ; } sc . close ( ) ; } static String solve ( int [ ] a , int k ) { for ( int i = 0 ; i < a . length - 1 ; ++ i ) { while ( a [ i ] != 0 && k != 0 ) { -- a [ i ] ; ++ a [ a . length - 1 ] ; -- k ; } } return Arrays . stream ( a ) . mapToObj ( String :: valueOf ) . collect ( Collectors . joining ( \" \u2581 \" ) ) ; } }"], "python": ["R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE t , = R ( ) NEW_LINE exec ( t * ' n , k = R ( ) ; a = [ * R ( ) ] ; i = 0 \\n while \u2581 k \u2581 and \u2581 i < n : d = min ( a [ i ] , k ) ; a [ i ] - = d ; a [ -1 ] + = d ; k - = d ; i + = 1 \\n print ( * a ) \\n ' ) NEW_LINE", "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sub = min ( a [ i ] , k ) NEW_LINE a [ i ] = a [ i ] - sub NEW_LINE a [ - 1 ] = a [ - 1 ] + sub NEW_LINE k = k - sub NEW_LINE DEDENT print ( * a , sep = \" \u2581 \" ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE i = 0 NEW_LINE while i < n and k : NEW_LINE INDENT while i < n - 1 and a [ i ] <= 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT a [ i ] -= 1 NEW_LINE a [ - 1 ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT print ( ' \u2581 ' . join ( map ( str , a ) ) ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if k > 0 : NEW_LINE INDENT t = min ( a [ i ] , k ) NEW_LINE a [ i ] -= t NEW_LINE k -= t NEW_LINE s += t NEW_LINE DEDENT DEDENT a [ - 1 ] += s NEW_LINE print ( * a ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE i = 0 NEW_LINE while k and i <= n - 2 : NEW_LINE INDENT x = min ( a [ i ] , k ) NEW_LINE a [ i ] -= x NEW_LINE a [ - 1 ] += x NEW_LINE i += 1 NEW_LINE k -= x NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1241_A", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float ellipse ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; } public static void main ( String args [ ] ) { float a = 5 , b = 3 ; System . out . println ( ellipse ( a , b ) ) ; } }"], "python": ["def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l , b = 5 , 3 NEW_LINE print ( ellipse ( l , b ) ) NEW_LINE DEDENT"]}
{"id": "aizu_p01968_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; TreeSet < Integer > plusSet = new TreeSet < > ( ) ; TreeSet < Integer > minusOneSet = new TreeSet < > ( ) ; TreeMap < Integer , Integer > minusMap = new TreeMap < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int x = sc . nextInt ( ) ; if ( x > 1 ) { plusSet . add ( i ) ; } else if ( x == - 1 ) { minusOneSet . add ( i ) ; } else if ( x < - 1 ) { minusMap . put ( i , x ) ; } } if ( minusMap . size ( ) % 2 == 1 ) { if ( minusOneSet . size ( ) > 0 ) { plusSet . addAll ( minusMap . keySet ( ) ) ; plusSet . add ( minusOneSet . first ( ) ) ; } else { int min = Integer . MAX_VALUE ; int minIdx = 0 ; for ( Map . Entry < Integer , Integer > entry : minusMap . entrySet ( ) ) { if ( min >= entry . getValue ( ) ) { min = entry . getValue ( ) ; minIdx = entry . getKey ( ) ; } } minusMap . remove ( minIdx ) ; plusSet . addAll ( minusMap . keySet ( ) ) ; } } else { plusSet . addAll ( minusMap . keySet ( ) ) ; } StringBuilder sb = new StringBuilder ( ) ; sb . append ( plusSet . size ( ) ) . append ( \" \\n \" ) ; for ( int x : plusSet ) { sb . append ( x ) . append ( \" \\n \" ) ; } System . out . print ( sb ) ; } }"], "python": ["from collections import Counter NEW_LINE def inpl ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = Counter ( A ) NEW_LINE if C [ - 2 ] % 2 == 0 : NEW_LINE INDENT ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * ans , sep = \" \\n \" ) NEW_LINE DEDENT DEDENT elif C [ - 1 ] > 0 : NEW_LINE INDENT ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] + [ A . index ( - 1 ) + 1 ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * sorted ( ans ) , sep = \" \\n \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d = N - A [ : : - 1 ] . index ( - 2 ) NEW_LINE ans = [ i + 1 for i , a in enumerate ( A ) if abs ( a ) == 2 ] NEW_LINE del ans [ ans . index ( d ) ] NEW_LINE print ( len ( ans ) ) NEW_LINE if len ( ans ) : NEW_LINE INDENT print ( * ans , sep = \" \\n \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_5009_A", "java": ["class GFG { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void main ( String [ ] args ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . print ( \" x \u2581 is \u2581 : \u2581 \" + x ) ; x = alternate ( a , b , x ) ; System . out . print ( \" \\n After \u2581 exchange \u2581 \" ) ; System . out . print ( \" \\n x \u2581 is \u2581 : \u2581 \" + x ) ; } }"], "python": ["def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( \" After \u2581 exchange \" ) NEW_LINE print ( \" x \u2581 is \" , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( \" x \u2581 is \" , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE"]}
{"id": "codejam_12_23", "java": ["package round1 ; import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Kattio extends PrintWriter { public Kattio ( InputStream i ) { super ( new BufferedOutputStream ( System . out ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public Kattio ( InputStream i , OutputStream o ) { super ( new BufferedOutputStream ( o ) ) ; r = new BufferedReader ( new InputStreamReader ( i ) ) ; } public boolean hasMoreTokens ( ) { return peekToken ( ) != null ; } public int getInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } public double getDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } public long getLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } public String getWord ( ) { return nextToken ( ) ; } private BufferedReader r ; private String line ; private StringTokenizer st ; private String token ; private String peekToken ( ) { if ( token == null ) try { while ( st == null || ! st . hasMoreTokens ( ) ) { line = r . readLine ( ) ; if ( line == null ) return null ; st = new StringTokenizer ( line ) ; } token = st . nextToken ( ) ; } catch ( IOException e ) { } return token ; } private String nextToken ( ) { String ans = peekToken ( ) ; token = null ; return ans ; } }", "import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . HashMap ; import java . util . Map ; import java . util . Random ; import java . util . Scanner ; public class EqualSums2 { public static void main ( final String ... args ) throws IOException { final String fname = \" C - large \" ; final Scanner sc = new Scanner ( new File ( fname + \" . in \" ) ) ; final PrintWriter pw = new PrintWriter ( fname + \" . out \" ) ; final int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; ++ i ) { System . out . println ( i ) ; final int n = sc . nextInt ( ) ; final long [ ] a = new long [ n ] ; for ( int j = 0 ; j < n ; ++ j ) { a [ j ] = sc . nextLong ( ) ; } final Random rnd = new Random ( ) ; final Map < Long , Long > m = new HashMap < Long , Long > ( ) ; long s1 = - 1 ; long s2 = - 1 ; while ( true ) { long j = rnd . nextLong ( ) ; if ( j < 0 ) { continue ; } long x = j ; int k = 0 ; long s = 0 ; while ( x > 0 ) { if ( ( x & 1 ) != 0 ) { s += a [ k ] ; } x >>= 1 ; ++ k ; } final Long b = m . get ( s ) ; if ( b == null ) { m . put ( s , j ) ; } else if ( b != j ) { s1 = b ; s2 = j ; break ; } } pw . println ( \" Case \u2581 # \" + i + \" : \" ) ; int k = 0 ; while ( s1 > 0 ) { if ( ( s1 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s1 >>= 1 ; ++ k ; } pw . println ( ) ; k = 0 ; while ( s2 > 0 ) { if ( ( s2 & 1 ) != 0 ) { pw . print ( a [ k ] + \" \u2581 \" ) ; } s2 >>= 1 ; ++ k ; } pw . println ( ) ; } pw . close ( ) ; } }", "import java . io . * ; import java . util . * ; public class C implements Runnable { private final int MAX_VALUE = 100000 * 20 + 10 ; private String IFILE = \" C - small - attempt0 . in \" ; private Scanner in ; private PrintWriter out ; public void Run ( ) throws IOException { in = new Scanner ( new File ( IFILE ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int ntest = in . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { out . println ( \" Case \u2581 # \" + test + \" : \" ) ; int n = in . nextInt ( ) ; int [ ] mas = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mas [ i ] = in . nextInt ( ) ; Arrays . sort ( mas ) ; int [ ] f = new int [ MAX_VALUE ] ; Arrays . fill ( f , - 1 ) ; f [ 0 ] = 0 ; boolean ok = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int d = MAX_VALUE - 1 ; d >= 0 ; d -- ) { if ( f [ d ] == - 1 ) continue ; int dd = d + mas [ i ] ; if ( f [ dd ] != - 1 ) { ok = true ; int z = dd ; while ( z != 0 ) { if ( z != dd ) out . print ( \" \u2581 \" ) ; out . print ( mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; out . print ( mas [ i ] ) ; z = d ; while ( z != 0 ) { out . print ( \" \u2581 \" + mas [ f [ z ] ] ) ; z -= mas [ f [ z ] ] ; } out . println ( ) ; break ; } else f [ dd ] = i ; } if ( ok ) break ; } if ( ! ok ) out . println ( \" Impossible \" ) ; } in . close ( ) ; out . close ( ) ; } public void run ( ) { try { Run ( ) ; } catch ( IOException e ) { } } public static void main ( String [ ] args ) throws IOException { new C ( ) . Run ( ) ; } }"], "python": ["class Solver ( object ) : NEW_LINE INDENT @ classmethod NEW_LINE def setup ( cls , infile ) : NEW_LINE INDENT cls . data = { } NEW_LINE DEDENT def __init__ ( self , infile , tc ) : NEW_LINE INDENT self . tc = tc NEW_LINE self . I = I = map ( int , infile . next ( ) . split ( ) ) NEW_LINE DEDENT def solve ( self ) : NEW_LINE INDENT import itertools as it NEW_LINE S = self . I [ 1 : ] NEW_LINE seen = { } NEW_LINE for n in xrange ( 1 , 4 ) : NEW_LINE INDENT for s in it . combinations ( S , n ) : NEW_LINE INDENT ss = sum ( s ) NEW_LINE if ss in seen : NEW_LINE INDENT return ' Case \u2581 # % s : \\n % s \\n % s \\n ' % ( self . tc , ' \u2581 ' . join ( ' % d ' % i for i in s ) , ' \u2581 ' . join ( ' % d ' % i for i in seen [ ss ] ) , ) NEW_LINE DEDENT seen [ ss ] = s NEW_LINE DEDENT DEDENT return ' Case \u2581 # % s : \u2581 Impossible \\n ' % ( self . tc , ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT import sys NEW_LINE T = int ( sys . stdin . next ( ) ) NEW_LINE Solver . setup ( sys . stdin ) NEW_LINE for t in xrange ( 1 , T + 1 ) : NEW_LINE INDENT sys . stdout . write ( Solver ( sys . stdin , t ) . solve ( ) ) NEW_LINE DEDENT DEDENT", "def readline_ints ( ) : NEW_LINE INDENT return [ int ( num ) for num in fin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE DEDENT import itertools NEW_LINE def ordered_subsets_sums ( S ) : NEW_LINE INDENT lim = sum ( S ) // 2 NEW_LINE for i in range ( 1 , len ( S ) ) : NEW_LINE INDENT for subset in itertools . combinations ( S , i ) : NEW_LINE INDENT sub_sum = sum ( subset ) NEW_LINE if sub_sum > lim : NEW_LINE INDENT break NEW_LINE DEDENT yield subset , sub_sum NEW_LINE DEDENT DEDENT DEDENT def find_collision ( S ) : NEW_LINE INDENT sums = { } NEW_LINE for sub , sub_sum in ordered_subsets_sums ( S ) : NEW_LINE INDENT if sub_sum in sums : NEW_LINE INDENT return sums [ sub_sum ] , sub NEW_LINE DEDENT sums [ sub_sum ] = sub NEW_LINE DEDENT DEDENT fname = \" C - large \" NEW_LINE with open ( fname + \" . in \" , \" r \" ) as fin , open ( fname + \" . out \" , \" w \" ) as fout : NEW_LINE INDENT numcases = readline_ints ( ) [ 0 ] NEW_LINE print ( numcases , \" cases \" ) NEW_LINE for caseno in range ( 1 , numcases + 1 ) : NEW_LINE INDENT N , * S = readline_ints ( ) NEW_LINE S . sort ( ) NEW_LINE coll = find_collision ( S ) NEW_LINE if coll is None : NEW_LINE INDENT result = \" Impossible \" NEW_LINE DEDENT else : NEW_LINE INDENT s1 , s2 = coll NEW_LINE result = \" \u2581 \" . join ( str ( n ) for n in sorted ( s1 ) ) + \" \\n \" + \" \u2581 \" . join ( str ( n ) for n in sorted ( s2 ) ) NEW_LINE DEDENT outstr = \" Case \u2581 # % d : \\n % s \" % ( caseno , result ) NEW_LINE fout . write ( outstr + \" \\n \" ) NEW_LINE print ( outstr ) NEW_LINE DEDENT DEDENT", "import os , itertools NEW_LINE curr_dir = os . path . dirname ( os . path . abspath ( __file__ ) ) NEW_LINE srcfilename = os . path . join ( curr_dir , ' C - large . in ' ) NEW_LINE dstfilename = os . path . join ( curr_dir , ' output . txt ' ) NEW_LINE def solve ( numbers_ ) : NEW_LINE INDENT numbers = sorted ( numbers_ ) NEW_LINE memory = dict ( ( k , [ k ] ) for k in numbers ) NEW_LINE for r in xrange ( 2 , len ( numbers ) ) : NEW_LINE INDENT combinations = itertools . combinations ( numbers , r ) NEW_LINE for combination in combinations : NEW_LINE INDENT s = sum ( combination ) NEW_LINE if s in memory : NEW_LINE INDENT r1 = memory [ s ] NEW_LINE r2 = combination NEW_LINE return r1 , r2 NEW_LINE DEDENT memory [ s ] = combination NEW_LINE DEDENT DEDENT return ' Impossible ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT with open ( srcfilename , ' rb ' ) as inp : NEW_LINE INDENT with open ( dstfilename , ' wb ' ) as outp : NEW_LINE INDENT lines = inp . readlines ( ) NEW_LINE count = int ( lines . pop ( 0 ) ) NEW_LINE outlines = [ ] NEW_LINE for i in xrange ( count ) : NEW_LINE INDENT line = lines [ i ] NEW_LINE numbers = [ int ( number ) for number in line . split ( ' \u2581 ' ) ] NEW_LINE numbers . pop ( 0 ) NEW_LINE result = solve ( numbers ) NEW_LINE if result == ' Impossible ' : NEW_LINE INDENT outlines . append ( ' Case \u2581 # % d : \u2581 Impossible \\n ' % ( i + 1 , ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r1 , r2 = result NEW_LINE outlines . append ( ' Case \u2581 # % d : \\n ' % ( i + 1 , ) ) NEW_LINE outlines . append ( ' % s \\n ' % ' \u2581 ' . join ( [ ' % d ' % r1i for r1i in r1 ] ) ) NEW_LINE outlines . append ( ' % s \\n ' % ' \u2581 ' . join ( [ ' % d ' % r2i for r2i in r2 ] ) ) NEW_LINE DEDENT DEDENT outp . writelines ( outlines ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "codeforces_26_A", "java": ["import java . util . ArrayList ; import java . util . HashSet ; import java . util . LinkedHashSet ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class CsAcademy { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int n = cin . nextInt ( ) ; Set < Integer > prime = new LinkedHashSet < > ( ) ; for ( int i = 2 ; i <= 3000 ; i ++ ) { if ( isPrime ( i ) ) { prime . add ( i ) ; } } int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = 0 ; for ( Integer pr : prime ) { if ( i % pr == 0 ) { temp ++ ; } } if ( temp == 2 ) ans ++ ; } System . out . println ( ans ) ; } public static boolean isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } }", "import java . util . Scanner ; import java . util . HashSet ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; HashSet < Integer > st = new HashSet < > ( ) ; int n = sc . nextInt ( ) ; int count ; int r = 0 ; boolean f ; for ( int i = 6 ; i <= n ; i ++ ) { count = 0 ; for ( int j = 2 ; j < i ; j ++ ) { if ( i % j == 0 ) { f = isPrime ( j ) ; count = f ? count += 1 : count ; } } if ( count == 2 ) { r ++ ; } } System . out . println ( r ) ; } static boolean isPrime ( int num ) { if ( num <= 1 ) { return false ; } for ( int i = 2 ; i <= num / 2 ; i ++ ) { if ( ( num % i ) == 0 ) { return false ; } } return true ; } }", "import java . util . Scanner ; public class Main { public static Scanner input = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int primes = 0 , count = 0 , n = input . nextInt ( ) ; if ( n <= 2 ) { System . out . println ( 0 ) ; } else { for ( int i = 3 ; i <= n ; i ++ ) { for ( int j = 2 ; j < i ; j ++ ) { if ( i % j == 0 ) if ( isPrime ( j ) ) { count ++ ; } } if ( count == 2 ) primes ++ ; count = 0 ; } System . out . println ( primes ) ; } } static boolean isPrime ( int num ) { if ( num == 1 ) { return true ; } else if ( num < 1 ) return false ; for ( int i = 2 ; i <= num / 2 ; i ++ ) { if ( ( num % i ) == 0 ) return false ; } return true ; } }", "import java . util . * ; public class H_Almost_Prime { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; int n = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 6 ; i <= n ; i ++ ) { int temp = i ; int count = 0 ; for ( int j = 2 ; j * j <= temp ; j ++ ) { if ( temp % j == 0 ) { count ++ ; while ( temp % j == 0 ) temp /= j ; } } if ( temp > 1 ) count ++ ; if ( count == 2 ) ans ++ ; } System . out . println ( ans ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; public class A_Almost_Prime { public static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( \" \\n \" ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader reader = new FastReader ( ) ; int N = reader . nextInt ( ) ; boolean isPrime [ ] = new boolean [ N + 1 ] ; for ( int i = 2 ; i <= N ; i ++ ) { isPrime [ i ] = true ; } isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; int [ ] factors = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPrime [ i ] == true ) { factors [ i ] ++ ; for ( int j = 2 * i ; j <= N ; j += i ) { factors [ j ] ++ ; isPrime [ j ] = false ; } } } int count = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { if ( factors [ i ] == 2 ) { count ++ ; } } System . out . println ( count ) ; } }"], "python": ["r = int ( input ( ) ) NEW_LINE k = [ 0 ] * ( r + 1 ) NEW_LINE for x in range ( 2 , r + 1 ) : NEW_LINE INDENT if k [ x ] == 0 : NEW_LINE INDENT for y in range ( 2 * x , r + 1 , x ) : NEW_LINE INDENT k [ y ] += 1 NEW_LINE DEDENT DEDENT DEDENT print ( k . count ( 2 ) ) NEW_LINE", "c = int ( input ( ) ) NEW_LINE cou = 0 NEW_LINE p = [ 0 for i in range ( 3005 ) ] NEW_LINE for i in range ( 2 , 3005 ) : NEW_LINE INDENT if p [ i ] == 0 : NEW_LINE INDENT for j in range ( 2 * i , 3005 , i ) : NEW_LINE INDENT p [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT if p [ i ] == 2 : NEW_LINE INDENT cou += 1 NEW_LINE DEDENT DEDENT print ( cou ) NEW_LINE", "def SieveOfEratosthenes ( n ) : NEW_LINE INDENT l_prime = [ ] NEW_LINE not_prime = [ ] NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT l_prime . append ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT not_prime . append ( p ) NEW_LINE DEDENT DEDENT return l_prime , not_prime NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE l_prime , not_prime = SieveOfEratosthenes ( n ) NEW_LINE count = 0 NEW_LINE set1 = set ( l_prime ) NEW_LINE for i in not_prime : NEW_LINE INDENT l = [ ] NEW_LINE j = 2 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT l . append ( j ) NEW_LINE l . append ( i // j ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT set2 = set ( l ) NEW_LINE c = set1 . intersection ( set2 ) NEW_LINE if len ( c ) == 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "import collections NEW_LINE p = [ 0 ] * ( 3005 ) NEW_LINE p [ 0 ] = 0 NEW_LINE p [ 1 ] = 0 NEW_LINE p [ 2 ] = 1 NEW_LINE def sieve_prime ( p , n ) : NEW_LINE INDENT for i in range ( 3 , n , 2 ) : NEW_LINE INDENT p [ i ] = 1 NEW_LINE DEDENT for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if p [ i ] == 1 : NEW_LINE INDENT for j in range ( i * i , n , i ) : NEW_LINE INDENT p [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return p NEW_LINE DEDENT def is_prime ( n , primes ) : NEW_LINE INDENT mp = collections . defaultdict ( list ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if primes [ i ] == 1 : NEW_LINE INDENT for j in range ( i , n , i ) : NEW_LINE INDENT if j not in mp : NEW_LINE INDENT mp [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if mp [ i ] == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT primes = sieve_prime ( p , 3005 ) NEW_LINE n = int ( input ( ) ) NEW_LINE print ( is_prime ( n + 1 , primes ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE def isprime ( x ) : NEW_LINE INDENT if x <= 2 : NEW_LINE INDENT return x == 2 NEW_LINE DEDENT for i in range ( 2 , x ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT s . add ( j ) NEW_LINE s . add ( i // j ) NEW_LINE DEDENT DEDENT res = 0 NEW_LINE for k in s : NEW_LINE INDENT if isprime ( k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if res == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_3698_A", "java": ["import java . util . * ; import java . lang . * ; class GFG { public static void main ( String args [ ] ) { float x1 = 1 , x2 = 3 , x3 = 6 ; float y1 = 2 , y2 = - 4 , y3 = - 7 ; float x = ( x1 + x2 + x3 ) / 3 ; float y = ( y1 + y2 + y3 ) / 3 ; System . out . println ( \" Centroid \u2581 = \u2581 \" + \" ( \" + x + \" , \u2581 \" + y + \" ) \" ) ; } }"], "python": ["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x1 , x2 , x3 = 1 , 3 , 6 NEW_LINE y1 , y2 , y3 = 2 , - 4 , - 7 NEW_LINE x = round ( ( x1 + x2 + x3 ) / 3 , 2 ) NEW_LINE y = round ( ( y1 + y2 + y3 ) / 3 , 2 ) NEW_LINE print ( \" Centroid \u2581 = \" , \" ( \" , x , \" , \" , y , \" ) \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4026_A", "java": ["import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { int max = Integer . MIN_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , arr [ i ] ) ; min = Math . min ( min , arr [ i ] ) ; } int m = max - min + 1 ; if ( m > n ) return false ; boolean visited [ ] = new boolean [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def areElementsContiguous ( arr , n ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited = [ 0 ] * m NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2116_A", "java": ["import java . io . * ; class GFG { static void count_ ( int count [ ] , int e ) { boolean hash [ ] = new boolean [ 10 ] ; while ( e > 0 ) { if ( hash [ e % 10 ] == false ) count [ e % 10 ] ++ ; hash [ e % 10 ] = true ; e /= 10 ; } } static void find_subsequence ( int arr [ ] , int n ) { int count [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { count_ ( count , arr [ i ] ) ; } int longest = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) longest = Math . max ( count [ i ] , longest ) ; System . out . print ( longest ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 12 , 23 , 74 , 13 } ; int n = arr . length ; find_subsequence ( arr , n ) ; } }"], "python": ["def count_ ( count , e ) : NEW_LINE INDENT hash = [ False ] * 10 NEW_LINE while ( e > 0 ) : NEW_LINE INDENT if ( hash [ e % 10 ] == False ) : NEW_LINE INDENT count [ e % 10 ] += 1 NEW_LINE DEDENT hash [ e % 10 ] = True NEW_LINE e //= 10 NEW_LINE DEDENT DEDENT def find_subsequence ( arr , n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count_ ( count , arr [ i ] ) NEW_LINE DEDENT longest = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT longest = max ( count [ i ] , longest ) NEW_LINE DEDENT print ( longest ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 11 , 12 , 23 , 74 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE find_subsequence ( arr , n ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2164_A", "java": ["import java . io . * ; import java . util . * ; class GFG { public static int MAXN = 1000001 ; public static int [ ] spf = new int [ MAXN ] ; static void sieve ( ) { for ( int i = 1 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static int countSubArray ( int arr [ ] , int n ) { int [ ] ind = new int [ MAXN ] ; Arrays . fill ( ind , - 1 ) ; int count = 0 ; int last_ind = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( arr [ i ] > 1 ) { int div = spf [ arr [ i ] ] ; last_ind = Math . max ( last_ind , ind [ div ] ) ; ind [ div ] = i + 1 ; arr [ i ] /= div ; } count += i - last_ind + 1 ; } return count ; } public static void main ( String [ ] args ) { sieve ( ) ; int arr [ ] = { 2 , 3 , 9 } ; int n = arr . length ; System . out . println ( countSubArray ( arr , n ) ) ; int arr1 [ ] = { 2 , 3 , 5 , 15 , 7 , 2 } ; int n1 = arr1 . length ; System . out . println ( countSubArray ( arr1 , n1 ) ) ; } }"], "python": ["from math import sqrt NEW_LINE MAXN = 1000001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT k = int ( sqrt ( MAXN ) ) NEW_LINE for i in range ( 3 , k , 1 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def countSubArray ( arr , n ) : NEW_LINE INDENT ind = [ - 1 for i in range ( MAXN ) ] NEW_LINE count = 0 NEW_LINE last_ind = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT div = spf [ arr [ i ] ] NEW_LINE last_ind = max ( last_ind , ind [ div ] ) NEW_LINE ind [ div ] = i + 1 NEW_LINE arr [ i ] = int ( arr [ i ] / div ) NEW_LINE DEDENT count += i - last_ind + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sieve ( ) NEW_LINE arr = [ 2 , 3 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSubArray ( arr , n ) ) NEW_LINE arr1 = [ 2 , 3 , 5 , 15 , 7 , 2 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( countSubArray ( arr1 , n1 ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4463_A", "java": ["import java . io . * ; class GFG { static int N = 3 ; static void multiply ( int mat [ ] [ ] , int res [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; } } } static boolean InvolutoryMatrix ( int mat [ ] [ ] ) { int res [ ] [ ] = new int [ N ] [ N ] ; multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i ] [ j ] != 1 ) return false ; if ( i != j && res [ i ] [ j ] != 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 0 } , { 0 , - 1 , 0 } , { 0 , 0 , - 1 } } ; if ( InvolutoryMatrix ( mat ) ) System . out . println ( \" Involutory \u2581 Matrix \" ) ; else System . out . println ( \" Not \u2581 Involutory \u2581 Matrix \" ) ; } }"], "python": ["N = 3 ; NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 ; NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] ; NEW_LINE res = multiply ( mat , res ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , - 1 , 0 ] , [ 0 , 0 , - 1 ] ] ; NEW_LINE if ( InvolutoryMatrix ( mat ) ) : NEW_LINE INDENT print ( \" Involutory \u2581 Matrix \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Involutory \u2581 Matrix \" ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1325_A", "java": ["import java . lang . * ; public class crazy_number { public static int first ( int n ) { int a = n ; int c = 1 ; while ( a != 0 ) { a /= 10 ; c = c * 10 ; } c = c / 10 ; int fi = n / c ; return fi ; } public static boolean prime ( int n ) { switch ( n ) { case 2 : return true ; case 3 : return true ; case 5 : return true ; case 7 : return true ; default : return false ; } } public static void check ( int n , int k ) { int l = n % 10 ; int f = first ( n ) ; boolean lp = prime ( l ) ; boolean fp = prime ( f ) ; if ( lp && fp ) { if ( l + f < k ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } else { System . out . println ( \" No \" ) ; } } public static void main ( String args [ ] ) { int n = 322223 ; int k = 10 ; check ( n , k ) ; n = 62531561 ; k = 15 ; check ( n , k ) ; } }"], "python": ["def first ( n ) : NEW_LINE INDENT a = n NEW_LINE c = 1 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a //= 10 NEW_LINE c = c * 10 NEW_LINE DEDENT c = c // 10 NEW_LINE fi = n // c NEW_LINE return fi NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if n in [ 2 , 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( n , k ) : NEW_LINE INDENT l = n % 10 NEW_LINE f = first ( n ) NEW_LINE lp = prime ( l ) NEW_LINE fp = prime ( f ) NEW_LINE if ( lp and fp ) : NEW_LINE INDENT if ( l + f < k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT n = 322223 NEW_LINE k = 10 NEW_LINE check ( n , k ) NEW_LINE n = 62531561 NEW_LINE k = 15 NEW_LINE check ( n , k ) NEW_LINE"]}
{"id": "geeksforgeeks_3649_A", "java": ["import java . awt . Point ; import static java . lang . Math . PI ; import static java . lang . Math . sqrt ; import static java . lang . Math . acos ; class Test { static int lengthSquare ( Point p1 , Point p2 ) { int xDiff = p1 . x - p2 . x ; int yDiff = p1 . y - p2 . y ; return xDiff * xDiff + yDiff * yDiff ; } static void printAngle ( Point A , Point B , Point C ) { int a2 = lengthSquare ( B , C ) ; int b2 = lengthSquare ( A , C ) ; int c2 = lengthSquare ( A , B ) ; float a = ( float ) sqrt ( a2 ) ; float b = ( float ) sqrt ( b2 ) ; float c = ( float ) sqrt ( c2 ) ; float alpha = ( float ) acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; float betta = ( float ) acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; float gamma = ( float ) acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; alpha = ( float ) ( alpha * 180 / PI ) ; betta = ( float ) ( betta * 180 / PI ) ; gamma = ( float ) ( gamma * 180 / PI ) ; System . out . println ( \" alpha \u2581 : \u2581 \" + alpha ) ; System . out . println ( \" betta \u2581 : \u2581 \" + betta ) ; System . out . println ( \" gamma \u2581 : \u2581 \" + gamma ) ; } public static void main ( String [ ] args ) { Point A = new Point ( 0 , 0 ) ; Point B = new Point ( 0 , 1 ) ; Point C = new Point ( 1 , 0 ) ; printAngle ( A , B , C ) ; } }"], "python": ["import math NEW_LINE def lengthSquare ( X , Y ) : NEW_LINE INDENT xDiff = X [ 0 ] - Y [ 0 ] NEW_LINE yDiff = X [ 1 ] - Y [ 1 ] NEW_LINE return xDiff * xDiff + yDiff * yDiff NEW_LINE DEDENT def printAngle ( A , B , C ) : NEW_LINE INDENT a2 = lengthSquare ( B , C ) NEW_LINE b2 = lengthSquare ( A , C ) NEW_LINE c2 = lengthSquare ( A , B ) NEW_LINE a = math . sqrt ( a2 ) ; NEW_LINE b = math . sqrt ( b2 ) ; NEW_LINE c = math . sqrt ( c2 ) ; NEW_LINE alpha = math . acos ( ( b2 + c2 - a2 ) / ( 2 * b * c ) ) ; NEW_LINE betta = math . acos ( ( a2 + c2 - b2 ) / ( 2 * a * c ) ) ; NEW_LINE gamma = math . acos ( ( a2 + b2 - c2 ) / ( 2 * a * b ) ) ; NEW_LINE alpha = alpha * 180 / math . pi ; NEW_LINE betta = betta * 180 / math . pi ; NEW_LINE gamma = gamma * 180 / math . pi ; NEW_LINE print ( \" alpha \u2581 : \u2581 % f \" % ( alpha ) ) NEW_LINE print ( \" betta \u2581 : \u2581 % f \" % ( betta ) ) NEW_LINE print ( \" gamma \u2581 : \u2581 % f \" % ( gamma ) ) NEW_LINE DEDENT A = ( 0 , 0 ) NEW_LINE B = ( 0 , 1 ) NEW_LINE C = ( 1 , 0 ) NEW_LINE printAngle ( A , B , C ) ; NEW_LINE"]}
{"id": "codeforces_1585_B", "java": ["import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { int size = sc . nextInt ( ) ; int [ ] arr = new int [ size ] ; for ( int j = 0 ; j < size ; j ++ ) { arr [ j ] = sc . nextInt ( ) ; } for ( int j = size - 2 ; j >= 0 ; j -- ) { arr [ j ] = Math . max ( arr [ j ] , arr [ j + 1 ] ) ; } int ans = 0 ; int ele = arr [ size - 1 ] ; for ( int j = size - 2 ; j >= 0 ; j -- ) { if ( ele != arr [ j ] ) { ele = arr [ j ] ; ans ++ ; } } System . out . println ( ans ) ; } } }", "import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int cnt = 0 ; int max = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > max ) { max = arr [ i ] ; cnt ++ ; } } System . out . println ( cnt ) ; } } }"], "python": ["t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE array_input = input ( ) . split ( ) NEW_LINE if len ( array_input ) == 1 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT array = [ int ( x ) for x in array_input ] NEW_LINE max_value = max ( array ) NEW_LINE e = 0 NEW_LINE x = array [ - 1 ] NEW_LINE while True : NEW_LINE INDENT for i in array [ : : - 1 ] : NEW_LINE INDENT if i > x : NEW_LINE INDENT e += 1 NEW_LINE x = i NEW_LINE DEDENT if i == max_value : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == max_value : NEW_LINE INDENT ans . append ( e ) NEW_LINE break NEW_LINE DEDENT if e == 0 : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT DEDENT DEDENT t -= 1 NEW_LINE DEDENT print ( * ans , sep = \" \\n \" ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE while ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxE = 0 ; maxV = a [ len ( a ) - 1 ] NEW_LINE for c in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ c ] > maxV ) : NEW_LINE INDENT maxE += 1 NEW_LINE maxV = a [ c ] NEW_LINE DEDENT DEDENT print ( maxE ) NEW_LINE t -= 1 NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for x in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxE = 0 ; maxV = a [ len ( a ) - 1 ] NEW_LINE for c in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ c ] > maxV ) : NEW_LINE INDENT maxE += 1 NEW_LINE maxV = a [ c ] NEW_LINE DEDENT DEDENT print ( maxE ) NEW_LINE DEDENT", "from sys import stdin , stdout NEW_LINE T = int ( stdin . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT N = int ( stdin . readline ( ) ) NEW_LINE A = list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) NEW_LINE MAX = max ( A ) NEW_LINE NEW = [ ] NEW_LINE for j in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if j == len ( A ) - 1 : NEW_LINE INDENT NEW . append ( A [ j ] ) NEW_LINE DEDENT elif A [ j ] > NEW [ - 1 ] : NEW_LINE INDENT NEW . append ( A [ j ] ) NEW_LINE DEDENT if A [ j ] == MAX : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT stdout . write ( f \" { len ( NEW ) -1 } \\n \" ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lena = len ( a ) NEW_LINE count = 0 NEW_LINE z = a [ lena - 1 ] NEW_LINE for j in range ( lena - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( z < a [ j ] ) : NEW_LINE INDENT z = a [ j ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1050_A", "java": ["class MaxevenSum { static int maxEvenSum ( int arr [ ] , int n ) { int pos_sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; if ( pos_sum % 2 == 0 ) return pos_sum ; int ans = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) { if ( arr [ i ] > 0 ) ans = ans > ( pos_sum - arr [ i ] ) ? ans : ( pos_sum - arr [ i ] ) ; else ans = ans > ( pos_sum + arr [ i ] ) ? ans : ( pos_sum + arr [ i ] ) ; } } return ans ; } public static void main ( String s [ ] ) { int a [ ] = { - 2 , 2 , - 3 , 1 } ; System . out . println ( maxEvenSum ( a , a . length ) ) ; } }"], "python": ["INT_MIN = - 100000000 NEW_LINE def maxEvenSum ( arr , n ) : NEW_LINE INDENT pos_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos_sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( pos_sum % 2 == 0 ) : NEW_LINE INDENT return pos_sum NEW_LINE DEDENT ans = INT_MIN ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT ans = max ( ans , pos_sum - arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , pos_sum + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT a = [ - 2 , 2 , - 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxEvenSum ( a , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_253_A", "java": ["class GFG { static int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . length ; System . out . println ( xorOfArray ( arr , n ) ) ; } }"], "python": ["def xorOfArray ( arr , n ) : NEW_LINE INDENT xor_arr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xor_arr = xor_arr ^ arr [ i ] NEW_LINE DEDENT return xor_arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( xorOfArray ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1689_A", "java": ["class GFG { static final int TEN = 10 ; static void updateFreq ( int n , int [ ] freq ) { while ( n > 0 ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } } static boolean areAnagrams ( int a , int b ) { int [ ] freqA = new int [ TEN ] ; int [ ] freqB = new int [ TEN ] ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; } public static void main ( String [ ] args ) { int a = 204 , b = 240 ; if ( areAnagrams ( a , b ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["TEN = 10 NEW_LINE def updateFreq ( n , freq ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT digit = n % TEN NEW_LINE freq [ digit ] += 1 NEW_LINE n //= TEN NEW_LINE DEDENT DEDENT def areAnagrams ( a , b ) : NEW_LINE INDENT freqA = [ 0 ] * TEN NEW_LINE freqB = [ 0 ] * TEN NEW_LINE updateFreq ( a , freqA ) NEW_LINE updateFreq ( b , freqB ) NEW_LINE for i in range ( TEN ) : NEW_LINE INDENT if ( freqA [ i ] != freqB [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = 240 NEW_LINE b = 204 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_644_A", "java": ["class GFG { static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( evenFib ( n ) ) ; } }"], "python": ["def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( evenFib ( n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2534_A", "java": ["class GFG { static int minOperations ( int N ) { double x = Math . log ( N ) / Math . log ( 2 ) ; int ans = ( int ) ( Math . ceil ( x ) ) ; return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . println ( minOperations ( N ) ) ; } }"], "python": ["from math import log2 , ceil NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC046_C", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long [ ] t = new long [ N ] ; long [ ] a = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { t [ i ] = sc . nextLong ( ) ; a [ i ] = sc . nextLong ( ) ; } long [ ] dp = new long [ N ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { long takahashi = ( t [ i - 1 ] * dp [ i - 1 ] + t [ i ] - 1 ) / t [ i ] ; long aoki = ( a [ i - 1 ] * dp [ i - 1 ] + a [ i ] - 1 ) / a [ i ] ; dp [ i ] = Math . max ( takahashi , aoki ) ; } System . out . println ( ( t [ N - 1 ] + a [ N - 1 ] ) * dp [ N - 1 ] ) ; } }", "import java . io . * ; import java . util . * ; public class Main { private static boolean debug = false ; private static boolean elapsed = false ; private static PrintWriter _err = new PrintWriter ( System . err ) ; private void solve ( Scanner sc , PrintWriter out ) { int N = sc . nextInt ( ) ; long [ ] count = new long [ 2 ] ; for ( int i = 0 ; i < N ; ++ i ) { int T = sc . nextInt ( ) ; int A = sc . nextInt ( ) ; if ( i == 0 ) { count [ 0 ] = T ; count [ 1 ] = A ; continue ; } long n = Math . max ( ( count [ 0 ] + T - 1 ) / T , ( count [ 1 ] + A - 1 ) / A ) ; count [ 0 ] = T * n ; count [ 1 ] = A * n ; } out . println ( ( count [ 0 ] + count [ 1 ] ) ) ; } private long C ( long n , long r ) { long res = 1 ; for ( long i = n ; i > n - r ; -- i ) { res *= i ; } for ( long i = r ; i > 1 ; -- i ) { res /= i ; } return res ; } private long P ( long n , long r ) { long res = 1 ; for ( long i = n ; i > n - r ; -- i ) { res *= i ; } return res ; } public static void main ( String [ ] args ) { long S = System . currentTimeMillis ( ) ; Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; new Main ( ) . solve ( sc , out ) ; out . flush ( ) ; long G = System . currentTimeMillis ( ) ; if ( elapsed ) { _err . println ( ( G - S ) + \" ms \" ) ; } _err . flush ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader input = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = input . readLine ( ) ; int n = Integer . parseInt ( str ) ; String [ ] [ ] list = new String [ n ] [ ] ; long [ ] t = new long [ n ] ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { str = input . readLine ( ) ; list [ i ] = str . split ( \" \u2581 \" ) ; t [ i ] = Long . parseLong ( list [ i ] [ 0 ] ) ; a [ i ] = Long . parseLong ( list [ i ] [ 1 ] ) ; } long tans = t [ 0 ] ; long aans = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( long j = 1 ; j < ( long ) Math . pow ( 10 , 18 ) ; ) { if ( tans <= t [ i ] * j && aans <= a [ i ] * j ) { tans = t [ i ] * j ; aans = a [ i ] * j ; break ; } else if ( tans < t [ i ] * j && aans > a [ i ] * j ) { j = ( long ) Math . max ( j + 1 , ( aans / a [ i ] ) ) ; } else if ( tans > t [ i ] * j && aans < a [ i ] * j ) { j = ( long ) Math . max ( j + 1 , ( tans / t [ i ] ) ) ; } else { j = ( long ) Math . max ( j + 1 , Math . max ( ( tans / t [ i ] ) , ( aans / a [ i ] ) ) ) ; } } } System . out . println ( tans + aans ) ; } }", "import java . util . * ; import static java . lang . System . * ; import static java . lang . Math . * ; public class Main { public static void main ( String [ ] $ ) { Scanner sc = new Scanner ( in ) ; int n = sc . nextInt ( ) ; long [ ] T = new long [ n ] ; long [ ] A = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { T [ i ] = sc . nextInt ( ) ; A [ i ] = sc . nextInt ( ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i - 1 ] > A [ i ] || T [ i - 1 ] > T [ i ] ) { long k = max ( ceil ( A [ i - 1 ] , A [ i ] ) , ceil ( T [ i - 1 ] , T [ i ] ) ) ; A [ i ] *= k ; T [ i ] *= k ; } } out . println ( A [ n - 1 ] + T [ n - 1 ] ) ; } static long ceil ( long a , long b ) { return a % b == 0 ? a / b : a / b + 1 ; } }", "import java . util . * ; public class Main { private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) throws Exception { int n = sc . nextInt ( ) ; long t = sc . nextLong ( ) ; long a = sc . nextLong ( ) ; long nt = 0 , na = 0 ; for ( int i = 1 ; i < n ; i ++ ) { nt = sc . nextLong ( ) ; na = sc . nextLong ( ) ; long m = Math . max ( ( t - 1 ) / nt + 1 , ( a - 1 ) / na + 1 ) ; t = nt * m ; a = na * m ; } System . out . println ( t + a ) ; } }"], "python": ["t = a = 1 NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT T , A = map ( int , input ( ) . split ( ) ) ; n = max ( - ( - t // T ) , - ( - a // A ) ) ; t = n * T ; a = n * A NEW_LINE DEDENT print ( t + a ) NEW_LINE", "def nextpt ( ratio1 , ratio2 , pt ) : NEW_LINE INDENT if ratio1 [ 0 ] * ratio2 [ 1 ] - ratio1 [ 1 ] * ratio2 [ 0 ] > 0 : NEW_LINE INDENT pt [ 0 ] = pt [ 0 ] + ( ( - 1 ) * pt [ 0 ] ) % ratio2 [ 0 ] NEW_LINE pt [ 1 ] = pt [ 0 ] * ratio2 [ 1 ] // ratio2 [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT pt [ 1 ] = pt [ 1 ] + ( ( - 1 ) * pt [ 1 ] ) % ratio2 [ 1 ] NEW_LINE pt [ 0 ] = pt [ 1 ] * ratio2 [ 0 ] // ratio2 [ 1 ] NEW_LINE DEDENT return pt NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE ratios = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE pt = ratios [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT pt = nextpt ( ratios [ i ] , ratios [ i + 1 ] , pt ) NEW_LINE DEDENT print ( sum ( pt ) ) NEW_LINE", "N = int ( input ( ) ) NEW_LINE TA = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Tprev , Aprev = TA [ i - 1 ] NEW_LINE Ti , Ai = TA [ i ] NEW_LINE if Ti >= Tprev and Ai >= Aprev : continue NEW_LINE if ( Tprev / Ti ) > ( Aprev / Ai ) : rate = - ( - Tprev // Ti ) NEW_LINE else : rate = - ( - Aprev // Ai ) NEW_LINE TA [ i ] [ 0 ] = Ti * rate NEW_LINE TA [ i ] [ 1 ] = Ai * rate NEW_LINE DEDENT print ( sum ( TA [ - 1 ] ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE suji = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT suji = suji + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT tlist = [ ] NEW_LINE alist = [ ] NEW_LINE for i in range ( 2 * n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT tlist . append ( suji [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT alist . append ( suji [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT aaa = alist [ i ] // alist [ i + 1 ] NEW_LINE ttt = tlist [ i ] // tlist [ i + 1 ] NEW_LINE if alist [ i ] % alist [ i + 1 ] != 0 : NEW_LINE INDENT aaa += 1 NEW_LINE DEDENT if tlist [ i ] % tlist [ i + 1 ] != 0 : NEW_LINE INDENT ttt += 1 NEW_LINE DEDENT k = max ( aaa , ttt ) NEW_LINE tlist [ i + 1 ] = tlist [ i + 1 ] * k NEW_LINE alist [ i + 1 ] = alist [ i + 1 ] * k NEW_LINE DEDENT print ( int ( tlist [ n - 1 ] + alist [ n - 1 ] ) ) NEW_LINE", "from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from string import ascii_lowercase NEW_LINE from functools import lru_cache NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10000 ) NEW_LINE INF = float ( \" inf \" ) NEW_LINE YES , Yes , yes , NO , No , no = \" YES \" , \" Yes \" , \" yes \" , \" NO \" , \" No \" , \" no \" NEW_LINE dy4 , dx4 = [ 0 , 1 , 0 , - 1 ] , [ 1 , 0 , - 1 , 0 ] NEW_LINE dy8 , dx8 = [ 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 , 1 ] , [ 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 ] NEW_LINE def inside ( y , x , H , W ) : NEW_LINE INDENT return 0 <= y < H and 0 <= x < W NEW_LINE DEDENT def ceil ( a , b ) : NEW_LINE INDENT return ( a + b - 1 ) // b NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( N - 1 ) : NEW_LINE INDENT T , A = map ( int , input ( ) . split ( ) ) NEW_LINE for i in count ( max ( a // T , b // A ) - 1 ) : NEW_LINE INDENT if T * i >= a and A * i >= b : NEW_LINE INDENT a , b = T * i , A * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( a + b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4280_A", "java": ["import java . util . * ; import java . io . * ; class GFG { static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return \" YES \" ; return \" NO \" ; } public static void main ( String [ ] args ) { int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; System . out . println ( check ( k , d0 , d1 ) ) ; k = 5 ; d0 = 3 ; d1 = 4 ; System . out . println ( check ( k , d0 , d1 ) ) ; } }"], "python": ["def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return \" YES \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" NO \" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1108_A", "java": ["import java . util . * ; import java . io . * ; import static java . lang . Math . * ; public class Practice { static Scanner scn ; static StringBuilder sb ; public static void main ( String [ ] ScoobyDoobyDo ) { scn = new Scanner ( System . in ) ; sb = new StringBuilder ( ) ; int t = scn . nextInt ( ) ; for ( int tests = 0 ; tests < t ; tests ++ ) solve ( ) ; System . out . println ( sb ) ; } public static void solve ( ) { int l1 = scn . nextInt ( ) , r1 = scn . nextInt ( ) ; int l2 = scn . nextInt ( ) , r2 = scn . nextInt ( ) ; for ( int i = l1 ; i <= r1 ; i ++ ) { for ( int j = l2 ; j <= r2 ; j ++ ) { if ( i != j ) { sb . append ( i + \" \u2581 \" + j + \" \\n \" ) ; return ; } } } } }", "import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- != 0 ) { long l1 = s . nextLong ( ) ; long r1 = s . nextLong ( ) ; long l2 = s . nextLong ( ) ; long r2 = s . nextLong ( ) ; long min = Math . min ( l1 , r1 ) ; long max = Math . max ( l2 , r2 ) ; if ( min == max ) { System . out . println ( Math . max ( l1 , r1 ) + \" \u2581 \" + Math . max ( l2 , r2 ) ) ; } else { System . out . println ( min + \" \u2581 \" + max ) ; } } } }"], "python": ["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if ( a == c and b == d ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( a == c ) : NEW_LINE INDENT print ( a , a + 1 ) NEW_LINE DEDENT elif ( b == d ) : NEW_LINE INDENT print ( b - 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , c ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE import sys NEW_LINE import itertools NEW_LINE import fractions NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT wtf = sys . stdin . read ( ) NEW_LINE wtf = wtf . strip ( ) . split ( ' \\n ' ) NEW_LINE for t in wtf [ 1 : ] : NEW_LINE INDENT l1 , r1 , l2 , r2 = map ( int , t . split ( ) ) NEW_LINE if l1 != l2 : NEW_LINE INDENT print ( l1 , l2 ) NEW_LINE DEDENT elif l1 != r2 : NEW_LINE INDENT print ( l1 , r2 ) NEW_LINE DEDENT elif r1 != l2 : NEW_LINE INDENT print ( r1 , l2 ) NEW_LINE DEDENT elif r1 != r2 : NEW_LINE INDENT print ( r1 , r2 ) NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if a == c : NEW_LINE INDENT print ( a , d ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , c ) NEW_LINE DEDENT DEDENT", "x = int ( input ( ) ) NEW_LINE for _ in range ( x ) : NEW_LINE INDENT l1 , r1 , l2 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE b = False NEW_LINE for i in range ( l1 , r1 + 1 ) : NEW_LINE INDENT for j in range ( l2 , r2 + 1 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT print ( i , j ) NEW_LINE b = True NEW_LINE break NEW_LINE DEDENT DEDENT if b : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT l1 , r1 , l2 , r2 = map ( int , input ( ) . split ( ) ) NEW_LINE if l1 == l2 : NEW_LINE INDENT print ( l1 , r2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l1 , l2 ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT"]}
{"id": "aizu_p02245_A", "java": ["import java . util . * ; import java . io . * ; class Main { public static final int N = 9 ; public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; char c [ ] = new char [ N ] ; String end = \"123456780\" ; String puzzle = \" \" ; int index [ ] = { 1 , - 1 , - 3 , 3 } ; HashMap < String , Integer > hash = new HashMap < String , Integer > ( ) ; Queue < String > queue = new ArrayDeque < String > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { c [ i ] += ( char ) ( sc . nextInt ( ) + 48 ) ; puzzle += c [ i ] ; } queue . add ( puzzle ) ; hash . put ( puzzle , 0 ) ; while ( ! queue . isEmpty ( ) ) { String comfirm = queue . remove ( ) ; if ( comfirm . equals ( end ) ) { System . out . println ( hash . get ( comfirm ) ) ; break ; } StringBuffer s = new StringBuffer ( comfirm ) ; int vacancy = s . indexOf ( \"0\" ) ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( vacancy + index [ i ] >= 0 && vacancy + index [ i ] < N ) { if ( ! ( ( index [ i ] == - 1 ) && ( ( index [ i ] + vacancy ) % 3 == 2 ) ) && ! ( ( index [ i ] == 1 ) && ( ( index [ i ] + vacancy ) % 3 == 0 ) ) ) { s . setCharAt ( vacancy , s . charAt ( vacancy + index [ i ] ) ) ; s . setCharAt ( vacancy + index [ i ] , '0' ) ; if ( ! hash . containsKey ( s . toString ( ) ) ) { queue . add ( s . toString ( ) ) ; hash . put ( s . toString ( ) , hash . get ( comfirm ) + 1 ) ; } s . setCharAt ( vacancy + index [ i ] , s . charAt ( vacancy ) ) ; s . setCharAt ( vacancy , '0' ) ; } } } } } }"], "python": ["from collections import deque NEW_LINE N = 3 NEW_LINE m = { 8 : { 7 , 5 } , 7 : { 8 , 6 , 4 } , 6 : { 7 , 3 } , 5 : { 8 , 4 , 2 } , 4 : { 7 , 5 , 3 , 1 } , 3 : { 6 , 4 , 0 } , 2 : { 5 , 1 } , 1 : { 4 , 2 , 0 } , 0 : { 3 , 1 } } NEW_LINE goal = 123456780 NEW_LINE def g ( i , j , a ) : NEW_LINE INDENT t = a // ( 10 ** j ) % 10 NEW_LINE return a - t * ( 10 ** j ) + t * ( 10 ** i ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT MAP = \" \" . join ( input ( ) . replace ( \" \u2581 \" , \" \" ) for _ in range ( N ) ) NEW_LINE zero = 8 - MAP . find ( \"0\" ) NEW_LINE start = int ( MAP ) NEW_LINE if start == goal : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = deque ( [ ( 0 , start , zero , 1 ) , ( 0 , goal , 0 , 0 ) ] ) NEW_LINE TABLE = { start : ( 1 , 0 ) , goal : ( 0 , 0 ) } NEW_LINE while dp : NEW_LINE INDENT cnt , M , yx , flg = dp . popleft ( ) NEW_LINE cnt += 1 NEW_LINE for nyx in m [ yx ] : NEW_LINE INDENT key = g ( yx , nyx , M ) NEW_LINE if key in TABLE : NEW_LINE INDENT if TABLE [ key ] [ 0 ] != flg : NEW_LINE INDENT return TABLE [ key ] [ 1 ] + cnt NEW_LINE DEDENT continue NEW_LINE DEDENT TABLE [ key ] = ( flg , cnt ) NEW_LINE dp . append ( ( cnt , key , nyx , flg ) ) NEW_LINE DEDENT DEDENT DEDENT def MAIN ( ) : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT MAIN ( ) NEW_LINE", "from heapq import heappush , heappop NEW_LINE N = 3 NEW_LINE M = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT M . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT A = ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 ) NEW_LINE def h ( M ) : NEW_LINE INDENT c = 0 NEW_LINE it = iter ( A ) . __next__ NEW_LINE for i in range ( N ) : NEW_LINE INDENT for v in M [ i ] : NEW_LINE INDENT if v != it ( ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT def f ( M ) : NEW_LINE INDENT M0 = [ ] NEW_LINE for m in M : NEW_LINE INDENT M0 . extend ( m ) NEW_LINE DEDENT return tuple ( M0 ) NEW_LINE DEDENT dd = ( ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ) NEW_LINE ci = cj = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if M [ i ] [ j ] == 0 : NEW_LINE INDENT ci = i ; cj = j NEW_LINE DEDENT DEDENT DEDENT que = [ ( h ( M ) , 0 , ci , cj , M ) ] NEW_LINE U = set ( f ( M ) ) NEW_LINE while que : NEW_LINE INDENT hc , c , cr , cc , M = heappop ( que ) NEW_LINE if hc == c : NEW_LINE INDENT print ( c ) NEW_LINE break NEW_LINE DEDENT for dr , dc in dd : NEW_LINE INDENT nr = cr + dr ; nc = cc + dc NEW_LINE if not 0 <= nr < N or not 0 <= nc < N : NEW_LINE INDENT continue NEW_LINE DEDENT MM = [ m [ : ] for m in M ] NEW_LINE MM [ cr ] [ cc ] = MM [ nr ] [ nc ] NEW_LINE MM [ nr ] [ nc ] = 0 NEW_LINE s = f ( MM ) NEW_LINE if s in U : NEW_LINE INDENT continue NEW_LINE DEDENT U . add ( s ) NEW_LINE heappush ( que , ( h ( MM ) + c + 1 , c + 1 , nr , nc , MM ) ) NEW_LINE DEDENT DEDENT", "adjacent = ( ( 1 , 3 ) , ( 0 , 2 , 4 ) , ( 1 , 5 ) , ( 0 , 4 , 6 ) , ( 1 , 3 , 5 , 7 ) , ( 2 , 4 , 8 ) , ( 3 , 7 ) , ( 4 , 6 , 8 ) , ( 5 , 7 ) ) NEW_LINE GOAL = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 ] NEW_LINE def solve ( start ) : NEW_LINE INDENT if start == GOAL : NEW_LINE INDENT return 0 NEW_LINE DEDENT generated_state = { tuple ( start ) : 0 , tuple ( GOAL ) : 1 } NEW_LINE step = { tuple ( start ) : 0 , tuple ( GOAL ) : 0 } NEW_LINE s = 0 NEW_LINE state1 = [ ( start , 0 ) , ( GOAL , 1 ) ] NEW_LINE while state1 : NEW_LINE INDENT state2 = state1 [ : ] NEW_LINE state1 = [ ] NEW_LINE s += 1 NEW_LINE for s2 , d in state2 : NEW_LINE INDENT i = s2 . index ( 0 ) NEW_LINE for p in adjacent [ i ] : NEW_LINE INDENT s1 = s2 [ : ] NEW_LINE s1 [ i ] , s1 [ p ] = s1 [ p ] , 0 NEW_LINE key = tuple ( s1 ) NEW_LINE if key in generated_state : NEW_LINE INDENT if generated_state [ key ] != d : NEW_LINE INDENT return s + step [ key ] NEW_LINE DEDENT continue NEW_LINE DEDENT state1 . append ( ( s1 , d ) ) NEW_LINE generated_state [ key ] = d NEW_LINE step [ key ] = s NEW_LINE DEDENT DEDENT DEDENT DEDENT import sys NEW_LINE start = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) NEW_LINE print ( solve ( start ) ) NEW_LINE", "from collections import defaultdict , deque NEW_LINE import sys NEW_LINE M = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 3 ) ] NEW_LINE start = 0 NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT start += M [ i ] [ j ] * 10 ** ( ( 2 - i ) * 3 + ( 2 - j ) ) NEW_LINE DEDENT DEDENT start = \" { :0 > 9 } \" . format ( start ) NEW_LINE def make_next_states ( h , w , s ) : NEW_LINE INDENT ret = [ ] NEW_LINE x = [ - 1 , 0 , 1 , 0 ] NEW_LINE y = [ 0 , - 1 , 0 , 1 ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT nh , nw = h + y [ i ] , w + x [ i ] NEW_LINE if ( 0 <= nh <= 2 ) and ( 0 <= nw <= 2 ) : NEW_LINE INDENT swap_ind = nh * 3 + nw NEW_LINE char = s [ swap_ind ] NEW_LINE next_s = s . replace ( char , \" x \" ) . replace ( \"0\" , char ) . replace ( \" x \" , \"0\" ) NEW_LINE ret . append ( next_s ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT finished = defaultdict ( bool ) NEW_LINE finished [ start ] = True NEW_LINE q = deque ( ) NEW_LINE q . append ( [ start , 0 ] ) NEW_LINE while 1 : NEW_LINE INDENT s , n = q . popleft ( ) NEW_LINE finished [ s ] = True NEW_LINE if s == \"123456780\" : NEW_LINE INDENT break NEW_LINE DEDENT null = s . index ( \"0\" ) NEW_LINE null_h = null // 3 NEW_LINE null_w = null % 3 NEW_LINE next_states = make_next_states ( null_h , null_w , s ) NEW_LINE for next_s in next_states : NEW_LINE INDENT if not finished [ next_s ] : NEW_LINE INDENT q . append ( [ next_s , n + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT print ( n ) NEW_LINE", "import heapq NEW_LINE from itertools import chain NEW_LINE from operator import mul NEW_LINE exp10 = [ 10 ** a for a in range ( 8 , - 1 , - 1 ) ] NEW_LINE movables = [ { 1 , 3 } , { 0 , 2 , 4 } , { 1 , 5 } , { 0 , 4 , 6 } , { 1 , 3 , 5 , 7 } , { 2 , 4 , 8 } , { 3 , 7 } , { 4 , 6 , 8 } , { 5 , 7 } ] NEW_LINE destination = 123456780 NEW_LINE def swap ( board , move_from , move_to ) : NEW_LINE INDENT return board + ( exp10 [ move_to ] - exp10 [ move_from ] ) * ( board // exp10 [ move_from ] % 10 ) NEW_LINE DEDENT board0 = sum ( map ( mul , exp10 , chain . from_iterable ( map ( int , input ( ) . split ( ) ) for _ in range ( 3 ) ) ) ) NEW_LINE p0 = ( '0' + str ( board0 ) ) [ - 9 : ] . index ( '0' ) NEW_LINE appeared = ( { board0 : 0 } , { destination : 0 } ) NEW_LINE queue = [ ] NEW_LINE queue . extend ( ( 0 , 0 , move_from , p0 , board0 ) for move_from in movables [ p0 ] ) NEW_LINE queue . extend ( ( 0 , 1 , move_from , 8 , destination ) for move_from in movables [ 8 ] ) NEW_LINE heapq . heapify ( queue ) NEW_LINE while True : NEW_LINE INDENT total_cost , direction , move_from , move_to , board = heapq . heappop ( queue ) NEW_LINE if board in appeared [ not direction ] : NEW_LINE INDENT print ( total_cost + appeared [ not direction ] [ board ] ) NEW_LINE break NEW_LINE DEDENT new_board = swap ( board , move_from , move_to ) NEW_LINE if new_board in appeared [ direction ] : NEW_LINE INDENT continue NEW_LINE DEDENT appeared [ direction ] [ new_board ] = total_cost + 1 NEW_LINE for move_from2 in movables [ move_from ] : NEW_LINE INDENT if move_from2 != move_to : NEW_LINE INDENT heapq . heappush ( queue , ( total_cost + 1 , direction , move_from2 , move_from , new_board ) ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "projecteuler_p171_A", "java": ["public final class p171 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p171 ( ) . run ( ) ) ; } private static final int LENGTH = 20 ; private static final int BASE = 10 ; private static final int MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { int MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH ; long [ ] [ ] sum = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; long [ ] [ ] count = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= LENGTH ; i ++ ) { for ( int j = 0 ; j < BASE ; j ++ ) { for ( int k = 0 ; k + j * j <= MAX_SQR_DIGIT_SUM ; k ++ ) { sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ] [ k ] + Library . powMod ( BASE , i - 1 , MODULUS ) * j % MODULUS * count [ i - 1 ] [ k ] ) % MODULUS ; count [ i ] [ k + j * j ] = ( count [ i ] [ k + j * j ] + count [ i - 1 ] [ k ] ) % MODULUS ; } } } long s = 0 ; for ( int i = 1 ; i * i <= MAX_SQR_DIGIT_SUM ; i ++ ) s = ( s + sum [ LENGTH ] [ i * i ] ) % MODULUS ; return String . format ( \" % 09d \" , s ) ; } }"], "python": ["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MODULUS = 10 ** 9 NEW_LINE MAX_SQR_DIGIT_SUM = ( BASE - 1 ) ** 2 * LENGTH NEW_LINE sqsum = [ ] NEW_LINE count = [ ] NEW_LINE for i in range ( LENGTH + 1 ) : NEW_LINE INDENT sqsum . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE count . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE if i == 0 : NEW_LINE INDENT count [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in itertools . count ( ) : NEW_LINE INDENT index = k + j ** 2 NEW_LINE if index > MAX_SQR_DIGIT_SUM : NEW_LINE INDENT break NEW_LINE DEDENT sqsum [ i ] [ index ] = ( sqsum [ i ] [ index ] + sqsum [ i - 1 ] [ k ] + pow ( BASE , i - 1 , MODULUS ) * j * count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE count [ i ] [ index ] = ( count [ i ] [ index ] + count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( sqsum [ LENGTH ] [ i ** 2 ] for i in range ( 1 , eulerlib . sqrt ( MAX_SQR_DIGIT_SUM ) ) ) NEW_LINE return f \" { ans % MODULUS : 09 } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC132_C", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] d = new int [ n ] ; Arrays . setAll ( d , i -> sc . nextInt ( ) ) ; Arrays . sort ( d ) ; System . out . println ( d [ n / 2 ] - d [ n / 2 - 1 ] ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException , InterruptedException { Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int mid = a [ ( n - 1 ) / 2 ] ; int midone = a [ ( ( n - 1 ) / 2 ) + 1 ] ; out . println ( midone - mid ) ; out . flush ( ) ; } } class Scanner { StringTokenizer st ; BufferedReader br ; public Scanner ( InputStream system ) { br = new BufferedReader ( new InputStreamReader ( system ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public char nextChar ( ) throws IOException { return next ( ) . charAt ( 0 ) ; } public Long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } public void waitForInput ( ) throws InterruptedException { Thread . sleep ( 3000 ) ; } }", "import java . io . BufferedInputStream ; import java . io . BufferedOutputStream ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws Exception { try ( BufferedInputStream in = new BufferedInputStream ( System . in ) ; PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ) { Scanner sc = new Scanner ( in ) ; int n = sc . nextInt ( ) ; int [ ] vs = new int [ n ] ; for ( int i = 0 ; i < vs . length ; i ++ ) vs [ i ] = sc . nextInt ( ) ; Arrays . sort ( vs ) ; out . println ( vs [ vs . length / 2 ] - vs [ vs . length / 2 - 1 ] ) ; } } }", "import java . io . InputStream ; import java . io . PrintStream ; import java . lang . reflect . Array ; import java . util . Arrays ; import java . util . Scanner ; public class Main { static final int MAX = 100100 ; InputStream in = System . in ; PrintStream out = System . out ; public void _main ( String [ ] args ) { Scanner sc = new Scanner ( in ) ; int N = sc . nextInt ( ) ; int d [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) d [ i ] = sc . nextInt ( ) ; Arrays . sort ( d ) ; if ( ( N & 1 ) == 1 ) { out . println ( \"0\" ) ; return ; } int mid = N / 2 ; out . println ( d [ mid ] - d [ mid - 1 ] ) ; } public static void main ( String [ ] args ) { new Main ( ) . _main ( args ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { final Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int [ ] n = new int [ in . nextInt ( ) ] ; for ( int i = 0 ; i < n . length ; i ++ ) { n [ i ] = in . nextInt ( ) ; } Arrays . sort ( n ) ; final int left = n [ n . length / 2 - 1 ] ; final int right = n [ n . length / 2 ] ; if ( left == right ) { System . out . println ( 0 ) ; return ; } System . out . println ( right - left ) ; } }"], "python": ["import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE sys . setrecursionlimit ( 1000000000 ) NEW_LINE from heapq import heappush , heappop , heappushpop NEW_LINE from collections import defaultdict NEW_LINE from itertools import accumulate NEW_LINE from collections import Counter NEW_LINE from collections import deque NEW_LINE from operator import itemgetter NEW_LINE from itertools import permutations NEW_LINE mod = 10 ** 9 + 7 NEW_LINE inf = float ( ' inf ' ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE n = I ( ) NEW_LINE d = LI ( ) NEW_LINE d . sort ( ) NEW_LINE ans = d [ n // 2 ] - d [ n // 2 - 1 ] NEW_LINE print ( ans ) NEW_LINE", "import numpy as np NEW_LINE i_N = int ( input ( ) ) NEW_LINE s_d = input ( ) . split ( ) NEW_LINE i_d = np . array ( s_d ) . astype ( type ( i_N ) ) NEW_LINE i_Counter = 0 NEW_LINE i_d = sorted ( i_d ) NEW_LINE if ( i_d [ int ( len ( i_d ) / 2 ) - 1 ] < i_d [ int ( len ( i_d ) / 2 ) ] ) : NEW_LINE INDENT i_Counter = i_d [ int ( len ( i_d ) / 2 ) ] - i_d [ int ( len ( i_d ) / 2 ) - 1 ] NEW_LINE DEDENT print ( i_Counter ) NEW_LINE", "from sys import stdin NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( stdin . readline ( ) ) NEW_LINE d = [ int ( x ) for x in stdin . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE d . sort ( ) NEW_LINE i = n // 2 NEW_LINE print ( d [ i ] - d [ i - 1 ] ) NEW_LINE DEDENT", "N = int ( input ( ) ) NEW_LINE D = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE D = sorted ( D ) NEW_LINE left = D [ N // 2 - 1 ] NEW_LINE right = D [ N // 2 ] NEW_LINE print ( right - left ) NEW_LINE", "def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE d = sorted ( d ) NEW_LINE print ( d [ int ( n / 2 ) ] - d [ int ( n / 2 - 1 ) ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "aizu_p02456_A", "java": ["import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; Set < Integer > S = new HashSet < > ( ) ; int q = Integer . parseInt ( in . next ( ) ) ; for ( int i = 0 ; i < q ; i ++ ) { int odr = Integer . parseInt ( in . next ( ) ) ; if ( odr == 0 ) { int x = Integer . parseInt ( in . next ( ) ) ; S . add ( x ) ; out . println ( S . size ( ) ) ; } else if ( odr == 1 ) { int x = Integer . parseInt ( in . next ( ) ) ; out . println ( ( S . contains ( x ) ) ? 1 : 0 ) ; } else { int x = Integer . parseInt ( in . next ( ) ) ; S . remove ( x ) ; } } out . flush ( ) ; } }", "import java . util . HashSet ; import java . util . Scanner ; public class Main { static Scanner InData = new Scanner ( System . in ) ; static HashSet < Integer > S = new HashSet < Integer > ( ) ; public static void main ( String [ ] args ) { getQuery ( ) ; } private static void getQuery ( ) { int qNum = InData . nextInt ( ) ; int qType , qVal ; for ( int indexOfQuery = 0 ; indexOfQuery < qNum ; indexOfQuery ++ ) { qType = InData . nextInt ( ) ; qVal = InData . nextInt ( ) ; ; doQuery ( qType , qVal ) ; } } private static void doQuery ( int type , int val ) { switch ( type ) { case 0 : S . add ( val ) ; System . out . println ( S . size ( ) ) ; break ; case 1 : System . out . println ( S . contains ( val ) ? 1 : 0 ) ; break ; case 2 : S . remove ( val ) ; } } }", "import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; HashSet < Integer > list = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; if ( a == 0 ) { list . add ( b ) ; System . out . println ( list . size ( ) ) ; } else if ( a == 1 ) { System . out . println ( list . contains ( b ) ? \"1\" : \"0\" ) ; } else if ( a == 2 ) { list . remove ( b ) ; } } } }", "import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int times = sc . nextInt ( ) ; Set < Long > set = new HashSet < Long > ( ) ; for ( int i = 0 ; i < times ; i ++ ) { int query = sc . nextInt ( ) ; long x = sc . nextLong ( ) ; switch ( query ) { case 0 : set . add ( x ) ; System . out . println ( set . size ( ) ) ; break ; case 1 : if ( set . contains ( x ) ) { System . out . println ( 1 ) ; } else System . out . println ( 0 ) ; break ; case 2 : set . remove ( x ) ; break ; } } } } }", "import java . util . * ; public class Main { public static void main ( String [ ] arg ) { HashSet < Integer > ht = new HashSet < Integer > ( ) ; Scanner sc = new Scanner ( System . in ) ; int cnt = sc . nextInt ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { int cmt = sc . nextInt ( ) ; switch ( cmt ) { case 0 : int num = sc . nextInt ( ) ; if ( ! ht . contains ( num ) ) ht . add ( num ) ; System . out . println ( ht . size ( ) ) ; break ; case 1 : int num2 = sc . nextInt ( ) ; int cnt2 = 0 ; if ( ht . contains ( num2 ) ) cnt2 = 1 ; System . out . println ( cnt2 ) ; break ; case 2 : int num3 = sc . nextInt ( ) ; ht . remove ( num3 ) ; break ; } } } }"], "python": ["def resolve ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE ans = set ( ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT q , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if q == 0 : NEW_LINE INDENT ans . add ( x ) NEW_LINE print ( len ( ans ) ) NEW_LINE DEDENT elif q == 1 : NEW_LINE INDENT if x in ans : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x in ans : NEW_LINE INDENT ans . remove ( x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT resolve ( ) NEW_LINE", "import bisect NEW_LINE S = [ ] NEW_LINE def insert ( S , count , x ) : NEW_LINE INDENT y = bisect . bisect_left ( S , x ) NEW_LINE if y >= count or S [ y ] != x : NEW_LINE INDENT S . insert ( y , x ) NEW_LINE count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE return S , count NEW_LINE DEDENT def find ( S , x ) : NEW_LINE INDENT y = bisect . bisect_left ( S , x ) NEW_LINE if y < count and S [ y ] == x : NEW_LINE INDENT judge = 1 NEW_LINE DEDENT else : NEW_LINE INDENT judge = 0 NEW_LINE DEDENT return judge , y NEW_LINE DEDENT q = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if query [ 0 ] == 0 : NEW_LINE INDENT S , count = insert ( S , count , query [ 1 ] ) NEW_LINE DEDENT elif query [ 0 ] == 1 : NEW_LINE INDENT print ( find ( S , query [ 1 ] ) [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if find ( S , query [ 1 ] ) [ 0 ] == 1 : NEW_LINE INDENT S . pop ( find ( S , query [ 1 ] ) [ 1 ] ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT DEDENT", "readline = open ( 0 ) . readline NEW_LINE writelines = open ( 1 , ' w ' ) . writelines NEW_LINE s = set ( ) NEW_LINE def insert ( x ) : NEW_LINE INDENT s . add ( x ) NEW_LINE ans . append ( \" % d \\n \" % len ( s ) ) NEW_LINE DEDENT def find ( x ) : NEW_LINE INDENT ans . append ( \" % d \\n \" % ( x in s ) ) NEW_LINE DEDENT C = [ insert , find , s . discard ] . __getitem__ NEW_LINE Q = int ( readline ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( Q ) : NEW_LINE INDENT t , x = map ( int , readline ( ) . split ( ) ) NEW_LINE C ( t ) ( x ) NEW_LINE DEDENT writelines ( ans ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE import collections NEW_LINE def main ( ) : NEW_LINE INDENT tl = { } NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cmd = l [ 0 ] NEW_LINE if cmd == 0 : NEW_LINE INDENT tl [ l [ 1 ] ] = 1 NEW_LINE print ( len ( tl ) ) NEW_LINE DEDENT elif cmd == 1 : NEW_LINE INDENT c = 1 if l [ 1 ] in tl else 0 NEW_LINE print ( c ) NEW_LINE DEDENT elif cmd == 2 : NEW_LINE INDENT d = l [ 1 ] NEW_LINE try : NEW_LINE INDENT tl . pop ( d ) NEW_LINE DEDENT except KeyError : NEW_LINE INDENT None NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE s = set ( ) NEW_LINE input ( ) NEW_LINE for q in sys . stdin : NEW_LINE INDENT q = q . split ( ) NEW_LINE if q [ 0 ] == '0' : NEW_LINE INDENT s . add ( q [ 1 ] ) NEW_LINE print ( len ( s ) ) NEW_LINE DEDENT elif q [ 0 ] == '1' : NEW_LINE INDENT print ( int ( q [ 1 ] in s ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . discard ( q [ 1 ] ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_75_A", "java": ["import java . util . Arrays ; class GFG { final static int MAX = 10000002 ; static int prime [ ] = new int [ MAX ] ; static int prime_count [ ] = new int [ MAX ] ; static void sieve ( ) { Arrays . fill ( prime , 0 , MAX , 0 ) ; prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < MAX ; j += i ) { if ( prime [ j ] == 0 ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { prime [ i ] = i ; } } } static long numberOfDivisorsOfProduct ( int [ ] arr , int n ) { Arrays . fill ( prime_count , 0 , MAX , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = arr [ i ] ; while ( temp != 1 ) { prime_count [ prime [ temp ] ] ++ ; temp = temp / prime [ temp ] ; } } long ans = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { ans = ans * ( prime_count [ i ] + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { sieve ( ) ; int arr [ ] = { 2 , 4 , 6 } ; int n = arr . length ; System . out . println ( numberOfDivisorsOfProduct ( arr , n ) ) ; } }"], "python": ["MAX = 10000002 NEW_LINE prime = [ 0 ] * ( MAX ) NEW_LINE MAX_sqrt = int ( MAX ** ( 0.5 ) ) NEW_LINE prime_count = [ 0 ] * ( MAX ) NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , MAX_sqrt ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT if prime [ j ] == 0 : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ i ] == 0 : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def numberOfDivisorsOfProduct ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while temp != 1 : NEW_LINE INDENT prime_count [ prime [ temp ] ] += 1 NEW_LINE temp = temp // prime [ temp ] NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , len ( prime_count ) ) : NEW_LINE INDENT ans = ans * ( prime_count [ i ] + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sieve ( ) NEW_LINE arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numberOfDivisorsOfProduct ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3129_A", "java": ["class GFG { static int check ( int num ) { int digitSum = 0 ; while ( num > 0 ) { digitSum = digitSum + num % 10 ; num = num / 10 ; } int temp = digitSum ; int reverseDigitSum = 0 ; while ( temp > 0 ) { int rem = temp % 10 ; reverseDigitSum = reverseDigitSum * 10 + rem ; temp = temp / 10 ; } int number = digitSum * reverseDigitSum ; return number ; } public static void main ( String args [ ] ) { int num = 1729 ; int x = check ( num ) ; if ( num == x ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while ( num != 0 ) : NEW_LINE INDENT digitSum = digitSum + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT temp = ( int ) ( digitSum ) NEW_LINE reverseDigitSum = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE reverseDigitSum = reverseDigitSum * 10 + rem NEW_LINE temp = temp / 10 NEW_LINE DEDENT number = digitSum * reverseDigitSum NEW_LINE return number NEW_LINE DEDENT num = 1729 NEW_LINE x = ( check ( num ) ) NEW_LINE if ( num == x ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4272_A", "java": ["class Test { static int arr [ ] = { 12 , 3 , 4 , 15 } ; static int sum ( ) { int sum = 0 ; int i ; for ( i = 0 ; i < arr . length ; i ++ ) sum += arr [ i ] ; return sum ; } public static void main ( String [ ] args ) { System . out . println ( \" Sum \u2581 of \u2581 given \u2581 array \u2581 is \u2581 \" + sum ( ) ) ; } }"], "python": ["def _sum ( arr , n ) : NEW_LINE INDENT return ( sum ( arr ) ) NEW_LINE DEDENT arr = [ ] NEW_LINE arr = [ 12 , 3 , 4 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE ans = _sum ( arr , n ) NEW_LINE print ( ' Sum \u2581 of \u2581 the \u2581 array \u2581 is \u2581 ' , ans ) NEW_LINE"]}
{"id": "geeksforgeeks_2329_A", "java": ["public class GFG { static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( \" Total \u2581 ways \u2581 are : \u2581 \" + ways ( n ) ) ; } }"], "python": ["def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( \" Total \u2581 ways \u2581 are : \u2581 \" , ways ( n ) ) ; NEW_LINE"]}
{"id": "codeforces_1006_B", "java": ["import java . io . * ; import java . util . * ; public class Main { public static void find ( int ar [ ] , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int max = 0 ; int idx = - 1 ; for ( int j = 0 ; j < ar . length ; j ++ ) { if ( ar [ j ] > max ) { max = ar [ j ] ; idx = j ; } } sum += max ; ar [ idx ] = - 1 ; } for ( int i = ar . length - 1 ; i >= 0 ; i -- ) { if ( ar [ i ] == - 1 ) { ar [ i ] = 0 ; break ; } } ar [ ar . length - 1 ] = - 1 ; int cnt = 0 ; System . out . println ( sum ) ; for ( int i = 0 ; i < ar . length ; i ++ ) { cnt ++ ; if ( ar [ i ] == - 1 ) { System . out . print ( cnt + \" \u2581 \" ) ; cnt = 0 ; } } } public static void main ( String [ ] args ) { try { System . setIn ( new FileInputStream ( \" input . txt \" ) ) ; System . setOut ( new PrintStream ( new FileOutputStream ( \" output . txt \" ) ) ) ; } catch ( Exception e ) { System . err . println ( \" Error \" ) ; } Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int ar [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = sc . nextInt ( ) ; } find ( ar , k ) ; } }"], "python": ["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ( int ( x ) , i ) for ( i , x ) in enumerate ( input ( ) . split ( ) ) ] NEW_LINE a . sort ( ) NEW_LINE used = [ False for i in range ( n ) ] NEW_LINE sum = 0 NEW_LINE for ( val , index ) in a [ - k : ] : NEW_LINE INDENT sum += val NEW_LINE used [ index ] = True NEW_LINE DEDENT print ( sum ) NEW_LINE cur = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT ans . append ( cur + 1 ) NEW_LINE cur = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT if cur > 0 : NEW_LINE INDENT ans [ - 1 ] += cur NEW_LINE DEDENT print ( * ans ) NEW_LINE", "R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , k = R ( ) NEW_LINE a = sorted ( zip ( R ( ) , range ( n ) ) ) [ - k : ] NEW_LINE print ( sum ( x [ 0 ] for x in a ) ) NEW_LINE b = sorted ( x [ 1 ] for x in a ) + [ n ] NEW_LINE b [ 0 ] = 0 NEW_LINE print ( * ( y - x for x , y in zip ( b , b [ 1 : ] ) ) ) NEW_LINE", "line1 = str ( input ( ) ) NEW_LINE line1 = line1 . split ( \" \u2581 \" ) NEW_LINE n = int ( line1 [ 0 ] ) NEW_LINE k = int ( line1 [ 1 ] ) NEW_LINE string = str ( input ( ) ) NEW_LINE string = string . split ( \" \u2581 \" ) NEW_LINE sort = [ ] NEW_LINE notsort = [ ] NEW_LINE visited = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT visited . append ( \"0\" ) NEW_LINE sort . append ( int ( string [ i ] ) ) NEW_LINE notsort . append ( int ( string [ i ] ) ) NEW_LINE DEDENT sort . sort ( ) NEW_LINE maximum = [ ] NEW_LINE sum = 0 NEW_LINE maximumind = [ ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT maximum . append ( sort [ len ( sort ) - i ] ) NEW_LINE sum += sort [ len ( sort ) - i ] NEW_LINE DEDENT for i in range ( len ( maximum ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( maximum [ i ] == notsort [ j ] and visited [ j ] == \"0\" ) : NEW_LINE INDENT visited [ j ] = \"1\" NEW_LINE maximumind . append ( j ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT maximumind . sort ( ) NEW_LINE size = [ ] NEW_LINE f = 0 NEW_LINE for i in range ( len ( maximumind ) ) : NEW_LINE INDENT count = 0 NEW_LINE if ( i == len ( maximumind ) - 1 ) : NEW_LINE INDENT for j in range ( f , n ) : NEW_LINE INDENT count += 1 NEW_LINE f += 1 NEW_LINE DEDENT size . append ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( f , maximumind [ i ] + 1 ) : NEW_LINE INDENT count += 1 NEW_LINE f += 1 NEW_LINE DEDENT size . append ( count ) NEW_LINE DEDENT DEDENT print ( sum ) NEW_LINE ans = \" \" NEW_LINE for i in range ( len ( size ) ) : NEW_LINE INDENT ans += str ( size [ i ] ) NEW_LINE ans += \" \u2581 \" NEW_LINE DEDENT print ( ans ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = sorted ( w , reverse = True ) [ : k ] NEW_LINE s = [ - 1 ] NEW_LINE for i in range ( len ( d ) ) : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT if d [ i ] != d [ i - 1 ] : NEW_LINE INDENT s . append ( w . index ( d [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( w . index ( d [ i ] , s [ - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . append ( w . index ( d [ i ] ) ) NEW_LINE DEDENT DEDENT print ( sum ( d ) ) NEW_LINE s . sort ( ) NEW_LINE s [ - 1 ] = n - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT print ( s [ i + 1 ] - s [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ ] NEW_LINE i = 0 NEW_LINE for x in input ( ) . split ( ) : NEW_LINE INDENT a . append ( ( int ( x ) , i ) ) NEW_LINE i += 1 NEW_LINE DEDENT used = [ False for i in range ( n ) ] NEW_LINE a . sort ( ) NEW_LINE sum = 0 NEW_LINE for ( val , index ) in a [ - k : ] : NEW_LINE INDENT sum += val NEW_LINE used [ index ] = True NEW_LINE DEDENT print ( sum ) NEW_LINE cur = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if used [ i ] : NEW_LINE INDENT ans . append ( cur + 1 ) NEW_LINE cur = 0 NEW_LINE DEDENT else : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT if cur > 0 : NEW_LINE INDENT ans [ - 1 ] += cur NEW_LINE DEDENT print ( * ans ) NEW_LINE"]}
{"id": "geeksforgeeks_1227_A", "java": ["public class demo { static float pi = 3.14159f ; public static float volume ( float r , float R , float h ) { return ( float ) 1 / 3 * pi * h * ( r * r + R * R + r * R ) ; } public static float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; } public static float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; } public static void main ( String args [ ] ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ; System . out . print ( \" Volume \u2581 Of \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; System . out . println ( volume ( small_radius , big_radius , height ) ) ; System . out . print ( \" Curved \u2581 Surface \u2581 Area \u2581 Of \" + \" \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; System . out . println ( curved_surface_area ( small_radius , big_radius , slant_height ) ) ; System . out . print ( \" Total \u2581 Surface \u2581 Area \u2581 Of \" + \" \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" ) ; System . out . println ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) ; } }"], "python": ["import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return 1 / 3 * pi * h * ( r * r + R * R + r * R ) NEW_LINE DEDENT def curved_surface_area ( r , R , l ) : NEW_LINE INDENT return pi * l * ( R + r ) NEW_LINE DEDENT def total_surface_area ( r , R , l , h ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( \" Volume \u2581 Of \u2581 Frustum \u2581 of \u2581 Cone \u2581 : \u2581 \" , end = ' ' ) NEW_LINE print ( volume ( small_radius , big_radius , height ) ) NEW_LINE print ( \" Curved \u2581 Surface \u2581 Area \u2581 Of \u2581 Frustum \" + \" \u2581 of \u2581 Cone \u2581 : \u2581 \" , end = ' ' ) NEW_LINE print ( curved_surface_area ( small_radius , big_radius , slant_height ) ) NEW_LINE print ( \" Total \u2581 Surface \u2581 Area \u2581 Of \u2581 Frustum \" + \" \u2581 of \u2581 Cone \u2581 : \u2581 \" , end = ' ' ) NEW_LINE print ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2419_A", "java": ["import java . util . * ; class GFG { static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; } static boolean isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static boolean isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 56 ; if ( isDigitSumPalindrome ( n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def digitSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 ; NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor ; NEW_LINE trailing = n % 10 ; NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = ( n % divisor ) // 10 ; NEW_LINE divisor = divisor // 100 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) ; NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 56 ; NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1555_A", "java": ["import java . util . Scanner ; public class PizzaForces { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int test = sc . nextInt ( ) ; while ( test > 0 ) { long n = sc . nextLong ( ) ; long ans = 0 ; if ( n <= 6 ) System . out . println ( \"15\" ) ; else { if ( n % 2 == 1 ) n ++ ; n = n / 2 ; ans = ( long ) ( n * 5 ) ; System . out . println ( ans ) ; } test -- ; } } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; long t = sc . nextLong ( ) ; while ( t -- > 0 ) { long n = sc . nextLong ( ) ; if ( n <= 6 ) { System . out . println ( 15 ) ; } else { if ( n % 2 == 0 ) System . out . println ( ( n / 2 ) * 5 ) ; else System . out . println ( ( n / 2 + 1 ) * 5 ) ; } } } }", "import java . util . Scanner ; public class T1555A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { long n = in . nextLong ( ) ; long n6 = 0 ; int n8 = 0 ; int n10 = 0 ; if ( n > 6 ) { n6 = n / 6 ; long remainder = n % 6 ; if ( remainder == 0 ) { } else if ( remainder <= 2 ) { n8 ++ ; n6 -- ; } else if ( remainder <= 4 ) { n10 ++ ; n6 -- ; } else { n6 ++ ; } } else { n6 = 1 ; } long result = n6 * 15 + n8 * 20 + n10 * 25 ; System . out . println ( result ) ; } } }"], "python": ["t = int ( input ( ) ) NEW_LINE z = 1 NEW_LINE while ( z <= t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( \"15\" ) NEW_LINE DEDENT elif ( n > 6 and n % 2 != 0 ) : NEW_LINE INDENT n = n + 1 NEW_LINE print ( n // 2 * 5 ) NEW_LINE DEDENT elif ( n >= 6 and n % 2 == 0 ) : NEW_LINE INDENT print ( n // 2 * 5 ) NEW_LINE DEDENT z = z + 1 NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE n += n % 2 NEW_LINE n = max ( 6 , n ) NEW_LINE print ( 5 * ( n // 2 ) ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if i > t : NEW_LINE INDENT break NEW_LINE DEDENT i = i + 1 NEW_LINE n = int ( input ( ) ) NEW_LINE k = n // 6 NEW_LINE if n <= 6 : NEW_LINE INDENT print ( 15 ) NEW_LINE continue NEW_LINE DEDENT if n % 6 == 0 : NEW_LINE INDENT print ( 15 * k ) NEW_LINE DEDENT elif n % 6 == 1 or n % 6 == 2 : NEW_LINE INDENT print ( 15 * ( k - 1 ) + 20 ) NEW_LINE DEDENT elif n % 6 == 3 or n % 6 == 4 : NEW_LINE INDENT print ( 15 * ( k - 1 ) + 25 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 15 * ( k + 1 ) ) NEW_LINE DEDENT DEDENT", "def solve ( n ) : NEW_LINE INDENT time = 2.5 NEW_LINE if n <= 6 : NEW_LINE INDENT return round ( 6 * time ) NEW_LINE DEDENT if n <= 8 : NEW_LINE INDENT return round ( 8 * time ) NEW_LINE DEDENT if n <= 10 : NEW_LINE INDENT return round ( 10 * time ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return round ( n * 2 + round ( n / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE return round ( n * 2 + round ( n / 2 ) ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT", "test = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE while ( count < test ) : NEW_LINE INDENT ans = 0 NEW_LINE friends = int ( input ( ) ) NEW_LINE smalls = friends // 6 NEW_LINE ans = smalls * 15 NEW_LINE if ( friends <= 6 ) : NEW_LINE INDENT print ( 15 ) NEW_LINE count += 1 NEW_LINE continue NEW_LINE DEDENT if ( friends % 6 == 1 or friends % 6 == 2 ) : NEW_LINE INDENT ans += 5 NEW_LINE DEDENT elif ( friends % 6 == 3 or friends % 6 == 4 ) : NEW_LINE INDENT ans += 10 NEW_LINE DEDENT elif ( friends % 6 == 5 ) : NEW_LINE INDENT ans += 15 NEW_LINE DEDENT print ( ans ) NEW_LINE count += 1 NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_29_A", "java": ["import java . util . * ; class GFG { static float getPercentile ( int rank , int students ) { float result = ( float ) ( students - rank ) / students * 100 ; return result ; } public static void main ( String [ ] args ) { int your_rank = 805 ; int total_students = 97481 ; System . out . print ( getPercentile ( your_rank , total_students ) ) ; } }"], "python": ["def getPercentile ( rank , students ) : NEW_LINE INDENT result = ( students - rank ) / students * 100 ; NEW_LINE return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT your_rank = 805 ; NEW_LINE total_students = 97481 ; NEW_LINE print ( getPercentile ( your_rank , total_students ) ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1323_A", "java": ["class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1324_A", "java": ["class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( isPrime ( n ) and ( n % 4 == 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_50_A", "java": ["class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE if ( isPrime ( n ) and isPowerOfTwo ( n * 3 - 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "codeforces_1593_A", "java": ["import java . io . * ; import java . util . * ; public class Main { public static double aver ( int [ ] arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { sum = sum + arr [ i ] ; } return sum / arr . length ; } public static int fac ( int x ) { int sum = 1 ; while ( x > 0 ) { sum = sum * x ; x = x - 1 ; } return sum ; } public static int comb ( int x , int y ) { int sum = 0 ; sum = fac ( x ) ; int temp = ( fac ( y ) * fac ( x - y ) ) ; return sum / temp ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n > 0 ) { int [ ] arr = new int [ 3 ] ; int max = 0 ; int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( arr [ i ] > max ) max = arr [ i ] ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == max ) count += 1 ; arr [ i ] = max - arr [ i ] + 1 ; } for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 1 && max != 0 && count == 1 ) System . out . print ( 0 + \" \u2581 \" ) ; else System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; n = n - 1 ; } } }", "import java . util . Scanner ; public class Elections { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int max = Math . max ( a , Math . max ( b , c ) ) ; if ( a == b && b == c ) { System . out . println ( 1 + \" \u2581 \" + 1 + \" \u2581 \" + 1 ) ; } else if ( a > b && a > c ) { System . out . println ( ( 0 ) + \" \u2581 \" + ( ( max - b ) + 1 ) + \" \u2581 \" + ( ( max - c ) + 1 ) ) ; } else if ( b > a && b > c ) { System . out . println ( ( ( max - a ) + 1 ) + \" \u2581 \" + ( 0 ) + \" \u2581 \" + ( ( max - c ) + 1 ) ) ; } else if ( c > a && c > b ) { System . out . println ( ( ( max - a ) + 1 ) + \" \u2581 \" + ( ( max - b ) + 1 ) + \" \u2581 \" + ( 0 ) ) ; } else if ( a == max && b == max ) { System . out . println ( 1 + \" \u2581 \" + 1 + \" \u2581 \" + ( ( max - c ) + 1 ) ) ; } else if ( a == max && c == max ) { System . out . println ( 1 + \" \u2581 \" + ( ( max - b ) + 1 ) + \" \u2581 \" + 1 ) ; } else if ( b == max && c == max ) { System . out . println ( ( ( max - a ) + 1 ) + \" \u2581 \" + 1 + \" \u2581 \" + 1 ) ; } t -- ; } } }", "import java . util . Scanner ; public class test186 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int a [ ] = new int [ 3 ] ; int max = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { a [ i ] = in . nextInt ( ) ; if ( a [ i ] > max ) { max = a [ i ] ; } } int sum = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] == max ) { sum ++ ; } } if ( sum == 1 ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] != max ) System . out . print ( ( max - a [ i ] + 1 ) + \" \u2581 \" ) ; else System . out . print ( ( max - a [ i ] ) + \" \u2581 \" ) ; } } else { for ( int i = 0 ; i < 3 ; i ++ ) { System . out . print ( ( max - a [ i ] + 1 ) + \" \u2581 \" ) ; } } System . out . println ( ) ; } in . close ( ) ; } }", "import java . util . * ; import static java . lang . Integer . parseInt ; public class _1593A_Election { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int test = parseInt ( input . nextLine ( ) ) ; while ( test -- > 0 ) { List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { list . add ( input . nextInt ( ) ) ; } input . nextLine ( ) ; int max = Collections . max ( list ) ; int maxCount = Collections . frequency ( list , max ) ; if ( maxCount == 3 ) { System . out . println ( \"1 \u2581 1 \u2581 1\" ) ; continue ; } List < Integer > result = new ArrayList < > ( ) ; for ( int i : list ) { if ( maxCount == 2 && i == max ) { result . add ( 1 ) ; } else if ( maxCount == 1 && i == max ) { result . add ( 0 ) ; } else { result . add ( max - i + 1 ) ; } } System . out . println ( result . toString ( ) . replaceAll ( \" [ \\\\ [ \\\\ ] , ] \" , \" \" ) ) ; } } }"], "python": ["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE maxx = max ( a , b , c ) NEW_LINE if a == b == c == maxx : print ( \"1 \u2581 1 \u2581 1\" ) NEW_LINE else : NEW_LINE INDENT if c == b == maxx : print ( maxx - a + 1 , 1 , 1 ) NEW_LINE else : NEW_LINE INDENT if a == c == maxx : print ( 1 , maxx - b + 1 , 1 ) NEW_LINE else : NEW_LINE INDENT if a == b == maxx : print ( 1 , 1 , maxx - c + 1 ) NEW_LINE else : NEW_LINE INDENT if a == maxx : print ( 0 , maxx - b + 1 , maxx - c + 1 ) NEW_LINE if b == maxx : print ( maxx - a + 1 , 0 , maxx - c + 1 ) NEW_LINE if c == maxx : print ( maxx - a + 1 , maxx - b + 1 , 0 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT votes = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_votes = max ( votes ) NEW_LINE max_count = len ( [ x for x in votes if x == max_votes ] ) NEW_LINE if max_count > 1 : NEW_LINE INDENT print ( * [ max_votes + 1 - x for x in votes ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( * [ max_votes + 1 - x if x != max_votes else 0 for x in votes ] ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE while ( t > 0 ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE k = max ( a , b , c ) NEW_LINE li = [ a , b , c ] NEW_LINE x = y = z = 0 NEW_LINE if ( a == b and b == c ) : NEW_LINE INDENT print ( x + 1 , y + 1 , z + 1 ) NEW_LINE DEDENT elif ( li . count ( k ) > 1 ) : NEW_LINE INDENT for i in li : NEW_LINE INDENT print ( k + 1 - i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in li : NEW_LINE INDENT if ( i != k ) : NEW_LINE INDENT print ( k + 1 - i , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT t -= 1 NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT mass = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = mass . count ( max ( mass ) ) NEW_LINE if d == 1 : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if mass [ i ] == max ( mass ) : NEW_LINE INDENT print ( 0 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( mass [ i ] - max ( mass ) ) + 1 , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT elif d == 2 : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT if mass [ i ] == max ( mass ) : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( mass [ i ] - max ( mass ) ) + 1 , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( 1 , 1 , 1 , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT", "def solve ( ) : NEW_LINE INDENT cand = input ( ) . split ( ) NEW_LINE a = int ( cand [ 0 ] ) NEW_LINE b = int ( cand [ 1 ] ) NEW_LINE c = int ( cand [ 2 ] ) NEW_LINE if a - max ( b , c ) < 0 : NEW_LINE INDENT print ( abs ( a - max ( b , c ) ) + 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif a - max ( b , c ) == 0 : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" \u2581 \" ) NEW_LINE DEDENT if b - max ( a , c ) < 0 : NEW_LINE INDENT print ( abs ( b - max ( a , c ) ) + 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif b - max ( a , c ) == 0 : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = \" \u2581 \" ) NEW_LINE DEDENT if c - max ( b , a ) < 0 : NEW_LINE INDENT print ( abs ( c - max ( b , a ) ) + 1 ) NEW_LINE DEDENT elif c - max ( b , a ) == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT solve ( ) NEW_LINE t -= 1 NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4148_A", "java": ["import java . io . * ; public class GFG { static int countOfSubstringWithKOnes ( String s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s . charAt ( i ) - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } static public void main ( String [ ] args ) { String s = \"10010\" ; int K = 1 ; System . out . println ( countOfSubstringWithKOnes ( s , K ) ) ; } }"], "python": ["def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"10010\" NEW_LINE K = 1 NEW_LINE print ( countOfSubstringWithKOnes ( s , K ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5118_A", "java": ["class Main { static int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; System . out . print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) ; } }"], "python": ["def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE k = 5 ; NEW_LINE print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4110_A", "java": ["public class GFG { static final int MAX = 256 ; static int freq [ ] [ ] ; static void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } static String firstNonRepeating ( String str , int n , int l , int r ) { for ( int i = l ; i < r ; i ++ ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( \" \" + ch ) ; } return \" - 1\" ; } public static void main ( String [ ] args ) { String str = \" GeeksForGeeks \" ; int n = str . length ( ) ; int queries [ ] [ ] = { { 0 , 3 } , { 2 , 3 } , { 5 , 12 } } ; int q = queries . length ; freq = new int [ MAX ] [ n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( firstNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } } }"], "python": ["MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def firstNonRepeating ( string , n , l , r ) : NEW_LINE INDENT t = [ \" \" ] * 2 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT t [ 0 ] = ch NEW_LINE return t [ 0 ] NEW_LINE DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksForGeeks \" NEW_LINE n = len ( string ) NEW_LINE queries = [ ( 0 , 3 ) , ( 2 , 3 ) , ( 5 , 12 ) ] NEW_LINE q = len ( queries ) NEW_LINE preCalculate ( string , n ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( firstNonRepeating ( string , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_4109_A", "java": ["public class GFG { static final int MAX = 256 ; static int freq [ ] [ ] ; static void preCalculate ( String str , int n ) { freq [ ( int ) str . charAt ( 0 ) ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str . charAt ( i ) ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } static String lastNonRepeating ( String str , int n , int l , int r ) { for ( int i = r ; i >= l ; i -- ) { char ch = str . charAt ( i ) ; if ( getFrequency ( ch , l , r ) == 1 ) return ( \" \" + ch ) ; } return \" - 1\" ; } public static void main ( String [ ] args ) { String str = \" GeeksForGeeks \" ; int n = str . length ( ) ; int queries [ ] [ ] = { { 2 , 9 } , { 2 , 3 } , { 0 , 12 } } ; int q = queries . length ; freq = new int [ MAX ] [ n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( lastNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } } }"], "python": ["MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( 256 ) ] for j in range ( 1000 ) ] NEW_LINE def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def lastNonRepeating ( string , n , l , r ) : NEW_LINE INDENT for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT return ch NEW_LINE DEDENT DEDENT return \" - 1\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GeeksForGeeks \" NEW_LINE n = len ( string ) NEW_LINE queries = [ ( 2 , 9 ) , ( 2 , 3 ) , ( 0 , 12 ) ] NEW_LINE q = len ( queries ) NEW_LINE preCalculate ( string , n ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( lastNonRepeating ( string , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_899_A", "java": ["import java . util . * ; class solution { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( \" A \u2581 = \u2581 \" + a + \" , \u2581 B \u2581 = \u2581 \" + b ) ; } public static void main ( String args [ ] ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }"], "python": ["def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( \" A \u2581 = \" , a , \" , \u2581 B \u2581 = \" , b ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3281_A", "java": ["import java . util . Vector ; class GFG { static Vector < Integer > permutation = new Vector < > ( ) ; static void printPermutation ( ) { permutation . stream ( ) . forEach ( ( i ) -> { System . out . print ( i + \" \u2581 \" ) ; } ) ; } static int give_random_number ( int l , int r ) { int x = ( int ) ( Math . random ( ) % ( r - l + 1 ) + l ) ; return x ; } static void generate_random_permutation ( int l , int r ) { if ( l > r ) return ; int n = give_random_number ( l , r ) ; permutation . add ( n ) ; generate_random_permutation ( l , n - 1 ) ; generate_random_permutation ( n + 1 , r ) ; } public static void main ( String [ ] args ) { int l = 5 ; int r = 15 ; generate_random_permutation ( l , r ) ; printPermutation ( ) ; } }"], "python": ["import random NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT for i in permutation : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = random . randint ( l , r ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE"]}
{"id": "aizu_p01076_A", "java": ["import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { long N = sc . nextLong ( ) ; long D = sc . nextLong ( ) ; long ans ; if ( D == 1 ) { ans = N * ( N - 1 ) / 2 ; } else { long dense = N - D ; ans = dense * ( dense - 1 ) / 2 ; ans += 2 * dense ; ans += D - 2 ; } System . out . println ( ans ) ; } }"], "python": ["n , d = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : print ( n * ( n - 1 ) // 2 ) NEW_LINE else : print ( ( n - 1 ) + ( n - d - 1 ) * n - ( ( n - d - 1 ) * ( n + d - 2 ) // 2 ) ) NEW_LINE", "n , d = map ( int , input ( ) . split ( ) ) NEW_LINE if d == 1 : print ( n * ( n - 1 ) // 2 ) NEW_LINE else : print ( ( n - 1 ) + ( n - d - 1 ) * n - ( ( n - d - 1 ) * ( n + d - 2 ) // 2 ) ) NEW_LINE"]}
{"id": "codeforces_1141_A", "java": ["import java . util . Scanner ; public class Game23 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int no = sc . nextInt ( ) ; int dest = sc . nextInt ( ) ; int res = - 1 ; if ( no == dest ) { System . out . println ( \"0\" ) ; } else if ( dest % no == 0 ) { res = 0 ; int d = dest / no ; while ( d % 2 == 0 ) { d = d / 2 ; res ++ ; } while ( d % 3 == 0 ) { d = d / 3 ; res ++ ; } if ( d != 1 ) res = - 1 ; System . out . println ( res ) ; } else { System . out . println ( res ) ; } } }", "import java . util . * ; public class Main { static long start ; static long target ; static long sum ; static boolean flag ; static int cou ; static int ans ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; start = in . nextInt ( ) ; target = in . nextInt ( ) ; solution1 ( start , target , cou ) ; if ( flag ) { System . out . println ( ans ) ; } else System . out . println ( - 1 ) ; } static void solution1 ( long start , long target , int cou ) { if ( start <= target ) { if ( start < target ) { cou ++ ; } else if ( start == target ) { flag = true ; ans = cou ; } } else { cou = 0 ; return ; } solution1 ( start * 2 , target , cou ) ; solution1 ( start * 3 , target , cou ) ; } }", "import java . util . Scanner ; public class NumberWay { public void input ( int number1 , int number2 ) { int count = 0 ; boolean b = true ; while ( true ) { if ( number1 == number2 ) { break ; } int n = number1 * 2 ; int n2 = number1 * 3 ; if ( number2 % n == 0 ) { count ++ ; number1 = n ; } else if ( number2 % n2 == 0 ) { count ++ ; number1 = n2 ; } else { b = false ; break ; } } if ( b == true ) { System . out . println ( count ) ; } else { System . out . println ( - 1 ) ; } } public static void main ( String [ ] a ) { Scanner input = new Scanner ( System . in ) ; NumberWay instance = new NumberWay ( ) ; int n1 = input . nextInt ( ) ; int n2 = input . nextInt ( ) ; instance . input ( n1 , n2 ) ; } }", "import java . util . * ; public class Sol { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n > m ) System . out . print ( \" - 1\" ) ; else if ( n == m ) System . out . print ( \"0\" ) ; else { int ans = find ( n , m , 0 ) ; if ( ans == Integer . MAX_VALUE ) System . out . print ( \" - 1\" ) ; else { System . out . print ( ans ) ; } } } public static int find ( int n , int m , int count ) { if ( n == m ) return count ; if ( n > m ) return Integer . MAX_VALUE ; return Math . min ( find ( 2 * n , m , count + 1 ) , find ( 3 * n , m , count + 1 ) ) ; } }", "import java . util . * ; import java . io . * ; public class MainClass { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ; int cnt = 0 ; boolean flag = false ; if ( m % n != 0 ) { System . out . println ( - 1 ) ; return ; } int temp = m / n ; while ( temp > 1 ) { if ( temp % 3 == 0 ) { temp /= 3 ; } else if ( temp % 2 == 0 ) { temp /= 2 ; } else { flag = true ; break ; } cnt ++ ; } if ( temp != 1 ) flag = true ; if ( flag ) { System . out . println ( - 1 ) ; } else { System . out . println ( cnt ) ; } } }"], "python": ["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT counter = 0 NEW_LINE flag = True NEW_LINE while m > n : NEW_LINE INDENT if ( m / 2 ) % n == 0 : NEW_LINE INDENT m /= 2 NEW_LINE counter += 1 NEW_LINE DEDENT elif ( m / 3 ) % n == 0 : NEW_LINE INDENT m /= 3 NEW_LINE counter += 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( counter if flag else - 1 ) NEW_LINE DEDENT", "s , target = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE ctr = 0 NEW_LINE ans = [ ] NEW_LINE def dfs ( prod , ctr ) : NEW_LINE INDENT if len ( ans ) : NEW_LINE INDENT return NEW_LINE DEDENT if prod == target : NEW_LINE INDENT ans . append ( ctr ) NEW_LINE return NEW_LINE DEDENT if prod > target : NEW_LINE INDENT return NEW_LINE DEDENT prod *= 2 NEW_LINE dfs ( prod , ctr + 1 ) NEW_LINE prod /= 2 NEW_LINE prod *= 3 NEW_LINE dfs ( prod , ctr + 1 ) NEW_LINE prod /= 3 NEW_LINE DEDENT dfs ( s , ctr ) NEW_LINE print ( ans [ 0 ] if len ( ans ) else - 1 ) NEW_LINE", "def f ( n , m ) : NEW_LINE INDENT nn = n NEW_LINE mm = m NEW_LINE if n == m : NEW_LINE INDENT return 0 NEW_LINE DEDENT n2 = 0 NEW_LINE n3 = 0 NEW_LINE m2 = 0 NEW_LINE m3 = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE n2 += 1 NEW_LINE DEDENT while n % 3 == 0 : NEW_LINE INDENT n = n // 3 NEW_LINE n3 += 1 NEW_LINE DEDENT while m % 3 == 0 : NEW_LINE INDENT m = m // 3 NEW_LINE m3 += 1 NEW_LINE DEDENT while m % 2 == 0 : NEW_LINE INDENT m = m // 2 NEW_LINE m2 += 1 NEW_LINE DEDENT if not m3 >= n3 or not m2 >= n2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n != m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return m3 - n3 + m2 - n2 NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE print ( f ( n , m ) ) NEW_LINE", "s , f = list ( input ( ) . split ( \" \u2581 \" ) ) NEW_LINE s , f = int ( s ) , int ( f ) NEW_LINE def check ( num ) : NEW_LINE INDENT step = 0 NEW_LINE while num % 2 == 0 : NEW_LINE INDENT num = num / 2 NEW_LINE step += 1 NEW_LINE DEDENT while num % 3 == 0 : NEW_LINE INDENT num = num / 3 NEW_LINE step += 1 NEW_LINE DEDENT if num == 1 : NEW_LINE INDENT print ( step ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT check ( f / s ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x , r = 0 , m / n NEW_LINE for i in [ 2 , 3 ] : NEW_LINE INDENT while r % i == 0 : r /= i ; x += 1 NEW_LINE DEDENT print ( x if r == 1 else - 1 ) NEW_LINE"]}
{"id": "codeforces_1245_B", "java": ["import java . util . Scanner ; public class B_Restricted_RPS { static Scanner in = new Scanner ( System . in ) ; static int testCases , n , a , b , c ; static char bobs_move [ ] ; static void solve ( ) { int bobs_rock = 0 , bobs_paper = 0 , bobs_sissor = 0 ; int alice_can_bit = 0 ; for ( char i : bobs_move ) { if ( i == ' R ' ) { bobs_rock ++ ; } else if ( i == ' P ' ) { bobs_paper ++ ; } else { ++ bobs_sissor ; } } alice_can_bit += Math . min ( bobs_paper , c ) + Math . min ( bobs_rock , b ) + Math . min ( bobs_sissor , a ) ; if ( 2 * alice_can_bit < n ) { System . out . println ( \" NO \" ) ; return ; } char alice_moves [ ] = new char [ n ] ; int index = 0 ; for ( char i : bobs_move ) { if ( i == ' R ' && b > 0 ) { alice_moves [ index ] = ' P ' ; -- b ; } else if ( i == ' P ' && c > 0 ) { alice_moves [ index ] = ' S ' ; -- c ; } else if ( i == ' S ' && a > 0 ) { -- a ; alice_moves [ index ] = ' R ' ; } else { alice_moves [ index ] = ' L ' ; } ++ index ; } System . out . println ( \" YES \" ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( alice_moves [ i ] == ' L ' ) { if ( a > 0 ) { alice_moves [ i ] = ' R ' ; -- a ; } else if ( b > 0 ) { alice_moves [ i ] = ' P ' ; -- b ; } else if ( c > 0 ) { alice_moves [ i ] = ' S ' ; -- c ; } } } System . out . println ( new String ( alice_moves ) ) ; } public static void main ( String [ ] amit ) { testCases = in . nextInt ( ) ; for ( int t = 0 ; t < testCases ; ++ t ) { n = in . nextInt ( ) ; a = in . nextInt ( ) ; b = in . nextInt ( ) ; c = in . nextInt ( ) ; bobs_move = in . next ( ) . toCharArray ( ) ; solve ( ) ; } } }", "import java . util . * ; public class MyClass { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int rock = sc . nextInt ( ) ; int paper = sc . nextInt ( ) ; int scissor = sc . nextInt ( ) ; sc . nextLine ( ) ; int f = 0 ; char ans [ ] = new char [ n ] ; int k = 0 ; Arrays . fill ( ans , '1' ) ; String s = sc . nextLine ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ' R ' ) { if ( paper > 0 ) { paper -- ; ans [ i ] = ( ' P ' ) ; } else { f ++ ; } } else if ( c == ' P ' ) { if ( scissor > 0 ) { scissor -- ; ans [ i ] = ( ' S ' ) ; } else { f ++ ; } } else if ( c == ' S ' ) { if ( rock > 0 ) { rock -- ; ans [ i ] = ( ' R ' ) ; } else { f ++ ; } } } StringBuffer ans1 = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == '1' && rock > 0 ) { ans [ i ] = ' R ' ; rock -- ; } else if ( ans [ i ] == '1' && paper > 0 ) { ans [ i ] = ' P ' ; paper -- ; } else if ( ans [ i ] == '1' && scissor > 0 ) { ans [ i ] = ' S ' ; scissor -- ; } ans1 . append ( ans [ i ] ) ; } double x = Double . valueOf ( n ) / 2 ; if ( f <= x ) { System . out . println ( \" Yes \" ) ; System . out . println ( ans1 . toString ( ) ) ; } else System . out . println ( \" No \" ) ; } } }"], "python": ["from random import randint NEW_LINE def fin_st ( l_i , st , l , rules ) : NEW_LINE INDENT dict_a = { \" R \" : l [ 0 ] , \" P \" : l [ 1 ] , \" S \" : l [ 2 ] } NEW_LINE fin_str = ' ' NEW_LINE for i in st : NEW_LINE INDENT if dict_a [ rules [ i ] ] > 0 : NEW_LINE INDENT fin_str += rules [ i ] NEW_LINE dict_a [ rules [ i ] ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = randint ( 0 , len ( l_i ) - 1 ) NEW_LINE fin_str += l_i [ t ] NEW_LINE del l_i [ t ] NEW_LINE DEDENT DEDENT return fin_str NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE st = input ( ) NEW_LINE rules = { \" S \" : \" R \" , \" P \" : \" S \" , \" R \" : \" P \" } NEW_LINE dict_a = { \" R \" : a , \" P \" : b , \" S \" : c } NEW_LINE dict_b = { \" R \" : 0 , \" P \" : 0 , \" S \" : 0 } NEW_LINE for i in st : NEW_LINE INDENT dict_b [ i ] += 1 NEW_LINE DEDENT wins = 0 NEW_LINE for i in dict_b : NEW_LINE INDENT if dict_a [ rules [ i ] ] >= dict_b [ i ] : NEW_LINE INDENT wins += dict_b [ i ] NEW_LINE dict_a [ rules [ i ] ] -= dict_b [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT wins += dict_a [ rules [ i ] ] NEW_LINE dict_a [ rules [ i ] ] = 0 NEW_LINE DEDENT DEDENT if round ( n / 2 + 1e-9 ) <= wins : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( fin_st ( [ \" R \" ] * dict_a [ ' R ' ] + [ \" P \" ] * dict_a [ ' P ' ] + [ \" S \" ] * dict_a [ \" S \" ] , st , [ a , b , c ] , rules ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = list ( map ( int , input ( ) . split ( ) ) ) [ 0 ] NEW_LINE r , p , s = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE S = list ( map ( str , input ( ) . split ( ) ) ) [ 0 ] NEW_LINE cnt = 0 NEW_LINE ans = ' ' NEW_LINE for i in S : NEW_LINE INDENT if i == ' R ' and p : NEW_LINE INDENT ans += ' P ' NEW_LINE p -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT elif i == ' P ' and s : NEW_LINE INDENT ans += ' S ' NEW_LINE s -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT elif i == ' S ' and r : NEW_LINE INDENT ans += ' R ' NEW_LINE r -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT ans = list ( ans ) NEW_LINE a = [ r , p , s ] NEW_LINE j = 0 NEW_LINE temp = \" RPS \" NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ i ] == '0' : NEW_LINE INDENT if a [ j ] == 0 : NEW_LINE INDENT while j < 3 and a [ j ] == 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT ans [ i ] = temp [ j ] NEW_LINE a [ j ] -= 1 NEW_LINE DEDENT DEDENT if cnt >= math . ceil ( n / 2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( * ans , sep = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE a1 , b1 , c1 = a , b , c NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE e , f , g = 0 , 0 , 0 NEW_LINE d = ' ' NEW_LINE for i in s : NEW_LINE INDENT if i == ' R ' : NEW_LINE INDENT e += 1 NEW_LINE if b > 0 : NEW_LINE INDENT b -= 1 NEW_LINE d += ' P ' NEW_LINE DEDENT else : NEW_LINE INDENT d += ' ? ' NEW_LINE DEDENT DEDENT elif i == ' P ' : NEW_LINE INDENT f += 1 NEW_LINE if c > 0 : NEW_LINE INDENT c -= 1 NEW_LINE d += ' S ' NEW_LINE DEDENT else : NEW_LINE INDENT d += ' ? ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT g += 1 NEW_LINE if a > 0 : NEW_LINE INDENT a -= 1 NEW_LINE d += ' R ' NEW_LINE DEDENT else : NEW_LINE INDENT d += ' ? ' NEW_LINE DEDENT DEDENT DEDENT x = min ( b1 , e ) + min ( c1 , f ) + min ( a1 , g ) NEW_LINE if x >= ( n + 1 ) // 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE q = ' ' NEW_LINE for i in d : NEW_LINE INDENT if i == ' ? ' : NEW_LINE INDENT if a > 0 : NEW_LINE INDENT a -= 1 NEW_LINE q += ' R ' NEW_LINE DEDENT elif b > 0 : NEW_LINE INDENT b -= 1 NEW_LINE q += ' P ' NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE q += ' S ' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT q += i NEW_LINE DEDENT DEDENT print ( q ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE s = list ( input ( ) . rstrip ( ) ) NEW_LINE ans0 = [ \" ? \" ] * n NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == 82 and b : NEW_LINE INDENT b -= 1 NEW_LINE ans0 [ i ] = \" P \" NEW_LINE cnt += 1 NEW_LINE DEDENT elif s [ i ] == 80 and c : NEW_LINE INDENT c -= 1 NEW_LINE ans0 [ i ] = \" S \" NEW_LINE cnt += 1 NEW_LINE DEDENT elif s [ i ] == 83 and a : NEW_LINE INDENT a -= 1 NEW_LINE ans0 [ i ] = \" R \" NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT if cnt < n // 2 + n % 2 : NEW_LINE INDENT ans0 = \" NO \" NEW_LINE ans . append ( ans0 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" YES \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if not ans0 [ i ] == \" ? \" : NEW_LINE INDENT continue NEW_LINE DEDENT if a : NEW_LINE INDENT a -= 1 NEW_LINE ans0 [ i ] = \" R \" NEW_LINE DEDENT elif b : NEW_LINE INDENT b -= 1 NEW_LINE ans0 [ i ] = \" P \" NEW_LINE DEDENT else : NEW_LINE INDENT c -= 1 NEW_LINE ans0 [ i ] = \" S \" NEW_LINE DEDENT DEDENT ans . append ( \" \" . join ( ans0 ) ) NEW_LINE DEDENT DEDENT sys . stdout . write ( \" \\n \" . join ( ans ) ) NEW_LINE", "import math NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE r , p , S = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = [ ] NEW_LINE cnt = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if s [ j ] == \" R \" : NEW_LINE INDENT if p > 0 : NEW_LINE INDENT ans . append ( \" P \" ) NEW_LINE p -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" \u2581 \" ) NEW_LINE DEDENT DEDENT elif s [ j ] == \" P \" : NEW_LINE INDENT if S > 0 : NEW_LINE INDENT ans . append ( \" S \" ) NEW_LINE S -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" \u2581 \" ) NEW_LINE DEDENT DEDENT elif s [ j ] == \" S \" : NEW_LINE INDENT if r > 0 : NEW_LINE INDENT ans . append ( \" R \" ) NEW_LINE r -= 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT for j in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ j ] == \" \u2581 \" : NEW_LINE INDENT if r > 0 : NEW_LINE INDENT ans [ j ] = \" R \" NEW_LINE r -= 1 NEW_LINE DEDENT elif p > 0 : NEW_LINE INDENT ans [ j ] = \" P \" NEW_LINE p -= 1 NEW_LINE DEDENT elif S > 0 : NEW_LINE INDENT ans [ j ] = \" S \" NEW_LINE S -= 1 NEW_LINE DEDENT DEDENT DEDENT if cnt >= ( n + 1 ) // 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( ans [ j ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "atcoder_ABC170_C", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] p = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = sc . nextInt ( ) ; } int a = 0 ; while ( true ) { int check = x - a ; boolean ju = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( check == p [ i ] ) { ju = false ; break ; } } if ( ju == true ) { System . out . println ( check ) ; return ; } check = x + a ; for ( int i = 0 ; i < n ; i ++ ) { if ( check == p [ i ] ) { ju = true ; break ; } } if ( ju == false ) { System . out . println ( check ) ; return ; } a ++ ; } } }", "import java . io . * ; import java . util . * ; public class Main { static PrintWriter out = new PrintWriter ( ( System . out ) ) ; public static void main ( String args [ ] ) throws IOException { Kioken sc = new Kioken ( ) ; int k = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; HashSet < Integer > set = new HashSet < > ( ) ; for ( int x = 0 ; x < n ; x ++ ) { set . add ( sc . nextInt ( ) ) ; } int d = 0 ; int ans = 0 ; while ( true ) { if ( ! set . contains ( k - d ) ) { ans = k - d ; break ; } if ( ! set . contains ( k + d ) ) { ans = k + d ; break ; } d ++ ; } out . println ( ans ) ; out . close ( ) ; } public static void kamehameha ( ) { } static class Kioken { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; public String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public String nextLine ( ) { try { return br . readLine ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public boolean hasNext ( ) { String next = null ; try { next = br . readLine ( ) ; } catch ( Exception e ) { } if ( next == null ) { return false ; } st = new StringTokenizer ( next ) ; return true ; } } }", "import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int x = Integer . parseInt ( scan . next ( ) ) ; int n = Integer . parseInt ( scan . next ( ) ) ; if ( n == 0 ) { System . out . println ( x ) ; scan . close ( ) ; return ; } Set < Integer > set = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( Integer . parseInt ( scan . next ( ) ) ) ; } scan . close ( ) ; int a = x ; int b = x ; while ( true ) { if ( ! set . contains ( b ) ) { System . out . println ( b ) ; return ; } if ( ! set . contains ( a ) ) { System . out . println ( a ) ; return ; } a ++ ; b -- ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Integer target = new Integer ( Integer . parseInt ( sc . next ( ) ) ) ; int n = Integer . parseInt ( sc . next ( ) ) ; if ( n == 0 ) { System . out . println ( target ) ; return ; } Integer x [ ] = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = new Integer ( Integer . parseInt ( sc . next ( ) ) ) ; } if ( ! Arrays . asList ( x ) . contains ( target ) ) { System . out . println ( target ) ; return ; } Arrays . sort ( x ) ; int index = Arrays . asList ( x ) . indexOf ( target ) ; int now = target . intValue ( ) ; int minus = 0 ; while ( now <= x [ x . length - 1 ] . intValue ( ) ) { minus ++ ; now = target . intValue ( ) - minus ; if ( ! Arrays . asList ( x ) . contains ( new Integer ( now ) ) ) { break ; } } now = target . intValue ( ) ; int plus = 0 ; while ( x [ 0 ] . intValue ( ) <= now ) { plus ++ ; now = target . intValue ( ) + plus ; if ( ! Arrays . asList ( x ) . contains ( new Integer ( now ) ) ) { break ; } } if ( minus <= plus ) { System . out . println ( target . intValue ( ) - minus ) ; } else { System . out . println ( target . intValue ( ) + plus ) ; } } }", "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; List < Integer > list = new ArrayList < > ( ) ; int ans = x ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( sc . nextInt ( ) ) ; } for ( int dif = 0 ; dif <= n ; dif ++ ) { if ( ! list . contains ( x - dif ) ) { ans = x - dif ; break ; } if ( ! list . contains ( x + dif ) ) { ans = x + dif ; break ; } } System . out . println ( ans ) ; } }"], "python": ["from collections import Counter NEW_LINE a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = [ ] NEW_LINE for i in range ( b ) : NEW_LINE INDENT c . append ( abs ( m [ i ] - a ) ) NEW_LINE DEDENT c = Counter ( c ) NEW_LINE if b > 0 : NEW_LINE INDENT i = 0 NEW_LINE while i <= b : NEW_LINE INDENT if i not in c : NEW_LINE INDENT print ( a - i ) NEW_LINE break NEW_LINE DEDENT elif c [ i ] < 2 and i != 0 : NEW_LINE INDENT if a - i in m : NEW_LINE INDENT print ( i + a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - i + a ) NEW_LINE DEDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT", "from sys import stdin NEW_LINE input = lambda : stdin . readline ( ) . rstrip ( ) NEW_LINE X , N = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solve ( A , B ) : NEW_LINE INDENT if A not in P : NEW_LINE INDENT print ( A ) NEW_LINE return NEW_LINE DEDENT if B not in P : NEW_LINE INDENT print ( B ) NEW_LINE return NEW_LINE DEDENT solve ( A - 1 , B + 1 ) NEW_LINE DEDENT solve ( X , X ) NEW_LINE", "x , n = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE p = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT if not x - i in p : NEW_LINE INDENT print ( x - i ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT if not x + i in p : NEW_LINE INDENT print ( x + i ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT", "targ , length = map ( int , input ( ) . split ( ' \u2581 ' ) ) NEW_LINE banned = [ False ] * 100 NEW_LINE bans = input ( ) NEW_LINE if bans != ' ' : NEW_LINE INDENT for ban in bans . split ( ' \u2581 ' ) : NEW_LINE INDENT banned [ int ( ban ) - 1 ] = True NEW_LINE DEDENT DEDENT for dist in range ( 100 ) : NEW_LINE INDENT if targ - dist > 0 : NEW_LINE INDENT if not banned [ targ - dist - 1 ] : NEW_LINE INDENT print ( targ - dist ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( targ - dist ) NEW_LINE exit ( ) NEW_LINE DEDENT if targ + dist <= 100 : NEW_LINE INDENT if not banned [ targ + dist - 1 ] : NEW_LINE INDENT print ( targ + dist ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( targ + dist ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT", "from math import floor , ceil , sqrt , factorial , log NEW_LINE from collections import Counter , deque NEW_LINE from functools import reduce NEW_LINE import numpy as np NEW_LINE def S ( ) : return input ( ) NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def MS ( ) : return map ( str , input ( ) . split ( ) ) NEW_LINE def MI ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def FLI ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def LS ( ) : return list ( MS ( ) ) NEW_LINE def LI ( ) : return list ( MI ( ) ) NEW_LINE def LLS ( ) : return [ list ( map ( str , l . split ( ) ) ) for l in input ( ) ] NEW_LINE def LLI ( ) : return [ list ( map ( int , l . split ( ) ) ) for l in input ( ) ] NEW_LINE def LLSN ( n : int ) : return [ LS ( ) for _ in range ( n ) ] NEW_LINE def LLIN ( n : int ) : return [ LI ( ) for _ in range ( n ) ] NEW_LINE X , N = MI ( ) NEW_LINE if N == 0 : NEW_LINE INDENT print ( X ) NEW_LINE exit ( ) NEW_LINE DEDENT P = LI ( ) NEW_LINE _min = 10 ** 9 NEW_LINE ans = [ ] NEW_LINE for p in range ( X + 1 ) : NEW_LINE INDENT for i in [ - 1 , 1 ] : NEW_LINE INDENT a = X + ( i * p ) NEW_LINE if a not in P : NEW_LINE INDENT print ( a ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "codeforces_707_A", "java": ["import java . util . Scanner ; import static javafx . application . Platform . exit ; public class NewClass25 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int z = in . nextInt ( ) ; String x [ ] [ ] = new String [ t ] [ z ] ; int b = 0 ; int w = 0 ; int c = 0 ; int g = 0 ; for ( int i = 0 ; i < t ; i ++ ) { for ( int j = 0 ; j < z ; j ++ ) { String colour = in . next ( ) ; if ( colour . equals ( \" C \" ) || colour . equals ( \" M \" ) || colour . equals ( \" Y \" ) ) { c = 1 ; break ; } } if ( c == 1 ) { break ; } } if ( c == 1 ) { System . out . println ( \" # Color \" ) ; } else { System . out . println ( \" # Black & White \" ) ; } } }", "import java . util . * ; public class A { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; char a [ ] [ ] = new char [ n ] [ m ] ; int c1 = 0 , c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { a [ i ] [ j ] = sc . next ( ) . charAt ( 0 ) ; c1 ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] == ' W ' || a [ i ] [ j ] == ' G ' || a [ i ] [ j ] == ' B ' ) c ++ ; } } if ( c1 == c ) System . out . println ( \" # Black & White \" ) ; else System . out . println ( \" # Color \" ) ; } }", "import java . util . Scanner ; public class CF707_D2_A { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; for ( int i = 0 ; i < n * m ; i ++ ) { char ch = scanner . next ( ) . charAt ( 0 ) ; if ( ch == ' C ' || ch == ' M ' || ch == ' Y ' ) { System . out . println ( \" # Color \" ) ; System . exit ( 0 ) ; } } System . out . println ( \" # Black & White \" ) ; scanner . close ( ) ; } }", "import static java . lang . System . * ; import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int flag_b = 0 ; int flag_c = 0 ; String [ ] [ ] arr = new String [ x ] [ y ] ; for ( int i = 0 ; i < x ; i ++ ) { for ( int j = 0 ; j < y ; j ++ ) { arr [ i ] [ j ] = sc . next ( ) ; } } for ( int i = 0 ; i < x ; i ++ ) { for ( int j = 0 ; j < y ; j ++ ) { if ( arr [ i ] [ j ] . equals ( \" C \" ) || arr [ i ] [ j ] . equals ( \" M \" ) || arr [ i ] [ j ] . equals ( \" Y \" ) ) { flag_c = 1 ; break ; } } } if ( flag_c == 1 ) out . println ( \" # Color \" ) ; else out . println ( \" # Black & White \" ) ; } }"], "python": ["n , m = input ( ) . split ( ) NEW_LINE color = ' # Black & White ' NEW_LINE for i in range ( int ( n ) ) : NEW_LINE INDENT x = input ( ) . split ( ) NEW_LINE for j in range ( int ( m ) ) : NEW_LINE INDENT if x [ j ] != ' B ' and x [ j ] != ' G ' and x [ j ] != ' W ' : NEW_LINE INDENT color = ' # Color ' NEW_LINE DEDENT DEDENT DEDENT print ( color ) NEW_LINE", "l = [ ] NEW_LINE x , y = ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( x ) : NEW_LINE INDENT l += input ( ) . split ( ) NEW_LINE DEDENT if ( ' C ' in l ) or ( ' M ' in l ) or ( ' Y ' in l ) : NEW_LINE INDENT print ( \" # Color \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' # Black & White ' ) NEW_LINE DEDENT", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d = \" \" NEW_LINE for i in range ( a ) : NEW_LINE INDENT c = [ str ( q ) for q in input ( ) . split ( ) ] NEW_LINE if \" C \" in c or \" M \" in c or \" Y \" in c : NEW_LINE INDENT d = \" # Color \" NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT d = \" # Black & White \" NEW_LINE DEDENT DEDENT print ( d ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = list ( ( input ( ) . split ( ) ) ) NEW_LINE for i in m : NEW_LINE INDENT if i == ' C ' or i == ' M ' or i == ' Y ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if count > 0 : NEW_LINE INDENT print ( \" # Color \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" # Black & White \" ) NEW_LINE DEDENT", "row , col = map ( int , input ( ) . split ( ) ) NEW_LINE st = set ( ) NEW_LINE for i in range ( row ) : NEW_LINE INDENT for n in input ( ) . split ( ) : st . add ( n ) NEW_LINE DEDENT print ( ' # Color ' if len ( st . intersection ( set ( ' CMY ' . strip ( ) ) ) ) else ' # Black & White ' ) NEW_LINE"]}
{"id": "geeksforgeeks_4061_A", "java": ["import java . lang . Math ; class GFG { static int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; } static int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; int K = 3 ; System . out . println ( sum ( K , n ) ) ; } }"], "python": ["def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B / 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE"]}
{"id": "atcoder_ABC072_B", "java": ["import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; sc . close ( ) ; for ( int i = 0 ; ( 2 * i ) < s . length ( ) ; i ++ ) { System . out . print ( s . charAt ( 2 * i ) ) ; } } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = in . readLine ( ) . split ( \" \" ) ; for ( int i = 0 ; i < str . length ; i = i + 2 ) { System . out . print ( str [ i ] ) ; } System . out . println ( ) ; } }", "import java . util . Scanner ; public class Main { private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String s = sc . next ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < s . length ( ) ; i += 2 ) { sb . append ( s . charAt ( i ) ) ; } System . out . println ( sb ) ; } }", "class Main { public static void main ( String [ ] $ ) { char [ ] v = new java . util . Scanner ( System . in ) . next ( ) . toCharArray ( ) ; for ( int i = 0 ; i < v . length ; i += 2 ) System . out . print ( v [ i ] ) ; System . out . println ( ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String S = sc . next ( ) ; int oddC = 0 ; if ( S . length ( ) % 2 == 0 ) { oddC = S . length ( ) / 2 ; } else { oddC = S . length ( ) / 2 + 1 ; } String odd [ ] = new String [ oddC ] ; for ( int i = 0 ; i < oddC ; i ++ ) { odd [ i ] = S . substring ( 2 * i , 2 * i + 1 ) ; } for ( int i = 0 ; i < oddC ; i ++ ) { System . out . print ( odd [ i ] ) ; } } }"], "python": ["s = input ( ) NEW_LINE print ( s [ : : 2 ] ) NEW_LINE", "import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE A = [ ] NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT A . append ( s [ i ] ) NEW_LINE DEDENT return ' ' . join ( A ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( solve ( input ( ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "s = input ( ) NEW_LINE L = [ \" a \" ] * ( ( len ( s ) + 1 ) // 2 ) NEW_LINE for i in range ( 0 , ( len ( s ) + 1 ) // 2 ) : NEW_LINE INDENT L [ i ] = s [ 2 * i ] NEW_LINE DEDENT print ( \" \" . join ( L ) ) NEW_LINE", "print ( input ( ) [ : : 2 ] ) NEW_LINE", "s = list ( input ( ) ) NEW_LINE array = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT array . append ( s [ i ] ) NEW_LINE DEDENT DEDENT print ( \" \" . join ( array ) , end = \" \" ) NEW_LINE"]}
{"id": "geeksforgeeks_444_A", "java": ["import java . util . * ; class GFG { static int [ ] pref = new int [ 100001 ] ; static int checkPalindrome ( int num ) { String str = String . valueOf ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { return 0 ; } l ++ ; r -- ; } return num ; } static void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } } static void printSum ( int L , int R ) { System . out . print ( pref [ R ] - pref [ L - 1 ] + \" \\n \" ) ; } static void printSumPalindromic ( int arr [ ] [ ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } public static void main ( String [ ] args ) { int Q = 2 ; int arr [ ] [ ] = { { 10 , 13 } , { 12 , 21 } } ; printSumPalindromic ( arr , Q ) ; } }"], "python": ["pref = [ 0 ] * 100001 NEW_LINE def checkPalindrome ( num ) : NEW_LINE INDENT strr = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT def preCompute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT print ( pref [ R ] - pref [ L - 1 ] ) NEW_LINE DEDENT def printSumPalindromic ( arr , Q ) : NEW_LINE INDENT preCompute ( ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT Q = 2 NEW_LINE arr = [ [ 10 , 13 ] , [ 12 , 21 ] ] NEW_LINE printSumPalindromic ( arr , Q ) NEW_LINE"]}
{"id": "atcoder_ABC153_D", "java": ["import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Scanner ; import java . util . Set ; public class Main { static Scanner scan = new Scanner ( System . in ) ; static long H = scan . nextLong ( ) ; static long min = 0 ; static Set < Long > memo = new HashSet < Long > ( ) ; static Map < Long , Long > me = new HashMap < Long , Long > ( ) ; static ArrayList < Long > meno = new ArrayList < Long > ( ) ; static Set < Boolean > cheak = new HashSet < Boolean > ( ) ; public static void main ( String [ ] args ) { System . out . println ( monster ( H ) ) ; } private static long monster ( long h ) { if ( h == 1 ) { return 1 ; } else { long k = h / 2 ; return 1 + 2 * monster ( k ) ; } } }", "import java . io . * ; import java . lang . * ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . IOException ; import java . util . Arrays ; import java . util . StringTokenizer ; import java . math . BigInteger ; public class Main { static InputReader in = new InputReader ( System . in ) ; static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) { long n = in . nextLong ( ) ; long sum = 1 ; long count = 1 ; while ( n > 1 ) { sum += Math . pow ( 2 , count ) ; ++ count ; n /= 2 ; } out . println ( sum ) ; out . close ( ) ; } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public String nextLine ( ) { try { return reader . readLine ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } public boolean hasNext ( ) { String next = null ; try { next = reader . readLine ( ) ; } catch ( Exception e ) { } if ( next == null ) { return false ; } tokenizer = new StringTokenizer ( next ) ; return true ; } public BigInteger nextBigInteger ( ) { return new BigInteger ( next ( ) ) ; } } }", "import java . io . * ; public class Main { final static long MOD = 1000000007 ; public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String W = in . readLine ( ) ; long H = Long . parseLong ( W ) ; ; long X = H ; long n = 1 ; while ( X != 1 ) { X = X / 2 ; n ++ ; } System . out . println ( ( long ) Math . pow ( 2 , n ) - 1 ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PipedInputStream ; import java . util . * ; public class Main { private static final int MOD = ( int ) Math . pow ( 10 , 9 ) ; private static final int [ ] [ ] DIRS = { { 0 , 1 } , { 0 , - 1 } , { 1 , 0 } , { - 1 , 0 } } ; public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; long m = sc . nextLong ( ) ; int pow = ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) + 1 ; long res = ( long ) Math . pow ( 2.0 , pow * 1.0 ) - 1L ; System . out . println ( res ) ; System . exit ( 0 ) ; } static private class Point { public int x ; public int y ; Point ( int x , int y ) { this . x = x ; this . y = y ; } } static private long gcd ( long m , long n ) { if ( m < n ) { return gcd ( n , m ) ; } if ( m % n == 0 ) { return n ; } return gcd ( n , m % n ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . util . Scanner ; public class Main { static long f ( long X ) { if ( X == 1 ) { return 1 ; } long H = X / 2 ; return 2 * f ( H ) + 1 ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long H = sc . nextLong ( ) ; System . out . println ( f ( H ) ) ; } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT H = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE while H > 0 : NEW_LINE INDENT ans += 1 NEW_LINE H //= 2 NEW_LINE DEDENT print ( pow ( 2 , ans ) - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import math NEW_LINE h = int ( input ( ) ) NEW_LINE l = math . floor ( math . log ( h , 2 ) ) NEW_LINE print ( 2 ** l * 2 - 1 ) NEW_LINE", "import sys NEW_LINE import os NEW_LINE import math NEW_LINE import string NEW_LINE ii = lambda : int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) NEW_LINE il = lambda : list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) NEW_LINE fl = lambda : list ( map ( float , sys . stdin . buffer . readline ( ) . split ( ) ) ) NEW_LINE iln = lambda n : [ int ( sys . stdin . buffer . readline ( ) . rstrip ( ) ) for _ in range ( n ) ] NEW_LINE iss = lambda : sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) NEW_LINE sl = lambda : list ( map ( str , sys . stdin . buffer . readline ( ) . decode ( ) . split ( ) ) ) NEW_LINE isn = lambda n : [ sys . stdin . buffer . readline ( ) . decode ( ) . rstrip ( ) for _ in range ( n ) ] NEW_LINE lcm = lambda x , y : x * y / math . gcd ( x , y ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE MAX = float ( ' inf ' ) NEW_LINE def f ( N ) : NEW_LINE INDENT atk = 0 NEW_LINE if N == 1 : NEW_LINE INDENT atk += 1 NEW_LINE DEDENT else : NEW_LINE INDENT atk += f ( N // 2 ) * 2 + 1 NEW_LINE DEDENT return atk NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT if os . getenv ( \" LOCAL \" ) : NEW_LINE INDENT sys . stdin = open ( \" input . txt \" , \" r \" ) NEW_LINE DEDENT N = ii ( ) NEW_LINE print ( f ( N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "H = int ( input ( ) ) NEW_LINE def divCount ( n , cnt = 0 ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return cnt NEW_LINE DEDENT return divCount ( int ( n / 2 ) , cnt + 1 ) NEW_LINE DEDENT attackCount = 0 NEW_LINE for i in range ( 0 , divCount ( H ) + 1 ) : NEW_LINE INDENT attackCount += pow ( 2 , i ) NEW_LINE DEDENT print ( attackCount ) NEW_LINE", "print ( 2 ** ( len ( bin ( int ( input ( ) ) ) ) - 2 ) - 1 ) NEW_LINE"]}
{"id": "atcoder_ARC064_D", "java": ["import java . util . * ; public class Main { final static long MODULO = 1_000_000_000 + 7 ; static ArrayList < Integer > divs ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long K = sc . nextLong ( ) ; divs = new ArrayList < > ( ) ; for ( int i = 1 ; i * i <= N ; ++ i ) { if ( N % i == 0 ) { divs . add ( i ) ; if ( i * i != N ) { divs . add ( N / i ) ; } } } Collections . sort ( divs ) ; HashMap < Integer , Long > dp = new HashMap < > ( ) ; for ( int d : divs ) { dp . put ( d , pow ( K , ( d + 1 ) / 2 ) ) ; for ( int i = 0 ; divs . get ( i ) < d ; ++ i ) { if ( d % divs . get ( i ) == 0 ) dp . put ( d , ( dp . get ( d ) - dp . get ( divs . get ( i ) ) + MODULO ) % MODULO ) ; } } long ans = 0 ; for ( int d : divs ) { ans = ( ans + dp . get ( d ) * ( d % 2 == 0 ? d / 2 : d ) ) % MODULO ; } System . out . println ( ans ) ; } static class Div { int div ; int num ; public Div ( int div , int num ) { this . div = div ; this . num = num ; } } static long pow ( long a , long n ) { long ret = 1 ; for ( ; n > 0 ; n >>= 1 , a = ( a * a ) % MODULO ) { if ( n % 2 == 1 ) { ret = ( ret * a ) % MODULO ; } } return ret ; } }", "import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static final long MOD = 1_000_000_007 ; public static void main ( String [ ] args ) { long N = sc . nextInt ( ) ; long K = sc . nextInt ( ) ; if ( N == 1 ) { System . out . println ( K ) ; return ; } ArrayList < Long > divisor = new ArrayList < > ( ) ; for ( long i = 2 ; i * i <= N ; i ++ ) { if ( N % i != 0 ) continue ; divisor . add ( i ) ; if ( i * i != N ) { divisor . add ( N / i ) ; } } divisor . add ( N ) ; Collections . sort ( divisor ) ; HashMap < Long , Long > map = new HashMap < > ( ) ; map . put ( 1L , K ) ; for ( long d : divisor ) { long add = pow ( K , ( d + 1 ) / 2 ) - K ; for ( long i = 2 ; i * i <= d ; i ++ ) { if ( d % i != 0 ) continue ; add += MOD - map . get ( i ) ; if ( i * i != d ) add += MOD - map . get ( d / i ) ; } map . put ( d , add % MOD ) ; } long ans = 0 ; for ( long k : map . keySet ( ) ) { ans += ( k % 2 == 0 ? k / 2 : k ) * map . get ( k ) ; } System . out . println ( ans % MOD ) ; } static long pow ( long base , long p ) { if ( p == 0 ) return 1 ; if ( p == 1 ) return base ; long ret = pow ( base , p / 2 ) ; ret = ret * ret % MOD ; if ( p % 2 == 1 ) { ret = ret * base % MOD ; } return ret ; } }"], "python": ["import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE sys . setrecursionlimit ( max ( 1000 , 10 ** 9 ) ) NEW_LINE write = lambda x : sys . stdout . write ( x + \" \\n \" ) NEW_LINE n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = 10 ** 9 + 7 NEW_LINE def fs ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT s . add ( i ) NEW_LINE s . add ( n // i ) NEW_LINE DEDENT DEDENT l = sorted ( list ( s ) ) NEW_LINE return l NEW_LINE DEDENT ds = fs ( n ) NEW_LINE m = len ( ds ) NEW_LINE nums = [ None ] * m NEW_LINE for i in range ( m ) : NEW_LINE INDENT val = pow ( k , ( ds [ i ] + 1 ) // 2 , M ) NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ds [ i ] % ds [ j ] == 0 : NEW_LINE INDENT val -= nums [ j ] NEW_LINE val %= M NEW_LINE DEDENT DEDENT nums [ i ] = val % M NEW_LINE DEDENT ans = 0 NEW_LINE inv2 = pow ( 2 , M - 2 , M ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ds [ i ] % 2 == 0 : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] * inv2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ds [ i ] * nums [ i ] NEW_LINE DEDENT ans %= M NEW_LINE DEDENT print ( ans % M ) NEW_LINE", "from math import gcd NEW_LINE def divisors ( M ) : NEW_LINE INDENT d = [ ] NEW_LINE i = 1 NEW_LINE while M >= i ** 2 : NEW_LINE INDENT if M % i == 0 : NEW_LINE INDENT d . append ( i ) NEW_LINE if i ** 2 != M : NEW_LINE INDENT d . append ( M // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT d . sort ( ) NEW_LINE return d NEW_LINE DEDENT mod = 10 ** 9 + 7 NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE div = divisors ( N ) NEW_LINE res = [ 0 for i in range ( len ( div ) ) ] NEW_LINE ans = 0 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT for i in range ( len ( div ) ) : NEW_LINE INDENT d = div [ i ] NEW_LINE g = gcd ( 2 * d , N ) NEW_LINE res [ i ] += pow ( K , g // 2 , mod ) NEW_LINE res [ i ] %= mod NEW_LINE ans += d * res [ i ] NEW_LINE ans %= mod NEW_LINE for j in range ( i + 1 , len ( div ) ) : NEW_LINE INDENT if div [ j ] % d == 0 : NEW_LINE INDENT res [ j ] -= res [ i ] NEW_LINE res [ j ] %= mod NEW_LINE DEDENT DEDENT DEDENT print ( ans % mod ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( len ( div ) ) : NEW_LINE INDENT d = div [ i ] NEW_LINE g = gcd ( 2 * d , N ) NEW_LINE res [ i ] += pow ( K , ( g + 1 ) // 2 , mod ) NEW_LINE res [ i ] %= mod NEW_LINE ans += d * res [ i ] NEW_LINE ans %= mod NEW_LINE for j in range ( i + 1 , len ( div ) ) : NEW_LINE INDENT if div [ j ] % d == 0 : NEW_LINE INDENT res [ j ] -= res [ i ] NEW_LINE res [ j ] %= mod NEW_LINE DEDENT DEDENT DEDENT print ( ans % mod ) NEW_LINE DEDENT", "import sys NEW_LINE read = sys . stdin . read NEW_LINE readline = sys . stdin . readline NEW_LINE n , k = map ( int , readline ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def divisor_list ( N ) : NEW_LINE INDENT if N == 1 : return [ 1 ] NEW_LINE res = [ ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if i * i >= N : break NEW_LINE if N % i == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE res . append ( N // i ) NEW_LINE DEDENT DEDENT if i * i == N : res . append ( i ) NEW_LINE return sorted ( res ) NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT p = [ i for i in divisor_list ( n ) ] NEW_LINE r = { pi : pow ( k , ( pi + 1 ) // 2 , MOD ) for pi in p } NEW_LINE for pi in p : NEW_LINE INDENT for pj in p : NEW_LINE INDENT if pj >= pi : break NEW_LINE if pi % pj == 0 : NEW_LINE INDENT r [ pi ] -= r [ pj ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for pi , v in r . items ( ) : NEW_LINE INDENT ans += v * ( pi ) NEW_LINE DEDENT ans %= MOD NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT p = [ 1 ] + [ i for i in divisor_list ( n ) if i % 2 == 0 and i != 2 ] NEW_LINE r = { pi : pow ( k , ( pi + 1 ) // 2 , MOD ) for pi in p } NEW_LINE for pi in p : NEW_LINE INDENT for pj in p : NEW_LINE INDENT if pj >= pi : break NEW_LINE if pi % pj == 0 : NEW_LINE INDENT r [ pi ] -= r [ pj ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for pi , v in r . items ( ) : NEW_LINE INDENT if pi == 1 : NEW_LINE INDENT ans += v NEW_LINE DEDENT else : NEW_LINE INDENT ans += v * ( pi // 2 ) NEW_LINE DEDENT DEDENT ans %= MOD NEW_LINE print ( ans ) NEW_LINE DEDENT", "import sys NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE N , K = MI ( ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def divisor ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE for i in range ( 1 , int ( n ** .5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT res . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT A = divisor ( N ) NEW_LINE d = { } NEW_LINE for a in A : NEW_LINE INDENT d [ a ] = divisor ( a ) NEW_LINE DEDENT prime = [ ] NEW_LINE for i in range ( 2 , int ( N ** .5 ) + 1 ) : NEW_LINE INDENT if N % i == 0 : NEW_LINE INDENT prime . append ( i ) NEW_LINE while N % i == 0 : NEW_LINE INDENT N //= i NEW_LINE DEDENT DEDENT DEDENT if N != 1 : NEW_LINE INDENT prime . append ( N ) NEW_LINE DEDENT mu = { } NEW_LINE for a in A : NEW_LINE INDENT b = a NEW_LINE r = 1 NEW_LINE for p in prime : NEW_LINE INDENT if b % p == 0 : NEW_LINE INDENT r *= - 1 NEW_LINE if b // p % p == 0 : NEW_LINE INDENT r = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT mu [ a ] = r NEW_LINE DEDENT ans = 0 NEW_LINE for a in A : NEW_LINE INDENT for b in d [ a ] : NEW_LINE INDENT if a % 2 == 0 : NEW_LINE INDENT ans += mu [ a // b ] * pow ( K , ( b + 1 ) // 2 , mod ) * ( a // 2 ) NEW_LINE ans %= mod NEW_LINE DEDENT else : NEW_LINE INDENT ans += mu [ a // b ] * pow ( K , ( b + 1 ) // 2 , mod ) * a NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE import numpy as np NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE U = int ( 10 ** 4.5 + 10 ) NEW_LINE div = np . arange ( 1 , U , dtype = np . int64 ) NEW_LINE div = div [ N % div == 0 ] NEW_LINE div = sorted ( np . union1d ( div , N // div ) ) NEW_LINE A = { d : pow ( K , int ( ( d + 1 ) // 2 ) , MOD ) for d in div } NEW_LINE B = { } NEW_LINE for d in div : NEW_LINE INDENT B [ d ] = A [ d ] - sum ( B [ dd ] for dd in div if dd < d and d % dd == 0 ) NEW_LINE DEDENT answer = sum ( B [ d ] * ( d // 2 if d % 2 == 0 else d ) for d in div ) NEW_LINE answer %= MOD NEW_LINE print ( answer ) NEW_LINE"]}
{"id": "geeksforgeeks_4423_A", "java": ["import java . io . * ; class GFG { public static int N = 3 ; static void interchangeDiagonals ( int array [ ] [ ] ) { for ( int i = 0 ; i < N ; ++ i ) if ( i != N / 2 ) { int temp = array [ i ] [ i ] ; array [ i ] [ i ] = array [ i ] [ N - i - 1 ] ; array [ i ] [ N - i - 1 ] = temp ; } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) System . out . print ( array [ i ] [ j ] + \" \u2581 \" ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int array [ ] [ ] = { { 4 , 5 , 6 } , { 1 , 2 , 3 } , { 7 , 8 , 9 } } ; interchangeDiagonals ( array ) ; } }"], "python": ["N = 3 ; NEW_LINE def interchangeDiagonals ( array ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT if ( i != N / 2 ) : NEW_LINE INDENT temp = array [ i ] [ i ] ; NEW_LINE array [ i ] [ i ] = array [ i ] [ N - i - 1 ] ; NEW_LINE array [ i ] [ N - i - 1 ] = temp ; NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( array [ i ] [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT array = [ 4 , 5 , 6 ] , [ 1 , 2 , 3 ] , [ 7 , 8 , 9 ] ; NEW_LINE interchangeDiagonals ( array ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_1065_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; public class P1065A { public static void main ( String [ ] args ) throws IOException { BufferedReader io = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Integer cnt = Integer . valueOf ( io . readLine ( ) ) ; List < Long > rs = new ArrayList < Long > ( ) ; while ( cnt > 0 ) { cnt -- ; String [ ] input = io . readLine ( ) . split ( \" \u2581 \" ) ; Long s = Long . valueOf ( input [ 0 ] ) ; Long a = Long . valueOf ( input [ 1 ] ) ; Long b = Long . valueOf ( input [ 2 ] ) ; Long c = Long . valueOf ( input [ 3 ] ) ; Long tmp = s / c ; tmp = ( tmp / a ) * b + tmp ; rs . add ( tmp ) ; } for ( Long long1 : rs ) { System . out . println ( long1 ) ; } } }", "import java . util . * ; public class class21 { public static void main ( String arg [ ] ) { Scanner input = new Scanner ( System . in ) ; int p = input . nextInt ( ) ; while ( p -- > 0 ) { long v , d , e , f ; v = input . nextLong ( ) ; d = input . nextLong ( ) ; e = input . nextLong ( ) ; f = input . nextLong ( ) ; v /= f ; long x = v / d ; v %= d ; long ans = x * ( d + e ) ; ans += v ; System . out . println ( ans ) ; } } }", "import java . util . * ; public class _1065A_VasyaandChocolate { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int test = input . nextInt ( ) ; while ( test -- > 0 ) { long s = input . nextLong ( ) ; long a = input . nextLong ( ) ; long b = input . nextLong ( ) ; long c = input . nextLong ( ) ; long capable = s / c ; long bought = capable / a ; long result = capable + ( bought * b ) ; System . out . println ( result ) ; } } }"], "python": ["t = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT l . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE DEDENT def m ( s , a , b , c ) : NEW_LINE INDENT capa = int ( s // c ) NEW_LINE free = int ( capa // a ) NEW_LINE return ( capa + b * free ) NEW_LINE DEDENT for i in l : NEW_LINE INDENT print ( m ( i [ 0 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ) ) NEW_LINE DEDENT", "import math NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s , a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d = ( s // c ) NEW_LINE x = d // a NEW_LINE final = x * b NEW_LINE print ( d + final ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : s , a , b , c = map ( int , input ( ) . split ( ) ) ; print ( s // c // a * b + s // c ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT s , a , b , c = [ int ( i ) for ( i ) in input ( ) . split ( ) ] NEW_LINE awcb = s // c NEW_LINE ab = ( awcb // a ) * b NEW_LINE print ( awcb + ab ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE s = a // d NEW_LINE d = ( s // b ) * c NEW_LINE print ( s + d ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2300_A", "java": ["class GFG { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ 100002 ] ; static void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } static int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } public static void main ( String [ ] args ) { int n = 256 ; System . out . println ( superpower ( n ) ) ; } }"], "python": ["MAX = 100000 ; NEW_LINE prime = [ True ] * 100002 ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE superPower = 0 ; NEW_LINE factor = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 0 ; NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return superPower ; NEW_LINE DEDENT n = 256 ; NEW_LINE print ( superpower ( n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_258_A", "java": ["class solution { static void printSubArrays ( int [ ] arr , int start , int end ) { if ( end == arr . length ) return ; else if ( start > end ) printSubArrays ( arr , 0 , end + 1 ) ; else { System . out . print ( \" [ \" ) ; for ( int i = start ; i < end ; i ++ ) { System . out . print ( arr [ i ] + \" , \u2581 \" ) ; } System . out . println ( arr [ end ] + \" ] \" ) ; printSubArrays ( arr , start + 1 , end ) ; } return ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 2 , 3 } ; printSubArrays ( arr , 0 , 0 ) ; } }"], "python": ["def printSubArrays ( arr , start , end ) : NEW_LINE INDENT if end == len ( arr ) : NEW_LINE INDENT return NEW_LINE DEDENT elif start > end : NEW_LINE INDENT return printSubArrays ( arr , 0 , end + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ start : end + 1 ] ) NEW_LINE return printSubArrays ( arr , start + 1 , end ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE printSubArrays ( arr , 0 , 0 ) NEW_LINE"]}
{"id": "geeksforgeeks_3294_A", "java": ["class Test { static boolean isDivisible999 ( String num ) { int n = num . length ( ) ; if ( n == 0 && num . charAt ( 0 ) == '0' ) return true ; if ( n % 3 == 1 ) num = \"00\" + num ; if ( n % 3 == 2 ) num = \"0\" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num . charAt ( i ++ ) - '0' ) * 100 ; group += ( num . charAt ( i ++ ) - '0' ) * 10 ; group += num . charAt ( i ) - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Integer . toString ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; } public static void main ( String args [ ] ) { String num = \"1998\" ; System . out . println ( isDivisible999 ( num ) ? \" Divisible \" : \" Not \u2581 divisible \" ) ; } }"], "python": ["def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE if ( n == 0 or num [ 0 ] == '0' ) : NEW_LINE INDENT return true NEW_LINE DEDENT if ( ( n % 3 ) == 1 ) : NEW_LINE INDENT num = \"00\" + num NEW_LINE DEDENT if ( ( n % 3 ) == 2 ) : NEW_LINE INDENT num = \"0\" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - 48 ) * 100 NEW_LINE group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 NEW_LINE group += ( ord ( num [ i + 2 ] ) - 48 ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = \"1998\" NEW_LINE n = len ( num ) NEW_LINE if ( isDivisible999 ( num ) ) : NEW_LINE INDENT print ( \" Divisible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_810_A", "java": ["public class Straight_A { public static void main ( String [ ] args ) { java . util . Scanner kbd = new java . util . Scanner ( System . in ) ; int n = kbd . nextInt ( ) ; int k = kbd . nextInt ( ) ; int [ ] marks = new int [ n ] ; int c = 0 ; double cur_gr = 0 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { marks [ i ] = kbd . nextInt ( ) ; total += marks [ i ] ; cur_gr = Math . round ( total / n ) ; } double r = 0 ; do { r = Math . round ( ( ( double ) total + ( c * k ) ) / ( n ) ) ; c ++ ; n ++ ; } while ( r < k ) ; System . out . println ( c - 1 ) ; } }", "import java . util . Scanner ; public class P810A { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = scan . nextInt ( ) ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) total += arr [ i ] ; for ( int i = 0 ; ; i ++ ) { if ( ( int ) Math . round ( total * 1.0 / ( n + i ) ) == k ) { System . out . println ( i ) ; return ; } total += k ; } } }", "import java . util . * ; import java . util . stream . * ; public class My25goal { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int z = s . nextInt ( ) ; sum += z ; } double an = sum / ( double ) n ; double q ; if ( Math . round ( an ) == k ) { q = 0 ; } else { q = ( ( n * ( k - 0.5 ) ) - sum ) / 0.5 ; } int answer = ( int ) q ; System . out . println ( answer ) ; } }", "import javax . print . DocFlavor ; import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { InputReader in = new InputReader ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int test_cases = 1 ; Solver s = new Solver ( ) ; for ( int i = test_cases ; i >= 1 ; i -- ) { s . solve ( 1 , in , out ) ; } out . close ( ) ; } } class Solver { void solve ( int test_number , InputReader in , PrintWriter out ) throws IOException { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; double sum = 0 ; double size = n ; for ( int i = 0 ; i < n ; i ++ ) { sum += in . nextDouble ( ) ; } int c = 0 ; while ( Math . round ( sum / size ) < k ) { c ++ ; sum += k ; size ++ ; } out . println ( c ) ; } } class InputReader { BufferedReader br ; StringTokenizer st ; public InputReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } }", "public class Straight_A { public static void main ( String [ ] args ) { java . util . Scanner kbd = new java . util . Scanner ( System . in ) ; int n = kbd . nextInt ( ) ; int k = kbd . nextInt ( ) ; int [ ] marks = new int [ n ] ; int ctr = 0 ; int total = 0 ; double r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { marks [ i ] = kbd . nextInt ( ) ; total += marks [ i ] ; } do { r = Math . round ( ( ( double ) total + ( ctr * k ) ) / ( n + ctr ) ) ; ctr ++ ; } while ( r < k ) ; System . out . println ( ctr - 1 ) ; } }"], "python": ["I = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , k = I ( ) NEW_LINE print ( max ( 0 , 2 * n * k - n - 2 * sum ( [ * I ( ) ] ) ) ) NEW_LINE", "n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE s = 0 NEW_LINE for i in a : NEW_LINE INDENT s += i NEW_LINE DEDENT while s / n + 0.5 < k : NEW_LINE INDENT s += k NEW_LINE cnt += 1 NEW_LINE n += 1 NEW_LINE DEDENT print ( cnt ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ' \u2581 ' ) ) NEW_LINE m = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE print ( max ( int ( ( n * k - sum ( m ) ) * 2 - n ) , 0 ) ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE lst = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 0 NEW_LINE t = sum ( lst ) NEW_LINE a = t / n NEW_LINE while a < ( 2 * k - 1 ) / 2 : NEW_LINE INDENT t += k NEW_LINE n += 1 NEW_LINE a = t / n NEW_LINE m += 1 NEW_LINE lst . append ( k ) NEW_LINE DEDENT print ( m ) NEW_LINE", "in1 = input ( ) NEW_LINE in2 = input ( ) NEW_LINE in1 = in1 . split ( ) NEW_LINE in11 = int ( in1 [ 0 ] ) NEW_LINE in12 = int ( in1 [ 1 ] ) NEW_LINE in2 = in2 . split ( ) NEW_LINE s = 0 NEW_LINE for i in in2 : NEW_LINE INDENT s += int ( i ) NEW_LINE DEDENT n = 0 NEW_LINE r = ( ( n * in12 ) + s ) / ( in11 + n ) NEW_LINE while r < in12 - .5 : NEW_LINE INDENT n = n + 1 NEW_LINE r = ( ( n * in12 ) + s ) / ( in11 + n ) NEW_LINE DEDENT print ( n ) NEW_LINE"]}
{"id": "geeksforgeeks_1780_A", "java": ["import java . io . * ; class GFG { public static void main ( String [ ] args ) { double n = 5 , a = 2 ; System . out . println ( sumOfSeries ( a , n ) ) ; } static double sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; } }"], "python": ["from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1915_A", "java": ["import java . util . * ; class GFG { static void printTheArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; } static void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; int [ ] arr = new int [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; } }"], "python": ["def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2587_A", "java": ["class GFG { static int numberSequence ( int n ) { int num = ( int ) ( Math . pow ( 4 , n ) - Math . pow ( 2 , n ) ) - 1 ; return num ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( numberSequence ( n ) ) ; } }"], "python": ["def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2311_A", "java": ["import java . io . * ; class GFG { static int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; } static void printMultiplicativePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . out . print ( i + \" \u2581 \" ) ; } } public static void main ( String [ ] args ) { int n = 10 ; printMultiplicativePrimes ( n ) ; } }"], "python": ["from math import sqrt NEW_LINE def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return prod NEW_LINE DEDENT def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE printMultiplicativePrimes ( n ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_699_A", "java": ["import java . io . * ; class GFG { static int minMoves ( int arr [ ] , int n ) { int expectedItem = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == expectedItem ) expectedItem -- ; } return expectedItem ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( minMoves ( arr , n ) ) ; } }"], "python": ["def minMoves ( arr , n ) : NEW_LINE INDENT expectedItem = n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == expectedItem ) : NEW_LINE INDENT expectedItem -= 1 NEW_LINE DEDENT DEDENT return expectedItem NEW_LINE DEDENT arr = [ 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMoves ( arr , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5279_A", "java": ["import java . util . Arrays ; class GFG { static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 2 , 5 , 4 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }"], "python": ["def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2015_A", "java": ["import java . io . * ; class GFG { static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( \" Sum \u2581 = \u2581 \" + calculateSum ( n ) ) ; } }"], "python": ["def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( \" Sum \u2581 = \" , int ( calculateSum ( n ) ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2827_A", "java": ["class GFG { static void count ( String str1 , String str2 ) { int c = 0 , j = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str2 . indexOf ( str1 . charAt ( i ) ) >= 0 ) { c += 1 ; } } System . out . println ( \" No . \u2581 of \u2581 matching \u2581 characters \u2581 are : \u2581 \" + c ) ; } public static void main ( String [ ] args ) { String str1 = \" aabcddekll12 @ \" ; String str2 = \" bb2211@55k \" ; count ( str1 , str2 ) ; } }"], "python": ["def count ( str1 , str2 ) : NEW_LINE INDENT c = 0 ; j = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if str1 [ i ] in str2 : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT print ( \" No . \u2581 of \u2581 matching \u2581 characters \u2581 are : \u2581 \" , c ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" aabcddekll12 @ \" ; NEW_LINE str2 = \" bb2211@55k \" ; NEW_LINE count ( str1 , str2 ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_1428_B", "java": ["import java . util . Scanner ; public class BeltedRooms { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) , i , c = 0 ; String s = in . next ( ) ; if ( ! s . contains ( \" > \" ) || ! s . contains ( \" < \" ) ) { c = n ; } else { for ( i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == ' - ' || s . charAt ( ( i + 1 ) % n ) == ' - ' ) c ++ ; } System . out . println ( c ) ; } in . close ( ) ; } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE c1 , c2 , d , e = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] == ' - ' : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT e += 2 NEW_LINE DEDENT else : NEW_LINE INDENT e += 1 NEW_LINE DEDENT d = 1 NEW_LINE DEDENT elif s [ i ] == ' > ' : NEW_LINE INDENT c1 = 1 NEW_LINE d = 0 NEW_LINE DEDENT else : NEW_LINE INDENT c2 = 1 NEW_LINE d = 0 NEW_LINE DEDENT DEDENT if s [ - 1 ] == ' - ' : NEW_LINE INDENT e += 2 NEW_LINE if s [ - 2 ] == ' - ' : NEW_LINE INDENT e -= 1 NEW_LINE DEDENT if s [ 0 ] == ' - ' : NEW_LINE INDENT e -= 1 NEW_LINE DEDENT DEDENT elif s [ - 1 ] == ' > ' : NEW_LINE INDENT c1 = 1 NEW_LINE DEDENT else : NEW_LINE INDENT c2 = 1 NEW_LINE DEDENT if c1 == 0 or c2 == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( e ) NEW_LINE DEDENT DEDENT", "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , r = int ( input ( ) ) , input ( ) , 0 NEW_LINE if 0 in ( s . count ( ' > ' ) , s . count ( ' < ' ) ) : NEW_LINE INDENT print ( n ) NEW_LINE continue NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ' - ' in ( s [ i ] , s [ ( i + 1 ) % n ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) . rstrip ( ) NEW_LINE c = d = e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' < ' : c += 1 NEW_LINE elif s [ i ] == ' > ' : d += 1 NEW_LINE else : e += 1 NEW_LINE DEDENT if c == 0 or d == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT if e == 0 : print ( 0 ) NEW_LINE else : NEW_LINE INDENT e = 0 NEW_LINE s += s [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' - ' : NEW_LINE INDENT if s [ i + 1 ] == ' - ' : e += 1 NEW_LINE else : e += 2 NEW_LINE DEDENT DEDENT print ( e ) NEW_LINE DEDENT DEDENT DEDENT", "import sys NEW_LINE import math NEW_LINE alfabet = { ' a ' : 1 , ' b ' : 2 , ' c ' : 3 , ' d ' : 4 , ' e ' : 5 , ' f ' : 6 , ' g ' : 7 , ' h ' : 8 , ' i ' : 9 , ' j ' : 10 , ' k ' : 11 , ' l ' : 12 , ' m ' : 13 , ' n ' : 14 , ' o ' : 15 , ' p ' : 16 , ' q ' : 17 , ' r ' : 18 , ' s ' : 19 , ' t ' : 20 , ' u ' : 21 , ' v ' : 22 , ' w ' : 23 , ' x ' : 24 , ' y ' : 25 , ' z ' : 26 } NEW_LINE alfabet_2 = { '1' : \" a \" , '2' : \" b \" , '3' : \" c \" , '4' : \" d \" , '5' : \" e \" , '6' : \" f \" , '7' : \" g \" , '8' : \" h \" , '9' : \" i \" , '10' : \" j \" , '11' : \" k \" , '12' : \" l \" , '13' : \" m \" , '14' : \" n \" , '15' : \" o \" , '16' : \" p \" , '17' : \" q \" , '18' : \" r \" , '19' : \" s \" , '20' : \" t \" , '21' : \" u \" , '22' : \" v \" , '23' : \" w \" , '24' : \" x \" , '25' : \" y \" , '26' : \" z \" } NEW_LINE contor = 1 NEW_LINE my_dict = { } NEW_LINE for j in range ( 1 , 27 ) : NEW_LINE INDENT for i in range ( 1 , 27 ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT element = alfabet_2 [ str ( j ) ] + alfabet_2 [ str ( i ) ] NEW_LINE my_dict [ element ] = contor NEW_LINE contor += 1 NEW_LINE DEDENT DEDENT DEDENT z = int ( input ( ) ) NEW_LINE for i in range ( z ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE stringul = input ( ) NEW_LINE my_set = set ( ) NEW_LINE blocaj = 0 NEW_LINE if \" > \" in stringul and \" < \" in stringul : NEW_LINE INDENT blocaj = 1 NEW_LINE DEDENT if stringul [ n - 1 ] == ' - ' : NEW_LINE INDENT my_set . add ( 0 ) NEW_LINE my_set . add ( n - 1 ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if stringul [ i ] == ' - ' : NEW_LINE INDENT my_set . add ( i ) NEW_LINE my_set . add ( i + 1 ) NEW_LINE DEDENT DEDENT if blocaj == 0 : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( len ( my_set ) ) NEW_LINE DEDENT DEDENT", "import math as m NEW_LINE i = input ( ) NEW_LINE inp = [ ] NEW_LINE for a in range ( 0 , int ( i ) ) : NEW_LINE INDENT input ( ) NEW_LINE inp += [ input ( ) ] NEW_LINE DEDENT for s in inp : NEW_LINE INDENT n = len ( s ) NEW_LINE M = ' < ' not in s NEW_LINE A = ' > ' not in s NEW_LINE c = 0 NEW_LINE in_pointer = - 1 NEW_LINE out_pointer = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT i = s [ in_pointer ] NEW_LINE o = s [ out_pointer ] NEW_LINE if i == ' - ' or o == ' - ' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif o == ' > ' : NEW_LINE INDENT c += M NEW_LINE DEDENT elif i == ' < ' : NEW_LINE INDENT c += A NEW_LINE DEDENT in_pointer += 1 NEW_LINE out_pointer += 1 NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT"]}
{"id": "codeforces_1407_A", "java": ["import java . util . * ; import java . math . BigInteger ; import java . io . * ; public class codeHundredSixty { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = input . nextInt ( ) ; int [ ] arrayOne = new int [ n ] ; long sum = 0 ; int countZ = 0 ; int countO = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrayOne [ i ] = input . nextInt ( ) ; if ( arrayOne [ i ] == 1 ) { countO ++ ; } else { countZ ++ ; } if ( i % 2 == 0 ) { sum += arrayOne [ i ] ; } else { sum -= arrayOne [ i ] ; } } int k = n / 2 ; if ( sum == 0 ) { System . out . println ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arrayOne [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; } else { if ( countZ >= countO ) { System . out . println ( k ) ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( 0 + \" \u2581 \" ) ; } System . out . println ( ) ; } else { int v = countO - ( countO % 2 ) ; System . out . println ( v ) ; for ( int i = 0 ; i < v ; i ++ ) { System . out . print ( 1 + \" \u2581 \" ) ; } System . out . println ( ) ; } } } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { even += arr [ i ] ; } else { odd += arr [ i ] ; } } if ( even == odd ) { System . out . println ( n ) ; for ( int elem : arr ) { System . out . print ( elem + \" \u2581 \" ) ; } System . out . println ( ) ; } else { int ones = 0 ; int zeroes = 0 ; for ( int elem : arr ) { if ( elem == 1 ) { ones ++ ; } else { zeroes ++ ; } } if ( ones > zeroes ) { if ( ones % 2 == 1 ) { ones -- ; } System . out . println ( ones ) ; for ( int i = 0 ; i < ones ; i ++ ) { System . out . print ( 1 + \" \u2581 \" ) ; } System . out . println ( ) ; } else { System . out . println ( n / 2 ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { System . out . print ( 0 + \" \u2581 \" ) ; } System . out . println ( ) ; } } } } }"], "python": ["for p in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a . count ( 0 ) NEW_LINE y = a . count ( 1 ) NEW_LINE if x >= n // 2 : NEW_LINE INDENT print ( x ) NEW_LINE print ( * ( [ 0 ] * x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT d = y - ( y % 2 ) NEW_LINE print ( d ) NEW_LINE print ( * ( [ 1 ] * d ) ) NEW_LINE DEDENT DEDENT", "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = b . count ( 0 ) NEW_LINE if c >= a // 2 : NEW_LINE INDENT print ( c ) NEW_LINE print ( * [ 0 for i in range ( c ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( a - c ) - ( ( a - c ) % 2 ) ) NEW_LINE print ( * [ 1 for i in range ( ( a - c ) - ( ( a - c ) % 2 ) ) ] ) NEW_LINE DEDENT DEDENT", "for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = b . count ( 0 ) NEW_LINE if c >= a // 2 : NEW_LINE INDENT print ( c ) NEW_LINE print ( * [ 0 for i in range ( c ) ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( a - c ) - ( ( a - c ) % 2 ) ) NEW_LINE print ( * [ 1 for i in range ( ( a - c ) - ( ( a - c ) % 2 ) ) ] ) NEW_LINE DEDENT DEDENT", "iter = int ( input ( ) ) NEW_LINE for _ in range ( iter ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count >= n // 2 ) : NEW_LINE INDENT print ( count ) NEW_LINE print ( '0 \u2581 ' * ( count ) ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( count & 1 ) : NEW_LINE INDENT print ( n - count - 1 ) NEW_LINE print ( '1 \u2581 ' * ( n - count - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - count ) NEW_LINE print ( '1 \u2581 ' * ( n - count ) ) NEW_LINE DEDENT DEDENT DEDENT", "import sys NEW_LINE input = sys . stdin . buffer . readline NEW_LINE def process ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE d = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ai = A [ i ] NEW_LINE d [ ai ] += 1 NEW_LINE DEDENT if d [ 0 ] >= n // 2 : NEW_LINE INDENT answer = [ ] NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT answer . append ( 0 ) NEW_LINE DEDENT sys . stdout . write ( f ' { len ( answer ) } \\n ' ) NEW_LINE answer = ' \u2581 ' . join ( map ( str , answer ) ) NEW_LINE sys . stdout . write ( f ' { answer } \\n ' ) NEW_LINE DEDENT else : NEW_LINE INDENT m = d [ 1 ] NEW_LINE m = m - ( m % 2 ) NEW_LINE answer = [ ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT answer . append ( 1 ) NEW_LINE DEDENT sys . stdout . write ( f ' { m } \\n ' ) NEW_LINE answer = ' \u2581 ' . join ( map ( str , answer ) ) NEW_LINE sys . stdout . write ( f ' { answer } \\n ' ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE process ( A ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5177_A", "java": ["class GFG { static int MinimumX ( int a , int b , int c , int k ) { int x = Integer . MAX_VALUE ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } public static void main ( String [ ] args ) { int a = 3 , b = 2 , c = 4 , k = 15 ; System . out . println ( MinimumX ( a , b , c , k ) ) ; } }"], "python": ["def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT a , b , c , k = 3 , 2 , 4 , 15 NEW_LINE print ( MinimumX ( a , b , c , k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3464_A", "java": ["class GFG { static int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 52 ; System . out . print ( minLettersNeeded ( n ) ) ; } }"], "python": ["def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE"]}
{"id": "codeforces_1737_A", "java": ["import java . util . Scanner ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; int [ ] arr = new int [ 26 ] ; int [ ] arr2 = new int [ 26 ] ; in . nextLine ( ) ; String s = in . nextLine ( ) ; char [ ] chars = s . toCharArray ( ) ; for ( char c : chars ) { arr [ c - ' a ' ] ++ ; } StringBuilder ans = new StringBuilder ( ) ; int i ; for ( i = 1 ; i < 25 ; i ++ ) arr [ i ] = Math . min ( arr [ i ] , arr [ i - 1 ] ) ; arr [ Math . min ( 25 , n / k ) ] = 0 ; for ( i = Math . min ( 24 , n / k - 1 ) ; i >= 0 ; i -- ) arr2 [ i ] = arr [ i ] - arr [ i + 1 ] ; for ( i = 0 ; i < 25 ; i ++ ) if ( arr2 [ i ] == 0 ) break ; int h = 0 ; for ( i = Math . min ( 25 , n / k - 1 ) ; i >= 0 ; i -- ) { if ( k >= arr2 [ i ] ) { int q = arr2 [ i ] ; while ( ( q -- ) > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; k -= arr2 [ i ] ; } else while ( k -- > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; } while ( k -- > 0 ) System . out . print ( ( char ) ( ' a ' + i + 1 ) ) ; System . out . println ( ) ; } } }"], "python": ["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE k1 = k NEW_LINE s = input ( ) NEW_LINE A = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT A [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT sch = 0 NEW_LINE otv = ' ' NEW_LINE while A [ sch ] != 0 and len ( otv ) != k1 : NEW_LINE INDENT if sch < n // k1 : NEW_LINE INDENT otv += chr ( sch + ord ( ' a ' ) ) * ( max ( 0 , k - A [ sch ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT k = min ( k , A [ sch ] ) NEW_LINE sch += 1 NEW_LINE DEDENT otv += chr ( sch + ord ( ' a ' ) ) * ( k1 - len ( otv ) ) NEW_LINE print ( otv [ : : - 1 ] ) NEW_LINE DEDENT", "T = int ( input ( ) ) NEW_LINE while T : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE string = input ( ) NEW_LINE freq = [ 0 ] * 26 NEW_LINE for ch in string : NEW_LINE INDENT freq [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT bps = n // k NEW_LINE ans = \" \" NEW_LINE for i in range ( k ) : NEW_LINE INDENT first_zero = freq . index ( 0 ) NEW_LINE till = min ( bps , first_zero ) NEW_LINE ans += chr ( 97 + till ) NEW_LINE for j in range ( till ) : NEW_LINE INDENT freq [ j ] -= 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE T -= 1 NEW_LINE DEDENT", "def solve ( n , k , s ) : NEW_LINE INDENT dct = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] not in dct : NEW_LINE INDENT dct [ s [ i ] ] = 1 NEW_LINE DEDENT else : dct [ s [ i ] ] += 1 NEW_LINE DEDENT if ' a ' not in dct : return ( ' a ' * k ) NEW_LINE res = ' ' NEW_LINE lim = n // k NEW_LINE j = 1 NEW_LINE while len ( res ) < k : NEW_LINE INDENT u = 0 NEW_LINE while abc [ u ] in dct and dct [ abc [ u ] ] >= j and u < lim : NEW_LINE INDENT u += 1 NEW_LINE DEDENT res += abc [ u ] NEW_LINE j += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE abc = list ( ' abcdefghijklmnopqrstuvwxyz ' ) NEW_LINE while ( t ) : NEW_LINE INDENT t -= 1 NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE print ( solve ( n , k , s ) ) NEW_LINE DEDENT", "def solve ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE dp = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = str ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while cnt < n / k and dp [ cnt ] > 0 : dp [ cnt ] -= 1 ; cnt += 1 NEW_LINE ans += chr ( 97 + cnt ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : solve ( ) NEW_LINE"]}
{"id": "codeforces_501_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; if ( Math . max ( 3 * a / 10 , a - a * c / 250 ) > Math . max ( 3 * b / 10 , b - b * d / 250 ) ) { System . out . println ( \" Misha \" ) ; } else if ( Math . max ( 3 * a / 10 , a - a * c / 250 ) < Math . max ( 3 * b / 10 , b - b * d / 250 ) ) { System . out . println ( \" Vasya \" ) ; } else { System . out . println ( \" Tie \" ) ; } } }", "import java . util . * ; public class cf { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; int d = in . nextInt ( ) ; int Misha = Math . max ( ( 3 * a ) / 10 , a - ( ( a * c ) / 250 ) ) ; int Vasya = Math . max ( ( 3 * b ) / 10 , b - ( ( b * d ) / 250 ) ) ; if ( Misha > Vasya ) System . out . println ( \" Misha \" ) ; else if ( Misha < Vasya ) System . out . println ( \" Vasya \" ) ; else System . out . println ( \" Tie \" ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; import java . lang . Math ; public class contest { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int fa = 3 * a / 10 ; int fa1 = a - ( a / 250 ) * c ; int fans = fa > fa1 ? fa : fa1 ; int fb = ( 3 * b ) / 10 ; int fb1 = b - ( b / 250 ) * d ; int fbans = fb > fb1 ? fb : fb1 ; if ( fans == fbans ) { System . out . println ( \" Tie \" ) ; } else { System . out . println ( fans > fbans ? \" Misha \" : \" Vasya \" ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { FastScanner fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; StringBuilder sb = new StringBuilder ( ) ; int a = fs . nextInt ( ) , b = fs . nextInt ( ) , c = fs . nextInt ( ) , d = fs . nextInt ( ) ; int n = Math . max ( ( 3 * a ) / 10 , a - ( a / 250 * c ) ) ; int m = Math . max ( ( 3 * b ) / 10 , b - ( b / 250 * d ) ) ; if ( n == m ) out . print ( \" Tie \" ) ; else out . print ( ( n > m ) ? \" Misha \" : \" Vasya \" ) ; out . close ( ) ; } static int isPerfectSquare ( int x ) { if ( x >= 0 ) { int sr = ( int ) Math . sqrt ( x ) ; if ( ( sr * sr ) == x ) return sr ; else return 0 ; } return 0 ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } Long [ ] readArray ( int n ) { Long [ ] a = new Long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextLong ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }"], "python": ["a , b , c , d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE vasya = max ( ( b * 3 ) / 10 , b - ( b / 250 ) * d ) NEW_LINE Misha = max ( ( a * 3 ) / 10 , a - ( a / 250 ) * c ) NEW_LINE if vasya == Misha : NEW_LINE INDENT print ( \" Tie \" ) NEW_LINE DEDENT elif vasya > Misha : NEW_LINE INDENT print ( \" Vasya \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Misha \" ) NEW_LINE DEDENT", "a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE m = max ( ( 3 * a ) // 10 , a - ( ( a // 250 ) * c ) ) NEW_LINE v = max ( ( 3 * b ) // 10 , b - ( ( b // 250 ) * d ) ) NEW_LINE if m > v : NEW_LINE INDENT print ( ' Misha ' ) NEW_LINE DEDENT elif m < v : NEW_LINE INDENT print ( ' Vasya ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Tie ' ) NEW_LINE DEDENT", "a , b , c , d = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE misha = max ( ( 3 * a / 10 ) , ( a - ( a * c / 250 ) ) ) NEW_LINE vasya = max ( ( 3 * b / 10 ) , ( b - ( b * d / 250 ) ) ) NEW_LINE if misha > vasya : NEW_LINE INDENT print ( \" Misha \" ) NEW_LINE DEDENT elif misha < vasya : NEW_LINE INDENT print ( \" Vasya \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Tie \" ) NEW_LINE DEDENT", "p1 , p2 , t1 , t2 = map ( int , input ( ) . split ( ) ) NEW_LINE sc1 = max ( 0.3 * p1 , p1 - ( 0.004 * p1 * t1 ) ) NEW_LINE sc2 = max ( 0.3 * p2 , p2 - ( 0.004 * p2 * t2 ) ) NEW_LINE if sc1 > sc2 : NEW_LINE INDENT print ( \" Misha \" ) NEW_LINE DEDENT elif sc2 > sc1 : NEW_LINE INDENT print ( \" Vasya \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Tie \" ) NEW_LINE DEDENT", "from collections import defaultdict , deque NEW_LINE from functools import lru_cache NEW_LINE from heapq import heappush , heappop NEW_LINE from typing import Counter NEW_LINE from bisect import bisect_right , bisect_left NEW_LINE import math NEW_LINE hpop = heappop NEW_LINE hpush = heappush NEW_LINE def solution ( ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE misha = max ( 3 * a / 10 , a - ( a * c ) / 250 ) NEW_LINE vasya = max ( 3 * b / 10 , b - ( b * d ) / 250 ) NEW_LINE if misha > vasya : NEW_LINE INDENT print ( \" Misha \" ) NEW_LINE DEDENT if misha < vasya : NEW_LINE INDENT print ( \" Vasya \" ) NEW_LINE DEDENT if misha == vasya : NEW_LINE INDENT print ( \" Tie \" ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = 1 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solution ( ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"]}
{"id": "atcoder_ABC134_F", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int score = sc . nextInt ( ) ; long dp [ ] [ ] [ ] = new long [ 55 ] [ 55 ] [ 2605 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; int mod = 1000000007 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { for ( int k = 0 ; k <= score ; k ++ ) { { int nj = j ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] += dp [ i ] [ j ] [ k ] ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] %= mod ; } { int nj = j + 1 ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] += dp [ i ] [ j ] [ k ] ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] %= mod ; } { int nj = j ; int x = j * 2 ; long y = dp [ i ] [ j ] [ k ] * x ; y %= mod ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] += y ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] %= mod ; } if ( j >= 1 ) { int nj = j - 1 ; int x = j * j ; long y = dp [ i ] [ j ] [ k ] * x ; y %= mod ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] += y ; dp [ i + 1 ] [ nj ] [ k + nj * 2 ] %= mod ; } } } } System . out . println ( dp [ n ] [ 0 ] [ score ] ) ; sc . close ( ) ; } }", "import java . io . PrintWriter ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . Scanner ; public class Main { long MOD = ( long ) 1e9 + 7 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; long [ ] [ ] [ ] dp = new long [ N + 1 ] [ N + 1 ] [ K + 1 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { for ( int k = 0 ; k <= K ; k ++ ) { if ( 0 > k - 2 * j || k - 2 * j > K ) continue ; dp [ i ] [ j ] [ k ] = ( 2 * j + 1 ) * dp [ i - 1 ] [ j ] [ k - 2 * j ] ; if ( j < N ) dp [ i ] [ j ] [ k ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ k - 2 * j ] ; if ( j > 0 ) dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j - 1 ] [ k - 2 * j ] ; dp [ i ] [ j ] [ k ] %= MOD ; } } } System . out . println ( dp [ N ] [ 0 ] [ K ] ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . util . * ; import java . util . stream . * ; public class Main { Scanner sc ; int N ; int K ; long [ ] [ ] [ ] dp ; public Main ( ) { sc = new Scanner ( System . in ) ; } private void calc ( ) { long mod = 1000000007L ; dp = new long [ N + 1 ] [ N + 1 ] [ K + 1 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { for ( int k = 2 * j ; k <= K ; k ++ ) { if ( j > 0 ) dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - 1 ] [ k - 2 * j ] ; dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] + ( 2 * j + 1 ) * dp [ i - 1 ] [ j ] [ k - 2 * j ] ) % mod ; if ( j < N ) dp [ i ] [ j ] [ k ] = ( dp [ i ] [ j ] [ k ] + ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ k - 2 * j ] ) % mod ; } } } } private void out ( Object o ) { System . out . println ( o ) ; System . out . flush ( ) ; } private void input ( ) { N = sc . nextInt ( ) ; K = sc . nextInt ( ) ; } private void output ( ) { out ( dp [ N ] [ 0 ] [ K ] ) ; } public static void main ( String [ ] args ) { Main m = new Main ( ) ; m . input ( ) ; m . calc ( ) ; m . output ( ) ; } }", "import java . util . Scanner ; public class Main { static final int MODULUS = 1_000_000_007 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; System . out . println ( solve ( n , k ) ) ; sc . close ( ) ; } static int solve ( int n , int k ) { int [ ] [ ] [ ] wayNums = new int [ n + 1 ] [ n + 1 ] [ k + 1 ] ; wayNums [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 0 ; j <= n ; ++ j ) { for ( int p = 0 ; p <= k ; ++ p ) { wayNums [ i ] [ j ] [ p ] = addMod ( addMod ( multiplyMod ( 2 * j + 1 , getWayNum ( wayNums , i - 1 , j , p - 2 * j ) ) , multiplyMod ( ( j + 1 ) * ( j + 1 ) , getWayNum ( wayNums , i - 1 , j + 1 , p - 2 * j ) ) ) , getWayNum ( wayNums , i - 1 , j - 1 , p - 2 * j ) ) ; } } } return wayNums [ n ] [ 0 ] [ k ] ; } static int getWayNum ( int [ ] [ ] [ ] wayNums , int seenNum , int unpairNum , int oddness ) { int n = wayNums . length - 1 ; return ( unpairNum == - 1 || unpairNum == n + 1 || oddness < 0 ) ? 0 : wayNums [ seenNum ] [ unpairNum ] [ oddness ] ; } static int addMod ( int x , int y ) { return ( x + y ) % MODULUS ; } static int multiplyMod ( int x , int y ) { return ( int ) ( ( long ) x * y % MODULUS ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int K = scanner . nextInt ( ) ; long M = 1_000_000_007 ; long [ ] [ ] [ ] dp = new long [ N + 1 ] [ N + 1 ] [ K + 1 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) for ( int k = 2 * j ; k <= K ; k ++ ) { if ( j > 0 ) dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j - 1 ] [ k - 2 * j ] ; dp [ i ] [ j ] [ k ] += ( 2 * j + 1 ) * dp [ i - 1 ] [ j ] [ k - 2 * j ] % M ; if ( dp [ i ] [ j ] [ k ] >= M ) dp [ i ] [ j ] [ k ] -= M ; if ( j < N ) dp [ i ] [ j ] [ k ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ k - 2 * j ] % M ; if ( dp [ i ] [ j ] [ k ] >= M ) dp [ i ] [ j ] [ k ] -= M ; } System . out . println ( dp [ N ] [ 0 ] [ K ] ) ; } }"], "python": ["import sys NEW_LINE from itertools import product NEW_LINE MOD = 1000000007 NEW_LINE def solve ( N : int , K : int ) : NEW_LINE INDENT if K % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT dp = [ [ [ 0 for k in range ( K + 1 ) ] for j in range ( N + 2 ) ] for i in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i , j , k in product ( range ( 1 , N + 1 ) , range ( N + 1 ) , range ( K + 1 ) ) : NEW_LINE INDENT prev_k = k - 2 * j NEW_LINE if prev_k < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] += 2 * j * dp [ i - 1 ] [ j ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] += ( j + 1 ) * ( j + 1 ) * dp [ i - 1 ] [ j + 1 ] [ prev_k ] NEW_LINE if j > 0 : dp [ i ] [ j ] [ k ] += dp [ i - 1 ] [ j - 1 ] [ prev_k ] NEW_LINE dp [ i ] [ j ] [ k ] %= MOD NEW_LINE DEDENT print ( dp [ N ] [ 0 ] [ K ] ) NEW_LINE return NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE n = int ( next ( tokens ) ) NEW_LINE k = int ( next ( tokens ) ) NEW_LINE solve ( n , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE scr = 10000 NEW_LINE dp = [ [ [ 0 ] * ( n + 1 ) for i in range ( scr ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for nsc in range ( - scr // 2 , scr // 2 ) : NEW_LINE INDENT for x in range ( n ) : NEW_LINE INDENT nownum = i + 1 NEW_LINE dp [ i + 1 ] [ nsc ] [ x ] += dp [ i ] [ nsc ] [ x ] NEW_LINE dp [ i + 1 ] [ nsc ] [ x ] %= mod NEW_LINE if x > 0 : NEW_LINE INDENT dp [ i + 1 ] [ ( nsc + 2 * nownum ) % scr ] [ x - 1 ] += dp [ i ] [ nsc ] [ x ] * x * x NEW_LINE dp [ i + 1 ] [ ( nsc + 2 * nownum ) % scr ] [ x - 1 ] %= mod NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT dp [ i + 1 ] [ nsc ] [ x ] += dp [ i ] [ nsc ] [ x ] * x NEW_LINE dp [ i + 1 ] [ nsc ] [ x ] %= mod NEW_LINE DEDENT if x > 0 : NEW_LINE INDENT dp [ i + 1 ] [ nsc ] [ x ] += dp [ i ] [ nsc ] [ x ] * x NEW_LINE dp [ i + 1 ] [ nsc ] [ x ] %= mod NEW_LINE DEDENT if x < n : NEW_LINE INDENT dp [ i + 1 ] [ ( nsc - 2 * nownum ) % scr ] [ x + 1 ] += dp [ i ] [ nsc ] [ x ] NEW_LINE dp [ i + 1 ] [ ( nsc - 2 * nownum ) % scr ] [ x + 1 ] %= mod NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ n ] [ k ] [ 0 ] % mod ) NEW_LINE", "import sys NEW_LINE read = sys . stdin . buffer . read NEW_LINE readline = sys . stdin . buffer . readline NEW_LINE readlines = sys . stdin . buffer . readlines NEW_LINE import numpy as np NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N , K = map ( int , read ( ) . split ( ) ) NEW_LINE L = N * ( N - 1 ) // 2 + 1 NEW_LINE dp = np . zeros ( ( N , L ) , dtype = np . int64 ) NEW_LINE dp [ 0 , 0 ] = 1 NEW_LINE for _ in range ( 1 , N + 1 ) : NEW_LINE INDENT prev = dp NEW_LINE dp = np . zeros_like ( prev ) NEW_LINE for n in range ( N ) : NEW_LINE INDENT x = prev [ n ] NEW_LINE dp [ n , n : ] += x [ : L - n ] * ( n + n + 1 ) NEW_LINE if n > 0 : dp [ n - 1 , n - 1 : ] += x [ : L - n + 1 ] * n NEW_LINE if n + 1 < N : dp [ n + 1 , n + 1 : ] += x [ : L - n - 1 ] * ( n + 1 ) NEW_LINE DEDENT dp %= MOD NEW_LINE DEDENT x = dp [ 0 ] NEW_LINE if K & 1 : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT elif K // 2 < L : NEW_LINE INDENT answer = x [ K // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT print ( answer ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE dp = { } NEW_LINE dp [ ( 0 , 0 , 0 ) ] = 1 NEW_LINE def perm ( i , j , k ) : NEW_LINE INDENT if ( i , j , k ) in dp : NEW_LINE INDENT return dp [ ( i , j , k ) ] NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT if k == 0 and j == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT elif k < 0 or j < 0 or i < j : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ( i , j , k ) ] = ( ( j + j + 1 ) * perm ( i - 1 , j , k - 2 * j ) + ( j + 1 ) * ( j + 1 ) * perm ( i - 1 , j + 1 , k - 2 * j ) + 1 * perm ( i - 1 , j - 1 , k - 2 * j ) ) % ( 10 ** 9 + 7 ) NEW_LINE return dp [ ( i , j , k ) ] NEW_LINE DEDENT DEDENT print ( perm ( n , 0 , k ) ) NEW_LINE", "MOD = 10 ** 9 + 7 NEW_LINE n , oddness = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE if oddness % 2 == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT oddness //= 2 NEW_LINE max_oddness = n * n + n NEW_LINE max_pending = n + 1 NEW_LINE dp = [ [ [ 0 ] * ( max_oddness ) for _ in range ( max_pending ) ] for _ in range ( n ) ] NEW_LINE oddness_itr = [ item for item in range ( n * n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 0 ] [ 1 ] [ 1 ] = 1 NEW_LINE continue NEW_LINE DEDENT for j in range ( i + 1 ) : NEW_LINE INDENT for k in oddness_itr : NEW_LINE INDENT dp [ i ] [ j ] [ k + j ] += dp [ i - 1 ] [ j ] [ k ] NEW_LINE dp [ i ] [ j ] [ k + j ] += dp [ i - 1 ] [ j ] [ k ] * j * 2 NEW_LINE dp [ i ] [ j ] [ k + j ] %= MOD NEW_LINE if j > 0 : NEW_LINE INDENT dp [ i ] [ j - 1 ] [ k + j - 1 ] += dp [ i - 1 ] [ j ] [ k ] * j * j NEW_LINE dp [ i ] [ j - 1 ] [ k + j - 1 ] %= MOD NEW_LINE DEDENT dp [ i ] [ j + 1 ] [ k + j + 1 ] += dp [ i - 1 ] [ j ] [ k ] NEW_LINE dp [ i ] [ j + 1 ] [ k + j + 1 ] %= MOD NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n - 1 ] [ 0 ] [ oddness ] ) NEW_LINE"]}
{"id": "atcoder_ABC100_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = Integer . parseInt ( sc . next ( ) ) ; int B = Integer . parseInt ( sc . next ( ) ) ; sc . close ( ) ; if ( Math . abs ( A - B ) < 2 ) { System . out . println ( \" Yay ! \" ) ; } else { System . out . println ( \" : ( \" ) ; } } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws Exception { String line = readLine ( ) ; StringTokenizer st = new StringTokenizer ( line , \" \u2581 \" ) ; Integer a = Integer . parseInt ( st . nextToken ( ) ) ; Integer b = Integer . parseInt ( st . nextToken ( ) ) ; if ( ( a <= 8 ) && ( b <= 8 ) ) { System . out . println ( \" Yay ! \" ) ; } else { System . out . println ( \" : ( \" ) ; } } private static String readLine ( ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; return br . readLine ( ) ; } }", "import java . io . * ; import java . util . StringTokenizer ; import static java . lang . Math . max ; public class Main { static StringTokenizer cin ; static PrintWriter out = new PrintWriter ( System . out ) ; static final void in_init ( ) throws Exception { BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder s = new StringBuilder ( ) ; while ( true ) { String st = bf . readLine ( ) ; if ( st == null ) { break ; } s . append ( ' \u2581 ' ) ; s . append ( st ) ; } cin = new StringTokenizer ( s . toString ( ) ) ; } static final int getInt ( ) throws Exception { return Integer . parseInt ( cin . nextToken ( ) ) ; } public static void main ( String [ ] args ) throws Exception { in_init ( ) ; int a = getInt ( ) , b = getInt ( ) ; if ( a + b == 16 ) { if ( a != b ) { out . println ( \" : ( \" ) ; } else { out . println ( \" Yay ! \" ) ; } } else { if ( max ( a , b ) * 2 <= 16 ) { out . println ( \" Yay ! \" ) ; } else { out . println ( \" : ( \" ) ; } } out . flush ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] tmp = br . readLine ( ) . split ( \" \u2581 \" ) ; int a = Integer . parseInt ( tmp [ 0 ] ) ; int b = Integer . parseInt ( tmp [ 1 ] ) ; if ( a > 8 || b > 8 ) System . out . println ( \" : ( \" ) ; else System . out . println ( \" Yay ! \" ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; for ( int i = 1 ; i <= 16 ; i ++ ) { if ( i % 2 == 0 ) { a -- ; } else { b -- ; } } if ( a <= 0 && b <= 0 ) { System . out . println ( \" Yay ! \" ) ; } else { System . out . println ( \" : ( \" ) ; } } }"], "python": ["import sys NEW_LINE a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a <= 8 and b <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" : ( \" ) NEW_LINE DEDENT", "s = input ( ) ; print ( ' : ( ' * ( len ( s ) > 3 or '9' in s ) or ' Yay ! ' ) NEW_LINE", "def main ( ) : NEW_LINE INDENT A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if A < 9 and B < 9 : NEW_LINE INDENT print ( \" Yay ! \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" : ( \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE if a < b : a , b = b , a NEW_LINE def main ( ) : NEW_LINE INDENT r , c = 16 - b * 2 , a - b NEW_LINE ans = ' Yay ! ' if c <= r // 2 else ' : ( ' NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a <= 8 and b <= 8 : NEW_LINE INDENT print ( ' Yay ! ' ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ' : ( ' ) NEW_LINE"]}
{"id": "atcoder_ABC096_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a > b ? a - 1 : a ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; Task solver = new Task ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class Task { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; if ( a > b ) { out . println ( a - 1 ) ; } else { out . println ( a ) ; } } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . IOException ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = in . readLine ( ) . split ( \" \u2581 \" ) ; int a = Integer . parseInt ( str [ 0 ] ) ; int b = Integer . parseInt ( str [ 1 ] ) ; if ( a == b ) System . out . println ( a ) ; else if ( a < b ) System . out . println ( a ) ; else System . out . println ( a - 1 ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws Exception { String line = readLine ( ) ; StringTokenizer st = new StringTokenizer ( line , \" \u2581 \" ) ; int a = Integer . parseInt ( st . nextToken ( ) ) ; int b = Integer . parseInt ( st . nextToken ( ) ) ; if ( a > b ) { System . out . println ( String . valueOf ( a - 1 ) ) ; } else { System . out . println ( String . valueOf ( a ) ) ; } } private static String readLine ( ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; return br . readLine ( ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; ABC096A solver = new ABC096A ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class ABC096A { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int ans = ( a - 1 ) + ( a <= b ? 1 : 0 ) ; out . println ( ans ) ; } } }"], "python": ["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT", "import bisect NEW_LINE import cmath NEW_LINE import heapq NEW_LINE import itertools NEW_LINE import math NEW_LINE import operator NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import string NEW_LINE import sys NEW_LINE from collections import Counter , deque , defaultdict NEW_LINE from copy import deepcopy NEW_LINE from decimal import Decimal NEW_LINE from fractions import gcd NEW_LINE from functools import lru_cache , reduce NEW_LINE from operator import itemgetter , mul , add , xor NEW_LINE import numpy as np NEW_LINE if os . getenv ( \" LOCAL \" ) : NEW_LINE INDENT sys . stdin = open ( \" _ in . txt \" , \" r \" ) NEW_LINE DEDENT sys . setrecursionlimit ( 10 ** 9 ) NEW_LINE INF = float ( \" inf \" ) NEW_LINE IINF = 10 ** 18 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE from datetime import datetime , timedelta NEW_LINE a , b = list ( map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) ) NEW_LINE dt = datetime ( 2018 , 1 , 1 ) NEW_LINE until = datetime ( 2018 , a , b ) NEW_LINE cnt = 0 NEW_LINE while dt <= until : NEW_LINE INDENT if dt . month == dt . day : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT dt += timedelta ( days = 1 ) NEW_LINE DEDENT print ( cnt ) NEW_LINE", "import sys , os NEW_LINE f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if ' local ' in os . environ : NEW_LINE INDENT sys . stdin = open ( ' . / input . txt ' , ' r ' ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT a , b = f ( ) NEW_LINE if a <= b : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a - 1 ) NEW_LINE DEDENT DEDENT solve ( ) NEW_LINE", "a , b = map ( int , input ( ) . split ( ) ) ; print ( a - 1 + ( a <= b ) ) NEW_LINE", "a = [ int ( x ) for x in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE m , d = a NEW_LINE if d < m : NEW_LINE INDENT print ( m - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC137_E", "java": ["import java . io . * ; import java . util . * ; public class Main { public static final Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; public static final PrintStream out = System . out ; static class Edge { int from , to , cost ; public Edge ( int from , int to , int cost ) { this . from = from ; this . to = to ; this . cost = cost ; } } public static void main ( String [ ] args ) { int N = in . nextInt ( ) ; int M = in . nextInt ( ) ; int P = in . nextInt ( ) ; List < Edge > G = new ArrayList < > ( M ) ; for ( int i = 0 ; i < M ; i ++ ) { int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int C = in . nextInt ( ) ; G . add ( new Edge ( A - 1 , B - 1 , - C + P ) ) ; } long [ ] data = new long [ N ] ; boolean [ ] visited = new boolean [ N ] ; Arrays . fill ( data , 1 , N , Long . MAX_VALUE ) ; for ( int i = 0 ; i < N * 2 ; i ++ ) { for ( Edge edge : G ) { if ( data [ edge . from ] != Long . MAX_VALUE && data [ edge . from ] + edge . cost < data [ edge . to ] ) { data [ edge . to ] = data [ edge . from ] + edge . cost ; if ( i > N ) { visited [ edge . to ] = true ; } } visited [ edge . to ] |= visited [ edge . from ] ; } } if ( visited [ N - 1 ] ) { out . println ( - 1 ) ; } else { out . println ( Math . max ( - data [ N - 1 ] , 0L ) ) ; } } }", "import java . util . * ; public class Main { Scanner sc ; int N , M , P ; int [ ] [ ] nodes ; int [ ] [ ] edges ; public Main ( ) { sc = new Scanner ( System . in ) ; } private void calc ( ) { N = sc . nextInt ( ) ; M = sc . nextInt ( ) ; P = sc . nextInt ( ) ; nodes = new int [ N + 1 ] [ 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) nodes [ i ] [ 0 ] = Integer . MIN_VALUE ; edges = new int [ M + 1 ] [ 3 ] ; for ( int i = 1 ; i <= M ; i ++ ) { edges [ i ] [ 0 ] = sc . nextInt ( ) ; edges [ i ] [ 1 ] = sc . nextInt ( ) ; edges [ i ] [ 2 ] = sc . nextInt ( ) - P ; } nodes [ 1 ] [ 0 ] = 0 ; nodes [ N ] [ 1 ] = 1 ; boolean infinite = false ; for ( int i = 0 ; i < N ; i ++ ) { infinite = false ; for ( int j = 1 ; j <= M ; j ++ ) { nodes [ edges [ j ] [ 0 ] ] [ 1 ] |= nodes [ edges [ j ] [ 1 ] ] [ 1 ] ; int s = nodes [ edges [ j ] [ 0 ] ] [ 0 ] ; if ( s == Integer . MIN_VALUE ) continue ; int p = s + edges [ j ] [ 2 ] ; if ( nodes [ edges [ j ] [ 1 ] ] [ 0 ] < p ) { nodes [ edges [ j ] [ 1 ] ] [ 0 ] = p ; if ( nodes [ edges [ j ] [ 1 ] ] [ 1 ] > 0 ) infinite = true ; } } } if ( infinite ) System . out . println ( - 1 ) ; else System . out . println ( Math . max ( 0 , nodes [ N ] [ 0 ] ) ) ; System . out . flush ( ) ; } public static void main ( String [ ] args ) { new Main ( ) . calc ( ) ; } }"], "python": ["n , m , p = map ( int , input ( ) . split ( ) ) NEW_LINE abc = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE abc = [ [ a , b , p - c ] for a , b , c in abc ] NEW_LINE def BF ( edges , num_v , source ) : NEW_LINE INDENT inf = float ( \" inf \" ) NEW_LINE dist = [ inf for i in range ( num_v ) ] NEW_LINE dist [ source - 1 ] = 0 NEW_LINE neg = [ False for _ in range ( num_v ) ] NEW_LINE for i in range ( num_v - 1 ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( num_v ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if edge [ 0 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE neg [ edge [ 1 ] - 1 ] = True NEW_LINE DEDENT if neg [ edge [ 0 ] - 1 ] == True : NEW_LINE INDENT neg [ edge [ 1 ] - 1 ] = True NEW_LINE DEDENT DEDENT DEDENT return dist , neg NEW_LINE DEDENT dis , neg = BF ( abc , n , 1 ) NEW_LINE print ( - 1 if neg [ - 1 ] else max ( 0 , - dis [ - 1 ] ) ) NEW_LINE", "inf = float ( ' inf ' ) NEW_LINE def bellmanford ( n : int , edges : list , start : int , goal : int ) -> ( list , bool ) : NEW_LINE INDENT dist = [ inf ] * n NEW_LINE dist [ start ] = 0 NEW_LINE exist_negative_cycle = False NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT for v , nv , w in edges : NEW_LINE INDENT if dist [ nv ] > dist [ v ] + w : NEW_LINE INDENT dist [ nv ] = dist [ v ] + w NEW_LINE DEDENT DEDENT DEDENT is_updated = [ False ] * n NEW_LINE for _ in range ( n ) : NEW_LINE INDENT for v , nv , w in edges : NEW_LINE INDENT if dist [ nv ] > dist [ v ] + w : NEW_LINE INDENT dist [ nv ] = dist [ v ] + w NEW_LINE is_updated [ nv ] = True NEW_LINE DEDENT if is_updated [ v ] is True : NEW_LINE INDENT is_updated [ nv ] = True NEW_LINE DEDENT DEDENT DEDENT exist_negative_cycle = is_updated [ goal ] NEW_LINE return dist , exist_negative_cycle NEW_LINE DEDENT N , M , P = map ( int , input ( ) . split ( ) ) NEW_LINE edges = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE A -= 1 ; B -= 1 NEW_LINE C = C - P NEW_LINE edges . append ( ( A , B , - C ) ) NEW_LINE DEDENT dist , exist_negative_cycle = bellmanford ( N , edges , 0 , N - 1 ) NEW_LINE if exist_negative_cycle is True : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( - dist [ N - 1 ] , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE", "import bisect NEW_LINE import collections NEW_LINE import copy NEW_LINE import functools NEW_LINE import heapq NEW_LINE import math NEW_LINE import sys NEW_LINE from collections import deque NEW_LINE from collections import defaultdict NEW_LINE input = sys . stdin . readline NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N , M , P = map ( int , ( input ( ) . split ( ) ) ) NEW_LINE line = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b , c = map ( int , ( input ( ) . split ( ) ) ) NEW_LINE line . append ( [ a - 1 , b - 1 , - c + P ] ) NEW_LINE DEDENT min_distance = [ float ( \" inf \" ) ] * N NEW_LINE min_distance [ 0 ] = 0 NEW_LINE def Bellman_Ford ( S , V , E , distance ) : NEW_LINE INDENT update = False NEW_LINE flag = 0 NEW_LINE for _ in range ( V ) : NEW_LINE INDENT for s , g , d in distance : NEW_LINE INDENT if min_distance [ s ] != float ( \" inf \" ) and min_distance [ s ] + d < min_distance [ g ] : NEW_LINE INDENT min_distance [ g ] = min_distance [ s ] + d NEW_LINE update = True NEW_LINE DEDENT DEDENT if not update : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return min_distance , flag NEW_LINE DEDENT def Bellman_Ford2 ( S , V , E , distance ) : NEW_LINE INDENT for _ in range ( V ) : NEW_LINE INDENT for s , g , d in distance : NEW_LINE INDENT if min_distance [ s ] != float ( \" inf \" ) and min_distance [ s ] + d < min_distance [ g ] : NEW_LINE INDENT min_distance [ g ] = - float ( \" inf \" ) NEW_LINE DEDENT DEDENT DEDENT return min_distance NEW_LINE DEDENT min_distance , flag = Bellman_Ford ( 1 , N , M , line ) NEW_LINE if flag == 1 : NEW_LINE INDENT ans = min_distance [ N - 1 ] NEW_LINE print ( max ( - ans , 0 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT min_distance = Bellman_Ford2 ( 1 , N , M , line ) NEW_LINE ans = min_distance [ N - 1 ] NEW_LINE if ans == - float ( \" inf \" ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( - ans , 0 ) ) NEW_LINE NEW_LINE DEDENT DEDENT", "import sys NEW_LINE sys . setrecursionlimit ( 1000000000 ) NEW_LINE ii = lambda : int ( input ( ) ) NEW_LINE miis = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE lmiis = lambda : list ( miis ( ) ) NEW_LINE def reachable_nodeset ( start , inc ) : NEW_LINE INDENT reachable = set ( ) NEW_LINE reachable . add ( start ) NEW_LINE nodes = [ start ] NEW_LINE while nodes : NEW_LINE INDENT n = nodes . pop ( ) NEW_LINE for i in inc [ n ] : NEW_LINE INDENT if i not in reachable : NEW_LINE INDENT nodes . append ( i ) NEW_LINE reachable . add ( i ) NEW_LINE DEDENT DEDENT DEDENT return reachable NEW_LINE DEDENT def bellmanford ( num , start , goal , edges ) : NEW_LINE INDENT cost = [ float ( ' inf ' ) ] * num NEW_LINE cost [ start ] = 0 NEW_LINE for _ in range ( num ) : NEW_LINE INDENT updated = False NEW_LINE for a , b , c in edges : NEW_LINE INDENT if cost [ b ] > cost [ a ] + c : NEW_LINE INDENT cost [ b ] = cost [ a ] + c NEW_LINE updated = True NEW_LINE DEDENT DEDENT if not updated : break NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return max ( 0 , - cost [ goal ] ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT N , M , P = miis ( ) NEW_LINE to = [ [ ] for _ in range ( N ) ] NEW_LINE ot = [ [ ] for _ in range ( N ) ] NEW_LINE edges = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b , c = miis ( ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE c = - ( c - P ) NEW_LINE to [ a ] . append ( b ) NEW_LINE ot [ b ] . append ( a ) NEW_LINE edges . append ( ( a , b , c ) ) NEW_LINE DEDENT reachableFromZero = reachable_nodeset ( 0 , to ) NEW_LINE reachableToN = reachable_nodeset ( N - 1 , ot ) NEW_LINE ok = reachableFromZero . intersection ( reachableToN ) NEW_LINE edges = tuple ( ( a , b , c ) for a , b , c in edges if a in ok and b in ok ) NEW_LINE print ( bellmanford ( N , 0 , N - 1 , edges ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT", "import sys NEW_LINE inf = 10000000000 NEW_LINE def BellmanFord ( edges , points , start ) : NEW_LINE INDENT dist = [ inf for i in range ( points ) ] NEW_LINE dist [ start - 1 ] = 0 NEW_LINE for i in range ( points ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if dist [ edge [ 0 ] - 1 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE DEDENT DEDENT dist1 = dist [ N - 1 ] NEW_LINE DEDENT for i in range ( points ) : NEW_LINE INDENT for edge in edges : NEW_LINE INDENT if dist [ edge [ 0 ] - 1 ] != inf and dist [ edge [ 1 ] - 1 ] > dist [ edge [ 0 ] - 1 ] + edge [ 2 ] : NEW_LINE INDENT dist [ edge [ 1 ] - 1 ] = dist [ edge [ 0 ] - 1 ] + edge [ 2 ] NEW_LINE DEDENT DEDENT dist2 = dist [ N - 1 ] NEW_LINE DEDENT if dist1 != dist2 : return \" Loop \" NEW_LINE return ( dist ) NEW_LINE DEDENT N , M , P = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Edges = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT a , b , c = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE Edges . append ( ( a , b , P - c ) ) NEW_LINE DEDENT dist = BellmanFord ( Edges , N , 1 ) NEW_LINE if dist == \" Loop \" : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( - dist [ N - 1 ] , 0 ) ) NEW_LINE DEDENT"]}
{"id": "aizu_p00392_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } UnionFind uf = new UnionFind ( ) ; for ( int ai : a ) { int value = ai ; for ( int i = 2 ; i * i <= ai ; i ++ ) { if ( value % i == 0 ) { uf . unite ( ai , i ) ; while ( value % i == 0 ) value /= i ; } } if ( value != 1 ) { uf . unite ( ai , value ) ; } } int [ ] asorted = a . clone ( ) ; Arrays . sort ( asorted ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! uf . isSameRoot ( a [ i ] , asorted [ i ] ) ) { System . out . println ( 0 ) ; return ; } } System . out . println ( 1 ) ; } } class UnionFind { int [ ] data = new int [ 100010 ] ; UnionFind ( ) { for ( int i = 0 ; i < 100010 ; i ++ ) { data [ i ] = i ; } } void unite ( int left , int right ) { data [ root ( left ) ] = root ( right ) ; } int root ( int i ) { if ( data [ i ] == i ) return i ; else return data [ i ] = root ( data [ i ] ) ; } boolean isSameRoot ( int x , int y ) { return root ( x ) == root ( y ) ; } }"], "python": ["from collections import defaultdict NEW_LINE def main ( ) : NEW_LINE INDENT def primes ( n ) : NEW_LINE INDENT is_prime = [ True ] * ( n + 1 ) NEW_LINE is_prime [ 0 ] = is_prime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( n ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if is_prime [ i ] : NEW_LINE INDENT for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT is_prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT return [ i for i in range ( n + 1 ) if is_prime [ i ] ] NEW_LINE DEDENT prime_list = primes ( 100000 ) NEW_LINE solvers = [ [ ] for _ in range ( 100001 ) ] NEW_LINE for p in prime_list : NEW_LINE INDENT for i in range ( p , 100001 , p ) : NEW_LINE INDENT solvers [ i ] . append ( p ) NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE parent = [ i for i in range ( 100001 ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT if x == parent [ x ] : NEW_LINE INDENT return x NEW_LINE DEDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT for i , v in enumerate ( a_list ) : NEW_LINE INDENT p_rep = find ( min ( solvers [ v ] ) ) NEW_LINE for s in solvers [ v ] : NEW_LINE INDENT parent [ find ( s ) ] = p_rep NEW_LINE DEDENT parent [ find ( v ) ] = p_rep NEW_LINE DEDENT dic = defaultdict ( set ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT dic [ find ( v ) ] . add ( i ) NEW_LINE DEDENT a_list . sort ( ) NEW_LINE for i , v in enumerate ( a_list ) : NEW_LINE INDENT if i not in dic [ find ( v ) ] : NEW_LINE INDENT print ( 0 ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"]}
{"id": "geeksforgeeks_2241_A", "java": ["class GFG { static int ways ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { String temp = \" \" ; for ( int j = i ; j < n ; j ++ ) { temp += s . charAt ( j ) ; String test = \" \" ; for ( int k = i - 1 ; k >= 0 ; k -- ) { test += s . charAt ( k ) ; if ( test . compareTo ( temp ) < 0 ) { dp [ i ] [ j ] += dp [ k ] [ i - 1 ] ; } } } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += dp [ i ] [ n - 1 ] ; } return ans ; } public static void main ( String [ ] args ) { String s = \" aabc \" ; int n = s . length ( ) ; System . out . println ( ways ( s , n ) ) ; } }"], "python": ["def ways ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT temp = \" \" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE test = \" \" NEW_LINE for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT test += s [ k ] NEW_LINE if ( test < temp ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ k ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += dp [ i ] [ n - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = \" aabc \" NEW_LINE n = len ( s ) NEW_LINE print ( ways ( s , n ) ) NEW_LINE"]}
{"id": "codeforces_1651_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . lang . Math ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Random ; import java . util . StringTokenizer ; public class Main { public static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } public static char different ( String s1 , String s2 , int i ) { char check [ ] = { ' a ' , ' b ' , ' c ' } ; for ( char ch : check ) { if ( ch != s1 . charAt ( i ) && ch != s2 . charAt ( i ) ) { return ch ; } } return ' z ' ; } public static void main ( String [ ] args ) throws java . lang . Exception { FastScanner fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int t = fs . nextInt ( ) ; while ( t -- > 0 ) { int n = fs . nextInt ( ) ; long x = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { x *= 2 ; } out . println ( x - 1 ) ; } out . close ( ) ; } }", "import java . io . * ; import java . util . * ; public class C { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { int n = s . nextInt ( ) ; System . out . println ( ( int ) Math . pow ( 2 , n ) - 1 + 1 - 1 ) ; } } }", "import java . io . * ; import java . util . * ; public class C { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { int n = s . nextInt ( ) ; System . out . println ( ( int ) Math . pow ( 2 , n ) - 2 + 1 ) ; } } }", "import java . util . Scanner ; public class test280 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { System . out . println ( ( int ) Math . pow ( 2 , in . nextInt ( ) ) - 1 ) ; } in . close ( ) ; } }"], "python": ["for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( 2 ** n - 1 ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x = int ( input ( ) ) NEW_LINE if ( x == 1 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ** x - 1 ) NEW_LINE DEDENT DEDENT", "num = int ( input ( ) ) NEW_LINE for i in range ( num ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( ( 2 ** n ) - 1 ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( 2 ** int ( input ( ) ) - 1 ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( ( 1 << n ) - 1 ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_99_A", "java": ["class GFG { static boolean isOdd ( int [ ] arr , int n ) { int l , r , flag = 0 , flag1 = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % 2 == 0 && flag == 0 ) { flag = 1 ; l = arr [ i ] ; } if ( arr [ i ] % 2 != 0 && flag1 == 0 ) { r = arr [ i ] ; flag1 = 1 ; } } if ( sum % 2 != 0 ) { return true ; } else { if ( flag1 == 1 && flag == 1 ) return true ; else return false ; } } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; boolean res = isOdd ( ar , n ) ; if ( res == true ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def isOdd ( arr , n ) : NEW_LINE INDENT flag = 0 ; flag1 = 0 ; sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE if ( arr [ i ] % 2 == 0 and flag == 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE l = arr [ i ] ; NEW_LINE DEDENT if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : NEW_LINE INDENT r = arr [ i ] ; NEW_LINE flag1 = 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag1 == 1 and flag == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE res = isOdd ( arr , n ) ; NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1496_A", "java": ["import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; sc . nextLine ( ) ; String val = sc . nextLine ( ) ; int i = 0 , j = val . length ( ) - 1 ; while ( k > 0 ) { if ( val . charAt ( i ) != val . charAt ( j ) ) break ; k -- ; i ++ ; j -- ; } if ( k > 0 ) System . out . println ( \" NO \" ) ; else if ( i > j ) { System . out . println ( \" NO \" ) ; } else System . out . println ( \" YES \" ) ; } } }", "import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; String s = sc . next ( ) ; if ( k == 0 ) { System . out . println ( \" YES \" ) ; } else if ( n % 2 == 0 && k == n / 2 ) { System . out . println ( \" NO \" ) ; } else { String ans = \" YES \" ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( n - i - 1 ) ) { ans = \" NO \" ; break ; } } System . out . println ( ans ) ; } t -- ; } sc . close ( ) ; } }"], "python": ["for nt in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if 2 * k == n : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE continue NEW_LINE DEDENT ans = \" NO \" NEW_LINE if s [ 0 : k ] == s [ n - k : ] [ : : - 1 ] : NEW_LINE INDENT ans = \" YES \" NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "from sys import stdin , stdout NEW_LINE T = int ( stdin . readline ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT N , K = map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE S = list ( stdin . readline ( ) . strip ( ) ) NEW_LINE LEN = 0 NEW_LINE for j in range ( ( N ) // 2 ) : NEW_LINE INDENT if S [ j ] == S [ N - j - 1 ] : NEW_LINE INDENT LEN += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if N % 2 != 0 : NEW_LINE INDENT LEN += 1 NEW_LINE DEDENT if K >= LEN and K != 0 : NEW_LINE INDENT stdout . write ( \" NO \\n \" ) NEW_LINE DEDENT else : NEW_LINE INDENT stdout . write ( \" YES \\n \" ) NEW_LINE DEDENT DEDENT", "def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE if n < 2 * k + 1 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT if s [ i ] != s [ n - i - 1 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "for pratyush in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = input ( ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif n == 2 * k : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT a = s [ : k ] NEW_LINE f = s [ : : - 1 ] NEW_LINE b = f [ : k ] NEW_LINE if a == b : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if s [ i ] == s [ n - 1 - i ] : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( n >= ( 2 * k ) + 1 and cnt >= k ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "geeksforgeeks_1370_A", "java": ["class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( maxCommonFactors ( a , b ) ) ; } }"], "python": ["import math NEW_LINE def maxCommonFactors ( a , b ) : NEW_LINE INDENT gcd = math . gcd ( a , b ) NEW_LINE ans = 1 ; NEW_LINE i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2686_A", "java": ["import java . io . * ; public class GFG { static boolean allCharactersSame ( String s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) if ( s . charAt ( i ) != s . charAt ( 0 ) ) return false ; return true ; } static public void main ( String [ ] args ) { String s = \" aaa \" ; if ( allCharactersSame ( s ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def allCharactersSame ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aaa \" NEW_LINE if allCharactersSame ( s ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1270_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class CardGame { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t -- > 0 ) { int n , a , b ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; n = Integer . parseInt ( st . nextToken ( ) ) ; a = Integer . parseInt ( st . nextToken ( ) ) ; b = Integer . parseInt ( st . nextToken ( ) ) ; int ma , mb , ta = 0 , tb = 0 ; st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < a ; i ++ ) { ma = Integer . parseInt ( st . nextToken ( ) ) ; ; if ( ma > ta ) ta = ma ; } st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < b ; i ++ ) { mb = Integer . parseInt ( st . nextToken ( ) ) ; ; if ( mb > tb ) tb = mb ; } System . out . println ( ( ta > tb ) ? \" YES \" : \" NO \" ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Comparator ; import java . util . List ; import java . util . StringTokenizer ; public class CardGame { public static class ListComparator implements Comparator < List < Integer > > { @ Override public int compare ( List < Integer > l1 , List < Integer > l2 ) { for ( int i = 0 ; i < l1 . size ( ) ; ++ i ) { if ( l1 . get ( i ) . compareTo ( l2 . get ( i ) ) != 0 ) { return l1 . get ( i ) . compareTo ( l2 . get ( i ) ) ; } } return 0 ; } } public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; int T = Integer . parseInt ( f . readLine ( ) ) ; for ( int i = 0 ; i < T ; i ++ ) { StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int a = Integer . parseInt ( st . nextToken ( ) ) ; int b = Integer . parseInt ( st . nextToken ( ) ) ; boolean check = false ; StringTokenizer ab = new StringTokenizer ( f . readLine ( ) ) ; for ( int j = 0 ; j < a ; j ++ ) { int c = Integer . parseInt ( ab . nextToken ( ) ) ; if ( c == N ) { check = true ; break ; } } f . readLine ( ) ; if ( check ) { out . println ( \" YES \" ) ; } else { out . println ( \" NO \" ) ; } } out . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; public class Main { static FastReader in = new FastReader ( ) ; static PrintWriter out = new PrintWriter ( System . out ) ; static int n , m , zu ; static void solve ( ) { n = in . nextInt ( ) ; int k1 = in . nextInt ( ) , k2 = in . nextInt ( ) ; int ans1 = 0 , ans2 = 0 ; for ( int i = 0 ; i < k1 ; i ++ ) { ans1 = Math . max ( in . nextInt ( ) , ans1 ) ; } for ( int i = 0 ; i < k2 ; i ++ ) { ans2 = Math . max ( in . nextInt ( ) , ans2 ) ; } if ( ans1 > ans2 ) out . println ( \" YES \" ) ; else out . println ( \" NO \" ) ; } public static void main ( String [ ] args ) { zu = in . nextInt ( ) ; while ( zu -- > 0 ) { solve ( ) ; } out . flush ( ) ; out . close ( ) ; } static class FastReader { StringTokenizer st ; BufferedReader br ; FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return st . nextToken ( ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return str ; } } }"], "python": ["t = int ( input ( ) ) NEW_LINE r = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = max ( b ) NEW_LINE n = max ( c ) NEW_LINE if m > n : NEW_LINE INDENT r . append ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( \" NO \" ) NEW_LINE DEDENT DEDENT for i in range ( len ( r ) ) : NEW_LINE INDENT print ( r [ i ] ) NEW_LINE DEDENT", "I = input NEW_LINE exec ( int ( I ( ) ) * \" n = I ( ) . split ( ) ; I ( ) ; print ( ' YNEOS ' [ n [ 0 ] in \u2581 I ( ) : :2 ] ) ; \" ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT n , n1 , n1 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x1 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE x2 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if max ( x1 ) > max ( x2 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT", "from cmath import * NEW_LINE from decimal import * NEW_LINE from opcode import HAVE_ARGUMENT NEW_LINE import sys NEW_LINE from tkinter import N NEW_LINE input_ = sys . stdin . readline NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT n , k1 , k2 = _input ( ) NEW_LINE a1 = _list ( ) NEW_LINE a2 = _list ( ) NEW_LINE if ( max ( a1 ) > max ( a2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT t = 1 NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT", "import sys NEW_LINE lines = [ ] NEW_LINE for line in sys . stdin : NEW_LINE INDENT lines . append ( line . split ( ) ) NEW_LINE DEDENT for i in range ( int ( lines [ 0 ] [ 0 ] ) ) : NEW_LINE INDENT n = int ( lines [ 3 * i + 1 ] [ 0 ] ) NEW_LINE k1 = int ( lines [ 3 * i + 1 ] [ 1 ] ) NEW_LINE k2 = int ( lines [ 3 * i + 1 ] [ 2 ] ) NEW_LINE for j in range ( k1 ) : NEW_LINE INDENT if int ( lines [ 3 * i + 2 ] [ j ] ) == n : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT for j in range ( k2 ) : NEW_LINE INDENT if int ( lines [ 3 * i + 3 ] [ j ] ) == n : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "geeksforgeeks_3830_A", "java": ["class Main { static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( \" The \u2581 complete \u2581 array \u2581 is \u2581 sorted \" ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( \" \u2581 The \u2581 unsorted \u2581 subarray \u2581 which \" + \" \u2581 makes \u2581 the \u2581 given \u2581 array \u2581 sorted \u2581 lies \" + \" \u2581 \u2581 between \u2581 the \u2581 indices \u2581 \" + s + \" \u2581 and \u2581 \" + e ) ; return ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = arr . length ; printUnsorted ( arr , arr_size ) ; } }"], "python": ["def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( \" The \u2581 complete \u2581 array \u2581 is \u2581 sorted \" ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( \" The \u2581 unsorted \u2581 subarray \u2581 which \u2581 makes \u2581 the \u2581 given \u2581 array \" ) NEW_LINE print ( \" sorted \u2581 lies \u2581 between \u2581 the \u2581 indexes \u2581 % d \u2581 and \u2581 % d \" % ( s , e ) ) NEW_LINE DEDENT arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printUnsorted ( arr , arr_size ) NEW_LINE"]}
{"id": "codeforces_580_A", "java": ["import java . util . * ; public class QQQ { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; int c = 1 ; int [ ] a = new int [ t ] ; int [ ] k = new int [ t + 1 ] ; int k1 = 0 ; for ( int i = 0 ; i < t ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 1 ; i < t ; i ++ ) { if ( a [ i ] >= a [ i - 1 ] ) { c ++ ; } else { k [ k1 ++ ] = c ; c = 1 ; } } k [ t ] = c ; Arrays . sort ( k ) ; System . out . println ( k [ k . length - 1 ] ) ; } }", "import java . util . * ; public class cf580A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = input . nextInt ( ) ; int count = 1 ; int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] <= a [ i + 1 ] ) count ++ ; else { if ( count > max ) max = count ; count = 1 ; } } System . out . println ( max < count ? count : max ) ; } }", "import java . util . * ; public class cf580A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = input . nextInt ( ) ; int count = 1 ; int max = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] <= a [ i + 1 ] ) count ++ ; else { if ( count > max ) max = count ; count = 1 ; } } System . out . println ( max < count ? count : max ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long arr [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextLong ( ) ; int count = 1 ; int max = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] ) count ++ ; else count = 1 ; max = Math . max ( max , count ) ; } System . out . print ( max ) ; } }"], "python": ["_ = input ( ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE best = 0 NEW_LINE curr = 0 NEW_LINE last = 0 NEW_LINE for v in l : NEW_LINE INDENT if v >= last : NEW_LINE INDENT curr += 1 NEW_LINE if curr > best : NEW_LINE INDENT best = curr NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = 1 NEW_LINE DEDENT last = v NEW_LINE DEDENT print ( best ) NEW_LINE", "x = int ( input ( ) ) NEW_LINE L = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE answer = 0 NEW_LINE count = 1 NEW_LINE for i in range ( len ( L ) - 1 ) : NEW_LINE INDENT if L [ i ] <= L [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if count > answer : NEW_LINE INDENT answer = count NEW_LINE DEDENT count = 1 NEW_LINE DEDENT DEDENT print ( max ( answer , count ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 1 NEW_LINE ans = float ( ' - inf ' ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l [ i ] <= l [ i + 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 1 NEW_LINE DEDENT ans = max ( ans , cnt ) NEW_LINE DEDENT if len ( l ) == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE inp = input ( ) . split ( ) NEW_LINE l = [ int ( i ) for i in inp ] NEW_LINE count = 1 NEW_LINE max_count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if l [ i ] > l [ i + 1 ] : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE count = 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT max_count = max ( max_count , count ) NEW_LINE print ( max_count ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c1 , c2 = 1 , 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if numbers [ i ] >= numbers [ i - 1 ] : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if c1 > c2 : NEW_LINE INDENT c2 = c1 NEW_LINE DEDENT c1 = 1 NEW_LINE DEDENT DEDENT if c1 > 1 and c2 < c1 : NEW_LINE INDENT c2 = c1 NEW_LINE DEDENT print ( c2 ) NEW_LINE"]}
{"id": "aizu_p00312_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sin = new Scanner ( System . in ) ; int L = sin . nextInt ( ) ; int D = sin . nextInt ( ) ; int result = L / D + L % D ; System . out . println ( result ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; line = br . readLine ( ) ; int D , L ; D = parseInt ( line . substring ( 0 , line . indexOf ( ' \u2581 ' ) ) ) ; L = parseInt ( line . substring ( line . indexOf ( ' \u2581 ' ) + 1 ) ) ; int [ ] dp = new int [ D + 1 ] ; for ( int i = 0 ; i <= D ; i ++ ) { if ( i < L ) dp [ i ] = i ; else dp [ i ] = Integer . MAX_VALUE ; } for ( int i = L ; i <= D ; i ++ ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - L ] + 1 ) ; } System . out . println ( dp [ D ] ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) { BufferedReader bfr = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = \" \" ; StringTokenizer stk ; int DIST , M_JUMP ; try { str = bfr . readLine ( ) ; if ( str == \" \" ) { System . exit ( 0 ) ; } stk = new StringTokenizer ( str , \" \u2581 \" ) ; DIST = Integer . parseInt ( stk . nextToken ( ) ) ; M_JUMP = Integer . parseInt ( stk . nextToken ( ) ) ; int d_jk = DIST / M_JUMP ; int kaisu = d_jk + ( ( DIST - ( M_JUMP * d_jk ) ) / 1 ) ; System . out . println ( kaisu ) ; } catch ( IOException e ) { System . exit ( 0 ) ; } catch ( NumberFormatException e ) { System . exit ( 0 ) ; } catch ( NullPointerException e ) { System . exit ( 0 ) ; } } }", "import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int gole = sc . nextInt ( ) ; int big = sc . nextInt ( ) ; int ans = ( gole / big ) + ( gole % big ) ; System . out . println ( ans ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { InputStreamReader is = new InputStreamReader ( System . in ) ; BufferedReader br = new BufferedReader ( is ) ; String str ; while ( ( str = br . readLine ( ) ) != null ) { String [ ] sp = str . split ( \" \u2581 \" ) ; int D = Integer . parseInt ( sp [ 0 ] ) ; int L = Integer . parseInt ( sp [ 1 ] ) ; if ( D % L == 0 ) { System . out . println ( D / L ) ; } else { System . out . println ( D / L + D % L ) ; } } } }"], "python": ["d , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( d // l + d % l ) NEW_LINE", "D , L = map ( int , input ( ) . split ( ) ) NEW_LINE if L <= D : NEW_LINE INDENT if D % L == 0 : NEW_LINE INDENT print ( D // L ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( D // L + D % L ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( D ) NEW_LINE DEDENT", "D , L = map ( int , input ( ) . split ( ) ) NEW_LINE i = 0 NEW_LINE while D >= L : NEW_LINE INDENT D = D - L NEW_LINE i += 1 NEW_LINE DEDENT i += D NEW_LINE print ( i ) NEW_LINE", "print ( sum ( divmod ( * map ( int , input ( ) . split ( ) ) ) ) ) NEW_LINE", "D , L = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( ( D // L ) + ( D % L ) ) NEW_LINE"]}
{"id": "codejam_15_02", "java": ["package cj2015 . qr ; import java . io . * ; import java . util . * ; public class B { Scanner sc ; PrintWriter pw ; int D ; int [ ] P ; public static void main ( String [ ] args ) throws Exception { String filePrefix = args . length > 0 ? args [ 0 ] : \" B - large \" ; try { new B ( ) . run ( filePrefix ) ; } catch ( Exception e ) { System . err . println ( e ) ; } } public void run ( String filePrefix ) throws Exception { sc = new Scanner ( new FileReader ( filePrefix + \" . in \" ) ) ; pw = new PrintWriter ( new FileWriter ( filePrefix + \" . out \" ) ) ; int ntest = sc . nextInt ( ) ; for ( int test = 1 ; test <= ntest ; test ++ ) { read ( sc ) ; pw . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; System . out . print ( \" Case \u2581 # \" + test + \" : \u2581 \" ) ; solve ( ) ; } System . out . println ( \" Finished . \" ) ; sc . close ( ) ; pw . close ( ) ; } void read ( Scanner sc ) { D = sc . nextInt ( ) ; P = new int [ D ] ; for ( int i = 0 ; i < D ; i ++ ) P [ i ] = sc . nextInt ( ) ; } void print ( Object s ) { pw . print ( s ) ; System . out . print ( s ) ; } void println ( Object s ) { pw . println ( s ) ; System . out . println ( s ) ; } public void solve ( ) { final int INF = 1000000 ; int min = INF ; for ( int x = 1 ; x <= 1000 ; x ++ ) { int time = 0 ; for ( int i = 0 ; i < D ; i ++ ) time += ( P [ i ] + x - 1 ) / x - 1 ; min = Math . min ( min , time + x ) ; } println ( min ) ; } }", "import java . io . BufferedWriter ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . util . Scanner ; public class B { static final String FILENAME = \" B - large \" ; static final String IN = FILENAME + \" . in \" ; static final String OUT = FILENAME + \" . out \" ; Scanner sc ; BufferedWriter out ; static final int MAXP = 1000 ; private int divideTime ( int [ ] num , int limit ) { int time = 0 ; for ( int i = limit + 1 ; i <= MAXP ; i ++ ) { time += num [ i ] * ( ( i - 1 ) / limit ) ; } return time ; } private void solve ( ) throws IOException { int ans = Integer . MAX_VALUE ; int d = sc . nextInt ( ) ; int [ ] num = new int [ MAXP + 1 ] ; for ( int i = 0 ; i < d ; i ++ ) { num [ sc . nextInt ( ) ] ++ ; } for ( int limit = 1 ; limit <= MAXP ; limit ++ ) { int cur = divideTime ( num , limit ) + limit ; if ( ans > cur ) { ans = cur ; } } out . write ( Integer . toString ( ans ) ) ; out . newLine ( ) ; out . flush ( ) ; } private void run ( ) throws IOException { sc = new Scanner ( new File ( IN ) ) ; out = new BufferedWriter ( new FileWriter ( OUT ) ) ; int t = sc . nextInt ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { out . write ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } sc . close ( ) ; out . close ( ) ; } public static void main ( String args [ ] ) throws Exception { new B ( ) . run ( ) ; } }", "import java . io . * ; import java . util . * ; import java . util . concurrent . * ; public class B { int n ; int [ ] a ; String solve ( ) { Arrays . sort ( a ) ; int m = a [ n - 1 ] ; int ans = m ; for ( int k = 1 ; k <= m ; k ++ ) { int divs = 0 ; for ( int x : a ) { divs += ( x - 1 ) / k ; } ans = Math . min ( ans , k + divs ) ; } return \" \" + ans ; } public B ( Scanner in ) { n = in . nextInt ( ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } } private static String fileName = B . class . getSimpleName ( ) . replaceFirst ( \" _ . * \" , \" \" ) . toLowerCase ( ) ; private static String inputFileName = fileName + \" . in \" ; private static String outputFileName = fileName + \" . out \" ; public static void main ( String [ ] args ) throws IOException , InterruptedException , ExecutionException { ExecutorService executor = Executors . newFixedThreadPool ( 4 ) ; Locale . setDefault ( Locale . US ) ; Scanner in = new Scanner ( new File ( inputFileName ) ) ; PrintWriter out = new PrintWriter ( outputFileName ) ; int tests = in . nextInt ( ) ; in . nextLine ( ) ; @ SuppressWarnings ( \" unchecked \" ) Future < String > [ ] outputs = new Future [ tests ] ; for ( int t = 0 ; t < tests ; t ++ ) { final B testCase = new B ( in ) ; final int testCaseNumber = t ; outputs [ t ] = executor . submit ( new Callable < String > ( ) { @ Override public String call ( ) { String answer = testCase . solve ( ) ; String printed = \" Case \u2581 # \" + ( testCaseNumber + 1 ) + \" : \u2581 \" + answer ; System . out . println ( printed ) ; return printed ; } } ) ; } for ( int t = 0 ; t < tests ; t ++ ) { out . println ( outputs [ t ] . get ( ) ) ; } in . close ( ) ; out . close ( ) ; executor . shutdown ( ) ; } }", "import java . util . * ; import java . io . * ; public class InfinitePancakes { static final String filename = \" C : / Users / Kevin / algs4 / CodeJam / InfinitePancakes / B - large . in \" ; static final String output = \" largeoutput . txt \" ; public static int howLong ( int [ ] cakecounts ) { if ( cakecounts . length < 4 ) return cakecounts . length - 1 ; int ret = Integer . MAX_VALUE ; for ( int maxsize = 2 ; maxsize < cakecounts . length ; ++ maxsize ) { int [ ] cakes = Arrays . copyOf ( cakecounts , cakecounts . length ) ; int numspec = 0 ; int maxstack = cakecounts . length - 1 ; while ( maxstack > maxsize ) { while ( cakes [ maxstack ] > 0 ) { cakes [ maxstack ] -- ; cakes [ maxstack - maxsize ] ++ ; cakes [ maxsize ] ++ ; numspec ++ ; } maxstack -- ; } ret = Math . min ( ret , maxsize + numspec ) ; } return ret ; } public static void main ( String [ ] args ) { try { Scanner sc = new Scanner ( new FileInputStream ( new File ( filename ) ) ) ; int no_of_times = sc . nextInt ( ) ; for ( int i = 0 ; i < no_of_times ; ++ i ) { int D = sc . nextInt ( ) ; int [ ] platenumbers = new int [ D ] ; int maxnumber = 0 ; for ( int j = 0 ; j < D ; ++ j ) { platenumbers [ j ] = sc . nextInt ( ) ; maxnumber = Math . max ( maxnumber , platenumbers [ j ] ) ; } int [ ] cakecounts = new int [ maxnumber + 1 ] ; for ( int j = 0 ; j < D ; ++ j ) { cakecounts [ platenumbers [ j ] ] ++ ; } FileOutputStream fos = new FileOutputStream ( output , true ) ; fos . write ( ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + howLong ( cakecounts ) + \" \\n \" ) . getBytes ( ) ) ; fos . close ( ) ; } sc . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }", "package gcj2015 . qualif ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; import java . util . logging . Level ; import java . util . logging . Logger ; public class ExoB { public static void main ( final String [ ] args ) { final String base = \" / home / jean / gcj2015 / q / ExoB / \" ; final String input = base + \" b1 . in \" ; final String output = base + \" b2 . out \" ; try { final Scanner sc = new Scanner ( new FileReader ( input ) ) ; final PrintWriter pw = new PrintWriter ( output ) ; final int n = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int c = 0 ; c < n ; c ++ ) { System . out . println ( \" Test \u2581 case \u2581 \" + ( c + 1 ) + \" . . . \" ) ; pw . print ( \" Case \u2581 # \" + ( c + 1 ) + \" : \u2581 \" ) ; test3 ( sc , pw ) ; pw . println ( ) ; } pw . println ( ) ; pw . flush ( ) ; pw . close ( ) ; sc . close ( ) ; } catch ( final FileNotFoundException ex ) { Logger . getLogger ( ExoB . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } private static void test3 ( final Scanner sc , final PrintWriter pw ) { final int D = sc . nextInt ( ) ; List < Integer > nums = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < D ; i ++ ) { nums . add ( sc . nextInt ( ) ) ; } int max = Collections . max ( nums ) ; int bt = max ; for ( int m = 1 ; m <= max ; m ++ ) { System . out . println ( \" for \u2581 m \u2581 = \u2581 \" + m ) ; int t = m ; for ( int k : nums ) { if ( k != 0 ) t += ( k % m == 0 ) ? ( k / m ) - 1 : k / m ; } System . out . println ( \" t \u2581 = \u2581 \" + t ) ; if ( t < bt ) { bt = t ; } } pw . print ( bt ) ; } }"], "python": ["import math NEW_LINE import re NEW_LINE def solve ( l ) : NEW_LINE INDENT s = max ( l ) NEW_LINE for a in range ( 1 , s ) : NEW_LINE INDENT s = min ( s , reduce ( lambda x , y : x - ( - y ) / a - 1 , l , a ) ) NEW_LINE DEDENT return ( s ) NEW_LINE DEDENT inp = open ( \" B - large . in \" , \" r \" ) NEW_LINE out = open ( \" B - large \" , \" w \" ) NEW_LINE lines = inp . readlines ( ) NEW_LINE for i in range ( 1 , len ( lines ) / 2 + 1 ) : NEW_LINE INDENT l = [ int ( x ) for x in re . split ( \" \u2581 \" , lines [ 2 * i ] ) ] NEW_LINE out . write ( \" Case \u2581 # \" + str ( i ) + \" : \u2581 \" + str ( solve ( l ) ) + \" \\n \" ) NEW_LINE DEDENT out . close ( ) NEW_LINE inp . close ( ) NEW_LINE", "DESCRIPTION = \"\"\" STRNEWLINE \"\"\" NEW_LINE import os NEW_LINE import sys NEW_LINE import argparse NEW_LINE def perr ( msg ) : NEW_LINE INDENT sys . stderr . write ( \" % s \" % msg ) NEW_LINE sys . stderr . flush ( ) NEW_LINE DEDENT def pinfo ( msg ) : NEW_LINE INDENT sys . stdout . write ( \" % s \" % msg ) NEW_LINE sys . stdout . flush ( ) NEW_LINE DEDENT def runcmd ( cmd ) : NEW_LINE INDENT perr ( \" % s \\n \" % cmd ) NEW_LINE os . system ( cmd ) NEW_LINE DEDENT def getargs ( ) : NEW_LINE INDENT parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawTextHelpFormatter ) NEW_LINE parser . add_argument ( ' infile ' , type = str , help = ' input \u2581 file ' ) NEW_LINE parser . add_argument ( ' outfile ' , type = str , nargs = ' ? ' , default = None , help = ' output \u2581 file ' ) NEW_LINE return parser . parse_args ( ) NEW_LINE DEDENT def steps_to_get_Pmax_eq_p ( P , Pmax ) : NEW_LINE INDENT nstep = 0 NEW_LINE for p in P : NEW_LINE INDENT nstep += ( ( p - 1 ) / Pmax ) NEW_LINE DEDENT return nstep NEW_LINE DEDENT def solve ( D , P ) : NEW_LINE INDENT min_costs = max ( P ) NEW_LINE for Pmax in range ( 1 , max ( P ) + 1 ) : NEW_LINE INDENT N = steps_to_get_Pmax_eq_p ( P , Pmax ) NEW_LINE costs = N + Pmax NEW_LINE if costs < min_costs : NEW_LINE INDENT min_costs = costs NEW_LINE DEDENT DEDENT return min_costs NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT if None == args . outfile : NEW_LINE INDENT outfile = sys . stdout NEW_LINE DEDENT else : NEW_LINE INDENT outfile = open ( args . outfile , \" w \" ) NEW_LINE DEDENT with open ( args . infile ) as infile : NEW_LINE INDENT T = int ( infile . readline ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT D = int ( infile . readline ( ) ) NEW_LINE P = [ int ( p ) for p in infile . readline ( ) . split ( ) ] NEW_LINE outfile . write ( \" Case \u2581 # % d : \u2581 % d \\n \" % ( i , solve ( D , P ) ) ) NEW_LINE DEDENT DEDENT if None != args . outfile : NEW_LINE INDENT outfile . close ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( getargs ( ) ) NEW_LINE DEDENT", "import math NEW_LINE import sys NEW_LINE def findsol ( P , D ) : NEW_LINE INDENT P . sort ( ) NEW_LINE T = P [ len ( P ) - 1 ] NEW_LINE for jj in range ( 1 , T ) : NEW_LINE INDENT N = 0 NEW_LINE for kk in P : NEW_LINE INDENT N += math . ceil ( kk / jj ) - 1 NEW_LINE DEDENT T2 = N + jj NEW_LINE if ( T2 < T ) : NEW_LINE INDENT T = T2 NEW_LINE DEDENT DEDENT return T NEW_LINE DEDENT def convertnums ( s ) : NEW_LINE INDENT a = [ ] NEW_LINE ii = 0 NEW_LINE for jj in range ( len ( s ) ) : NEW_LINE INDENT if s [ jj ] == ' \u2581 ' : NEW_LINE INDENT if ( ii < jj ) : NEW_LINE INDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE ii = jj + 1 NEW_LINE DEDENT DEDENT DEDENT a . append ( int ( s [ ii : jj ] ) ) NEW_LINE return a NEW_LINE DEDENT fidi = open ( ' B - large . in ' , ' r ' ) NEW_LINE fido = open ( ' a . out ' , ' w ' ) NEW_LINE T = fidi . readline ( ) NEW_LINE T = int ( T ) NEW_LINE for ii in range ( 1 , T + 1 ) : NEW_LINE INDENT D = int ( fidi . readline ( ) ) NEW_LINE P = fidi . readline ( ) NEW_LINE P = convertnums ( P ) NEW_LINE a = findsol ( P , D ) NEW_LINE fido . write ( ' Case \u2581 # ' + str ( ii ) + ' : \u2581 ' + str ( a ) + ' \\n ' ) NEW_LINE print ( ' Case \u2581 # ' , str ( ii ) , ' : \u2581 ' , str ( a ) ) NEW_LINE DEDENT fidi . close ( ) NEW_LINE fido . close ( ) NEW_LINE", "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT input ( ) NEW_LINE p = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE ans = min ( e + sum ( - ( - i // e ) - 1 for i in p ) for e in range ( 1 , max ( p ) + 1 ) ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , ans ) ) NEW_LINE DEDENT", "import sys , math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( sys . stdin . readline ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sys . stdout . write ( \" Case \u2581 # { } : \u2581 \" . format ( i + 1 ) ) NEW_LINE n = int ( sys . stdin . readline ( ) ) NEW_LINE l = map ( int , sys . stdin . readline ( ) . split ( ' \u2581 ' ) ) NEW_LINE m = max ( l ) NEW_LINE ans = m NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT d = 0 NEW_LINE for p in l : NEW_LINE INDENT if p > i : NEW_LINE INDENT d = d + int ( math . ceil ( p / float ( i ) ) ) - 1 NEW_LINE DEDENT DEDENT ans = min ( ans , d + i ) NEW_LINE DEDENT sys . stdout . write ( \" { } \\n \" . format ( ans ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "atcoder_ABC131_F", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } ArrayList < ArrayList < Integer > > g = new ArrayList < > ( ) ; int V = 100005 ; boolean used [ ] ; int cnt [ ] ; private void dfs ( int n ) { ArrayDeque < Integer > st = new ArrayDeque < > ( ) ; st . add ( n ) ; used [ n ] = true ; cnt [ n / V ] ++ ; while ( ! st . isEmpty ( ) ) { int s = st . pop ( ) ; ArrayList < Integer > l = g . get ( s ) ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { int t = l . get ( i ) ; if ( ! used [ t ] ) { used [ t ] = true ; cnt [ t / V ] ++ ; st . add ( t ) ; } } } } public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; for ( int i = 0 ; i < V * 2 ; i ++ ) g . add ( new ArrayList < > ( ) ) ; used = new boolean [ V * 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; y += V ; g . get ( x ) . add ( y ) ; g . get ( y ) . add ( x ) ; } long ans = 0 ; for ( int i = 0 ; i < V * 2 ; i ++ ) { if ( ! used [ i ] ) { used [ i ] = true ; cnt = new int [ 2 ] ; dfs ( i ) ; ans += ( long ) cnt [ 0 ] * cnt [ 1 ] ; } } ans -= n ; System . out . println ( ans ) ; sc . close ( ) ; } }", "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; Node [ ] nodes = new Node [ 200_001 ] ; for ( int i = 0 ; i < 200_001 ; i ++ ) nodes [ i ] = new Node ( i ) ; int N = scanner . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) + 100_000 ; nodes [ x ] . adjacents . add ( nodes [ y ] ) ; nodes [ y ] . adjacents . add ( nodes [ x ] ) ; } boolean [ ] visited = new boolean [ 200_001 ] ; long res = 0 ; for ( int i = 0 ; i < 200_001 ; i ++ ) { if ( ! visited [ i ] ) { Result result = new Result ( ) ; dfs ( nodes [ i ] , visited , result ) ; res += ( long ) result . nx * result . ny - result . m / 2 ; } } System . out . println ( res ) ; } private static void dfs ( Node node , boolean [ ] visited , Result result ) { visited [ node . id ] = true ; if ( node . id <= 100_000 ) result . nx ++ ; else result . ny ++ ; for ( Node n : node . adjacents ) { result . m ++ ; if ( ! visited [ n . id ] ) { dfs ( n , visited , result ) ; } } } private static class Result { int nx ; int ny ; int m ; } private static class Node { private final int id ; private List < Node > adjacents = new ArrayList < > ( ) ; public Node ( int id ) { this . id = id ; } } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE n = int ( input ( ) ) NEW_LINE xy = [ [ [ ] for _ in range ( 10 ** 5 + 1 ) ] for __ in range ( 2 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE xy [ 0 ] [ x ] . append ( y ) NEW_LINE xy [ 1 ] [ y ] . append ( x ) NEW_LINE DEDENT ans = 0 NEW_LINE used = [ [ False for _ in range ( 10 ** 5 + 1 ) ] for __ in range ( 2 ) ] NEW_LINE def dfs ( i , flag ) : NEW_LINE INDENT for v in xy [ flag ] [ i ] : NEW_LINE INDENT if not used [ 1 - flag ] [ v ] : NEW_LINE INDENT used [ 1 - flag ] [ v ] = True NEW_LINE dfs ( v , 1 - flag ) NEW_LINE count [ 1 - flag ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 10 ** 5 + 1 ) : NEW_LINE INDENT if xy [ 0 ] [ i ] and not used [ 0 ] [ i ] : NEW_LINE INDENT used [ 0 ] [ i ] = True NEW_LINE count = [ 1 , 0 ] NEW_LINE dfs ( i , 0 ) NEW_LINE ans += count [ 0 ] * count [ 1 ] NEW_LINE DEDENT DEDENT ans -= n NEW_LINE print ( ans ) NEW_LINE", "from collections import Counter NEW_LINE class UnionFind : NEW_LINE INDENT def __init__ ( self , size ) : NEW_LINE INDENT self . data = [ - 1 ] * size NEW_LINE DEDENT def find ( self , x ) : NEW_LINE INDENT if self . data [ x ] < 0 : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT self . data [ x ] = self . find ( self . data [ x ] ) NEW_LINE return self . data [ x ] NEW_LINE DEDENT DEDENT def union ( self , x , y ) : NEW_LINE INDENT x , y = self . find ( x ) , self . find ( y ) NEW_LINE if x != y : NEW_LINE INDENT if self . data [ y ] < self . data [ x ] : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT self . data [ x ] += self . data [ y ] NEW_LINE self . data [ y ] = x NEW_LINE DEDENT return ( x != y ) NEW_LINE DEDENT def same ( self , x , y ) : NEW_LINE INDENT return ( self . find ( x ) == self . find ( y ) ) NEW_LINE DEDENT def size ( self , x ) : NEW_LINE INDENT return - self . data [ self . find ( x ) ] NEW_LINE DEDENT DEDENT MAX = 10 ** 5 + 10 NEW_LINE uf = UnionFind ( 2 * MAX ) NEW_LINE N , * XY = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE for x , y in zip ( * [ iter ( XY ) ] * 2 ) : NEW_LINE INDENT uf . union ( x , y + MAX ) NEW_LINE DEDENT X = Counter ( uf . find ( i ) for i in range ( MAX ) ) NEW_LINE Y = Counter ( uf . find ( i ) for i in range ( MAX , MAX * 2 ) ) NEW_LINE res = sum ( X [ i ] * Y [ i ] for i in range ( MAX * 2 ) ) NEW_LINE print ( res - N ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE import copy NEW_LINE N = int ( input ( ) ) NEW_LINE P = [ list ( map ( int , input ( ) . split ( ) ) ) + [ i ] for i in range ( N ) ] NEW_LINE Q = copy . deepcopy ( P ) NEW_LINE Group = [ i for i in range ( N ) ] NEW_LINE def find ( x ) : NEW_LINE INDENT while Group [ x ] != x : NEW_LINE INDENT x = Group [ x ] NEW_LINE DEDENT return x NEW_LINE DEDENT def Union ( x , y ) : NEW_LINE INDENT if find ( x ) != find ( y ) : NEW_LINE INDENT Group [ find ( y ) ] = Group [ find ( x ) ] = min ( find ( y ) , find ( x ) ) NEW_LINE DEDENT DEDENT P . sort ( key = lambda x : x [ 0 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if P [ i ] [ 0 ] == P [ i - 1 ] [ 0 ] : NEW_LINE INDENT Union ( P [ i ] [ 2 ] , P [ i - 1 ] [ 2 ] ) NEW_LINE DEDENT DEDENT P . sort ( key = lambda x : x [ 1 ] ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if P [ i ] [ 1 ] == P [ i - 1 ] [ 1 ] : NEW_LINE INDENT Union ( P [ i ] [ 2 ] , P [ i - 1 ] [ 2 ] ) NEW_LINE DEDENT DEDENT B = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT B [ find ( i ) ] . append ( i ) NEW_LINE DEDENT ANS = 0 NEW_LINE for BEL in B : NEW_LINE INDENT X = [ ] NEW_LINE Y = [ ] NEW_LINE for b in BEL : NEW_LINE INDENT X . append ( Q [ b ] [ 0 ] ) NEW_LINE Y . append ( Q [ b ] [ 1 ] ) NEW_LINE DEDENT ANS += len ( set ( X ) ) * len ( set ( Y ) ) - len ( BEL ) NEW_LINE DEDENT print ( ANS ) NEW_LINE", "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def dfs ( G , F , crr , pre , ret , st ) : NEW_LINE INDENT F [ crr ] = False NEW_LINE if crr < 10 ** 5 : NEW_LINE INDENT ret [ 0 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ret [ 1 ] += 1 NEW_LINE DEDENT for nxt in G [ crr ] : NEW_LINE INDENT if nxt == pre : NEW_LINE INDENT continue NEW_LINE DEDENT p , q = crr , nxt NEW_LINE if q < p : NEW_LINE INDENT p , q = q , p NEW_LINE DEDENT if not ( p , q ) in st : NEW_LINE INDENT st . add ( ( p , q ) ) NEW_LINE ret [ 2 ] += 1 NEW_LINE DEDENT if F [ nxt ] : NEW_LINE INDENT dfs ( G , F , nxt , crr , ret , st ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE G = [ [ ] for _ in range ( 2 * 10 ** 5 ) ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = x - 1 , y - 1 + 10 ** 5 NEW_LINE G [ x ] . append ( y ) NEW_LINE G [ y ] . append ( x ) NEW_LINE DEDENT F = [ True ] * ( 2 * 10 ** 5 ) NEW_LINE ans = 0 NEW_LINE st = set ( ) NEW_LINE for i in range ( 2 * 10 ** 5 ) : NEW_LINE INDENT if F [ i ] and len ( G [ i ] ) > 0 : NEW_LINE INDENT tmp = [ 0 ] * 3 NEW_LINE dfs ( G , F , i , - 1 , tmp , st ) NEW_LINE ans += tmp [ 0 ] * tmp [ 1 ] - tmp [ 2 ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from collections import deque NEW_LINE N = int ( input ( ) ) NEW_LINE nmax = 2 * 10 ** 5 NEW_LINE nhalf = 10 ** 5 NEW_LINE G = [ [ ] for i in range ( nmax ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE G [ x - 1 ] . append ( nhalf + y - 1 ) NEW_LINE G [ nhalf + y - 1 ] . append ( x - 1 ) NEW_LINE DEDENT used = [ False ] * nmax NEW_LINE ans = 0 NEW_LINE for i in range ( nhalf ) : NEW_LINE INDENT if G [ i ] != [ ] and not used [ i ] : NEW_LINE INDENT cnt_1 = 0 NEW_LINE cnt_2 = 0 NEW_LINE q = deque ( [ i ] ) NEW_LINE used [ i ] = True NEW_LINE while len ( q ) > 0 : NEW_LINE INDENT a = q . popleft ( ) NEW_LINE if a < nhalf : NEW_LINE INDENT cnt_2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_1 += 1 NEW_LINE DEDENT Vs = G [ a ] NEW_LINE for u in Vs : NEW_LINE INDENT if not used [ u ] : NEW_LINE INDENT q . append ( u ) NEW_LINE used [ u ] = True NEW_LINE DEDENT DEDENT DEDENT ans += cnt_1 * cnt_2 NEW_LINE DEDENT DEDENT print ( ans - N ) NEW_LINE"]}
{"id": "geeksforgeeks_183_A", "java": ["class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 9 == 0 ) ; } public static void main ( String [ ] args ) { String str = \"99333\" ; if ( check ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT st = \"99333\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_185_A", "java": ["class IsDivisible { static boolean check ( String str ) { int n = str . length ( ) ; if ( ( str . charAt ( n - 1 ) - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str . charAt ( i ) - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void main ( String [ ] args ) { String str = \"1332\" ; if ( check ( str ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = \"1332\" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 \" ) NEW_LINE DEDENT"]}
{"id": "leetcode_784_A", "java": ["class Solution { public List < String > letterCasePermutation ( String S ) { List < StringBuilder > ans = new ArrayList ( ) ; ans . add ( new StringBuilder ( ) ) ; for ( char c : S . toCharArray ( ) ) { int n = ans . size ( ) ; if ( Character . isLetter ( c ) ) { for ( int i = 0 ; i < n ; ++ i ) { ans . add ( new StringBuilder ( ans . get ( i ) ) ) ; ans . get ( i ) . append ( Character . toLowerCase ( c ) ) ; ans . get ( n + i ) . append ( Character . toUpperCase ( c ) ) ; } } else { for ( int i = 0 ; i < n ; ++ i ) ans . get ( i ) . append ( c ) ; } } List < String > finalans = new ArrayList ( ) ; for ( StringBuilder sb : ans ) finalans . add ( sb . toString ( ) ) ; return finalans ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def letterCasePermutation ( self , S ) : NEW_LINE INDENT B = sum ( letter . isalpha ( ) for letter in S ) NEW_LINE ans = [ ] NEW_LINE for bits in xrange ( 1 << B ) : NEW_LINE INDENT b = 0 NEW_LINE word = [ ] NEW_LINE for letter in S : NEW_LINE INDENT if letter . isalpha ( ) : NEW_LINE INDENT if ( bits >> b ) & 1 : NEW_LINE INDENT word . append ( letter . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT word . append ( letter . upper ( ) ) NEW_LINE DEDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT word . append ( letter ) NEW_LINE DEDENT DEDENT ans . append ( \" \" . join ( word ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_913_A", "java": ["import java . util . * ; class Gfg { static int countDigits ( int n ) { return ( int ) ( n * Math . log10 ( 2 ) + 1 ) ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( countDigits ( n ) ) ; } }"], "python": ["import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countDigits ( n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_773_A", "java": ["class GFG { static boolean isPerfectSquare ( int N ) { double sr = Math . sqrt ( N ) ; return ( sr - Math . floor ( sr ) ) == 0 ; } static void BetrothedNumbers ( int n , int m ) { int Sum1 = 1 ; int Sum2 = 1 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Sum1 += i + ( isPerfectSquare ( n ) ? 0 : n / i ) ; } } for ( int i = 2 ; i <= Math . sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { Sum2 += i + ( isPerfectSquare ( m ) ? 0 : m / i ) ; } } if ( ( n + 1 == Sum2 ) && ( m + 1 == Sum1 ) ) { System . out . print ( \" YES \" + \" \\n \" ) ; } else { System . out . print ( \" NO \" + \" \\n \" ) ; } } public static void main ( String [ ] args ) { int N = 9504 ; int M = 20734 ; BetrothedNumbers ( N , M ) ; } }"], "python": ["from math import sqrt , floor NEW_LINE def isPerfectSquare ( N ) : NEW_LINE INDENT sr = sqrt ( N ) NEW_LINE return ( sr - floor ( sr ) ) == 0 NEW_LINE DEDENT def BetrothedNumbers ( n , m ) : NEW_LINE INDENT Sum1 = 1 NEW_LINE Sum2 = 1 NEW_LINE for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( n ) ) : NEW_LINE INDENT Sum1 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum1 += i + n / i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , int ( sqrt ( m ) ) + 1 , 1 ) : NEW_LINE INDENT if ( m % i == 0 ) : NEW_LINE INDENT if ( isPerfectSquare ( m ) ) : NEW_LINE INDENT Sum2 += i NEW_LINE DEDENT else : NEW_LINE INDENT Sum2 += i + ( m / i ) NEW_LINE DEDENT DEDENT DEDENT if ( ( n + 1 == Sum2 ) and ( m + 1 == Sum1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9504 NEW_LINE M = 20734 NEW_LINE BetrothedNumbers ( N , M ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p214_A", "java": ["public final class p214 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p214 ( ) . run ( ) ) ; } private static final int LIMIT = 40000000 ; public String run ( ) { int [ ] totient = Library . listTotients ( LIMIT - 1 ) ; int [ ] totientChainLength = new int [ totient . length ] ; totientChainLength [ 0 ] = 0 ; long sum = 0 ; for ( int i = 1 ; i < totient . length ; i ++ ) { int chainlen = totientChainLength [ totient [ i ] ] + 1 ; totientChainLength [ i ] = chainlen ; if ( chainlen == 25 && totient [ i ] == i - 1 ) sum += i ; } return Long . toString ( sum ) ; } }"], "python": ["import array NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = list_totients ( LIMIT - 1 ) NEW_LINE totientchainlen = array . array ( \" L \" , [ 0 , 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( totientchainlen ) , len ( totient ) ) : NEW_LINE INDENT chainlen = totientchainlen [ totient [ i ] ] + 1 NEW_LINE totientchainlen . append ( chainlen ) NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def list_totients ( n ) : NEW_LINE INDENT assert n < ( 1 << 32 ) NEW_LINE result = array . array ( \" L \" , range ( n + 1 ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if result [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT result [ j ] = result [ j ] // i * ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1466_B", "java": ["import java . util . * ; import java . io . * ; public class LastMinuteEnhancements { public static void main ( String [ ] args ) throws Exception { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; StringTokenizer st = new StringTokenizer ( in . readLine ( ) ) ; int t = Integer . parseInt ( st . nextToken ( ) ) ; for ( int i = 0 ; i < t ; i ++ ) { StringTokenizer st1 = new StringTokenizer ( in . readLine ( ) ) ; int n = Integer . parseInt ( st1 . nextToken ( ) ) ; StringTokenizer st2 = new StringTokenizer ( in . readLine ( ) ) ; int [ ] array = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { array [ j ] = Integer . parseInt ( st2 . nextToken ( ) ) ; } Arrays . sort ( array ) ; array [ n - 1 ] ++ ; int cnt = 1 ; for ( int k = n - 2 ; k >= 0 ; k -- ) { if ( array [ k ] + 1 < array [ k + 1 ] ) { cnt ++ ; array [ k ] ++ ; } else if ( array [ k ] != array [ k + 1 ] ) { cnt ++ ; } } out . println ( cnt ) ; } out . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class LastMinuteEnhancements { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( reader . readLine ( ) ) ; while ( t > 0 ) { int n = Integer . parseInt ( reader . readLine ( ) ) ; String [ ] data = reader . readLine ( ) . split ( \" \\\\ s + \" ) ; int [ ] nums = new int [ n ] ; Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = Integer . parseInt ( data [ i ] ) ; set . add ( nums [ i ] ) ; } Arrays . sort ( nums ) ; System . out . println ( new LastMinuteEnhancements ( ) . maxNotes ( nums , set ) ) ; t -- ; } } private int maxNotes ( int [ ] nums , Set < Integer > set ) { int n = nums . length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int temp = nums [ i ] + 1 ; if ( ! set . contains ( temp ) ) { set . add ( temp ) ; set . remove ( nums [ i ] ) ; } else set . add ( nums [ i ] ) ; } return set . size ( ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t -- > 0 ) { int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] str = br . readLine ( ) . split ( \" \u2581 \" ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( str [ i ] ) ; } HashSet < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = arr [ i ] ; if ( set . contains ( num ) ) { set . add ( num + 1 ) ; } else { set . add ( num ) ; } } System . out . println ( set . size ( ) ) ; } } }", "import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int N = in . nextInt ( ) ; int answer = 0 ; int last = 0 ; for ( int n = 0 ; n < N ; n ++ ) { int x = in . nextInt ( ) ; if ( last < x ) { last = x ; answer ++ ; } else if ( last == x ) { last = x + 1 ; answer ++ ; } } pw . println ( answer ) ; } pw . close ( ) ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE ans = 0 NEW_LINE b = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] in b ) == False : NEW_LINE INDENT ans += 1 NEW_LINE b . add ( a [ i ] ) NEW_LINE DEDENT elif ( a [ i ] + 1 in b ) == False : NEW_LINE INDENT ans += 1 NEW_LINE b . add ( a [ i ] + 1 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = set ( ) NEW_LINE num = map ( int , input ( ) . split ( ) ) NEW_LINE for j in num : NEW_LINE INDENT if j in s : NEW_LINE INDENT s . add ( j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . add ( j ) NEW_LINE DEDENT DEDENT print ( len ( s ) ) NEW_LINE DEDENT", "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT t = set ( ) ; NEW_LINE for x in map ( int , s . split ( ) ) : t |= { x + ( x in t ) } NEW_LINE print ( len ( t ) ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t = t - 1 NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE stack = [ ] NEW_LINE stack1 = [ 0 , 0 ] NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT check = 0 NEW_LINE ii = len ( a ) - i - 1 NEW_LINE if not stack1 : NEW_LINE INDENT stack1 . append ( a [ ii ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = a [ ii ] + 1 NEW_LINE if x != stack1 [ - 1 ] and x != stack1 [ - 2 ] : NEW_LINE INDENT stack1 . append ( x ) NEW_LINE DEDENT elif a [ ii ] != stack1 [ - 1 ] and a [ ii ] != stack1 [ - 2 ] : NEW_LINE INDENT stack1 . append ( a [ ii ] ) NEW_LINE DEDENT DEDENT DEDENT print ( len ( stack1 ) - 2 ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE notes = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE note_lst = set ( ) NEW_LINE diversity = 0 NEW_LINE for i in notes : NEW_LINE INDENT if i in note_lst : NEW_LINE INDENT if i + 1 not in note_lst : NEW_LINE INDENT note_lst . add ( i + 1 ) NEW_LINE diversity += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT note_lst . add ( i ) NEW_LINE diversity += 1 NEW_LINE DEDENT DEDENT print ( diversity ) NEW_LINE DEDENT"]}
{"id": "aizu_p00593_A", "java": ["import java . util . * ; class Main { static void solve ( int n ) { int [ ] [ ] jpeg = new int [ n ] [ n ] ; int x = 0 ; int y = 0 ; boolean ascending = true ; for ( int i = 1 ; i <= n * n ; i ++ ) { jpeg [ x ] [ y ] = i ; if ( ascending && y == 0 && x != n - 1 ) { x += 1 ; ascending = false ; } else if ( ( ! ascending ) && x == 0 && y != n - 1 ) { y += 1 ; ascending = true ; } else if ( ascending && x == n - 1 ) { y += 1 ; ascending = false ; } else if ( ( ! ascending ) && y == n - 1 ) { x += 1 ; ascending = true ; } else if ( ascending ) { x += 1 ; y -= 1 ; } else { x -= 1 ; y += 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . printf ( \" % 3d \" , jpeg [ j ] [ i ] ) ; } System . out . println ( \" \" ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int times = 1 ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; System . out . printf ( \" Case \u2581 % d : \\n \" , times ) ; solve ( n ) ; times += 1 ; } } }", "import java . util . Scanner ; public class Main { private static int C = 1 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; for ( int n = sc . nextInt ( ) ; n != 0 ; n = sc . nextInt ( ) ) solve ( n ) ; } private static void solve ( int n ) { int [ ] [ ] ns = new int [ n ] [ n ] ; int inc = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = i ; j >= 0 ; j -- ) { ns [ j ] [ i - j ] = inc ++ ; } } else { for ( int j = 0 ; j <= i ; j ++ ) { ns [ j ] [ i - j ] = inc ++ ; } } } for ( int i = n ; i < 2 * ( n - 1 ) + 1 ; i ++ ) { if ( i % 2 == 1 ) { for ( int j = i - n + 1 ; j < n ; j ++ ) { ns [ j ] [ i - j ] = inc ++ ; } } else { for ( int j = n - 1 ; j >= i - n + 1 ; j -- ) { ns [ j ] [ i - j ] = inc ++ ; } } } System . out . printf ( \" Case \u2581 % d : \\n \" , C ++ ) ; for ( int [ ] as : ns ) { for ( int a : as ) { System . out . printf ( \" % 3d \" , a ) ; } System . out . println ( ) ; } } }", "import java . util . Scanner ; public class Main { private static final Integer END_FLAG = Integer . valueOf ( 0 ) ; static Scanner in = new Scanner ( System . in ) ; static Integer nextValue ; public static void main ( String [ ] args ) { int caseNum = 0 ; do { int n = ( nextValue != null ) ? nextValue : in . nextInt ( ) ; printCase ( ++ caseNum ) ; int [ ] [ ] jpeg = new int [ n ] [ n ] ; int x = 0 ; final int lastX = n * n ; final int lastIndex = n - 1 ; int column = 0 , row = 0 ; int nextStartColumn = 0 , nextStartRow = 0 , d = 1 ; while ( x < lastX ) { column = nextStartColumn ; row = nextStartRow ; while ( 0 <= column && column < n && 0 <= row && row < n ) { jpeg [ column ] [ row ] = ++ x ; nextStartColumn = column ; nextStartRow = row ; column -= d ; row += d ; } if ( nextStartColumn == lastIndex || ( nextStartColumn == 0 && nextStartRow != lastIndex ) ) { nextStartRow ++ ; } else if ( nextStartRow == lastIndex || ( nextStartRow == 0 && nextStartColumn != lastIndex ) ) { nextStartColumn ++ ; } d = - d ; } for ( column = 0 ; column < n ; column ++ ) { for ( row = 0 ; row < n ; row ++ ) { System . out . printf ( \" % 3d \" , jpeg [ column ] [ row ] ) ; if ( row == lastIndex ) { System . out . println ( ) ; } } } nextValue = Integer . valueOf ( in . next ( ) ) ; } while ( ! nextValue . equals ( END_FLAG ) ) ; } private static void printCase ( int caseNum ) { System . out . print ( \" Case \u2581 \" ) ; System . out . print ( caseNum ) ; System . out . println ( ' : ' ) ; } }", "import java . util . * ; import static java . util . Arrays . * ; import static java . lang . Math . * ; public class Main { static int tc ; public static void main ( String [ ] args ) { for ( tc = 1 ; read ( ) ; tc ++ ) { solve ( ) ; } } static int N ; static Scanner sc = new Scanner ( System . in ) ; static boolean read ( ) { N = sc . nextInt ( ) ; if ( N == 0 ) return false ; return true ; } static void solve ( ) { int val = 1 ; int [ ] [ ] jpeg = new int [ 100 ] [ 100 ] ; jpeg [ 0 ] [ 0 ] = val ++ ; int m = 0 , x = 1 , y = 0 ; for ( int i = 1 ; i < N * 2 ; i ++ ) { if ( i < N - 1 ) { if ( i % 2 == 0 ) { for ( ; y >= 0 ; x ++ , y -- ) { jpeg [ y ] [ x ] = val ++ ; } } else { for ( ; x >= 0 ; x -- , y ++ ) { jpeg [ y ] [ x ] = val ++ ; } } } else { if ( i % 2 == 0 ) { for ( ; x < N ; x ++ , y -- ) { jpeg [ y ] [ x ] = val ++ ; } } else { for ( ; y < N ; x -- , y ++ ) { jpeg [ y ] [ x ] = val ++ ; } } } if ( i < N - 1 ) { if ( i % 2 == 0 ) { y ++ ; } else { x ++ ; } } else { if ( i % 2 == 0 ) { x -- ; y += 2 ; } else { x += 2 ; y -- ; } } } System . out . println ( \" Case \u2581 \" + tc + \" : \" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . printf ( \" % 3d \" , jpeg [ i ] [ j ] ) ; } System . out . println ( ) ; } } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; int input = Integer . parseInt ( reader . readLine ( ) ) ; int cases = 1 ; while ( input > 0 ) { int [ ] [ ] arr = new int [ input ] [ input ] ; int x = 0 , y = 0 ; int count = 1 ; boolean mode = false ; while ( x < input && y < input ) { arr [ x ] [ y ] = count ; if ( mode ) { x -- ; y ++ ; } else { y -- ; x ++ ; } if ( x >= input ) { x -- ; y ++ ; y ++ ; mode = ! mode ; } else if ( y >= input ) { y -- ; x ++ ; x ++ ; mode = ! mode ; } if ( x < 0 ) { x ++ ; mode = ! mode ; } else if ( y < 0 ) { y ++ ; mode = ! mode ; } count ++ ; } sb . append ( \" Case \u2581 \" + cases + \" : \\n \" ) ; for ( int i = 0 ; i < input ; i ++ ) { for ( int j = 0 ; j < input ; j ++ ) { sb . append ( String . format ( \" % 3d \" , arr [ j ] [ i ] ) ) ; } sb . append ( \" \\n \" ) ; } input = Integer . parseInt ( reader . readLine ( ) ) ; cases ++ ; } System . out . print ( sb . toString ( ) ) ; } }"], "python": ["case = 1 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT jpeg = [ [ 0 ] * n for _ in range ( n ) ] NEW_LINE n1 = n - 1 NEW_LINE px , cur = [ 0 , 0 ] , 1 NEW_LINE while px [ 0 ] < n : NEW_LINE INDENT i , j = px NEW_LINE jpeg [ i ] [ j ] = cur NEW_LINE odd = ( i + j ) % 2 NEW_LINE if px [ not odd ] == n1 : NEW_LINE INDENT px [ odd ] += 1 NEW_LINE DEDENT elif not px [ odd ] : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT px [ not odd ] += 1 NEW_LINE px [ odd ] -= 1 NEW_LINE DEDENT cur += 1 NEW_LINE DEDENT print ( ' Case \u2581 { } : ' . format ( case ) ) NEW_LINE for row in jpeg : NEW_LINE INDENT print ( ' ' . join ( ' { : > 3 } ' . format ( pixel ) for pixel in row ) ) NEW_LINE DEDENT case += 1 NEW_LINE DEDENT", "import sys NEW_LINE def p ( t ) : NEW_LINE INDENT for l in t : NEW_LINE INDENT for n in l : NEW_LINE INDENT print ( \" { 0 : > 3 } \" . format ( n ) , end = \" \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for n in sys . stdin : NEW_LINE INDENT n = int ( n ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT t = [ [ 0 for _ in range ( n ) ] for _ in range ( n ) ] NEW_LINE c += 1 NEW_LINE print ( \" Case \u2581 { } : \" . format ( c ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE up = True NEW_LINE for i in range ( 1 , n * n + 1 ) : NEW_LINE INDENT t [ y ] [ x ] = i NEW_LINE if up : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT if x < n - 1 : NEW_LINE INDENT x += 1 NEW_LINE up = False NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE up = False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x < n - 1 : NEW_LINE INDENT x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE up = False NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT if y < n - 1 : NEW_LINE INDENT y += 1 NEW_LINE up = True NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE up = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if y < n - 1 : NEW_LINE INDENT x -= 1 NEW_LINE y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE up = True NEW_LINE DEDENT DEDENT DEDENT DEDENT p ( t ) NEW_LINE DEDENT", "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT TC = 1 NEW_LINE while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT arr = [ [ 0 for _ in range ( N ) ] for _ in range ( N ) ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE val = 1 NEW_LINE prevMove = \" UR \" NEW_LINE while True : NEW_LINE INDENT arr [ i ] [ j ] = val NEW_LINE val += 1 NEW_LINE if i == N - 1 and j == N - 1 : NEW_LINE INDENT break NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT if prevMove == \" UR \" : NEW_LINE INDENT if j != N - 1 : NEW_LINE INDENT j += 1 NEW_LINE prevMove = \" R \" NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE prevMove = \" D \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE prevMove = \" DL \" NEW_LINE DEDENT DEDENT elif i == N - 1 : NEW_LINE INDENT if prevMove == \" DL \" : NEW_LINE INDENT j += 1 NEW_LINE prevMove = \" R \" NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE prevMove = \" UR \" NEW_LINE DEDENT DEDENT elif j == 0 : NEW_LINE INDENT if prevMove == \" DL \" : NEW_LINE INDENT i += 1 NEW_LINE prevMove = \" D \" NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE prevMove = \" UR \" NEW_LINE DEDENT DEDENT elif j == N - 1 : NEW_LINE INDENT if prevMove == \" UR \" : NEW_LINE INDENT i += 1 NEW_LINE prevMove = \" D \" NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE prevMove = \" DL \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if prevMove == \" DL \" : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" Case \u2581 { } : \" . format ( TC ) ) NEW_LINE TC += 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( \" { :3d } \" . format ( arr [ i ] [ j ] ) , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT", "t = 1 NEW_LINE while 1 : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( \" Case \u2581 % d : \" % t ) ; t += 1 NEW_LINE M = [ [ 0 ] * N for i in range ( N ) ] NEW_LINE c = 1 NEW_LINE for i in range ( 2 * N - 1 ) : NEW_LINE INDENT for j in range ( max ( i - N + 1 , 0 ) , min ( N , i + 1 ) ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT M [ i - j ] [ j ] = \" % 3d \" % c NEW_LINE DEDENT else : NEW_LINE INDENT M [ j ] [ i - j ] = \" % 3d \" % c NEW_LINE DEDENT c += 1 NEW_LINE DEDENT DEDENT for l in M : NEW_LINE INDENT print ( * l , sep = ' ' ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE from sys import stdin NEW_LINE input = stdin . readline NEW_LINE cno = 0 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE cno += 1 NEW_LINE a = [ [ 0 for j in range ( 12 ) ] for i in range ( 12 ) ] NEW_LINE m = k = f = 1 ; NEW_LINE while True : NEW_LINE INDENT if f : NEW_LINE INDENT for r in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT a [ r ] [ k - 1 - r ] = m NEW_LINE m += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for c in range ( k - 1 , - 1 , - 1 ) : NEW_LINE INDENT a [ k - 1 - c ] [ c ] = m NEW_LINE m += 1 NEW_LINE DEDENT DEDENT f = 1 - f NEW_LINE k += 1 NEW_LINE if k > n : break NEW_LINE DEDENT k = n - 1 NEW_LINE while True : NEW_LINE INDENT if f : NEW_LINE INDENT for c in range ( n - k , n ) : NEW_LINE INDENT a [ 2 * n - 1 - k - c ] [ c ] = m NEW_LINE m += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for r in range ( n - k , n ) : NEW_LINE INDENT a [ r ] [ 2 * n - 1 - k - r ] = m NEW_LINE m += 1 NEW_LINE DEDENT DEDENT f = 1 - f NEW_LINE k -= 1 NEW_LINE if k < 1 : break NEW_LINE DEDENT print ( \" Case \u2581 \" , cno , \" : \" , sep = ' ' ) NEW_LINE for r in range ( n ) : NEW_LINE INDENT for c in range ( n ) : print ( format ( a [ r ] [ c ] , \"3d \" ) , end = ' ' ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1189_B", "java": ["import java . util . * ; public class circle { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n , i , r , s ; long a [ ] ; n = sc . nextInt ( ) ; a = new long [ n ] ; PriorityQueue < Long > pq = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; for ( i = 0 ; i < n ; i ++ ) pq . add ( sc . nextLong ( ) ) ; r = 0 ; s = n - 1 ; i = 1 ; while ( r <= s && pq . size ( ) > 0 ) { if ( i % 2 == 1 ) a [ s -- ] = pq . poll ( ) ; else a [ r ++ ] = pq . poll ( ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( a [ 0 ] >= a [ 1 ] + a [ n - 1 ] ) break ; } else if ( i == n - 1 ) { if ( a [ n - 1 ] >= a [ 0 ] + a [ n - 2 ] ) break ; } else if ( a [ i ] >= a [ i - 1 ] + a [ i + 1 ] ) break ; } if ( i != n ) System . out . println ( \" NO \" ) ; else { System . out . println ( \" YES \" ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; } } }", "import java . util . * ; public class circle { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n , i , r , s ; long a [ ] ; n = sc . nextInt ( ) ; a = new long [ n ] ; PriorityQueue < Long > pq = new PriorityQueue < > ( Collections . reverseOrder ( ) ) ; for ( i = 0 ; i < n ; i ++ ) pq . add ( sc . nextLong ( ) ) ; r = 0 ; s = n - 1 ; i = 1 ; while ( r <= s && pq . size ( ) > 0 ) { if ( i % 2 == 1 ) a [ s -- ] = pq . poll ( ) ; else a [ r ++ ] = pq . poll ( ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( a [ 0 ] >= a [ 1 ] + a [ n - 1 ] ) break ; } else if ( i == n - 1 ) { if ( a [ n - 1 ] >= a [ 0 ] + a [ n - 2 ] ) break ; } else if ( a [ i ] >= a [ i - 1 ] + a [ i + 1 ] ) break ; } if ( i != n ) System . out . println ( \" NO \" ) ; else { System . out . println ( \" YES \" ) ; for ( i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + \" \u2581 \" ) ; } } }"], "python": ["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ n - 1 ] >= a [ n - 2 ] + a [ n - 3 ] : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( n - 1 , - 1 , - 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT for i in range ( n % 2 , n , 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l . sort ( ) NEW_LINE x = l [ - 1 ] NEW_LINE l . pop ( - 1 ) NEW_LINE g = - 2 NEW_LINE for i in range ( len ( l ) + 1 ) : NEW_LINE INDENT if ( l [ i - 1 ] + l [ ( i ) % len ( l ) ] ) > x : NEW_LINE INDENT if i > g : NEW_LINE INDENT g = i NEW_LINE DEDENT DEDENT DEDENT if g > - 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE l . insert ( g , x ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if a [ n - 1 ] >= a [ n - 2 ] + a [ n - 3 ] : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE for i in range ( n - 1 , - 1 , - 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT for i in range ( n % 2 , n , 2 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE if ( a [ - 3 ] + a [ - 2 ] > a [ - 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( * a [ : - 2 ] , * a [ - 2 : ] [ : : - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( reverse = True ) NEW_LINE a [ 0 ] , a [ 1 ] = a [ 1 ] , a [ 0 ] NEW_LINE ans = \" YES \" if a [ 1 ] < a [ 0 ] + a [ 2 ] else \" NO \" NEW_LINE print ( ans ) NEW_LINE if ans == \" YES \" : NEW_LINE INDENT sys . stdout . write ( \" \u2581 \" . join ( map ( str , a ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5085_A", "java": ["import java . io . * ; class GFG { static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; } static public void main ( String [ ] args ) { int [ ] arr = { 30 , 10 , 9 , 3 , 35 } ; int n = arr . length ; System . out . println ( findGreatest ( arr , n ) ) ; } }"], "python": ["def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 30 , 10 , 9 , 3 , 35 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5198_A", "java": ["import java . io . * ; class GFG { static int XorSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int k = 0 ; for ( int j = 1 ; j <= arr [ i ] ; j ++ ) k ^= arr [ i ] ; result += k ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( XorSum ( arr , n ) ) ; } }"], "python": ["def XorSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT k = k ^ arr [ i ] NEW_LINE DEDENT result = result + k NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( XorSum ( arr , n ) ) NEW_LINE"]}
{"id": "codeforces_1073_A", "java": ["import java . io . * ; import java . util . StringTokenizer ; public final class cp { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( \" \\n \" ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } void close ( ) throws IOException { br . close ( ) ; } } public static void main ( String [ ] args ) throws IOException { FastReader r = new FastReader ( ) ; PrintWriter w = new PrintWriter ( System . out , true ) ; int n = r . nextInt ( ) ; String str = r . next ( ) ; int max , j ; String res = \" \" ; int [ ] freq ; boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { max = Integer . MIN_VALUE ; freq = new int [ 26 ] ; for ( j = i ; j < n ; j ++ ) { int val = str . charAt ( j ) - ' a ' ; freq [ val ] ++ ; if ( freq [ val ] > max ) { max = freq [ val ] ; } if ( max <= ( j - i + 1 ) >> 1 ) { res = str . substring ( i , j + 1 ) ; flag = true ; break ; } } if ( flag ) break ; } w . println ( ( res . equals ( \" \" ) ? \" NO \" : \" YES \\n \" + res ) ) ; r . close ( ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; String s = sc . next ( ) ; int flag = 0 ; String ans = \" \" ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 1 ) ) { flag = 1 ; ans += s . charAt ( i ) ; ans += s . charAt ( i + 1 ) ; break ; } } if ( flag == 0 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; System . out . println ( ans ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; sc . nextInt ( ) ; String s = sc . next ( ) ; System . out . println ( solve ( s ) ) ; sc . close ( ) ; } static String solve ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + 1 ) ) { return String . format ( \" YES \\n % s \" , s . substring ( i , i + 2 ) ) ; } } return \" NO \" ; } }", "import java . util . * ; import java . io . * ; import static java . lang . Math . max ; import static java . lang . Math . min ; public class Codeforces { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { this . br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( this . st == null || ! this . st . hasMoreElements ( ) ) { try { this . st = new StringTokenizer ( this . br . readLine ( ) ) ; } catch ( IOException var2 ) { var2 . printStackTrace ( ) ; } } return this . st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( this . next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( this . next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( this . next ( ) ) ; } String nextLine ( ) { String var1 = \" \" ; try { if ( this . st . hasMoreTokens ( ) ) { var1 = this . st . nextToken ( \" \\n \" ) ; } else { var1 = this . br . readLine ( ) ; } } catch ( IOException var3 ) { var3 . printStackTrace ( ) ; } return var1 ; } } public static void main ( String [ ] args ) throws Exception { solve ( ) ; } public static void solve ( ) { FastReader in = new FastReader ( ) ; int n = in . nextInt ( ) ; String s = in . next ( ) ; boolean f = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i - 1 ) != s . charAt ( i ) ) { System . out . println ( \" YES \" ) ; System . out . println ( \" \" + s . charAt ( i - 1 ) + s . charAt ( i ) ) ; f = false ; break ; } } if ( f ) System . out . println ( \" NO \" ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( s [ i ] , s [ i + 1 ] , sep = \" \" ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT DEDENT print ( \" NO \" ) NEW_LINE", "def f ( n , s ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if s [ i ] != s [ i + 1 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( s [ i ] + s [ i + 1 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE f ( n , s ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE ans = None NEW_LINE ch = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != ch : NEW_LINE INDENT ans = ch + s [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT if ans == None : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( ans ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE found = False NEW_LINE for c1 , c2 in zip ( s [ : - 1 ] , s [ 1 : ] ) : NEW_LINE INDENT if c1 != c2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( c1 + c2 ) NEW_LINE found = True NEW_LINE break NEW_LINE DEDENT DEDENT if not found : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE cur_len = 1 NEW_LINE cur_str = s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i ] != s [ i - 1 ] : NEW_LINE INDENT cur_len += 1 NEW_LINE cur_str += s [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT cur_len = 1 NEW_LINE cur_str = s [ i ] NEW_LINE DEDENT if cur_len == 2 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE print ( cur_str ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2782_A", "java": ["public class GFG { static final int MAX = 256 ; static boolean compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; char [ ] countP = new char [ MAX ] ; char [ ] countTW = new char [ MAX ] ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat . charAt ( i ) ] ) ++ ; ( countTW [ txt . charAt ( i ) ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) System . out . println ( \" Found \u2581 at \u2581 Index \u2581 \" + ( i - M ) ) ; ( countTW [ txt . charAt ( i ) ] ) ++ ; countTW [ txt . charAt ( i - M ) ] -- ; } if ( compare ( countP , countTW ) ) System . out . println ( \" Found \u2581 at \u2581 Index \u2581 \" + ( N - M ) ) ; } public static void main ( String args [ ] ) { String txt = \" BACDGABCDA \" ; String pat = \" ABCD \" ; search ( pat , txt ) ; } }"], "python": ["MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT if arr1 [ i ] != arr2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE countP = [ 0 ] * MAX NEW_LINE countTW = [ 0 ] * MAX NEW_LINE for i in range ( M ) : NEW_LINE INDENT ( countP [ ord ( pat [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE DEDENT for i in range ( M , N ) : NEW_LINE INDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found \u2581 at \u2581 Index \" , ( i - M ) ) NEW_LINE DEDENT ( countTW [ ord ( txt [ i ] ) ] ) += 1 NEW_LINE ( countTW [ ord ( txt [ i - M ] ) ] ) -= 1 NEW_LINE DEDENT if compare ( countP , countTW ) : NEW_LINE INDENT print ( \" Found \u2581 at \u2581 Index \" , N - M ) NEW_LINE DEDENT DEDENT txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE search ( pat , txt ) NEW_LINE"]}
{"id": "atcoder_ARC071_B", "java": ["import java . util . Scanner ; public class Main { static int MOD = 1000000007 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; long xSum = 0 ; long ySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xSum = ( xSum + ( 2 * i - n + 1 ) * sc . nextLong ( ) ) % MOD ; } for ( int i = 0 ; i < m ; i ++ ) { ySum = ( ySum + ( 2 * i - m + 1 ) * sc . nextLong ( ) ) % MOD ; } System . out . println ( ( ( ( xSum * ySum ) % MOD ) + MOD ) % MOD ) ; } }", "import java . io . * ; import java . util . * ; class Main { static Scanner scanner = new Scanner ( ) ; static long mod = 1000000007 ; public static void main ( String [ ] $ ) { int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ m ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = scanner . nextInt ( ) ; if ( i > 0 ) { x [ i ] -= sum ; } sum += x [ i ] ; } sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { y [ i ] = scanner . nextInt ( ) ; if ( i > 0 ) { y [ i ] -= sum ; } sum += y [ i ] ; } long c = 0 ; for ( int i = 1 ; i < m ; i ++ ) { c = ( c + y [ i ] * i % mod * ( m - i ) % mod ) % mod ; } long ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ans + c * x [ i ] % mod * i % mod * ( n - i ) % mod ) % mod ; } System . out . println ( ans ) ; } static class Scanner { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) , 32768 ) ; StringTokenizer tokenizer ; String next ( ) { try { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return tokenizer . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }", "import java . util . * ; public final class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int m = s . nextInt ( ) ; long mod = 1000000000 + 7 ; long [ ] x = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = s . nextInt ( ) ; } long [ ] y = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { y [ i ] = s . nextInt ( ) ; } long sum_interval = 0 ; long before_inteval = 0 ; for ( int i = 1 ; i < m ; i ++ ) { long interval = y [ i ] - y [ i - 1 ] ; long now = before_inteval + ( interval * i ) % mod ; before_inteval = now ; sum_interval += now ; } sum_interval = sum_interval % mod ; long result = 0 ; long before_sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { long x1 = x [ i ] ; long x2 = x [ i - 1 ] ; long xint = x1 - x2 ; long now = xint * sum_interval ; long r = ( now % mod * i ) % mod + before_sum ; before_sum = r ; result += r ; } System . out . print ( result % mod ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] sa = br . readLine ( ) . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( sa [ 0 ] ) ; int m = Integer . parseInt ( sa [ 1 ] ) ; sa = br . readLine ( ) . split ( \" \u2581 \" ) ; long [ ] x = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = Integer . parseInt ( sa [ i ] ) ; } sa = br . readLine ( ) . split ( \" \u2581 \" ) ; long [ ] y = new long [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { y [ i ] = Integer . parseInt ( sa [ i ] ) ; } br . close ( ) ; int mod = 1000000007 ; long xx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xx += i * x [ i ] - ( n - i - 1 ) * x [ i ] ; xx %= mod ; } long yy = 0 ; for ( int i = 0 ; i < m ; i ++ ) { yy += i * y [ i ] - ( m - i - 1 ) * y [ i ] ; yy %= mod ; } long ans = xx * yy % mod ; if ( ans < 0 ) { ans += mod ; } System . out . println ( ans ) ; } }", "import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } long MODULO = 1_000_000_000 + 7 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ m ] ; for ( int i = 0 ; i < n ; ++ i ) { x [ i ] = sc . nextLong ( ) ; } for ( int j = 0 ; j < m ; ++ j ) { y [ j ] = sc . nextLong ( ) ; } System . out . println ( sum ( x ) * sum ( y ) % MODULO ) ; } long sum ( long [ ] arr ) { int n = arr . length ; long ret = 0 ; long s = 0 ; for ( long v : arr ) { s = ( s + v - arr [ 0 ] ) % MODULO ; } for ( int i = 0 ; i < arr . length ; ++ i ) { ret = ( ret + s ) % MODULO ; if ( i + 1 < arr . length ) s = ( s - ( n - 1 ) * ( arr [ i + 1 ] - arr [ i ] ) % MODULO + MODULO ) % MODULO ; -- n ; } return ret ; } void tr ( Object ... objects ) { System . out . println ( Arrays . deepToString ( objects ) ) ; } }"], "python": ["import sys NEW_LINE readline = sys . stdin . readline NEW_LINE N , M = map ( int , readline ( ) . split ( ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE N -= 1 NEW_LINE M -= 1 NEW_LINE X = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CX = [ x2 - x1 for x1 , x2 in zip ( X , X [ 1 : ] ) ] NEW_LINE CX = [ CX [ i ] * ( N - i ) * ( i + 1 ) for i in range ( N ) ] NEW_LINE Y = list ( map ( int , readline ( ) . split ( ) ) ) NEW_LINE CY = [ y2 - y1 for y1 , y2 in zip ( Y , Y [ 1 : ] ) ] NEW_LINE CY = [ CY [ j ] * ( M - j ) * ( j + 1 ) for j in range ( M ) ] NEW_LINE print ( sum ( CX ) % MOD * sum ( CY ) % MOD ) NEW_LINE", "def get_sum_line ( count , val_list ) : NEW_LINE INDENT len_list = len ( val_list ) NEW_LINE sum_line = 0 NEW_LINE for i in range ( len_list ) : NEW_LINE INDENT sum_line += val_list [ i ] * ( i - ( len_list - 1 - i ) ) NEW_LINE DEDENT return sum_line NEW_LINE DEDENT n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum_x_line = get_sum_line ( n , x_list ) NEW_LINE sum_y_line = get_sum_line ( m , y_list ) NEW_LINE ans = int ( sum_x_line * sum_y_line % ( 10 ** 9 + 7 ) ) NEW_LINE print ( ans ) NEW_LINE", "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE def sort ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE DEDENT def rev ( a ) : NEW_LINE INDENT a . reverse ( ) NEW_LINE DEDENT def sd ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def _sd ( ) : NEW_LINE INDENT return map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT def sa ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def ss ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def sf ( ) : NEW_LINE INDENT return float ( input ( ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , m = _sd ( ) NEW_LINE X = sa ( ) NEW_LINE Y = sa ( ) NEW_LINE sum_x = int ( 0 ) NEW_LINE sum_y = int ( 0 ) NEW_LINE mod = int ( ( 1e+9 ) + 7 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum_x += ( i + i - n - 1 ) * X [ i - 1 ] NEW_LINE sum_x %= mod NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT sum_y += ( i + i - m - 1 ) * Y [ i - 1 ] NEW_LINE sum_y %= mod NEW_LINE DEDENT print ( ( sum_x * sum_y ) % mod ) NEW_LINE DEDENT main ( ) NEW_LINE", "mod = 10 ** 9 + 7 NEW_LINE def sum_subarrays ( A ) : NEW_LINE INDENT N = len ( A ) NEW_LINE S = [ 0 ] NEW_LINE for a in A : NEW_LINE INDENT S . append ( S [ - 1 ] + a ) NEW_LINE S [ - 1 ] %= mod NEW_LINE DEDENT return sum ( ( 2 * i - N - 1 ) * s % mod for i , s in enumerate ( S ) ) % mod NEW_LINE DEDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Y = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE diff_X = [ X [ i + 1 ] - X [ i ] for i in range ( N ) ] NEW_LINE diff_Y = [ Y [ i + 1 ] - Y [ i ] for i in range ( M ) ] NEW_LINE print ( sum_subarrays ( diff_X ) * sum_subarrays ( diff_Y ) % mod ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE x = map ( int , input ( ) . split ( ) ) NEW_LINE y = map ( int , input ( ) . split ( ) ) NEW_LINE x = list ( x ) NEW_LINE y = list ( y ) NEW_LINE x . sort ( ) NEW_LINE y . sort ( ) NEW_LINE M = 10 ** 9 + 7 NEW_LINE a = sum ( [ ( 2 * k - n + 1 ) * x [ k ] for k in range ( n ) ] ) NEW_LINE b = sum ( [ ( 2 * k - m + 1 ) * y [ k ] for k in range ( m ) ] ) NEW_LINE a %= M NEW_LINE b %= M NEW_LINE res = a * b % M NEW_LINE print ( res ) NEW_LINE"]}
{"id": "codeforces_553_B", "java": ["import java . io . PrintWriter ; import java . util . Scanner ; public class PermutationFinder { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out , true ) ; int N = in . nextInt ( ) ; long K = in . nextLong ( ) ; long [ ] fib = new long [ N + 1 ] ; fib [ 0 ] = fib [ 1 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int idx = 0 ; int [ ] res = new int [ N ] ; while ( idx < N ) { if ( K <= fib [ N - idx - 1 ] ) { res [ idx ] = idx + 1 ; idx ++ ; } else { K -= fib [ N - idx - 1 ] ; res [ idx ] = idx + 2 ; res [ idx + 1 ] = idx + 1 ; idx += 2 ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) out . print ( \" \u2581 \" ) ; out . print ( res [ i ] ) ; } out . println ( ) ; out . close ( ) ; System . exit ( 0 ) ; } }", "import java . util . * ; import java . io . * ; import java . math . * ; public class Solution { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; long k = Long . parseLong ( st . nextToken ( ) ) ; if ( n == 1 ) out . println ( \"1\" ) ; else { long [ ] tab = new long [ n ] ; tab [ 0 ] = ( long ) 0 ; tab [ 1 ] = ( long ) 0 ; for ( int i = 2 ; i < n ; i ++ ) { tab [ i ] = tab [ i - 1 ] ; tab [ i ] += tab [ i - 2 ] + ( long ) 1 ; } int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long cnt = tab [ n - i - 1 ] + 1 ; if ( cnt < k ) { k -= cnt ; int d = a [ i ] ; a [ i ] = a [ i + 1 ] ; a [ i + 1 ] = d ; i ++ ; if ( k == 1 ) break ; continue ; } if ( k == 1 ) break ; } for ( int i = 0 ; i < n - 1 ; i ++ ) out . print ( a [ i ] + \" \u2581 \" ) ; out . println ( a [ n - 1 ] ) ; } out . flush ( ) ; } }", "import java . io . * ; import java . util . * ; public class CF553B extends PrintWriter { CF553B ( ) { super ( System . out , true ) ; } Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] $ ) { CF553B o = new CF553B ( ) ; o . main ( ) ; o . flush ( ) ; } void main ( ) { int n = sc . nextInt ( ) ; long k = sc . nextLong ( ) ; long [ ] ff = new long [ n + 1 ] ; ff [ 0 ] = ff [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ff [ i ] = ff [ i - 2 ] + ff [ i - 1 ] ; int a = 0 ; while ( n > 0 ) if ( k <= ff [ n - 1 ] ) { print ( ( a + 1 ) + \" \u2581 \" ) ; a ++ ; n -- ; } else { k -= ff [ n - 1 ] ; print ( ( a + 2 ) + \" \u2581 \" + ( a + 1 ) + \" \u2581 \" ) ; a += 2 ; n -= 2 ; } println ( ) ; } }"], "python": ["fib = [ 0 , 1 , 1 ] NEW_LINE for i in range ( 3 , 51 ) : NEW_LINE INDENT fib . append ( fib [ - 1 ] + fib [ - 2 ] ) NEW_LINE DEDENT for i in range ( 1 , 51 ) : NEW_LINE INDENT fib [ i ] += fib [ i - 1 ] NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE left = m NEW_LINE last = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ans [ i ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT size = n - j NEW_LINE if size == 1 : NEW_LINE INDENT perms = 1 NEW_LINE DEDENT else : NEW_LINE INDENT perms = fib [ size - 1 ] + 1 NEW_LINE DEDENT if perms >= left : NEW_LINE INDENT ans [ i ] = j NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT left -= perms NEW_LINE DEDENT DEDENT nlast = ans [ i ] NEW_LINE t = i + 1 NEW_LINE while ( t < n and ans [ t - 1 ] != last + 1 ) : NEW_LINE INDENT ans [ t ] = ans [ t - 1 ] - 1 NEW_LINE t += 1 NEW_LINE DEDENT last = nlast NEW_LINE DEDENT print ( * ans ) NEW_LINE", "def rint ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def rints ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT n , k = rints ( ) NEW_LINE pos = [ 0 ] * ( n + 1 ) NEW_LINE pos [ 0 ] = 1 NEW_LINE pos [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT pos [ i ] = pos [ i - 1 ] + pos [ i - 2 ] NEW_LINE DEDENT perm = list ( range ( 1 , n + 1 ) ) NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if pos [ n - i - 1 ] < k : NEW_LINE INDENT perm [ i ] += 1 NEW_LINE perm [ i + 1 ] -= 1 NEW_LINE k -= pos [ n - i - 1 ] NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , perm ) ) ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 for i in range ( n + 1 ) ] NEW_LINE a [ 0 ] , a [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + a [ i - 2 ] NEW_LINE DEDENT p = [ i + 1 for i in range ( n ) ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if k > a [ n - 1 - i ] : NEW_LINE INDENT p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] NEW_LINE k -= a [ n - 1 - i ] NEW_LINE i += 2 NEW_LINE DEDENT else : i += 1 NEW_LINE DEDENT p = [ str ( i ) for i in p ] NEW_LINE print ( ' \u2581 ' . join ( p ) ) NEW_LINE", "from typing import List NEW_LINE def find_kth_permutation ( n : int , k : int ) -> List [ int ] : NEW_LINE INDENT fib = [ 0 ] * ( n + 1 ) NEW_LINE fib [ 0 ] = fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT idx = 0 NEW_LINE res = [ 0 ] * n NEW_LINE while idx < n : NEW_LINE INDENT if k <= fib [ n - idx - 1 ] : NEW_LINE INDENT res [ idx ] = idx + 1 NEW_LINE idx += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= fib [ n - idx - 1 ] NEW_LINE res [ idx ] = idx + 2 NEW_LINE res [ idx + 1 ] = idx + 1 NEW_LINE idx += 2 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE r = find_kth_permutation ( n , k ) NEW_LINE print ( * r ) NEW_LINE"]}
{"id": "codeforces_46_B", "java": ["import java . util . ArrayList ; import java . util . LinkedHashMap ; import java . util . Scanner ; public class B46 { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; LinkedHashMap < String , Integer > n = new LinkedHashMap < String , Integer > ( ) ; n . put ( \" S \" , sc . nextInt ( ) ) ; n . put ( \" M \" , sc . nextInt ( ) ) ; n . put ( \" L \" , sc . nextInt ( ) ) ; n . put ( \" XL \" , sc . nextInt ( ) ) ; n . put ( \" XXL \" , sc . nextInt ( ) ) ; int k = sc . nextInt ( ) ; for ( int i = 0 ; i < k ; i ++ ) { String size = sc . next ( ) ; if ( n . get ( size ) > 0 ) { System . out . println ( size ) ; n . put ( size , n . get ( size ) - 1 ) ; } else { ArrayList < String > keys = new ArrayList < String > ( n . keySet ( ) ) ; boolean found = false ; int ind = 0 ; int d = 1 ; while ( true ) { ind = keys . indexOf ( size ) + d ; if ( ind < keys . size ( ) ) { if ( n . get ( keys . get ( ind ) ) > 0 ) { System . out . println ( keys . get ( ind ) ) ; n . put ( keys . get ( ind ) , n . get ( keys . get ( ind ) ) - 1 ) ; found = true ; break ; } } if ( ! found && keys . indexOf ( size ) - d >= 0 ) { ind = keys . indexOf ( size ) - d ; if ( n . get ( keys . get ( ind ) ) > 0 ) { System . out . println ( keys . get ( ind ) ) ; n . put ( keys . get ( ind ) , n . get ( keys . get ( ind ) ) - 1 ) ; break ; } } d ++ ; } } } } }", "import java . util . * ; public class Main1 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T [ ] = new int [ 5 ] ; String str [ ] = { \" S \" , \" M \" , \" L \" , \" XL \" , \" XXL \" } ; for ( int i = 0 ; i < 5 ; i ++ ) { T [ i ] = sc . nextInt ( ) ; } int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; int sum = 0 ; if ( s . equals ( \" S \" ) ) sum = 0 ; else if ( s . equals ( \" M \" ) ) sum = 1 ; else if ( s . equals ( \" L \" ) ) sum = 2 ; else if ( s . equals ( \" XL \" ) ) sum = 3 ; else if ( s . equals ( \" XXL \" ) ) sum = 4 ; if ( T [ sum ] > 0 ) { System . out . println ( str [ sum ] ) ; T [ sum ] -- ; } else { int step = 1 , left = 1 , right = 1 ; while ( true ) { if ( step == 1 ) { if ( sum + right < 5 && T [ sum + right ] > 0 ) { System . out . println ( str [ sum + right ] ) ; T [ sum + right ] -- ; break ; } else { step = 2 ; right ++ ; } } else { if ( sum - left >= 0 && T [ sum - left ] > 0 ) { System . out . println ( str [ sum - left ] ) ; T [ sum - left ] -- ; break ; } else { step = 1 ; left ++ ; } } } } } } }"], "python": ["size = [ ' S ' , ' M ' , ' L ' , ' XL ' , ' XXL ' ] NEW_LINE n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k = int ( input ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT w = size . index ( input ( ) ) NEW_LINE fit = [ size [ w ] ] NEW_LINE x = 1 NEW_LINE while x < 5 : NEW_LINE INDENT if w + x < 5 : NEW_LINE INDENT fit . append ( size [ w + x ] ) NEW_LINE DEDENT if w - x >= 0 : NEW_LINE INDENT fit . append ( size [ w - x ] ) NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT for e in fit : NEW_LINE INDENT if n [ size . index ( e ) ] : NEW_LINE INDENT n [ size . index ( e ) ] -= 1 NEW_LINE print ( e ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE D = { ' S ' : 0 , ' M ' : 1 , ' L ' : 2 , ' XL ' : 3 , ' XXL ' : 4 } NEW_LINE L = { 0 : ' S ' , 1 : ' M ' , 2 : ' L ' , 3 : ' XL ' , 4 : ' XXL ' } NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) [ : - 1 ] NEW_LINE if w [ D [ s ] ] > 0 : NEW_LINE INDENT w [ D [ s ] ] -= 1 NEW_LINE print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT if D [ s ] + i <= 4 : NEW_LINE INDENT if w [ D [ s ] + i ] > 0 : NEW_LINE INDENT w [ D [ s ] + i ] -= 1 NEW_LINE print ( L [ D [ s ] + i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT if D [ s ] - i >= 0 : NEW_LINE INDENT if w [ D [ s ] - i ] > 0 : NEW_LINE INDENT w [ D [ s ] - i ] -= 1 NEW_LINE print ( L [ D [ s ] - i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT", "def main ( ) : NEW_LINE INDENT sizes = [ [ ' S ' , 0 ] , [ ' M ' , 0 ] , [ ' L ' , 0 ] , [ ' XL ' , 0 ] , [ ' XXL ' , 0 ] ] NEW_LINE arr = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE index = 0 NEW_LINE for k in sizes : NEW_LINE INDENT k [ 1 ] = arr [ index ] NEW_LINE index += 1 NEW_LINE DEDENT arr_s = [ 0 , 1 , 2 , 3 , 4 ] NEW_LINE arr_m = [ 1 , 2 , 0 , 3 , 4 ] NEW_LINE arr_l = [ 2 , 3 , 1 , 4 , 0 ] NEW_LINE arr_xl = [ 3 , 4 , 2 , 1 , 0 ] NEW_LINE arr_xxl = [ 4 , 3 , 2 , 1 , 0 ] NEW_LINE n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = input ( ) NEW_LINE if x == ' S ' : NEW_LINE INDENT for j in arr_s : NEW_LINE INDENT if sizes [ j ] [ 1 ] > 0 : NEW_LINE INDENT sizes [ j ] [ 1 ] -= 1 NEW_LINE print ( sizes [ j ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if x == ' M ' : NEW_LINE INDENT for j in arr_m : NEW_LINE INDENT if sizes [ j ] [ 1 ] > 0 : NEW_LINE INDENT sizes [ j ] [ 1 ] -= 1 NEW_LINE print ( sizes [ j ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if x == ' L ' : NEW_LINE INDENT for j in arr_l : NEW_LINE INDENT if sizes [ j ] [ 1 ] > 0 : NEW_LINE INDENT sizes [ j ] [ 1 ] -= 1 NEW_LINE print ( sizes [ j ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if x == ' XL ' : NEW_LINE INDENT for j in arr_xl : NEW_LINE INDENT if sizes [ j ] [ 1 ] > 0 : NEW_LINE INDENT sizes [ j ] [ 1 ] -= 1 NEW_LINE print ( sizes [ j ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if x == ' XXL ' : NEW_LINE INDENT for j in arr_xxl : NEW_LINE INDENT if sizes [ j ] [ 1 ] > 0 : NEW_LINE INDENT sizes [ j ] [ 1 ] -= 1 NEW_LINE print ( sizes [ j ] [ 0 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = { ' S ' : 0 , ' M ' : 1 , ' L ' : 2 , ' XL ' : 3 , ' XXL ' : 4 } NEW_LINE b = [ ' S ' , ' M ' , ' L ' , ' XL ' , ' XXL ' ] NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT c = a [ input ( ) ] NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT if c + i < 5 and n [ c + i ] > 0 : NEW_LINE INDENT print ( b [ c + i ] ) NEW_LINE n [ c + i ] -= 1 NEW_LINE break NEW_LINE DEDENT elif c - i >= 0 and n [ c - i ] > 0 : NEW_LINE INDENT print ( b [ c - i ] ) NEW_LINE n [ c - i ] -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "codeforces_1445_A", "java": ["import java . util . * ; public class ArrayRearrangment { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q = sc . nextInt ( ) ; while ( q -- > 0 ) { int n = sc . nextInt ( ) , x = sc . nextInt ( ) , flag = 0 ; List < Integer > list = new ArrayList < > ( ) ; List < Integer > list1 = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { list . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { list1 . add ( sc . nextInt ( ) ) ; } Collections . sort ( list ) ; Collections . reverse ( list1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( list . get ( i ) + list1 . get ( i ) > x ) { flag = 1 ; break ; } } if ( flag == 1 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; } } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int testCases = scanner . nextInt ( ) ; for ( int i = 0 ; i < testCases ; i ++ ) { int len = scanner . nextInt ( ) ; int x = scanner . nextInt ( ) ; int [ ] a = new int [ len ] ; int [ ] b = new int [ len ] ; for ( int j = 0 ; j < a . length ; j ++ ) { a [ j ] = scanner . nextInt ( ) ; } for ( int j = 0 ; j < b . length ; j ++ ) { b [ j ] = scanner . nextInt ( ) ; } int tmp ; for ( int k = 0 ; k < len ; k ++ ) { for ( int l = k ; l < len ; l ++ ) { if ( a [ k ] <= x ) { tmp = b [ k ] ; b [ k ] = b [ l ] ; b [ l ] = tmp ; } } } boolean flag = true ; for ( int z = 0 ; z < len ; z ++ ) { if ( a [ z ] + b [ z ] > x ) { flag = false ; break ; } } if ( flag ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } } }"], "python": ["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) NEW_LINE if _ != t - 1 : NEW_LINE INDENT input ( ) NEW_LINE DEDENT flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT print ( ' YES ' if flag else ' NO ' ) NEW_LINE DEDENT", "def solve ( ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b . sort ( reverse = True ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE if _ != t - 1 : NEW_LINE INDENT c = input ( ) NEW_LINE DEDENT DEDENT", "f = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s = f ( ) [ 0 ] NEW_LINE for i in range ( s ) : NEW_LINE INDENT n , x = f ( ) NEW_LINE a = sorted ( f ( ) ) NEW_LINE b = sorted ( f ( ) ) [ : : - 1 ] NEW_LINE l = [ z + y for z , y in zip ( a , b ) ] NEW_LINE print ( \" YNEOS \" [ max ( l ) > x : : 2 ] ) NEW_LINE if i != s - 1 : input ( ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT t -= 1 NEW_LINE n , x = ( int ( _ ) for _ in input ( ) . strip ( ) . split ( ' \u2581 ' ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE if t != 0 : NEW_LINE INDENT s = input ( ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( reverse = True ) NEW_LINE k = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > x : NEW_LINE INDENT k = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for j in range ( t ) : NEW_LINE INDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] NEW_LINE if j != t - 1 : NEW_LINE INDENT z = input ( ) NEW_LINE DEDENT ans = ' Yes ' NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] + b [ i ] > s : NEW_LINE INDENT ans = ' No ' NEW_LINE break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5042_A", "java": ["class GFG { public static int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( solve ( n ) ) ; } }"], "python": ["def solve ( n ) : NEW_LINE INDENT ans = ( n * n // 4 ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1574_A", "java": ["import java . util . * ; public class A { public static void main ( String args [ ] ) { Scanner Sc = new Scanner ( System . in ) ; int t = Sc . nextInt ( ) ; while ( t -- > 0 ) { int n = Sc . nextInt ( ) ; int size = 2 * n ; counter = 0 ; helper ( \" ( \" , 1 , 0 , size , n ) ; } } static int counter ; static void helper ( String str , int o , int c , int size , int n ) { if ( counter == n ) return ; if ( o > n || c > n ) return ; if ( o == c && ( o + c ) == size ) { counter ++ ; System . out . println ( str ) ; return ; } helper ( str + ' ( ' , o + 1 , c , size , n ) ; helper ( str + ' ) ' , o , c + 1 , size , n ) ; } }", "import java . util . * ; public class A1574 { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int tt = 0 ; tt < t ; tt ++ ) { int n = input . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 2 * n - 1 ; j ++ ) { if ( j < n ) { System . out . print ( \" ( \" ) ; } else { System . out . print ( \" ) \" ) ; } if ( j == i ) { System . out . print ( \" ) \" ) ; } } System . out . println ( ) ; } } } }"], "python": ["def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE w = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT w . append ( \" ( \" * ( n - i ) + \" ) \" * ( n - i ) + \" ( ) \" * i ) NEW_LINE DEDENT return \" \\n \" . join ( w ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( \" \\n \" . join ( ans ) ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( \" ( ) \" * j + \" ( \" * ( n - j ) + \" ) \" * ( n - j ) ) NEW_LINE DEDENT DEDENT", "iteraciones = int ( input ( ) ) NEW_LINE for _ in range ( iteraciones ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE str = \" ( \" * n + \" ) \" * ( n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str [ 0 : i + 1 ] + \" ) \" + str [ i + 1 : ] ) NEW_LINE DEDENT DEDENT", "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ' ( ' * i + ' ( ) ' * ( N - i ) + ' ) ' * i ) NEW_LINE DEDENT DEDENT", "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ' ( ' * i + ' ( ) ' * ( N - i ) + ' ) ' * i ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_4285_A", "java": ["class GFG { public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) System . out . println ( \" Valid \u2581 quadilateral \" ) ; else System . out . println ( \" Invalid \u2581 quadilateral \" ) ; } }"], "python": ["def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( \" Valid \u2581 quadilateral \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \u2581 quadilateral \" ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_140_A", "java": ["import java . util . Scanner ; public class Solution20200410 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; double R = scanner . nextDouble ( ) ; double r = scanner . nextDouble ( ) ; double angle = 360.0 / ( n * 2 ) ; double minR = r / Math . sin ( Math . toRadians ( angle ) ) + r ; if ( n == 1 ) { if ( R >= r ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else if ( n == 2 ) { if ( R >= r * 2 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( R >= minR ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }", "import java . util . Scanner ; public class Test10 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int dishCount = sc . nextInt ( ) ; int desk = sc . nextInt ( ) ; int dishR = sc . nextInt ( ) ; double angle = 360.0 / ( dishCount * 2 ) ; double minR = dishR / Math . sin ( Math . toRadians ( angle ) ) + dishR ; if ( dishCount == 1 ) { if ( desk >= dishR ) { System . out . println ( \" YES \" ) ; return ; } else { System . out . println ( \" NO \" ) ; return ; } } if ( dishCount == 2 ) { if ( 2 * dishR <= desk ) { System . out . println ( \" YES \" ) ; return ; } else { System . out . println ( \" NO \" ) ; return ; } } if ( desk >= minR ) { System . out . println ( \" YES \" ) ; return ; } else { System . out . println ( \" NO \" ) ; return ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { private static class InputReader { private BufferedReader br = null ; private StringTokenizer tokenizer = null ; public InputReader ( InputStream is ) { super ( ) ; this . br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public String nextLine ( ) { try { return br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw new RuntimeException ( e ) ; } } public String next ( ) { for ( ; tokenizer == null || ! tokenizer . hasMoreTokens ( ) ; ) { tokenizer = new StringTokenizer ( nextLine ( ) ) ; } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } public static void main ( String [ ] args ) { InputReader in = new InputReader ( System . in ) ; int n = in . nextInt ( ) ; double R = in . nextDouble ( ) ; double r = in . nextDouble ( ) ; if ( n > 1 ) { if ( R >= r / Math . sin ( Math . toRadians ( 360.0 / n / 2 ) ) + r ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } else { if ( R >= r || n <= 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }", "import java . util . Scanner ; public class Test3 { public static void main ( String [ ] args ) { int n ; double R , r ; double eps = 1e-10 ; double PI = Math . acos ( - 1 ) ; Scanner in = new Scanner ( System . in ) ; while ( in . hasNext ( ) ) { n = in . nextInt ( ) ; R = in . nextInt ( ) ; r = in . nextInt ( ) ; if ( n == 1 ) { if ( R >= r ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; continue ; } double tmp = Math . asin ( r / ( R - r ) ) ; if ( PI / tmp - n > - eps ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } } }", "import java . util . Scanner ; public class ProblemK { public static int n ; public static int R ; public static int r ; public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; n = input . nextInt ( ) ; R = input . nextInt ( ) ; r = input . nextInt ( ) ; if ( n == 1 ) { System . out . println ( r <= R ? \" YES \" : \" NO \" ) ; } else if ( n == 2 ) { System . out . println ( r * 2 <= R ? \" YES \" : \" NO \" ) ; } else { double x = Math . PI / n ; double r1 = R * Math . sin ( x ) / ( 1 + Math . sin ( x ) ) ; System . out . println ( r <= r1 + 0.000000001 ? \" YES \" : \" NO \" ) ; } } }"], "python": ["import math NEW_LINE n , R , r = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT if r <= R : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT lhs = 2 * r * r / ( 1 - math . cos ( 2 * math . pi / n ) ) NEW_LINE rhs = ( R - r ) * ( R - r ) NEW_LINE if float ( ' % .9f ' % lhs ) <= rhs : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE number_of_plates , radius_of_table , radius_of_plate = map ( int , input ( ) . split ( ) ) NEW_LINE radius_of_plate = float ( radius_of_plate ) NEW_LINE radius_of_table = float ( radius_of_table ) NEW_LINE if number_of_plates == 1 and radius_of_plate <= radius_of_table : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT elif radius_of_table < radius_of_plate : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( radius_of_table - radius_of_plate ) * math . sin ( math . pi / number_of_plates ) > radius_of_plate - 1.0e-9 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE from bisect import bisect_left as lb , bisect_right as rb NEW_LINE from collections import * NEW_LINE from math import gcd , pi , sin NEW_LINE input_ = lambda : sys . stdin . readline ( ) . strip ( \" \\n \" ) NEW_LINE ii = lambda : int ( input_ ( ) ) NEW_LINE il = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) NEW_LINE ilf = lambda : list ( map ( float , input_ ( ) . split ( ) ) ) NEW_LINE lii = lambda : list ( map ( int , list ( ip ( ) ) ) ) NEW_LINE ip = lambda : input_ ( ) NEW_LINE f = lambda : sys . stdout . flush ( ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE n , R , r = il ( ) NEW_LINE if ( n == 1 and R >= r ) or ( R >= r + r / sin ( pi / n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "import math NEW_LINE n , R , r = map ( int , input ( ) . split ( ) ) NEW_LINE if ( r > R ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT elif ( r > R / 2 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s = math . asin ( r / ( R - r ) ) * 2 NEW_LINE if ( s * n < 2 * math . pi or abs ( s * n - 2 * math . pi ) < 0.000000001 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , R , r = map ( int , input ( ) . split ( ) ) NEW_LINE if R < r : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT elif r > R / 2 : NEW_LINE INDENT print ( ' YES ' if n == 1 else ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT from math import asin , pi NEW_LINE a = 2 * asin ( r / ( R - r ) ) NEW_LINE print ( ' YES ' if 2 * pi / a - n >= - 1e-8 else ' NO ' ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC142_E", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) , M = sc . nextInt ( ) ; int key [ ] [ ] = new int [ M ] [ 2 ] ; for ( int i = 0 ; i < M ; i ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) ; int s = 0 ; for ( int j = 0 ; j < b ; j ++ ) { int c = sc . nextInt ( ) - 1 ; s |= 1 << c ; } key [ i ] [ 0 ] = s ; key [ i ] [ 1 ] = a ; } sc . close ( ) ; int dp [ ] = new int [ 1 << N ] ; int INF = Integer . MAX_VALUE / 2 ; Arrays . fill ( dp , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int keyOpenNum = key [ j ] [ 0 ] ; int keyCost = key [ j ] [ 1 ] ; int nextOpenNum = i | keyOpenNum ; dp [ nextOpenNum ] = Math . min ( dp [ nextOpenNum ] , dp [ i ] + keyCost ) ; } } int ans = ( dp [ ( 1 << N ) - 1 ] == INF ) ? - 1 : dp [ ( 1 << N ) - 1 ] ; System . out . println ( ans ) ; } }", "import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Scanner ; import java . util . Set ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scan = new Scanner ( System . in ) ) { int N = scan . nextInt ( ) ; int M = scan . nextInt ( ) ; int [ ] dp = new int [ 1 << N ] ; for ( int i = 0 ; i < 1 << N ; ++ i ) dp [ i ] = 1001001 ; List < List < Integer > > key = new ArrayList < > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int v = scan . nextInt ( ) ; int keyNum = scan . nextInt ( ) ; int s = 0 ; for ( int j = 0 ; j < keyNum ; j ++ ) { int c = scan . nextInt ( ) ; c -- ; s |= 1 << c ; } List < Integer > a = Arrays . asList ( v , s ) ; key . add ( a ) ; } dp [ 0 ] = 0 ; for ( int s = 0 ; s < 1 << N ; s ++ ) { for ( int i = 0 ; i < M ; i ++ ) { int t = s | key . get ( i ) . get ( 1 ) ; int v = key . get ( i ) . get ( 0 ) ; dp [ t ] = Math . min ( dp [ t ] , v + dp [ s ] ) ; } } int ans = dp [ ( 1 << N ) - 1 ] ; if ( ans == 1001001 ) { System . out . println ( - 1 ) ; } else { System . out . println ( ans ) ; } } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int N = scan . nextInt ( ) ; int M = scan . nextInt ( ) ; int p = power ( 2 , N ) ; int [ ] dp = new int [ p ] ; for ( int i = 0 ; i < p ; i ++ ) { dp [ i ] = 1_000_000_000 ; } dp [ 0 ] = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; int [ ] c_list = new int [ b ] ; for ( int j = 0 ; j < b ; j ++ ) { c_list [ j ] = scan . nextInt ( ) ; } int c = 0 ; for ( int item : c_list ) { c += power ( 2 , item - 1 ) ; } for ( int k = 0 ; k < p ; k ++ ) { if ( dp [ k | c ] > dp [ k ] + a ) { dp [ k | c ] = dp [ k ] + a ; } } } if ( dp [ dp . length - 1 ] == 1_000_000_000 ) { System . out . println ( - 1 ) ; } else { System . out . println ( dp [ dp . length - 1 ] ) ; } } public static int power ( int n , int m ) { int res = 1 ; if ( m == 0 ) { return 1 ; } else { if ( n == 0 ) { return 0 ; } else { for ( int i = 0 ; i < m ; i ++ ) { res = res * n ; } return res ; } } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ m ] ; int [ ] b = new int [ m ] ; int [ ] c = new int [ m ] ; boolean [ ] u = new boolean [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; for ( int j = 0 ; j < b [ i ] ; j ++ ) { int t = sc . nextInt ( ) - 1 ; c [ i ] = c [ i ] | ( 1 << t ) ; u [ t ] = true ; } } boolean able = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! u [ i ] ) { able = false ; break ; } } if ( able ) { int max = 1 << n ; int [ ] dp = new int [ max ] ; Arrays . fill ( dp , Integer . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < max ; j ++ ) { if ( ( j & c [ i ] ) == c [ i ] || dp [ j ] == Integer . MAX_VALUE ) continue ; int next = j | c [ i ] ; if ( dp [ j ] + a [ i ] < dp [ next ] ) dp [ next ] = dp [ j ] + a [ i ] ; } } System . out . println ( dp [ max - 1 ] ) ; } else { System . out . println ( - 1 ) ; } sc . close ( ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] a = new int [ M ] ; int [ ] b = new int [ M ] ; int [ ] c = new int [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; for ( int j = 0 ; j < b [ i ] ; j ++ ) { int t = sc . nextInt ( ) ; t -- ; c [ i ] += 1 << t ; } } int INF = Integer . MAX_VALUE / 2 ; int [ ] [ ] dp = new int [ M + 1 ] [ 1 << N ] ; for ( int [ ] d : dp ) { Arrays . fill ( d , INF ) ; } dp [ 0 ] [ 0 ] = 0 ; for ( int idxKey = 0 ; idxKey < M ; idxKey ++ ) { for ( int j = 0 ; j < ( 1 << N ) ; j ++ ) { dp [ idxKey + 1 ] [ j ] = Math . min ( dp [ idxKey + 1 ] [ j ] , dp [ idxKey ] [ j ] ) ; int nj = j | c [ idxKey ] ; dp [ idxKey + 1 ] [ nj ] = Math . min ( dp [ idxKey + 1 ] [ nj ] , dp [ idxKey ] [ j ] + a [ idxKey ] ) ; } } int ans = ( dp [ M ] [ ( 1 << N ) - 1 ] < INF ) ? dp [ M ] [ ( 1 << N ) - 1 ] : - 1 ; System . out . println ( ans ) ; } }"], "python": ["INF = 2 * 10 ** 7 NEW_LINE def main ( ) : NEW_LINE INDENT N , M = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE C = [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE B . append ( b ) NEW_LINE C . append ( { int ( i ) for i in input ( ) . split ( ) } ) NEW_LINE DEDENT dp = [ [ INF ] * ( 1 << N ) for _ in range ( M + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT for j in range ( 1 << N ) : NEW_LINE INDENT dp [ i + 1 ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE if dp [ i ] [ j ] != INF : NEW_LINE INDENT next_bit = j NEW_LINE for bit in C [ i ] : NEW_LINE INDENT next_bit |= ( 1 << ( bit - 1 ) ) NEW_LINE DEDENT dp [ i + 1 ] [ next_bit ] = min ( dp [ i + 1 ] [ next_bit ] , dp [ i ] [ j ] + A [ i ] ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ - 1 ] [ - 1 ] NEW_LINE if ans == INF : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from functools import reduce NEW_LINE INF = 10 ** 7 NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE L = 1 << N NEW_LINE keys = [ 0 ] * M NEW_LINE for m in range ( M ) : NEW_LINE INDENT cost , _ = map ( int , input ( ) . split ( ) ) NEW_LINE match = reduce ( lambda a , b : a | b , ( 1 << shamt for shamt in map ( lambda n : int ( n ) - 1 , input ( ) . split ( ) ) ) ) NEW_LINE keys [ m ] = cost , match NEW_LINE DEDENT table = [ [ INF ] * L for _ in range ( M + 1 ) ] NEW_LINE table [ 0 ] [ 0 ] = 0 NEW_LINE for m in range ( M ) : NEW_LINE INDENT cost , match = keys [ m ] NEW_LINE for l in range ( L ) : NEW_LINE INDENT now = table [ m ] [ l ] NEW_LINE if l and not now : NEW_LINE INDENT continue NEW_LINE DEDENT table [ m + 1 ] [ l ] = min ( now , table [ m + 1 ] [ l ] ) NEW_LINE table [ m + 1 ] [ l | match ] = min ( now + cost , table [ m + 1 ] [ l | match ] ) NEW_LINE DEDENT DEDENT print ( table [ M ] [ L - 1 ] if table [ M ] [ L - 1 ] != INF else - 1 ) NEW_LINE", "from subprocess import * NEW_LINE with open ( ' e . cpp ' , ' w ' ) as f : f . write ( r \"\"\" STRNEWLINE # include \u2581 < bits / stdc + + . h > STRNEWLINE using \u2581 namespace \u2581 std ; STRNEWLINE STRNEWLINE const \u2581 int \u2581 maxs \u2581 = \u2581 4096 ; STRNEWLINE int \u2581 dp [ maxs ] ; STRNEWLINE STRNEWLINE int \u2581 main ( ) \u2581 { STRNEWLINE TABSYMBOL memset ( dp , \u2581 0x3f , \u2581 16384 ) ; STRNEWLINE TABSYMBOL dp [ 0 ] \u2581 = \u2581 0 ; STRNEWLINE TABSYMBOL int \u2581 n , \u2581 m ; STRNEWLINE TABSYMBOL cin \u2581 > > \u2581 n \u2581 > > \u2581 m ; STRNEWLINE TABSYMBOL while \u2581 ( m - - ) \u2581 { STRNEWLINE TABSYMBOL TABSYMBOL int \u2581 a , \u2581 b , \u2581 s \u2581 = \u2581 0 ; STRNEWLINE TABSYMBOL TABSYMBOL cin \u2581 > > \u2581 a \u2581 > > \u2581 b ; STRNEWLINE TABSYMBOL TABSYMBOL while \u2581 ( b - - ) \u2581 { STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL int \u2581 c ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL cin \u2581 > > \u2581 c ; STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL s \u2581 ^ = \u2581 1 \u2581 < < \u2581 c \u2581 - \u2581 1 ; STRNEWLINE TABSYMBOL TABSYMBOL } STRNEWLINE TABSYMBOL TABSYMBOL dp [ s ] \u2581 = \u2581 min ( dp [ s ] , \u2581 a ) ; STRNEWLINE TABSYMBOL } STRNEWLINE TABSYMBOL for \u2581 ( int \u2581 i \u2581 = \u2581 0 ; \u2581 i \u2581 ! = \u2581 n ; \u2581 + + i ) \u2581 for \u2581 ( int \u2581 all \u2581 = \u2581 ( 1 \u2581 < < \u2581 n ) \u2581 - \u2581 1 \u2581 ^ \u2581 1 \u2581 < < \u2581 i , \u2581 sub \u2581 = \u2581 all ; \u2581 sub ; \u2581 sub \u2581 = \u2581 sub \u2581 - \u2581 1 \u2581 & \u2581 all ) STRNEWLINE TABSYMBOL TABSYMBOL dp [ sub ] \u2581 = \u2581 min ( dp [ sub ] , \u2581 dp [ sub \u2581 ^ \u2581 1 \u2581 < < \u2581 i ] ) ; STRNEWLINE TABSYMBOL for \u2581 ( int \u2581 s \u2581 = \u2581 0 ; \u2581 s \u2581 ! = \u2581 ( 1 \u2581 < < \u2581 n ) ; \u2581 + + s ) \u2581 if \u2581 ( s \u2581 ! = \u2581 ( s \u2581 & \u2581 - s ) ) STRNEWLINE TABSYMBOL TABSYMBOL for \u2581 ( int \u2581 t \u2581 = \u2581 s \u2581 - \u2581 1 \u2581 & \u2581 s ; \u2581 t \u2581 ! = \u2581 s ; \u2581 t \u2581 = \u2581 t \u2581 - \u2581 1 \u2581 & \u2581 s ) STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL dp [ s ] \u2581 = \u2581 min ( dp [ s ] , \u2581 dp [ t ] \u2581 + \u2581 dp [ s \u2581 ^ \u2581 t ] ) ; STRNEWLINE TABSYMBOL int \u2581 mask \u2581 = \u2581 ( 1 \u2581 < < \u2581 n ) \u2581 - \u2581 1 ; STRNEWLINE TABSYMBOL if \u2581 ( dp [ mask ] \u2581 = = \u2581 0x3f3f3f3f ) \u2581 dp [ mask ] \u2581 = \u2581 - 1 ; STRNEWLINE TABSYMBOL cout \u2581 < < \u2581 dp [ mask ] \u2581 < < \u2581 endl ; STRNEWLINE } \"\"\" ) NEW_LINE call ( ( ' g + + ' , ' e . cpp ' ) ) NEW_LINE call ( ' . / a . out ' ) NEW_LINE", "INF = 10 ** 9 NEW_LINE def as_bit ( ls ) : NEW_LINE INDENT ret = 0 NEW_LINE for l in ls : NEW_LINE INDENT ret |= 1 << ( l - 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE C , A = [ ] , [ ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE A . append ( a ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C . append ( as_bit ( c ) ) NEW_LINE DEDENT dp = [ [ INF ] * ( 2 ** N ) for _ in range ( M + 1 ) ] NEW_LINE for i in range ( M + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT for bit in range ( 2 ** N ) : NEW_LINE INDENT dp [ i + 1 ] [ bit | C [ i ] ] = min ( dp [ i + 1 ] [ bit | C [ i ] ] , dp [ i ] [ bit ] + A [ i ] ) NEW_LINE dp [ i + 1 ] [ bit ] = min ( dp [ i + 1 ] [ bit ] , dp [ i ] [ bit ] ) NEW_LINE DEDENT DEDENT ans = dp [ - 1 ] [ - 1 ] NEW_LINE print ( ans if ans != INF else - 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE dp = [ 0 ] + [ 10 ** 8 + 10 ] * ( 2 ** n - 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE s = sum ( [ 2 ** ( x - 1 ) for x in list ( map ( int , input ( ) . split ( ) ) ) ] ) NEW_LINE for j in range ( 2 ** n ) : NEW_LINE INDENT if dp [ j | s ] > dp [ j ] + a : NEW_LINE INDENT dp [ j | s ] = dp [ j ] + a NEW_LINE DEDENT DEDENT DEDENT if dp [ - 1 ] <= 10 ** 8 : NEW_LINE INDENT print ( dp [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5280_A", "java": ["class GFG { static int MAX = 100001 ; static int [ ] prime = new int [ MAX + 1 ] ; static int [ ] countdiv = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; } static int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 10 , 15 , 7 , 25 , 9 , 35 } ; int size = arr . length ; System . out . println ( largestGCDSubsequence ( arr , size ) ) ; } }"], "python": ["import math as mt NEW_LINE MAX = 100001 NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countdiv = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3799_A", "java": ["class GFG { static int Count ( String s , int pos ) { int c = s . charAt ( pos - 1 ) ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s . charAt ( i ) == c ) counter = counter + 1 ; } return counter ; } public static void main ( String [ ] args ) { String s = \" abacsddaa \" ; int pos ; int n = s . length ( ) ; int query [ ] = { 9 , 3 , 2 } ; int Q = query . length ; for ( int i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; System . out . println ( Count ( s , pos ) ) ; } } }"], "python": ["def Count ( s , pos ) : NEW_LINE INDENT c = s [ pos - 1 ] NEW_LINE counter = 0 NEW_LINE for i in range ( pos - 1 ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" abacsddaa \" NEW_LINE n = len ( s ) NEW_LINE query = [ 9 , 3 , 2 ] NEW_LINE Q = len ( query ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT pos = query [ i ] NEW_LINE print ( Count ( s , pos ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1354_A", "java": ["import java . util . Scanner ; public class AlarmClock { public static void main ( String [ ] args ) { Scanner iScanner = new Scanner ( System . in ) ; int test = iScanner . nextInt ( ) ; while ( test > 0 ) { test -- ; long a = iScanner . nextLong ( ) ; long b = iScanner . nextLong ( ) ; long c = iScanner . nextLong ( ) ; long d = iScanner . nextLong ( ) ; if ( b >= a ) { System . out . println ( b ) ; } else { if ( d >= c ) System . out . println ( \" - 1\" ) ; else { long rest = a - b ; long restAlarm = c - d ; long totalRest = 0 ; if ( rest % restAlarm != 0 ) totalRest = ( rest / restAlarm ) + 1 ; else totalRest = rest / restAlarm ; System . out . println ( b + totalRest * c ) ; } } } } }", "import java . io . * ; import java . math . * ; import java . util . * ; public class apples { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } char nextchar ( ) { char ch = ' \u2581 ' ; try { ch = ( char ) br . read ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ch ; } } public static void main ( String [ ] args ) { FastReader x = new FastReader ( ) ; StringBuilder str = new StringBuilder ( ) ; int t = x . nextInt ( ) ; while ( t > 0 ) { long a = x . nextLong ( ) ; long b = x . nextLong ( ) ; long c = x . nextLong ( ) ; long d = x . nextLong ( ) ; long res = 0 ; if ( a <= b ) { res = b ; } else if ( c <= d ) { res = - 1 ; } else { res += b ; a -= b ; long k = c - d ; k = ( long ) Math . ceil ( ( double ) a / ( double ) k ) ; res += k * c ; } str . append ( res ) ; str . append ( \" \\n \" ) ; t -- ; } System . out . println ( str ) ; } }", "import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long c = sc . nextLong ( ) ; long d = sc . nextLong ( ) ; if ( b >= a ) { System . out . println ( b ) ; } else if ( c <= d ) { System . out . println ( - 1 ) ; } else { long cnt = c - d ; long ans = ( a - b ) / cnt ; if ( ( a - b ) % cnt != 0 ) ans ++ ; System . out . println ( b + ( ans * c ) ) ; } } } }"], "python": ["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( b ) NEW_LINE continue NEW_LINE DEDENT if c <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE continue NEW_LINE DEDENT a -= b NEW_LINE dif = c - d NEW_LINE print ( b + ( a + dif - 1 ) // dif * c ) NEW_LINE DEDENT", "for s in [ * open ( 0 ) ] [ 1 : ] : a , b , c , d = map ( int , s . split ( ) ) ; print ( b + ( a > b ) * ( c > d and 0 - ( b - a ) // ( c - d ) * c or - b - 1 ) ) NEW_LINE", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE sm = b NEW_LINE a -= b NEW_LINE if c - d <= 0 and a > 0 : NEW_LINE INDENT sm = - 1 NEW_LINE DEDENT elif a > 0 : NEW_LINE INDENT k = a // ( c - d ) NEW_LINE if a % ( c - d ) != 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT sm += k * c NEW_LINE DEDENT print ( sm ) NEW_LINE DEDENT", "from math import ceil NEW_LINE t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT elif c <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + ceil ( ( a - b ) / ( c - d ) ) * c ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT if i > t : NEW_LINE INDENT break NEW_LINE DEDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE if b >= a : NEW_LINE INDENT print ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT if c <= d : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT n = ( a - b ) / ( c - d ) NEW_LINE if n % 1 == 0 : NEW_LINE INDENT print ( b + ( int ( n ) * c ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + ( int ( n ) + 1 ) * c ) NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4438_A", "java": ["import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; public class FindDuplicatedInArray { public static void main ( String [ ] args ) { int arr [ ] = { 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 } ; int n = arr . length ; printDuplicates ( arr , n ) ; } private static void printDuplicates ( int [ ] arr , int n ) { Map < Integer , Integer > map = new HashMap < > ( ) ; int count = 0 ; boolean dup = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { count = map . get ( arr [ i ] ) ; map . put ( arr [ i ] , count + 1 ) ; } else { map . put ( arr [ i ] , 1 ) ; } } for ( Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) > 1 ) { System . out . print ( entry . getKey ( ) + \" \u2581 \" ) ; dup = true ; } } if ( ! dup ) { System . out . println ( \" - 1\" ) ; } } }"], "python": ["def printDuplicates ( arr ) : NEW_LINE INDENT dict = { } NEW_LINE for ele in arr : NEW_LINE INDENT try : NEW_LINE INDENT dict [ ele ] += 1 NEW_LINE DEDENT except : NEW_LINE INDENT dict [ ele ] = 1 NEW_LINE DEDENT DEDENT for item in dict : NEW_LINE INDENT if ( dict [ item ] > 1 ) : NEW_LINE INDENT print ( item , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT print ( \" \\n \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT list = [ 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 ] NEW_LINE printDuplicates ( list ) NEW_LINE DEDENT"]}
{"id": "atcoder_AGC010_A", "java": ["import java . io . * ; import java . util . * ; public class Main { private static MyScanner scanner ; public static void main ( String [ ] args ) { Main instance = new Main ( ) ; scanner = instance . new MyScanner ( ) ; instance . solve ( ) ; } private void solve ( ) { try { int N = scanner . nextInt ( ) ; int kisu = 0 , gusu = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long ai = scanner . nextLong ( ) ; if ( ai % 2 == 0 ) { gusu ++ ; } else { kisu ++ ; } } gusu += kisu / 2 ; kisu = kisu - kisu / 2 * 2 ; if ( kisu == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } } private class MyScanner { String [ ] s ; int i ; BufferedReader br ; String reg = \" \u2581 \" ; MyScanner ( ) { s = new String [ 0 ] ; i = 0 ; br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public String next ( ) throws IOException { if ( i < s . length ) return s [ i ++ ] ; String line = br . readLine ( ) ; while ( line . equals ( \" \" ) ) { line = br . readLine ( ) ; } s = line . split ( reg , 0 ) ; i = 0 ; return s [ i ++ ] ; } public int nextInt ( ) throws NumberFormatException , IOException { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) throws NumberFormatException , IOException { return Double . parseDouble ( next ( ) ) ; } public long nextLong ( ) throws NumberFormatException , IOException { return Long . parseLong ( next ( ) ) ; } } }", "import java . io . IOException ; import java . util . ArrayList ; import java . util . Scanner ; class Main { public static void main ( String args [ ] ) throws IOException { @ SuppressWarnings ( \" resource \" ) Scanner cin = new Scanner ( System . in ) ; ArrayList < String > inLines = new ArrayList < String > ( ) ; for ( ; cin . hasNext ( ) ; ) { inLines . add ( cin . nextLine ( ) ) ; } Solver solver = new Solver ( ) ; solver . solve ( inLines ) ; } } class Solver { public void solve ( ArrayList < String > inLines ) { int N = Integer . parseInt ( inLines . get ( 0 ) ) ; String [ ] strArr = inLines . get ( 1 ) . split ( \" \u2581 \" ) ; boolean ans = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( Long . parseLong ( strArr [ i ] ) % 2 == 1 ) ans = ! ans ; } if ( ans ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Main { private static final int MOD = ( int ) Math . pow ( 10 , 9 ) ; public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; int n = sc . nextInt ( ) ; int [ ] count = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ sc . nextInt ( ) % 2 ] ++ ; } while ( count [ 0 ] > 1 || count [ 1 ] > 1 ) { if ( count [ 0 ] >= 2 ) { count [ 0 ] -- ; } if ( count [ 1 ] >= 2 ) { count [ 1 ] -= 2 ; count [ 0 ] ++ ; } } if ( ( count [ 0 ] == 0 && count [ 1 ] == 1 ) || ( count [ 0 ] == 1 && count [ 1 ] == 0 ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } private static int findDigit ( int num ) { int res = 0 ; while ( num > 0 ) { res += ( num % 10 ) ; num /= 10 ; } return res ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . io . BufferedReader ; import java . io . Closeable ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . LinkedList ; import java . util . PriorityQueue ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { final Scanner sc = new Scanner ( System . in ) ; final int N = sc . nextInt ( ) ; int odd = 0 , even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { final long input = sc . nextLong ( ) ; if ( input % 2 == 0 ) { even ++ ; } else { odd ++ ; } } if ( odd % 2 == 1 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; } } public static class Scanner implements Closeable { private BufferedReader br ; private StringTokenizer tok ; public Scanner ( InputStream is ) throws IOException { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } private void getLine ( ) throws IOException { while ( ! hasNext ( ) ) { tok = new StringTokenizer ( br . readLine ( ) ) ; } } private boolean hasNext ( ) { return tok != null && tok . hasMoreTokens ( ) ; } public String next ( ) throws IOException { getLine ( ) ; return tok . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) throws IOException { final int [ ] ret = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ret [ i ] = this . nextInt ( ) ; } return ret ; } public void close ( ) throws IOException { br . close ( ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { void solve ( ) throws IOException { int n = ni ( ) ; int [ ] a = nia ( n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) cnt ++ ; } if ( cnt % 2 == 1 ) { out . println ( \" NO \" ) ; } else { out . println ( \" YES \" ) ; } } String ns ( ) throws IOException { while ( ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) , \" \u2581 \" ) ; } return tok . nextToken ( ) ; } int ni ( ) throws IOException { return Integer . parseInt ( ns ( ) ) ; } long nl ( ) throws IOException { return Long . parseLong ( ns ( ) ) ; } double nd ( ) throws IOException { return Double . parseDouble ( ns ( ) ) ; } String [ ] nsa ( int n ) throws IOException { String [ ] res = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = ns ( ) ; } return res ; } int [ ] nia ( int n ) throws IOException { int [ ] res = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = ni ( ) ; } return res ; } long [ ] nla ( int n ) throws IOException { long [ ] res = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = nl ( ) ; } return res ; } static BufferedReader in ; static PrintWriter out ; static StringTokenizer tok ; public static void main ( String [ ] args ) throws IOException { in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ; tok = new StringTokenizer ( \" \" ) ; Main main = new Main ( ) ; main . solve ( ) ; out . close ( ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE c = 0 NEW_LINE for i in a : NEW_LINE INDENT if i % 2 != 0 : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( \" YES \" if c % 2 == 0 else \" NO \" ) NEW_LINE", "def main10 ( ) : NEW_LINE INDENT buf = int ( input ( \" \" ) ) ; NEW_LINE strbuf = input ( \" \" ) ; NEW_LINE strbufs = strbuf . split ( ) ; NEW_LINE buf2 = [ ] ; NEW_LINE for i in range ( buf ) : NEW_LINE INDENT buf2 . append ( int ( strbufs [ i ] ) ) ; NEW_LINE DEDENT if len ( buf2 ) == 1 : NEW_LINE INDENT return ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ki = 0 ; NEW_LINE for i in range ( buf ) : NEW_LINE INDENT if buf2 [ i ] % 2 == 1 : NEW_LINE INDENT ki += 1 ; NEW_LINE DEDENT DEDENT if ki % 2 == 0 : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main10 ( ) NEW_LINE DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( A ) % 2 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "N = int ( input ( ) ) NEW_LINE aa = [ int ( a ) for a in input ( ) . rstrip ( ) . split ( ) ] NEW_LINE n_even = len ( list ( filter ( lambda a : a % 2 == 0 , aa ) ) ) NEW_LINE n_odd = len ( list ( filter ( lambda a : a % 2 == 1 , aa ) ) ) NEW_LINE x = n_odd // 2 NEW_LINE n_odd -= x * 2 NEW_LINE n_even += x NEW_LINE if n_even > 1 : NEW_LINE INDENT n_even = 1 NEW_LINE DEDENT if n_even == 0 or n_odd == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE s = input ( ) . split ( ) NEW_LINE i = 0 NEW_LINE count = 0 NEW_LINE while i < n : NEW_LINE INDENT if int ( s [ i ] ) % 2 != 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if count % 2 == 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4954_A", "java": ["import java . io . * ; class GFG { static int findMissingUtil ( int arr [ ] , int low , int high , int diff ) { if ( high <= low ) return Integer . MAX_VALUE ; int mid = low + ( high - low ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissingUtil ( arr , mid + 1 , high , diff ) ; return findMissingUtil ( arr , low , mid - 1 , diff ) ; } static int findMissing ( int arr [ ] , int n ) { int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissingUtil ( arr , 0 , n - 1 , diff ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 8 , 10 , 12 , 14 } ; int n = arr . length ; System . out . println ( \" The \u2581 missing \u2581 element \u2581 is \u2581 \" + findMissing ( arr , n ) ) ; } }"], "python": ["import sys NEW_LINE def findMissingUtil ( arr , low , high , diff ) : NEW_LINE INDENT if ( high <= low ) : NEW_LINE INDENT return sys . maxsize ; NEW_LINE DEDENT mid = int ( low + ( high - low ) / 2 ) ; NEW_LINE if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) ; NEW_LINE DEDENT if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) ; NEW_LINE DEDENT if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissingUtil ( arr , mid + 1 , high , diff ) ; NEW_LINE DEDENT return findMissingUtil ( arr , low , mid - 1 , diff ) ; NEW_LINE DEDENT def findMissing ( arr , n ) : NEW_LINE INDENT diff = int ( ( arr [ n - 1 ] - arr [ 0 ] ) / n ) ; NEW_LINE return findMissingUtil ( arr , 0 , n - 1 , diff ) ; NEW_LINE DEDENT arr = [ 2 , 4 , 8 , 10 , 12 , 14 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" The \u2581 missing \u2581 element \u2581 is \" , findMissing ( arr , n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_383_A", "java": ["class GFG { static void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( \" - 1\" ) ; return ; } int i , first , second ; first = second = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } System . out . println ( \" n \u2581 = \u2581 \" + first + \" \u2581 and \u2581 r \u2581 = \u2581 \" + second ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 } ; int n = arr . length ; findPair ( arr , n ) ; } }"], "python": ["def findPair ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE first = - 1 NEW_LINE second = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" n \u2581 = \" , first , \" and \u2581 r \u2581 = \" , second ) NEW_LINE DEDENT arr = [ 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE findPair ( arr , n ) NEW_LINE"]}
{"id": "codeforces_1105_A", "java": ["import java . io . * ; import java . util . * ; public class A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; Arrays . setAll ( a , i -> in . nextInt ( ) ) ; int ans = Integer . MAX_VALUE ; int T = 0 ; for ( int k = 1 ; k <= 100 ; k ++ ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k == a [ i ] ) continue ; int v1 = Math . abs ( ( k + 1 ) - a [ i ] ) ; int v2 = Math . abs ( ( k - 1 ) - a [ i ] ) ; res += Math . min ( v1 , v2 ) ; } if ( ans > res ) { ans = res ; T = k ; } } pw . println ( T + \" \u2581 \" + ans ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }", "import java . util . * ; import java . lang . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } Arrays . sort ( a ) ; int cost = 0 ; int ans1 = 0 ; int ans = Integer . MAX_VALUE ; for ( int i = a [ 0 ] ; i <= a [ n - 1 ] ; i ++ ) { int t = i ; cost = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( t - a [ j ] ) > 1 ) { cost += Math . abs ( t - a [ j ] ) - 1 ; } } if ( cost < ans ) { ans = cost ; ans1 = t ; } } System . out . println ( ans1 + \" \u2581 \" + ans ) ; } }", "import java . util . Scanner ; public class SalemAndSticks { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } int ans = Integer . MAX_VALUE , t = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] > i ) sum += ( arr [ j ] - ( i + 1 ) ) ; else if ( arr [ j ] < i ) sum += ( i - 1 - arr [ j ] ) ; } if ( sum < ans ) { ans = sum ; t = i ; } } System . out . println ( t + \" \u2581 \" + ans ) ; } }"], "python": ["import os , sys , io , math NEW_LINE from array import array NEW_LINE from math import * NEW_LINE I = lambda : [ * map ( int , sys . stdin . readline ( ) . split ( ) ) ] NEW_LINE IS = lambda : input ( ) NEW_LINE IN = lambda : int ( input ( ) ) NEW_LINE IF = lambda : float ( input ( ) ) NEW_LINE n = IN ( ) NEW_LINE l = I ( ) NEW_LINE inf = pow ( 10 , 9 ) + 1 NEW_LINE t , c = 0 , inf NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT d = 0 NEW_LINE for j in l : d += min ( abs ( ( i - 1 ) - j ) , abs ( i - j ) , abs ( ( i + 1 ) - j ) ) NEW_LINE if c > d : t , c = i , d NEW_LINE DEDENT print ( t , c ) NEW_LINE", "from math import ceil NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE global_cost = 100000000000000 NEW_LINE T = None NEW_LINE for t in range ( 1 , 101 ) : NEW_LINE INDENT local_cost = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if abs ( a [ i ] - t ) >= 2 : local_cost += abs ( a [ i ] - t ) - 1 NEW_LINE DEDENT if global_cost > local_cost : NEW_LINE INDENT global_cost = local_cost NEW_LINE T = t NEW_LINE DEDENT DEDENT print ( T , global_cost ) NEW_LINE", "import math NEW_LINE import os NEW_LINE import random NEW_LINE import re NEW_LINE import sys NEW_LINE ans = 1e9 NEW_LINE total = 1 NEW_LINE n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT count += min ( min ( abs ( arr [ j ] - i - 1 ) , abs ( arr [ j ] - i + 1 ) ) , abs ( arr [ j ] - i ) ) NEW_LINE DEDENT if count < ans : NEW_LINE INDENT ans = count NEW_LINE total = i ; NEW_LINE DEDENT DEDENT if total == 0 and ans == 0 : NEW_LINE INDENT print ( 1 , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( total , ans ) NEW_LINE DEDENT", "import sys NEW_LINE def ii ( ) : return int ( input ( ) ) NEW_LINE def si ( ) : return input ( ) NEW_LINE def mi ( ) : return map ( int , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) NEW_LINE def msi ( ) : return map ( str , input ( ) . strip ( ) . split ( \" \u2581 \" ) ) NEW_LINE def li ( ) : return list ( mi ( ) ) NEW_LINE def read ( ) : NEW_LINE INDENT sys . stdin = open ( \" input . txt \" , ' r ' ) NEW_LINE sys . stout = open ( \" output . txt \" , ' w ' ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = ii ( ) NEW_LINE lst = li ( ) NEW_LINE cost = 1e9 + 7 NEW_LINE ans = 0 NEW_LINE for i in range ( min ( lst ) , max ( lst ) + 1 ) : NEW_LINE INDENT s = 0 NEW_LINE for j in lst : NEW_LINE INDENT if j == i : NEW_LINE INDENT continue NEW_LINE DEDENT s += abs ( j - i ) - 1 NEW_LINE DEDENT if s < cost : NEW_LINE INDENT cost = min ( cost , s ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( ans , cost ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE inf = pow ( 10 , 9 ) + 1 NEW_LINE t , c = 0 , inf NEW_LINE for i in range ( 1 , 101 ) : NEW_LINE INDENT c0 = 0 NEW_LINE for j in a : NEW_LINE INDENT c0 += min ( abs ( ( i - 1 ) - j ) , abs ( i - j ) , abs ( ( i + 1 ) - j ) ) NEW_LINE DEDENT if c > c0 : NEW_LINE INDENT t , c = i , c0 NEW_LINE DEDENT DEDENT print ( t , c ) NEW_LINE"]}
{"id": "aizu_p01531_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = in . readLine ( ) ; String [ ] vowel = { \" w \" , \" \" , \" k \" , \" s \" , \" t \" , \" n \" , \" h \" , \" m \" , \" y \" , \" r \" } ; for ( int i = 0 ; i < str . length ( ) ; i += 2 ) { char m = str . charAt ( i ) ; char c = str . charAt ( i + 1 ) ; if ( m == '0' && c == ' U ' ) { System . out . print ( \" nn \" ) ; } else { System . out . print ( vowel [ m - '0' ] ) ; switch ( c ) { case ' T ' : System . out . print ( ' a ' ) ; break ; case ' L ' : System . out . print ( ' i ' ) ; break ; case ' U ' : System . out . print ( ' u ' ) ; break ; case ' R ' : System . out . print ( ' e ' ) ; break ; case ' D ' : System . out . print ( ' o ' ) ; break ; } } } System . out . println ( ) ; } }", "import java . util . * ; import java . awt . geom . * ; public class Main { String [ ] [ ] table = { { \" wa \" , \" \" , \" nn \" , \" \" , \" wo \" } , { \" a \" , \" i \" , \" u \" , \" e \" , \" o \" } , { \" ka \" , \" ki \" , \" ku \" , \" ke \" , \" ko \" } , { \" sa \" , \" si \" , \" su \" , \" se \" , \" so \" } , { \" ta \" , \" ti \" , \" tu \" , \" te \" , \" to \" } , { \" na \" , \" ni \" , \" nu \" , \" ne \" , \" no \" } , { \" ha \" , \" hi \" , \" hu \" , \" he \" , \" ho \" } , { \" ma \" , \" mi \" , \" mu \" , \" me \" , \" mo \" } , { \" ya \" , \" \" , \" yu \" , \" \" , \" yo \" } , { \" ra \" , \" ri \" , \" ru \" , \" re \" , \" ro \" } , } ; String order = \" TLURD \" ; private void doit ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { String s = sc . next ( ) ; for ( int i = 0 ; i < s . length ( ) ; i += 2 ) { char c1 = s . charAt ( i ) ; char c2 = s . charAt ( i + 1 ) ; int num1 = c1 - '0' ; int num2 = order . indexOf ( c2 + \" \" ) ; System . out . print ( table [ num1 ] [ num2 ] ) ; } System . out . println ( ) ; } } private void debug ( Object ... o ) { System . out . println ( \" debug \u2581 = \u2581 \" + Arrays . deepToString ( o ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . doit ( ) ; } }", "import java . io . * ; public class Main { public static void main ( String args [ ] ) throws IOException { InputStreamReader in = new InputStreamReader ( System . in ) ; BufferedReader bf = new BufferedReader ( in ) ; String str = bf . readLine ( ) ; char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length / 2 ; i ++ ) { output ( Integer . parseInt ( \" \" + ch [ i * 2 ] ) , ch [ i * 2 + 1 ] ) ; } System . out . println ( ) ; } static void output ( int i , char c ) { switch ( i ) { case 0 : if ( c == ' T ' ) { System . out . print ( \" wa \" ) ; } else if ( c == ' U ' ) { System . out . print ( \" nn \" ) ; } else if ( c == ' D ' ) { System . out . print ( \" wo \" ) ; } return ; case 1 : break ; case 2 : System . out . print ( \" k \" ) ; break ; case 3 : System . out . print ( \" s \" ) ; break ; case 4 : System . out . print ( \" t \" ) ; break ; case 5 : System . out . print ( \" n \" ) ; break ; case 6 : System . out . print ( \" h \" ) ; break ; case 7 : System . out . print ( \" m \" ) ; break ; case 8 : System . out . print ( \" y \" ) ; break ; case 9 : System . out . print ( \" r \" ) ; break ; } switch ( c ) { case ' T ' : System . out . print ( \" a \" ) ; return ; case ' L ' : System . out . print ( \" i \" ) ; return ; case ' U ' : System . out . print ( \" u \" ) ; return ; case ' R ' : System . out . print ( \" e \" ) ; return ; case ' D ' : System . out . print ( \" o \" ) ; return ; } } }", "import java . util . Scanner ; public class Main { void run ( ) { Scanner sc = new Scanner ( System . in ) ; String [ ] s = { \" a \" , \" i \" , \" u \" , \" e \" , \" o \" } ; String [ ] b = { \" w \" , \" a \" , \" k \" , \" s \" , \" t \" , \" n \" , \" h \" , \" m \" , \" y \" , \" r \" } ; char [ ] r = sc . next ( ) . toCharArray ( ) ; StringBuilder res = new StringBuilder ( ) ; for ( int i = 0 ; i < r . length ; i += 2 ) { int id = r [ i ] - '0' ; int x = r [ i + 1 ] == ' T ' ? 0 : r [ i + 1 ] == ' L ' ? 1 : r [ i + 1 ] == ' U ' ? 2 : r [ i + 1 ] == ' R ' ? 3 : 4 ; if ( id == 1 ) res . append ( s [ x ] ) ; else if ( id == 0 ) { if ( x == 0 ) res . append ( \" wa \" ) ; else if ( x == 2 ) res . append ( \" nn \" ) ; else res . append ( \" wo \" ) ; } else res . append ( b [ id ] + s [ x ] ) ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) { int k ; String c ; String str = \" \" ; try { str = new BufferedReader ( new InputStreamReader ( System . in ) ) . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } String result = \" \" ; for ( int i = 0 ; i < str . length ( ) / 2 ; i ++ ) { k = Integer . parseInt ( str . substring ( 2 * i , 2 * i + 1 ) ) ; c = str . substring ( 2 * i + 1 , 2 * ( i + 1 ) ) ; result += translator ( k , c ) ; } System . out . println ( result ) ; } private static String translator ( int k , String c ) { String result = \" \" ; int [ ] nums = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; String [ ] cons = { \" w \" , \" \" , \" k \" , \" s \" , \" t \" , \" n \" , \" h \" , \" m \" , \" y \" , \" r \" } ; String [ ] dir = { \" T \" , \" L \" , \" U \" , \" R \" , \" D \" } ; String [ ] vowel = { \" a \" , \" i \" , \" u \" , \" e \" , \" o \" } ; if ( k == 0 && c . equals ( \" U \" ) ) { result += \" nn \" ; } else { for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == k ) { result += cons [ i ] ; } } for ( int i = 0 ; i < dir . length ; i ++ ) { if ( c . equals ( dir [ i ] ) ) { result += vowel [ i ] ; } } } return result ; } }"], "python": ["c = { \"1\" : \" \" , \"2\" : \" k \" , \"3\" : \" s \" , \"4\" : \" t \" , \"5\" : \" n \" , \"6\" : \" h \" , \"7\" : \" m \" , \"8\" : \" y \" , \"9\" : \" r \" , \"0\" : \" w \" } NEW_LINE m = { \" T \" : \" a \" , \" L \" : \" i \" , \" U \" : \" u \" , \" R \" : \" e \" , \" D \" : \" o \" } NEW_LINE s = input ( ) NEW_LINE ans = \" \" NEW_LINE for i in range ( 0 , len ( s ) , 2 ) : NEW_LINE INDENT com = s [ i : i + 2 ] NEW_LINE if com == \"0U \" : ans += \" nn \" NEW_LINE else : ans += c [ com [ 0 ] ] + m [ com [ 1 ] ] NEW_LINE DEDENT print ( ans ) NEW_LINE", "c = \" w \u2581 kstnhmyr \" NEW_LINE v = \" aiueo \" NEW_LINE d = [ \" T \" , \" L \" , \" U \" , \" R \" , \" D \" ] NEW_LINE f = [ ] NEW_LINE a = input ( ) NEW_LINE for i in range ( 0 , len ( a ) , 2 ) : NEW_LINE INDENT b = int ( a [ i ] ) NEW_LINE e = d . index ( a [ i + 1 ] ) NEW_LINE if b == 0 and e == 2 : f += ' nn ' NEW_LINE elif b == 1 : f += v [ e ] NEW_LINE else : f += c [ b ] + v [ e ] NEW_LINE DEDENT print ( \" \" . join ( f ) ) NEW_LINE", "c , v , d , f , a = \" w \u2581 kstnhmyr \" , \" aiueo \" , [ \" T \" , \" L \" , \" U \" , \" R \" , \" D \" ] , \" \" , input ( ) NEW_LINE for i in range ( 0 , len ( a ) , 2 ) : NEW_LINE INDENT b = int ( a [ i ] ) NEW_LINE e = d . index ( a [ i + 1 ] ) NEW_LINE if b == 0 and e == 2 : f += ' nn ' NEW_LINE elif b == 1 : f += v [ e ] NEW_LINE else : f += c [ b ] + v [ e ] NEW_LINE DEDENT print ( f ) NEW_LINE", "flicks = { \" T \" : \" a \" , \" L \" : \" i \" , \" U \" : \" u \" , \" R \" : \" e \" , \" D \" : \" o \" } NEW_LINE buttons = { \"1\" : \" \" , \"2\" : \" k \" , \"3\" : \" s \" , \"4\" : \" t \" , \"5\" : \" n \" , \"6\" : \" h \" , \"7\" : \" m \" , \"8\" : \" y \" , \"9\" : \" r \" , \"0\" : \" w \" } NEW_LINE def get_word ( button , flick ) : NEW_LINE INDENT if button == \"0\" and flick == \" U \" : NEW_LINE INDENT return \" nn \" NEW_LINE DEDENT return buttons [ button ] + flicks [ flick ] NEW_LINE DEDENT cmds = input ( ) NEW_LINE result = \" \" NEW_LINE for i in range ( 0 , len ( cmds ) , 2 ) : NEW_LINE INDENT result += get_word ( cmds [ i ] , cmds [ i + 1 ] ) NEW_LINE DEDENT print ( result ) NEW_LINE", "moji = input ( ) NEW_LINE flag = 0 NEW_LINE answer = [ ] NEW_LINE for i in range ( 0 , len ( moji ) ) : NEW_LINE INDENT if flag == 1 : NEW_LINE INDENT flag = 0 NEW_LINE continue NEW_LINE DEDENT if moji [ i ] == \"2\" : NEW_LINE INDENT answer . append ( \" k \" ) NEW_LINE DEDENT elif moji [ i ] == \"3\" : NEW_LINE INDENT answer . append ( \" s \" ) NEW_LINE DEDENT elif moji [ i ] == \"4\" : NEW_LINE INDENT answer . append ( \" t \" ) NEW_LINE DEDENT elif moji [ i ] == \"5\" : NEW_LINE INDENT answer . append ( \" n \" ) NEW_LINE DEDENT elif moji [ i ] == \"6\" : NEW_LINE INDENT answer . append ( \" h \" ) NEW_LINE DEDENT elif moji [ i ] == \"7\" : NEW_LINE INDENT answer . append ( \" m \" ) NEW_LINE DEDENT elif moji [ i ] == \"8\" : NEW_LINE INDENT answer . append ( \" y \" ) NEW_LINE DEDENT elif moji [ i ] == \"9\" : NEW_LINE INDENT answer . append ( \" r \" ) NEW_LINE DEDENT elif moji [ i ] == \"0\" : NEW_LINE INDENT i += 1 NEW_LINE flag = 1 NEW_LINE if moji [ i ] == \" T \" : NEW_LINE INDENT answer . append ( \" wa \" ) NEW_LINE DEDENT elif moji [ i ] == \" D \" : NEW_LINE INDENT answer . append ( \" wo \" ) NEW_LINE DEDENT elif moji [ i ] == \" U \" : NEW_LINE INDENT answer . append ( \" nn \" ) NEW_LINE DEDENT DEDENT elif moji [ i ] == \" T \" : NEW_LINE INDENT answer . append ( \" a \" ) NEW_LINE DEDENT elif moji [ i ] == \" L \" : NEW_LINE INDENT answer . append ( \" i \" ) NEW_LINE DEDENT elif moji [ i ] == \" U \" : NEW_LINE INDENT answer . append ( \" u \" ) NEW_LINE DEDENT elif moji [ i ] == \" R \" : NEW_LINE INDENT answer . append ( \" e \" ) NEW_LINE DEDENT elif moji [ i ] == \" D \" : NEW_LINE INDENT answer . append ( \" o \" ) NEW_LINE DEDENT DEDENT for i in answer : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE"]}
{"id": "geeksforgeeks_3050_A", "java": ["class GFG { static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } public static void main ( String [ ] args ) { int R = 4 , C = 5 , M = 2 ; System . out . println ( Square ( R , C , M ) ) ; } }"], "python": ["def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_1582_A", "java": ["import java . io . * ; import java . util . * ; public class Main { static PrintWriter out = new PrintWriter ( System . out ) ; static Scanner in = new Scanner ( System . in ) ; static BufferedReader re = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter wr = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws IOException { PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int T = in . nextInt ( ) ; while ( T > 0 ) { long a = in . nextLong ( ) ; long b = in . nextLong ( ) ; long c = in . nextLong ( ) ; long res = ( a + 2 * b + 3 * c ) % 2 ; out . println ( res ) ; T -- ; } out . flush ( ) ; } }"], "python": ["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE tot = a + 2 * b + 3 * c NEW_LINE if tot % 2 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE while t > 0 : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE n = 1 * a + 2 * b + 3 * c NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT t = t - 1 NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a [ 0 ] NEW_LINE y = a [ 1 ] NEW_LINE z = a [ 2 ] NEW_LINE ans = 1 NEW_LINE if ( ( ( ( ( x % 2 == 0 ) and ( y % 2 == 0 ) ) and ( z % 2 == 0 ) ) or ( ( ( x % 2 == 0 ) and ( y % 2 == 1 ) ) and ( z % 2 == 0 ) ) ) or ( ( ( ( x % 2 == 1 ) and ( y % 2 == 1 ) ) and ( z % 2 == 1 ) ) or ( ( ( x % 2 == 1 ) and ( y % 2 == 0 ) ) and ( z % 2 == 1 ) ) ) ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( a + c ) % 2 ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = 1 * n [ 0 ] + 2 * n [ 1 ] + 3 * n [ 2 ] NEW_LINE if a % 2 == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a % 2 == 1 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_4596_A", "java": ["class GFG { static int powmod ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }"], "python": ["import math ; NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE value = [ 0 ] * m ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m ; NEW_LINE if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - j ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_4848_A", "java": ["import java . io . * ; class GFG { static int Circumference ( int l , int w ) { return ( 2 * ( l + w ) ) ; } static public void main ( String [ ] args ) { int l = 8 , w = 4 ; int c = Circumference ( l , w ) ; System . out . println ( \" Circumference \u2581 of \u2581 \" + \" a \u2581 rectangle \u2581 is \u2581 \" + c ) ; } }"], "python": ["def Circumference ( l , w ) : NEW_LINE INDENT return ( 2 * ( l + w ) ) NEW_LINE DEDENT l = 8 NEW_LINE w = 4 NEW_LINE c = Circumference ( l , w ) NEW_LINE print ( \" Circumference \u2581 of \u2581 a \" + \" \u2581 rectangle \u2581 is \u2581 % \u2581 d \" % ( c ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5045_A", "java": ["import java . io . * ; class GFG { static double edgeDisjoint ( int n ) { double result = 0 ; result = Math . floor ( n / 2 ) ; return result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( ( int ) edgeDisjoint ( n ) ) ; } }"], "python": ["import math NEW_LINE def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 NEW_LINE print ( int ( edgeDisjoint ( n ) ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_792_B", "java": ["import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class B792 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int [ ] A = new int [ K ] ; for ( int k = 0 ; k < K ; k ++ ) { A [ k ] = in . nextInt ( ) ; } List < Integer > list = new LinkedList < > ( ) ; for ( int n = 1 ; n <= N ; n ++ ) { list . add ( n ) ; } StringBuilder output = new StringBuilder ( ) ; int pos = 0 ; for ( int k = 0 ; k < K ; k ++ ) { pos += A [ k ] ; pos %= list . size ( ) ; output . append ( list . get ( pos ) ) . append ( ' \u2581 ' ) ; list . remove ( pos ) ; } System . out . println ( output ) ; } }", "import java . io . * ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . * ; import java . math . * ; public class Main { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } static long [ ] ans = new long [ 100001 ] ; public static void main ( String [ ] args ) throws java . lang . Exception { FastReader sc = new FastReader ( ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int t = 1 ; while ( t -- > 0 ) { int n = sc . nextInt ( ) , k = sc . nextInt ( ) ; int a [ ] = new int [ k ] , c = 1 ; for ( int i = 0 ; i < k ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } List < Integer > l = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) l . add ( i + 1 ) ; int pos = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int nxt = ( pos + a [ i ] ) % l . size ( ) ; int d = l . remove ( nxt ) ; pw . print ( d + \" \u2581 \" ) ; pos = nxt ; } } pw . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . LinkedList ; import java . util . List ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int k = Integer . parseInt ( st . nextToken ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; st = new StringTokenizer ( br . readLine ( ) ) ; int [ ] ar = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { ar [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } List < Integer > people = new LinkedList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { people . add ( i + 1 ) ; } int ptr = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int times = ar [ i ] ; ptr = ( ptr + times ) % people . size ( ) ; sb . append ( people . get ( ptr ) ) . append ( \" \u2581 \" ) ; people . remove ( ptr ) ; if ( ptr == people . size ( ) + 1 ) { ptr = 0 ; } } System . out . println ( sb ) ; } public static void swap ( int [ ] ar , int i , int j ) { int temp = ar [ i ] ; ar [ i ] = ar [ j ] ; ar [ j ] = temp ; } public static class Pair { int x ; int y ; Pair ( int x , int y ) { this . x = x ; this . y = y ; } public int getX ( ) { return x ; } public int getY ( ) { return y ; } } }"], "python": ["def solve ( n , a , k ) : NEW_LINE INDENT leader = 0 NEW_LINE size = n NEW_LINE p = list ( range ( 1 , n + 1 ) ) NEW_LINE res = [ ] NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT j = ( leader + a [ i ] ) % size NEW_LINE res . append ( p [ j ] ) NEW_LINE p . pop ( j ) NEW_LINE size -= 1 NEW_LINE leader = j % size NEW_LINE DEDENT print ( * res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE solve ( n , a , k ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE X = list ( range ( n ) ) NEW_LINE cur = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT m = len ( X ) NEW_LINE j = ( cur + A [ i ] ) % m NEW_LINE ans . append ( X . pop ( j ) ) NEW_LINE cur = j NEW_LINE DEDENT ans = [ i + 1 for i in ans ] NEW_LINE print ( * ans ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ i for i in range ( 1 , n + 1 ) ] NEW_LINE r = 0 NEW_LINE j = 0 NEW_LINE d = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT if j == len ( a ) : NEW_LINE INDENT j = 0 NEW_LINE DEDENT for _ in range ( s [ i ] % len ( a ) ) : NEW_LINE INDENT if j >= len ( a ) - 1 : NEW_LINE INDENT j = 0 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT d . append ( a . pop ( j ) ) NEW_LINE DEDENT print ( * d ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE kids = [ i + 1 for i in range ( n ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE lead = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT x = ( a [ i ] + lead ) % len ( kids ) NEW_LINE lead = x NEW_LINE if lead == len ( kids ) - 1 : NEW_LINE INDENT lead = 0 NEW_LINE DEDENT print ( kids . pop ( x ) , end = ' \u2581 ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3292_A", "java": ["class GFG { static int sum [ ] = new int [ 1000005 ] ; static int toInt ( char x ) { return x - '0' ; } static void prepareSum ( String s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum [ i + 1 ] = sum [ i ] + toInt ( s . charAt ( i ) ) ; } } static void query ( int l , int r ) { if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) { System . out . println ( \" Divisible \u2581 by \u2581 3\" ) ; } else { System . out . println ( \" Not \u2581 divisible \u2581 by \u2581 3\" ) ; } } public static void main ( String [ ] args ) { String n = \"12468236544\" ; prepareSum ( n ) ; query ( 0 , 1 ) ; query ( 1 , 2 ) ; query ( 3 , 6 ) ; query ( 0 , 10 ) ; } }"], "python": ["sum = [ 0 for i in range ( 1000005 ) ] NEW_LINE def toInt ( x ) : NEW_LINE INDENT return int ( x ) NEW_LINE DEDENT def prepareSum ( s ) : NEW_LINE INDENT sum [ 0 ] = 0 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) : NEW_LINE INDENT print ( \" Divisible \u2581 by \u2581 3\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 divisible \u2581 by \u2581 3\" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"12468236544\" NEW_LINE prepareSum ( n ) NEW_LINE query ( 0 , 1 ) NEW_LINE query ( 1 , 2 ) NEW_LINE query ( 3 , 6 ) NEW_LINE query ( 0 , 10 ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p124_A", "java": ["import java . util . Arrays ; public final class p124 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p124 ( ) . run ( ) ) ; } private static final int LIMIT = 100000 ; public String run ( ) { int [ ] rads = new int [ LIMIT + 1 ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } IntPair [ ] data = new IntPair [ LIMIT ] ; for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = new IntPair ( rads [ i + 1 ] , i + 1 ) ; Arrays . sort ( data ) ; return Integer . toString ( data [ 10000 - 1 ] . b ) ; } private static final class IntPair implements Comparable < IntPair > { public final int a ; public final int b ; public IntPair ( int a , int b ) { this . a = a ; this . b = b ; } public int compareTo ( IntPair other ) { if ( a != other . a ) return Integer . compare ( a , other . a ) ; else return Integer . compare ( b , other . b ) ; } } }"], "python": ["def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 0 ] + [ 1 ] * LIMIT NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT data = sorted ( ( rad , i ) for ( i , rad ) in enumerate ( rads ) ) NEW_LINE return str ( data [ 10000 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1266_B", "java": ["import java . util . * ; import java . io . * ; public class MyClass { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { long x = Long . parseLong ( s [ i ] ) ; if ( x < 15 ) { System . out . println ( \" NO \" ) ; continue ; } x = x % 14 ; if ( x >= 1 && x <= 6 ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }", "import java . util . * ; import java . io . * ; public class Samyak { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long x = sc . nextLong ( ) ; long temp = x / 14 ; temp = temp * 14 ; if ( x - temp <= 6 && x - temp > 0 && x > 14 ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }"], "python": ["t = int ( input ( ) ) NEW_LINE x = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] NEW_LINE for xi in x : NEW_LINE INDENT val = xi % 14 NEW_LINE if xi > 14 and val <= 6 and val > 0 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE str_inp = lambda : input ( ) NEW_LINE a = input ( ) NEW_LINE for j in list ( map ( int , input ( ) . split ( ) ) ) : NEW_LINE INDENT print ( \" YNEOS \" [ 1 - ( j % 14 in range ( 1 , 7 ) and j > 14 ) : : 2 ] ) NEW_LINE DEDENT", "import math as mt NEW_LINE from collections import defaultdict , deque NEW_LINE from bisect import bisect_left as b_l NEW_LINE from bisect import bisect_right as b_r NEW_LINE import sys NEW_LINE mod = 10 ** 9 + 7 NEW_LINE t = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE for i in a : NEW_LINE INDENT if ( i > 14 and ( i % 14 > 0 and i % 14 < 7 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "x = int ( input ( ) ) NEW_LINE y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( x ) : NEW_LINE INDENT if 1 <= y [ i ] % 14 <= 6 and y [ i ] > 14 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "def f ( n ) : NEW_LINE INDENT return ' YES ' if n > 14 and 1 <= n % 14 <= 6 else ' NO ' NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE [ print ( f ( int ( c ) ) ) for c in input ( ) . split ( ) ] NEW_LINE"]}
{"id": "atcoder_ARC069_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long N = sc . nextLong ( ) ; long M = sc . nextLong ( ) ; if ( N >= M / 2 ) { System . out . println ( M / 2 ) ; return ; } System . out . println ( N + ( M - 2 * N ) / 4 ) ; } }", "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Main implements Runnable { private void solve ( ) throws IOException { long N = nextLong ( ) ; long M = nextLong ( ) ; long low = 0L ; long high = 1_000_000_000_000_00L ; long best = 0L ; while ( low <= high ) { long mid = low + ( high - low ) / 2L ; if ( can ( mid , N , M ) ) { best = Math . max ( best , mid ) ; low = mid + 1 ; } else high = mid - 1 ; } writer . println ( best ) ; } private boolean can ( long packs , long n , long m ) { if ( m / 2 < packs ) return false ; m -= packs * 2L ; if ( n >= packs ) return true ; long need = 0L ; if ( n < packs ) { need += ( packs - n ) * 2L ; } return m >= need ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } BufferedReader reader ; StringTokenizer tokenizer ; PrintWriter writer ; public void run ( ) { try { reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; tokenizer = null ; writer = new PrintWriter ( System . out ) ; solve ( ) ; reader . close ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws IOException { return Double . parseDouble ( nextToken ( ) ) ; } short nextShort ( ) throws IOException { return Short . parseShort ( nextToken ( ) ) ; } String nextToken ( ) throws IOException { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; } }", "import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . HashSet ; import java . util . Scanner ; import java . util . Stack ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long m = sc . nextLong ( ) ; long ans = 0 ; if ( 2 * n <= m ) { ans += n ; m -= 2 * n ; ans += m / 4 ; } else { if ( m % 2 != 0 ) { ans = ( m - 1 ) / 2 ; } else { ans = m / 2 ; } } System . out . println ( ans ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long N = sc . nextLong ( ) ; long M = sc . nextLong ( ) ; if ( N * 2 > M ) System . out . println ( M / 2 ) ; else System . out . println ( ( N * 2 + M ) / 4 ) ; } }", "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { static Scanner scanner ; public static void main ( String [ ] args ) { scanner = new Scanner ( System . in ) ; long n = gl ( ) ; long m = gl ( ) ; if ( n >= Math . floorDiv ( m , 2 ) ) { System . out . println ( Math . floorDiv ( m , 2 ) ) ; } else { long c = n ; m -= 2 * n ; c += Math . floorDiv ( m , 4 ) ; System . out . println ( c ) ; } } public static String gs ( ) { return scanner . next ( ) ; } public static int gi ( ) { return Integer . parseInt ( scanner . next ( ) ) ; } public static long gl ( ) { return Long . parseLong ( scanner . next ( ) ) ; } public static double gd ( ) { return Double . parseDouble ( scanner . next ( ) ) ; } }"], "python": ["def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m > n * 2 : NEW_LINE INDENT print ( n + ( m - n * 2 ) // 4 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( m // 2 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from math import floor NEW_LINE s_num , c_num = tuple ( int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ) NEW_LINE ans = 0 NEW_LINE temp = s_num * 2 NEW_LINE if c_num <= temp : NEW_LINE INDENT ans += floor ( c_num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += s_num NEW_LINE ans += floor ( ( c_num - temp ) / 4 ) NEW_LINE DEDENT print ( ans ) NEW_LINE", "def examC ( ) : NEW_LINE INDENT N , M = LI ( ) NEW_LINE if N - M // 2 >= 0 : NEW_LINE INDENT ans = M // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = N + ( M - N * 2 ) // 4 NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT def examD ( ) : NEW_LINE INDENT return NEW_LINE DEDENT def examE ( ) : NEW_LINE INDENT return NEW_LINE DEDENT def examF ( ) : NEW_LINE INDENT ans = 0 NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT import sys , copy , bisect , itertools , heapq , math NEW_LINE from heapq import heappop , heappush , heapify NEW_LINE from collections import Counter , defaultdict , deque NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LSI ( ) : return list ( map ( str , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def SI ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE global mod , mod2 , inf , alphabet NEW_LINE mod = 10 ** 9 + 7 NEW_LINE mod2 = 998244353 NEW_LINE inf = 10 ** 18 NEW_LINE alphabet = [ chr ( ord ( ' a ' ) + i ) for i in range ( 26 ) ] NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT examC ( ) NEW_LINE DEDENT", "N , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE def check ( x ) : NEW_LINE INDENT if M < 2 * x : NEW_LINE INDENT return False NEW_LINE DEDENT s = max ( 0 , x - N ) NEW_LINE if M < 2 * s + 2 * x : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT ok = 0 NEW_LINE ng = 2 ** 60 NEW_LINE while ng - ok > 1 : NEW_LINE INDENT m = ( ok + ng ) // 2 NEW_LINE if check ( m ) : NEW_LINE INDENT ok = m NEW_LINE DEDENT else : NEW_LINE INDENT ng = m NEW_LINE DEDENT DEDENT print ( ok ) NEW_LINE", "def solve ( N , M ) : NEW_LINE INDENT ans = min ( M // 2 , N ) NEW_LINE x = ( M - 2 * N ) // 4 NEW_LINE for i in range ( x - 5 , x + 6 ) : NEW_LINE INDENT if i >= 0 and M >= 2 * i : NEW_LINE INDENT M2 = M - 2 * i NEW_LINE N2 = N + i NEW_LINE ans = max ( ans , min ( M2 // 2 , N2 ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE ret = solve ( N , M ) NEW_LINE print ( ret ) NEW_LINE"]}
{"id": "geeksforgeeks_1449_A", "java": ["import java . util . * ; class GFG { static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { LinkedList < Integer > Di = new LinkedList < > ( ) ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . add ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + \" \u2581 \" ) ; else System . out . print ( \"0\" + \" \u2581 \" ) ; while ( ( ! Di . isEmpty ( ) ) && Di . peek ( ) < ( i - k + 1 ) ) Di . remove ( ) ; if ( arr [ i ] < 0 ) Di . add ( i ) ; } if ( ! Di . isEmpty ( ) ) System . out . print ( arr [ Di . peek ( ) ] + \" \u2581 \" ) ; else System . out . print ( \"0\" + \" \u2581 \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 } ; int n = arr . length ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; } }"], "python": ["from collections import deque NEW_LINE def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT Di = deque ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT for i in range ( k , n ) : NEW_LINE INDENT if ( not Di ) : NEW_LINE INDENT print ( 0 , end = ' \u2581 ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = ' \u2581 ' ) ; NEW_LINE DEDENT while Di and Di [ 0 ] <= ( i - k ) : NEW_LINE INDENT Di . popleft ( ) NEW_LINE DEDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT Di . append ( i ) ; NEW_LINE DEDENT DEDENT if not Di : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ Di [ 0 ] ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) ; NEW_LINE DEDENT"]}
{"id": "aizu_p00506_A", "java": ["import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; int [ ] v = new int [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { v [ i ] = sc . nextInt ( ) ; } ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= ( int ) Math . sqrt ( v [ 0 ] ) ; ++ i ) { if ( v [ 0 ] % i != 0 ) continue ; boolean ok = true ; for ( int j = 1 ; j < N ; ++ j ) { if ( v [ j ] % i != 0 ) { ok = false ; break ; } } if ( ok ) ans . add ( i ) ; if ( i * i != v [ 0 ] ) { ok = true ; for ( int j = 1 ; j < N ; ++ j ) { if ( v [ j ] % ( v [ 0 ] / i ) != 0 ) { ok = false ; break ; } } if ( ok ) ans . add ( v [ 0 ] / i ) ; } } Collections . sort ( ans ) ; for ( int a : ans ) { System . out . println ( a ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . List ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) { BufferedReader bfr = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = \" \" ; StringTokenizer stk ; try { str = bfr . readLine ( ) ; if ( str == null ) { System . exit ( 0 ) ; } int suuji = Integer . parseInt ( str ) ; str = bfr . readLine ( ) ; if ( str == null ) { System . exit ( 0 ) ; } stk = new StringTokenizer ( str , \" \u2581 \" ) ; int [ ] moto = new int [ suuji ] ; int minimum = 99999999 ; int aa = 0 ; while ( stk . hasMoreTokens ( ) ) { moto [ aa ] = Integer . parseInt ( stk . nextToken ( ) ) ; aa ++ ; } List < Integer > yakusu = new ArrayList < > ( ) ; for ( int i = 0 ; i < suuji ; i ++ ) { if ( minimum > moto [ i ] ) { minimum = moto [ i ] ; } } int [ ] amari = new int [ suuji ] ; int amariwa = 0 ; for ( int i = 1 ; i <= minimum ; i ++ ) { for ( int j = 0 ; j < suuji ; j ++ ) { amari [ j ] = moto [ j ] % i ; amariwa += amari [ j ] ; } if ( amariwa == 0 ) { yakusu . add ( i ) ; } amariwa = 0 ; } for ( Integer s : yakusu ) { System . out . println ( s ) ; } } catch ( IOException e ) { } catch ( NumberFormatException er ) { } } }", "import java . io . * ; import java . util . * ; import java . math . * ; class Main { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { BufferedReader sc = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int n = Integer . valueOf ( sc . readLine ( ) ) ; String [ ] st = sc . readLine ( ) . split ( \" \u2581 \" ) ; int map [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) map [ i ] = Integer . valueOf ( st [ i ] ) ; int c = gcd ( Math . max ( map [ 0 ] , map [ 1 ] ) , Math . min ( map [ 0 ] , map [ 1 ] ) ) ; if ( n == 3 ) c = gcd ( Math . max ( c , map [ 2 ] ) , Math . min ( c , map [ 2 ] ) ) ; for ( int i = 1 ; i <= c ; i ++ ) if ( c % i == 0 ) System . out . println ( i ) ; } catch ( Exception e ) { System . out . println ( \" Error \" ) ; } } }", "import java . io . IOException ; import java . io . InputStreamReader ; import java . io . BufferedReader ; public class Main { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int num = Integer . valueOf ( br . readLine ( ) ) ; String [ ] inputs = br . readLine ( ) . split ( \" \u2581 \" ) ; int [ ] input = new int [ num ] ; for ( int i = 0 ; i < num ; i ++ ) input [ i ] = Integer . valueOf ( inputs [ i ] ) ; int GCD = gcd ( Math . max ( input [ 0 ] , input [ 1 ] ) , Math . min ( input [ 0 ] , input [ 1 ] ) ) ; if ( num == 3 ) GCD = gcd ( Math . max ( GCD , input [ 2 ] ) , Math . min ( GCD , input [ 2 ] ) ) ; for ( int i = 1 ; i <= GCD ; i ++ ) { if ( ( GCD % i ) == 0 ) System . out . println ( i ) ; } } }", "import java . util . Scanner ; public class Main { private static void kou2 ( int a , int b ) { int min = Math . min ( a , b ) ; for ( int i = 1 ; i <= min ; i ++ ) { if ( a % i + b % i == 0 ) System . out . println ( i ) ; } } private static void kou3 ( int a , int b , int c ) { int min = Math . min ( c , Math . min ( a , b ) ) ; for ( int i = 1 ; i <= min ; i ++ ) { if ( a % i + b % i + c % i == 0 ) System . out . println ( i ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a , b , c ; a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; if ( n == 3 ) { c = sc . nextInt ( ) ; kou3 ( a , b , c ) ; } if ( n == 2 ) kou2 ( a , b ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE if n == 2 : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE small = min ( a , b ) NEW_LINE large = max ( a , b ) NEW_LINE for i in range ( 1 , min ( small , large // 2 ) ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE small = min ( a , b , c ) NEW_LINE large = max ( a , b , c ) NEW_LINE for i in range ( 1 , min ( small , large // 2 ) ) : NEW_LINE INDENT if a % i == 0 and b % i == 0 and c % i == 0 : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT", "def gcd ( n1 , n2 ) : NEW_LINE INDENT if n1 < n2 : NEW_LINE INDENT n1 , n2 = n2 , n1 NEW_LINE DEDENT if n1 == n2 or n2 == 0 : NEW_LINE INDENT return n1 NEW_LINE DEDENT n1 , n2 = n2 , ( n1 % n2 ) NEW_LINE return gcd ( n1 , n2 ) NEW_LINE DEDENT def make_divisor_list ( number ) : NEW_LINE INDENT divisor_list = [ ] NEW_LINE if number == 1 : NEW_LINE INDENT return [ 1 ] NEW_LINE DEDENT for i in range ( 1 , number // 2 + 1 ) : NEW_LINE INDENT if number % i == 0 : NEW_LINE INDENT divisor_list . append ( i ) NEW_LINE DEDENT DEDENT divisor_list . append ( number ) NEW_LINE return divisor_list NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE number_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if N == 2 : NEW_LINE INDENT GCD = gcd ( number_list [ 0 ] , number_list [ 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT GCD = gcd ( gcd ( number_list [ 0 ] , number_list [ 1 ] ) , number_list [ 2 ] ) NEW_LINE DEDENT [ print ( element ) for element in make_divisor_list ( GCD ) ] NEW_LINE DEDENT", "import sys NEW_LINE import math NEW_LINE n = int ( sys . stdin . readline ( ) . rstrip ( ) ) NEW_LINE nums = list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) NEW_LINE g = nums [ 0 ] NEW_LINE for num in nums [ 1 : ] : NEW_LINE INDENT g = math . gcd ( g , num ) NEW_LINE DEDENT ans = set ( ) NEW_LINE for i in range ( 1 , int ( math . sqrt ( g ) ) + 1 ) : NEW_LINE INDENT if g % i == 0 : NEW_LINE INDENT ans . add ( i ) NEW_LINE ans . add ( g // i ) NEW_LINE DEDENT DEDENT for n in sorted ( ans ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT", "input ( ) NEW_LINE n = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE [ print ( x ) for x in range ( 1 , min ( n ) + 1 ) if sum ( m % x for m in n ) == 0 ] NEW_LINE", "n = int ( input ( ) ) NEW_LINE Ans = [ ] NEW_LINE if n == 2 : NEW_LINE INDENT l = input ( ) . split ( ) NEW_LINE a = int ( l [ 0 ] ) NEW_LINE b = int ( l [ 1 ] ) NEW_LINE if a >= b : NEW_LINE INDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT if b % i == 0 : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT Ans . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT if b % i == 0 : NEW_LINE INDENT Ans . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT l = input ( ) . split ( ) NEW_LINE p = [ ] NEW_LINE p . append ( int ( l [ 0 ] ) ) NEW_LINE p . append ( int ( l [ 1 ] ) ) NEW_LINE p . append ( int ( l [ 2 ] ) ) NEW_LINE c = max ( p ) NEW_LINE p . remove ( c ) NEW_LINE a = p [ 0 ] NEW_LINE b = p [ 1 ] NEW_LINE if a >= b : NEW_LINE INDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT if b % i == 0 : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT if c % i == 0 : NEW_LINE INDENT Ans . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT if b % i == 0 : NEW_LINE INDENT if c % i == 0 : NEW_LINE INDENT Ans . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT DEDENT for A in Ans : NEW_LINE INDENT print ( A ) NEW_LINE DEDENT"]}
{"id": "aizu_p00173_A", "java": ["import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static String name ; static int num ; public static void main ( String [ ] args ) { for ( int i = 0 ; i < 9 ; i ++ ) { read_and_solve ( ) ; } } static void read_and_solve ( ) { int res = 0 ; int temp = 0 ; name = sc . next ( ) ; num = sc . nextInt ( ) ; temp = num ; res = num * 200 ; num = sc . nextInt ( ) ; res = res + num * 300 ; num = num + temp ; System . out . println ( name + \" \u2581 \" + num + \" \u2581 \" + res ) ; } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int a , b ; for ( ; sc . hasNext ( ) ; ) { out . print ( sc . next ( ) + \" \u2581 \" ) ; a = sc . nextInt ( ) ; b = sc . nextInt ( ) ; out . println ( ( a + b ) + \" \u2581 \" + ( 200 * a + 300 * b ) ) ; } sc . close ( ) ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import java . util . Scanner ; public class Main { public static int [ ] Fee = { 200 , 300 } ; public static int Num_Classes = 9 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String [ ] className = new String [ Num_Classes ] ; int [ ] [ ] visitors = new int [ Num_Classes ] [ 2 ] ; for ( int i = 0 ; i < Num_Classes ; i ++ ) { className [ i ] = sc . next ( ) ; visitors [ i ] [ 0 ] = sc . nextInt ( ) ; visitors [ i ] [ 1 ] = sc . nextInt ( ) ; } sc . close ( ) ; int [ ] [ ] data = new int [ Num_Classes ] [ 2 ] ; for ( int i = 0 ; i < Num_Classes ; i ++ ) { data [ i ] [ 0 ] = visitors [ i ] [ 0 ] + visitors [ i ] [ 1 ] ; data [ i ] [ 1 ] = visitors [ i ] [ 0 ] * Fee [ 0 ] + visitors [ i ] [ 1 ] * Fee [ 1 ] ; } for ( int i = 0 ; i < Num_Classes ; i ++ ) { System . out . printf ( \" % s \u2581 % d \u2581 % d \\n \" , className [ i ] , data [ i ] [ 0 ] , data [ i ] [ 1 ] ) ; } } }", "import java . util . ArrayList ; import java . util . Scanner ; class Class_Visitor { private String class_name ; private int visitor_am ; private int visitor_pm ; Class_Visitor ( String class_name , int visitor_am , int visitor_pm ) { setClass_name ( class_name ) ; setVisitor_am ( visitor_am ) ; setVisitor_pm ( visitor_pm ) ; } public void setClass_name ( String class_name ) { this . class_name = class_name ; } public void setVisitor_am ( int visitor_am ) { this . visitor_am = visitor_am ; } public void setVisitor_pm ( int visitor_pm ) { this . visitor_pm = visitor_pm ; } public String getClass_name ( ) { return class_name ; } public int getVisitor_am ( ) { return visitor_am ; } public int getVisitor_pm ( ) { return visitor_pm ; } } public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { ArrayList < Class_Visitor > vis = new ArrayList < Class_Visitor > ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) { String [ ] data = sc . nextLine ( ) . split ( \" \u2581 \" ) ; Class_Visitor c_v = new Class_Visitor ( data [ 0 ] , Integer . parseInt ( data [ 1 ] ) , Integer . parseInt ( data [ 2 ] ) ) ; vis . add ( c_v ) ; String c_name = vis . get ( i ) . getClass_name ( ) ; int v_sum = vis . get ( i ) . getVisitor_am ( ) + vis . get ( i ) . getVisitor_pm ( ) ; int f_sum = 200 * vis . get ( i ) . getVisitor_am ( ) + 300 * vis . get ( i ) . getVisitor_pm ( ) ; System . out . printf ( \" % s \u2581 % d \u2581 % d \\n \" , c_name , v_sum , f_sum ) ; } } }", "import static java . util . Arrays . deepToString ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void tr ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } Scanner sc = new Scanner ( System . in ) ; public void run ( ) { for ( ; sc . hasNext ( ) ; ) { String s = sc . next ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( s + \" \u2581 \" + ( a + b ) + \" \u2581 \" + ( a * 200 + b * 300 ) ) ; } } }"], "python": ["for i in range ( 9 ) : NEW_LINE INDENT name , a , p = map ( str , input ( ) . split ( ) ) NEW_LINE print ( name , int ( a ) + int ( p ) , int ( a ) * 200 + int ( p ) * 300 ) NEW_LINE DEDENT", "k = 0 NEW_LINE a = [ 0 , 0 , 0 ] NEW_LINE while k < 27 : NEW_LINE INDENT a [ 0 ] , a [ 1 ] , a [ 2 ] = input ( ) . split ( ) NEW_LINE x = int ( a [ 1 ] ) + int ( a [ 2 ] ) NEW_LINE y = 200 * int ( a [ 1 ] ) + 300 * int ( a [ 2 ] ) NEW_LINE print ( a [ 0 ] , x , y ) NEW_LINE k = k + 3 NEW_LINE DEDENT", "classmate = [ ] NEW_LINE morning = [ ] NEW_LINE afternoon = [ ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT a , b , c = input ( ) . split ( ) NEW_LINE classmate . append ( a ) NEW_LINE morning . append ( int ( b ) ) NEW_LINE afternoon . append ( int ( c ) ) NEW_LINE DEDENT for i in range ( 9 ) : NEW_LINE INDENT print ( classmate [ i ] , morning [ i ] + afternoon [ i ] , morning [ i ] * 200 + afternoon [ i ] * 300 ) NEW_LINE DEDENT", "list = [ ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT n , a , b = input ( ) . split ( ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE list . append ( ( n , int ( a ) , int ( b ) ) ) NEW_LINE print ( n , end = ' \u2581 ' ) NEW_LINE print ( a + b , end = ' \u2581 ' ) NEW_LINE print ( a * 200 + b * 300 ) NEW_LINE DEDENT", "i = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT a , b , c = map ( str , input ( ) . split ( ) ) NEW_LINE b = int ( b ) NEW_LINE c = int ( c ) NEW_LINE print ( a , b + c , b * 200 + c * 300 ) NEW_LINE i += 1 NEW_LINE DEDENT"]}
{"id": "aizu_p02290_A", "java": ["import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; double x1 , y1 , x2 , y2 , xq , yq , ax , ay ; double m1 , m2 , l1 , l2 ; int q ; x1 = scan . nextDouble ( ) ; y1 = scan . nextDouble ( ) ; x2 = scan . nextDouble ( ) ; y2 = scan . nextDouble ( ) ; m1 = ( y2 - y1 ) / ( x2 - x1 ) ; l1 = y1 - ( m1 * x1 ) ; m2 = - 1.0 / m1 ; q = scan . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { xq = scan . nextDouble ( ) ; yq = scan . nextDouble ( ) ; if ( x1 == x2 ) { ax = x1 ; ay = yq ; } else if ( y1 == y2 ) { ax = xq ; ay = y1 ; } else { l2 = yq - ( m2 * xq ) ; ax = ( l2 - l1 ) / ( m1 - m2 ) ; ay = ( l2 * m1 - l1 * m2 ) / ( m1 - m2 ) ; } System . out . println ( ax + \" \u2581 \" + ay ) ; } scan . close ( ) ; } }", "import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJCGL_1C ( ) . doIt ( ) ; } class AOJCGL_1C { private Point2D projection ( Line2D l , Point2D p2 ) { double kyori = l . getP1 ( ) . distance ( l . getP2 ( ) ) ; double angle = angle ( l . getP1 ( ) , l . getP2 ( ) , p2 ) ; double t = l . getP1 ( ) . distance ( p2 ) * Math . cos ( angle ) ; Point2D result = new Point2D . Double ( l . getP1 ( ) . getX ( ) + ( l . getP2 ( ) . getX ( ) - l . getP1 ( ) . getX ( ) ) * t / kyori , l . getP1 ( ) . getY ( ) + ( l . getP2 ( ) . getY ( ) - l . getP1 ( ) . getY ( ) ) * t / kyori ) ; return result ; } private double angle ( Point2D p0 , Point2D p1 , Point2D p2 ) { return Math . atan2 ( p2 . getY ( ) - p0 . getY ( ) , p2 . getX ( ) - p0 . getX ( ) ) - Math . atan2 ( p1 . getY ( ) - p0 . getY ( ) , p1 . getX ( ) - p0 . getX ( ) ) ; } void doIt ( ) { Point2D p0 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; Point2D p1 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; int q = in . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { Point2D p2 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; Point2D ans = projection ( new Line2D . Double ( p0 , p1 ) , p2 ) ; System . out . printf ( \" % .9f \u2581 % .9f \\n \" , ans . getX ( ) , ans . getY ( ) ) ; } } } }", "import java . util . Scanner ; public class Main { public static void calc ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { if ( y1 == y2 ) System . out . println ( px + \" \u2581 \" + y1 ) ; else if ( x1 == x2 ) System . out . println ( x1 + \" \u2581 \" + py ) ; else { double katamuki1 = ( y2 - y1 ) / ( x2 - x1 ) ; double seppen1 = - katamuki1 * x1 + y1 ; double katamuki2 = - 1.0 / katamuki1 ; double seppen2 = - katamuki2 * px + py ; double ansx = ( seppen2 - seppen1 ) / ( katamuki1 - katamuki2 ) ; double ansy = ansx * katamuki1 + seppen1 ; System . out . println ( ansx + \" \u2581 \" + ansy ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int px = sc . nextInt ( ) ; int py = sc . nextInt ( ) ; calc ( ( double ) x1 , ( double ) y1 , ( double ) x2 , ( double ) y2 , ( double ) px , ( double ) py ) ; } } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; double xp1 , xp2 , yp1 , yp2 ; int q ; double [ ] xp , yp ; double ansx , ansy , t ; int i ; xp1 = sc . nextDouble ( ) ; yp1 = sc . nextDouble ( ) ; xp2 = sc . nextDouble ( ) ; yp2 = sc . nextDouble ( ) ; q = sc . nextInt ( ) ; xp = new double [ q ] ; yp = new double [ q ] ; for ( i = 0 ; i < q ; i ++ ) { xp [ i ] = sc . nextDouble ( ) ; yp [ i ] = sc . nextDouble ( ) ; } sc . close ( ) ; for ( i = 0 ; i < q ; i ++ ) { t = ( xp2 - xp1 ) * ( xp [ i ] - xp1 ) + ( yp2 - yp1 ) * ( yp [ i ] - yp1 ) ; t = t / ( ( xp2 - xp1 ) * ( xp2 - xp1 ) + ( yp2 - yp1 ) * ( yp2 - yp1 ) ) ; ansx = xp1 + t * ( xp2 - xp1 ) ; ansy = yp1 + t * ( yp2 - yp1 ) ; System . out . printf ( \" % .10f \u2581 % .10f % n \" , ansx , ansy ) ; } } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import java . util . * ; import java . lang . * ; public class Main { static final int INF = ( 1 << 31 ) - 1 ; static final int MAXN = 11111 ; static double a , b , c ; static double a1 , b1 , c1 ; static double resX , resY ; public static void main ( String [ ] args ) throws Exception { Scanner input = new Scanner ( System . in ) ; int x0 , y0 , x1 , y1 , x2 , y2 ; int q ; x0 = input . nextInt ( ) ; y0 = input . nextInt ( ) ; x1 = input . nextInt ( ) ; y1 = input . nextInt ( ) ; lineOf ( x0 , y0 , y1 - y0 , x0 - x1 ) ; q = input . nextInt ( ) ; for ( int i = 0 ; i < q ; ++ i ) { x2 = input . nextInt ( ) ; y2 = input . nextInt ( ) ; line1Of ( x2 , y2 , x0 - x1 , y0 - y1 ) ; intersectionOf2Lines ( ) ; System . out . printf ( \" % .8f \u2581 % .8f \\n \" , resX , resY ) ; } } static void lineOf ( double x1 , double y1 , double vx , double vy ) { a = vx ; b = vy ; c = - vx * x1 - vy * y1 ; } static void line1Of ( double x1 , double y1 , double vx , double vy ) { a1 = vx ; b1 = vy ; c1 = - vx * x1 - vy * y1 ; } static void intersectionOf2Lines ( ) { double d = a * b1 - a1 * b ; double dx = b * c1 - b1 * c ; double dy = c * a1 - c1 * a ; resX = dx / d ; resY = dy / d ; } }"], "python": ["def dot ( a , b ) : return a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 1 ] NEW_LINE def projection ( a , b ) : return [ x * dot ( a , b ) / dot ( a , a ) for x in a ] NEW_LINE x1 , y1 , x2 , y2 = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ x2 - x1 , y2 - y1 ] NEW_LINE q = int ( input ( ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x , y = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE b = [ x - x1 , y - y1 ] NEW_LINE c = projection ( a , b ) NEW_LINE print ( c [ 0 ] + x1 , c [ 1 ] + y1 ) NEW_LINE DEDENT", "class Vec2 : NEW_LINE INDENT def __init__ ( self , y , x ) : NEW_LINE INDENT self . y = y NEW_LINE self . x = x NEW_LINE DEDENT def __add__ ( self , other ) : NEW_LINE INDENT assert isinstance ( other , Vec2 ) NEW_LINE return Vec2 ( self . y + other . y , self . x + other . x ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT assert isinstance ( other , Vec2 ) NEW_LINE return Vec2 ( self . y - other . y , self . x - other . x ) NEW_LINE DEDENT def __mul__ ( self , other ) : NEW_LINE INDENT if isinstance ( other , Vec2 ) : NEW_LINE INDENT return self . y * other . y + self . x * other . x NEW_LINE DEDENT else : NEW_LINE INDENT return Vec2 ( self . y * other , self . x * other ) NEW_LINE DEDENT DEDENT def __str__ ( self ) : NEW_LINE INDENT return str ( ( self . y , self . x ) ) NEW_LINE DEDENT def size ( self ) : NEW_LINE INDENT return ( self . x ** 2 + self . y ** 2 ) ** 0.5 NEW_LINE DEDENT def projection ( self , vec ) : NEW_LINE INDENT p = self * vec / self . size ( ) ** 2 NEW_LINE return self * p NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT x_p1 , y_p1 , x_p2 , y_p2 = map ( int , input ( ) . split ( ) ) NEW_LINE p1 = Vec2 ( y_p1 , x_p1 ) NEW_LINE p2 = Vec2 ( y_p2 , x_p2 ) NEW_LINE p1p2 = p2 - p1 NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT x_q , y_q = map ( int , input ( ) . split ( ) ) NEW_LINE p1q = Vec2 ( y_q , x_q ) - p1 NEW_LINE p1x = p1p2 . projection ( p1q ) NEW_LINE x = p1 + p1x NEW_LINE print ( x . x , x . y ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE from itertools import starmap NEW_LINE readline = sys . stdin . readline NEW_LINE class Segment ( object ) : NEW_LINE INDENT __slots__ = ( ' fi ' , ' se ' ) NEW_LINE def __init__ ( self , fi , se ) : NEW_LINE INDENT self . fi = fi NEW_LINE self . se = se NEW_LINE DEDENT DEDENT def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def norm ( base ) : NEW_LINE INDENT return abs ( base ) ** 2 NEW_LINE DEDENT def project ( s , p2 ) : NEW_LINE INDENT base = s . fi - s . se NEW_LINE r = dot ( p2 - s . fi , base ) / norm ( base ) NEW_LINE return s . fi + base * r NEW_LINE DEDENT s = Segment ( * list ( starmap ( complex , zip ( * [ map ( int , readline ( ) . split ( ) ) ] * 2 ) ) ) ) NEW_LINE n = int ( readline ( ) ) NEW_LINE for _ in [ 0 ] * n : NEW_LINE INDENT p2 = complex ( * [ int ( i ) for i in readline ( ) . split ( ) ] ) NEW_LINE ap = project ( s , p2 ) NEW_LINE print ( ap . real , ap . imag ) NEW_LINE DEDENT", "sx , sy , ex , ey = ( int ( n ) for n in input ( ) . split ( \" \u2581 \" ) ) NEW_LINE trial = int ( input ( ) ) NEW_LINE for _ in range ( trial ) : NEW_LINE INDENT x , y = ( int ( n ) for n in input ( ) . split ( \" \u2581 \" ) ) NEW_LINE if sx == ex : NEW_LINE INDENT print ( sx , y ) NEW_LINE DEDENT elif sy == ey : NEW_LINE INDENT print ( x , sy ) NEW_LINE DEDENT else : NEW_LINE INDENT grad = ( ey - sy ) / ( ex - sx ) NEW_LINE y_seg = sy - ( grad * sx ) NEW_LINE per_grad = - 1 / grad NEW_LINE per_y_seg = y - ( per_grad * x ) NEW_LINE ans_x = ( y_seg - per_y_seg ) / ( - 1 * ( grad - per_grad ) ) NEW_LINE ans_y = per_grad * ans_x + per_y_seg NEW_LINE print ( ans_x , ans_y ) NEW_LINE DEDENT DEDENT", "from math import sqrt NEW_LINE def inner_product ( vect1 , vect2 ) : NEW_LINE INDENT return sum ( [ ( v1_el * v2_el ) for v1_el , v2_el in zip ( vect1 , vect2 ) ] ) NEW_LINE DEDENT def vector_abs ( vect ) : NEW_LINE INDENT return sqrt ( sum ( [ element ** 2 for element in vect ] ) ) NEW_LINE DEDENT def direction_unit_vector ( p_from , p_to ) : NEW_LINE INDENT d_vector = [ ( xt - xf ) for xt , xf in zip ( p_to , p_from ) ] NEW_LINE d_u_vector = [ element / vector_abs ( d_vector ) for element in d_vector ] NEW_LINE return d_u_vector NEW_LINE DEDENT def projection ( origin , line_from , line_to ) : NEW_LINE INDENT direction_unit = direction_unit_vector ( line_from , line_to ) NEW_LINE origin_d_vector = [ ( org - lf ) for org , lf in zip ( origin , line_from ) ] NEW_LINE inject_dist = inner_product ( direction_unit , origin_d_vector ) NEW_LINE on_line_vect = [ inject_dist * element for element in direction_unit ] NEW_LINE return [ olv_el + lf_el for olv_el , lf_el in zip ( on_line_vect , line_from ) ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xy_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE p1_list = xy_list [ : 2 ] NEW_LINE p2_list = xy_list [ 2 : ] NEW_LINE Q = int ( input ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT p_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x_list = projection ( p_list , p1_list , p2_list ) NEW_LINE print ( ' \u2581 ' . join ( map ( str , x_list ) ) ) NEW_LINE DEDENT DEDENT"]}
{"id": "aizu_p02291_A", "java": ["public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; double xp1 , xp2 , yp1 , yp2 ; int q ; double [ ] xp , yp ; double ansx , ansy , t ; int i ; xp1 = sc . nextDouble ( ) ; yp1 = sc . nextDouble ( ) ; xp2 = sc . nextDouble ( ) ; yp2 = sc . nextDouble ( ) ; q = sc . nextInt ( ) ; xp = new double [ q ] ; yp = new double [ q ] ; for ( i = 0 ; i < q ; i ++ ) { xp [ i ] = sc . nextDouble ( ) ; yp [ i ] = sc . nextDouble ( ) ; } sc . close ( ) ; for ( i = 0 ; i < q ; i ++ ) { t = ( xp2 - xp1 ) * ( xp [ i ] - xp1 ) + ( yp2 - yp1 ) * ( yp [ i ] - yp1 ) ; t = t / ( ( xp2 - xp1 ) * ( xp2 - xp1 ) + ( yp2 - yp1 ) * ( yp2 - yp1 ) ) ; ansx = xp1 + t * ( xp2 - xp1 ) ; ansx = ansx + ( ansx - xp [ i ] ) ; ; ansy = yp1 + t * ( yp2 - yp1 ) ; ansy = ansy + ( ansy - yp [ i ] ) ; System . out . printf ( \" % .10f \u2581 % .10f % n \" , ansx , ansy ) ; } } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import java . util . * ; import java . lang . * ; public class Main { static final int INF = ( 1 << 31 ) - 1 ; static final int MAXN = 11111 ; static double a , b , c ; static double a1 , b1 , c1 ; static double resX , resY ; public static void main ( String [ ] args ) throws Exception { Scanner input = new Scanner ( System . in ) ; int x0 , y0 , x1 , y1 , x2 , y2 ; int q ; x0 = input . nextInt ( ) ; y0 = input . nextInt ( ) ; x1 = input . nextInt ( ) ; y1 = input . nextInt ( ) ; lineOf ( x0 , y0 , y1 - y0 , x0 - x1 ) ; q = input . nextInt ( ) ; for ( int i = 0 ; i < q ; ++ i ) { x2 = input . nextInt ( ) ; y2 = input . nextInt ( ) ; line1Of ( x2 , y2 , x0 - x1 , y0 - y1 ) ; intersectionOf2Lines ( ) ; resX = resX * 2 - x2 ; resY = resY * 2 - y2 ; System . out . printf ( \" % .8f \u2581 % .8f \\n \" , resX , resY ) ; } } static void lineOf ( double x1 , double y1 , double vx , double vy ) { a = vx ; b = vy ; c = - vx * x1 - vy * y1 ; } static void line1Of ( double x1 , double y1 , double vx , double vy ) { a1 = vx ; b1 = vy ; c1 = - vx * x1 - vy * y1 ; } static void intersectionOf2Lines ( ) { double d = a * b1 - a1 * b ; double dx = b * c1 - b1 * c ; double dy = c * a1 - c1 * a ; resX = dx / d ; resY = dy / d ; } }", "import java . awt . geom . Point2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new AOJCGL_1B ( ) . doIt ( ) ; } class AOJCGL_1B { void doIt ( ) { Point2D p0 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; Point2D p1 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; int q = in . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { Point2D p2 = new Point2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) ) ; Point2D result = getVerticalPoint ( p0 , p1 , p2 ) ; double dx = result . getX ( ) - p2 . getX ( ) ; double dy = result . getY ( ) - p2 . getY ( ) ; double tx = dx + result . getX ( ) ; double ty = dy + result . getY ( ) ; System . out . printf ( \" % .9f \u2581 % .9f \\n \" , tx , ty ) ; } } private Point2D getVerticalPoint ( Point2D p0 , Point2D p1 , Point2D p2 ) { double kyori = p0 . distance ( p1 ) ; double angle = angle ( p0 , p1 , p2 ) ; double t = p0 . distance ( p2 ) * Math . cos ( angle ) ; Point2D result = new Point2D . Double ( p0 . getX ( ) + ( p1 . getX ( ) - p0 . getX ( ) ) * t / kyori , p0 . getY ( ) + ( p1 . getY ( ) - p0 . getY ( ) ) * t / kyori ) ; return result ; } private double angle ( Point2D p0 , Point2D p1 , Point2D p2 ) { return Math . atan2 ( p2 . getY ( ) - p0 . getY ( ) , p2 . getX ( ) - p0 . getX ( ) ) - Math . atan2 ( p1 . getY ( ) - p0 . getY ( ) , p1 . getX ( ) - p0 . getX ( ) ) ; } } }", "import java . util . Scanner ; public class Main { public static void calc ( double x1 , double y1 , double x2 , double y2 , double px , double py ) { if ( y1 == y2 ) System . out . println ( px + \" \u2581 \" + ( py - 2 * ( py - y1 ) ) ) ; else if ( x1 == x2 ) System . out . println ( ( px - 2 * ( px - x1 ) ) + \" \u2581 \" + py ) ; else { double katamuki1 = ( y2 - y1 ) / ( x2 - x1 ) ; double seppen1 = - 1.0 * katamuki1 * x1 + y1 ; double katamuki2 = - 1.0 / katamuki1 ; double seppen2 = - 1.0 * katamuki2 * px + py ; double ansx = ( seppen2 - seppen1 ) / ( katamuki1 - katamuki2 ) ; double ansy = ansx * katamuki1 + seppen1 ; System . out . println ( ( px - 2 * ( px - ansx ) ) + \" \u2581 \" + ( py - 2 * ( py - ansy ) ) ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int px = sc . nextInt ( ) ; int py = sc . nextInt ( ) ; calc ( ( double ) x1 , ( double ) y1 , ( double ) x2 , ( double ) y2 , ( double ) px , ( double ) py ) ; } } }", "import java . io . * ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; double x = scan . nextDouble ( ) ; double y = scan . nextDouble ( ) ; double xx = scan . nextDouble ( ) ; double yy = scan . nextDouble ( ) ; int qer = scan . nextInt ( ) ; double xxx = 0 ; double yyy = 0 ; xxx = xx - x ; yyy = yy - y ; double xp [ ] = new double [ qer ] ; double yp [ ] = new double [ qer ] ; double ansx [ ] = new double [ qer ] ; double ansy [ ] = new double [ qer ] ; for ( int i = 0 ; i < qer ; i ++ ) { xp [ i ] = scan . nextDouble ( ) ; yp [ i ] = scan . nextDouble ( ) ; double xxxx = x - xp [ i ] ; double yyyy = y - yp [ i ] ; ansx [ i ] = x - xxx * ( xxxx * xxx + yyyy * yyy ) / ( xxx * xxx + yyy * yyy ) ; ansy [ i ] = y - yyy * ( xxxx * xxx + yyyy * yyy ) / ( xxx * xxx + yyy * yyy ) ; ansx [ i ] = 2 * ansx [ i ] - xp [ i ] ; ansy [ i ] = 2 * ansy [ i ] - yp [ i ] ; System . out . println ( ansx [ i ] + \" \u2581 \" + ansy [ i ] ) ; } } }"], "python": ["xp1 , yp1 , xp2 , yp2 = map ( int , input ( ) . split ( ) ) NEW_LINE q = int ( input ( ) ) NEW_LINE if xp1 == xp2 : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ' { : . 10f } ' . format ( 2 * xp1 - x0 ) , ' { : . 10f } ' . format ( y0 ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = float ( ( yp2 - yp1 ) / ( xp2 - xp1 ) ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT x0 , y0 = map ( int , input ( ) . split ( ) ) NEW_LINE x = a * ( ( y0 - yp1 ) - a * ( x0 - xp1 ) ) / ( 1 + a ** 2 ) + x0 NEW_LINE y = ( a * ( a * y0 + x0 - xp1 ) + yp1 ) / ( 1 + a ** 2 ) NEW_LINE print ( ' { : . 10f } ' . format ( 2 * x - x0 ) , ' { : . 10f } ' . format ( 2 * y - y0 ) ) NEW_LINE DEDENT DEDENT", "class Vector : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT def is_orthogonal ( self , v ) : NEW_LINE INDENT if self . x * v . x + self . y * v . y == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def is_parallel ( self , v ) : NEW_LINE INDENT if self . x * v . y - self . y * v . x == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def dot_product ( self , v ) : NEW_LINE INDENT return self . x * v . x + self . y * v . y NEW_LINE DEDENT def quadrance ( self ) : NEW_LINE INDENT return self . x ** 2 + self . y ** 2 NEW_LINE DEDENT def mul ( self , k ) : NEW_LINE INDENT return Vector ( self . x * k , self . y * k ) NEW_LINE DEDENT def __add__ ( self , v ) : NEW_LINE INDENT return Vector ( self . x + v . x , self . y + v . y ) NEW_LINE DEDENT def __sub__ ( self , v ) : NEW_LINE INDENT return Vector ( self . x - v . x , self . y - v . y ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return \" { 0 : . 8f } \u2581 { 1 : . 8f } \" . format ( self . x , self . y ) NEW_LINE DEDENT def projection_on ( self , v ) : NEW_LINE INDENT return v . mul ( self . dot_product ( v ) / v . quadrance ( ) ) NEW_LINE DEDENT def rejection_from ( self , v ) : NEW_LINE INDENT return self - self . projection_on ( v ) NEW_LINE DEDENT DEDENT import sys NEW_LINE file_input = sys . stdin NEW_LINE x_p1 , y_p1 , x_p2 , y_p2 = map ( int , file_input . readline ( ) . split ( ) ) NEW_LINE p1_p2 = Vector ( x_p2 - x_p1 , y_p2 - y_p1 ) NEW_LINE q = int ( file_input . readline ( ) ) NEW_LINE for line in file_input : NEW_LINE INDENT x_p , y_p = map ( int , line . split ( ) ) NEW_LINE p1_p = Vector ( x_p - x_p1 , y_p - y_p1 ) NEW_LINE r_v = p1_p . rejection_from ( p1_p2 ) NEW_LINE o_p = Vector ( x_p , y_p ) NEW_LINE print ( o_p - r_v . mul ( 2 ) ) NEW_LINE DEDENT", "def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE p1 = x1 + y1 * 1j NEW_LINE p2 = x2 + y2 * 1j NEW_LINE l = p2 - p1 NEW_LINE l_norm = dot ( l , l ) NEW_LINE q = int ( input ( ) ) NEW_LINE for x3 , y3 in ( map ( int , input ( ) . split ( ) ) for _ in [ 0 ] * q ) : NEW_LINE INDENT p3 = x3 + y3 * 1j NEW_LINE a = p3 - p1 NEW_LINE k = dot ( a , l ) / l_norm NEW_LINE projection_vector = k * l NEW_LINE reflect_vector = projection_vector - a NEW_LINE print ( x3 + 2 * reflect_vector . real , y3 + 2 * reflect_vector . imag ) NEW_LINE DEDENT", "def inner_product ( v1 , v2 ) : NEW_LINE INDENT return v1 . real * v2 . real + v1 . imag * v2 . imag NEW_LINE DEDENT def project ( a , b ) : NEW_LINE INDENT return a * inner_product ( a , b ) / ( abs ( a ) ** 2 ) NEW_LINE DEDENT def reflect ( p0 , p1 , p2 ) : NEW_LINE INDENT a = p1 - p0 NEW_LINE b = p2 - p0 NEW_LINE v = project ( a , b ) NEW_LINE u = v - b NEW_LINE p3 = p2 + 2 * u NEW_LINE return p3 NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x_p0 , y_p0 , x_p1 , y_p1 = map ( float , input ( ) . split ( ) ) NEW_LINE p0 = complex ( x_p0 , y_p0 ) NEW_LINE p1 = complex ( x_p1 , y_p1 ) NEW_LINE q = int ( input ( ) ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT p2 = complex ( * map ( float , input ( ) . split ( ) ) ) NEW_LINE t = reflect ( p0 , p1 , p2 ) NEW_LINE print ( \" { : . 10f } \u2581 { : . 10f } \" . format ( t . real , t . imag ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import collections NEW_LINE import math NEW_LINE class Vector2 ( collections . namedtuple ( \" Vector2\" , [ \" x \" , \" y \" ] ) ) : NEW_LINE INDENT def __add__ ( self , other ) : NEW_LINE INDENT return Vector2 ( self . x + other . x , self . y + other . y ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT return Vector2 ( self . x - other . x , self . y - other . y ) NEW_LINE DEDENT def __mul__ ( self , scalar ) : NEW_LINE INDENT return Vector2 ( self . x * scalar , self . y * scalar ) NEW_LINE DEDENT def __neg__ ( self ) : NEW_LINE INDENT return Vector2 ( - self . x , - self . y ) NEW_LINE DEDENT def __pos__ ( self ) : NEW_LINE INDENT return Vector2 ( + self . x , + self . y ) NEW_LINE DEDENT def __abs__ ( self ) : NEW_LINE INDENT return math . sqrt ( float ( self . x * self . x + self . y * self . y ) ) NEW_LINE DEDENT def dot ( self , other ) : NEW_LINE INDENT return self . x * other . x + self . y * other . y NEW_LINE DEDENT def cross ( self , other ) : NEW_LINE INDENT return self . x * other . y - self . y * other . x NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , c , d = map ( int , input ( ) . split ( ) ) NEW_LINE p1 = Vector2 ( a , b ) NEW_LINE p2 = Vector2 ( c , d ) NEW_LINE base = p2 - p1 NEW_LINE q = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( q ) : NEW_LINE INDENT e , f = map ( int , input ( ) . split ( ) ) NEW_LINE p = Vector2 ( e , f ) NEW_LINE hypo = Vector2 ( e - a , f - b ) NEW_LINE proj = p1 + base * ( hypo . dot ( base ) / float ( base . x ** 2 + base . y ** 2 ) ) NEW_LINE x = p + ( proj - p ) * 2 NEW_LINE ans . append ( x ) NEW_LINE DEDENT for x in ans : NEW_LINE INDENT print ( x . x , x . y ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_5266_A", "java": ["import java . util . * ; class Initials { public static void printInitials ( String str ) { int len = str . length ( ) ; str = str . trim ( ) ; String t = \" \" ; for ( int i = 0 ; i < len ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch != ' \u2581 ' ) { t = t + ch ; } else { System . out . print ( Character . toUpperCase ( t . charAt ( 0 ) ) + \" . \u2581 \" ) ; t = \" \" ; } } String temp = \" \" ; for ( int j = 0 ; j < t . length ( ) ; j ++ ) { if ( j == 0 ) temp = temp + Character . toUpperCase ( t . charAt ( 0 ) ) ; else temp = temp + Character . toLowerCase ( t . charAt ( j ) ) ; } System . out . println ( temp ) ; } public static void main ( String [ ] args ) { String str = \" ishita \u2581 bhuiya \" ; printInitials ( str ) ; } }"], "python": ["def printInitials ( string : str ) : NEW_LINE INDENT length = len ( string ) NEW_LINE string . strip ( ) NEW_LINE t = \" \" NEW_LINE for i in range ( length ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if ch != ' \u2581 ' : NEW_LINE INDENT t += ch NEW_LINE DEDENT else : NEW_LINE INDENT print ( t [ 0 ] . upper ( ) + \" . \u2581 \" , end = \" \" ) NEW_LINE t = \" \" NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE for j in range ( len ( t ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT temp += t [ 0 ] . upper ( ) NEW_LINE DEDENT else : NEW_LINE INDENT temp += t [ j ] . lower ( ) NEW_LINE DEDENT DEDENT print ( temp ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ishita \u2581 bhuiya \" NEW_LINE printInitials ( string ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_652_A", "java": ["class GFG { static int max_sum ( int arr [ ] , int n , int k ) { int dp [ ] = new int [ n ] ; dp [ 0 ] = Math . max ( 0 , arr [ 0 ] ) ; int i = 1 ; while ( i < k ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] ) ; i ++ ; } i = k ; while ( i < n ) { dp [ i ] = Math . max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; i ++ ; } return dp [ n - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , - 2 , 4 , 3 , 1 } ; int n = arr . length ; int k = 4 ; System . out . println ( max_sum ( arr , n , k ) ) ; } }"], "python": ["def max_sum ( arr , n , k ) : NEW_LINE INDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = max ( 0 , arr [ 0 ] ) ; NEW_LINE i = 1 ; NEW_LINE while ( i < k ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = k ; NEW_LINE while ( i < n ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] , arr [ i ] + dp [ i - k ] ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return dp [ n - 1 ] ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , - 2 , 4 , 3 , 1 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 4 ; NEW_LINE print ( max_sum ( arr , n , k ) ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_1177_A", "java": ["import java . io . * ; import java . util . * ; public class Run { public static int [ ] getMin ( char [ ] [ ] grid , boolean forCol ) { int n = grid . length ; int m = grid [ 0 ] . length ; int [ ] ans ; if ( ! forCol ) { ans = new int [ n ] ; int i = 0 ; for ( char [ ] row : grid ) { int currAns = m ; for ( char c : row ) { if ( c == ' * ' ) -- currAns ; } ans [ i ] = currAns ; ++ i ; } } else { ans = new int [ m ] ; for ( int j = 0 ; j < m ; j ++ ) { int currAns = n ; for ( char [ ] chars : grid ) { if ( chars [ j ] == ' * ' ) -- currAns ; } ans [ j ] = currAns ; } } return ans ; } public static void main ( String [ ] Z ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder op = new StringBuilder ( ) ; int k = Integer . parseInt ( br . readLine ( ) ) ; StringBuilder s = new StringBuilder ( k ) ; int dig = 1 ; while ( s . length ( ) < k ) { s . append ( dig ) ; ++ dig ; } op . append ( s . charAt ( k - 1 ) ) ; System . out . println ( op ) ; } }", "import java . io . * ; import java . util . * ; import java . math . * ; public class A_1177 { public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; int k = sc . nextInt ( ) ; String s = \" \" ; for ( int i = 1 ; i <= k ; i ++ ) { s += String . valueOf ( i ) ; } System . out . println ( s . charAt ( k - 1 ) ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ( str ) ; } } }", "import java . util . * ; import java . lang . Long ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int k = input . nextInt ( ) ; String str = \" \u2581 \" ; for ( int i = 1 ; i <= k ; i ++ ) str += i ; System . out . println ( str . charAt ( k ) ) ; } }", "import java . io . PrintWriter ; import java . util . Scanner ; public class Digits_Sequence { static Scanner sc = new Scanner ( System . in ) ; static PrintWriter pw = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) { int k = sc . nextInt ( ) ; String string = \" \" ; for ( int i = 1 ; i < 9999 ; i ++ ) { string = string + i + \" \" ; } System . out . println ( string . charAt ( k - 1 ) ) ; } }"], "python": ["s = \" \" NEW_LINE k = int ( input ( ) ) NEW_LINE x = 1 NEW_LINE while True : NEW_LINE INDENT try : NEW_LINE INDENT if s [ k - 1 ] != \" \" : NEW_LINE INDENT print ( s [ k - 1 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT s += str ( x ) NEW_LINE x += 1 NEW_LINE DEDENT DEDENT", "out = [ ] NEW_LINE for i in range ( 10000 ) : NEW_LINE INDENT out . append ( str ( i ) ) NEW_LINE DEDENT str1 = \" \" . join ( out ) NEW_LINE print ( str1 [ int ( input ( ) ) ] ) NEW_LINE", "out = [ ] NEW_LINE for i in range ( 0 , 10001 ) : NEW_LINE INDENT out . append ( str ( i ) ) NEW_LINE DEDENT str1 = \" \" . join ( out ) NEW_LINE print ( str1 [ int ( input ( ) ) ] ) NEW_LINE", "s = \" \" NEW_LINE p = int ( input ( ) ) NEW_LINE for i in range ( 1 , 3000 ) : NEW_LINE INDENT s += str ( i ) NEW_LINE DEDENT print ( s [ p - 1 ] ) NEW_LINE", "import sys NEW_LINE from sys import stdin , stdout NEW_LINE from math import * NEW_LINE import math , random , operator NEW_LINE from itertools import product , permutations , combinations NEW_LINE from collections import deque , defaultdict , Counter NEW_LINE input = sys . stdin . readline NEW_LINE s = ' ' NEW_LINE l = [ i for i in range ( 1 , 100000 ) ] NEW_LINE for i in l : s += str ( i ) NEW_LINE def hi ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( s [ n - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : hi ( ) NEW_LINE"]}
{"id": "geeksforgeeks_5004_A", "java": ["class GFG { static int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return - 1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } } static public void main ( String args [ ] ) { int a = 21 , b = 5 ; System . out . println ( countX ( a , b ) ) ; } }"], "python": ["def countX ( a , b ) : NEW_LINE INDENT if ( b > a ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT x = a - b NEW_LINE ans = 0 NEW_LINE i = 1 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT d1 = i NEW_LINE d2 = b - 1 NEW_LINE if ( i * i != x ) : NEW_LINE INDENT d2 = x // i NEW_LINE DEDENT if ( d1 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( d2 > b ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 21 NEW_LINE b = 5 NEW_LINE print ( countX ( a , b ) ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC087_D", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; ArrayList < Pair > [ ] g = new ArrayList [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { g [ i ] = new ArrayList < > ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { int l = sc . nextInt ( ) - 1 ; int r = sc . nextInt ( ) - 1 ; int d = sc . nextInt ( ) ; g [ l ] . add ( new Pair ( r , d ) ) ; g [ r ] . add ( new Pair ( l , - d ) ) ; } int [ ] p = new int [ n ] ; boolean [ ] used = new boolean [ n ] ; boolean ans = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( used [ i ] ) continue ; ArrayDeque < Integer > q = new ArrayDeque < > ( ) ; q . add ( i ) ; used [ i ] = true ; while ( ! q . isEmpty ( ) ) { int v = q . poll ( ) ; for ( Pair na : g [ v ] ) { int nv = na . x , nd = na . y ; if ( used [ nv ] ) { if ( p [ nv ] != p [ v ] + nd ) { ans = false ; break ; } } else { p [ nv ] = p [ v ] + nd ; used [ nv ] = true ; q . add ( nv ) ; } } if ( ! ans ) break ; } if ( ! ans ) break ; } System . out . println ( ans ? \" Yes \" : \" No \" ) ; sc . close ( ) ; } static class Pair { final int x ; final int y ; Pair ( int x , int y ) { this . x = x ; this . y = y ; } } }", "import java . util . * ; public class Main { static int [ ] belongs = null ; static int [ ] states = null ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . next ( ) ) ; int m = Integer . parseInt ( sc . next ( ) ) ; states = new int [ n ] ; belongs = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { belongs [ i ] = i ; states [ i ] = 0 ; } for ( int i = 0 ; i < m ; i ++ ) { int l = Integer . parseInt ( sc . next ( ) ) - 1 ; int r = Integer . parseInt ( sc . next ( ) ) - 1 ; int d = Integer . parseInt ( sc . next ( ) ) ; if ( ! merge ( l , r , d ) ) { System . out . println ( \" No \" ) ; sc . close ( ) ; return ; } } System . out . println ( \" Yes \" ) ; sc . close ( ) ; } public static int updateBelongs ( int a ) { if ( a == belongs [ a ] ) { return a ; } else { int temp = belongs [ a ] ; belongs [ a ] = updateBelongs ( belongs [ a ] ) ; states [ a ] += states [ temp ] ; return belongs [ a ] ; } } public static boolean merge ( int l , int r , int d ) { int lb = updateBelongs ( l ) ; int rb = updateBelongs ( r ) ; if ( lb == rb ) { return states [ r ] == states [ l ] + d ; } else { belongs [ rb ] = lb ; states [ rb ] = states [ l ] + d - states [ r ] ; return true ; } } }", "import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int M = scanner . nextInt ( ) ; Node [ ] nodes = new Node [ N ] ; for ( int i = 0 ; i < N ; i ++ ) nodes [ i ] = new Node ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int l = scanner . nextInt ( ) - 1 ; int r = scanner . nextInt ( ) - 1 ; int d = scanner . nextInt ( ) ; nodes [ l ] . edges . add ( new Edge ( nodes [ r ] , d ) ) ; nodes [ r ] . edges . add ( new Edge ( nodes [ l ] , - d ) ) ; } for ( Node node : nodes ) { if ( ! node . visited ) { if ( ! dfs ( node ) ) { System . out . println ( \" No \" ) ; return ; } } } System . out . println ( \" Yes \" ) ; } private static boolean dfs ( Node node ) { node . visited = true ; for ( Edge edge : node . edges ) { Node a = edge . to ; if ( ! a . visited ) { a . pos = node . pos + edge . dist ; if ( ! dfs ( a ) ) return false ; } else if ( a . pos != node . pos + edge . dist ) { return false ; } } return true ; } private static class Node { private int pos ; private List < Edge > edges = new ArrayList < > ( ) ; private boolean visited ; } private static class Edge { private final Node to ; private final int dist ; private Edge ( Node to , int dist ) { this . to = to ; this . dist = dist ; } } }"], "python": ["def sol ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE t , w = { } , { } NEW_LINE p , q = set ( ) , set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r , d = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE if l in w : w [ l ] . add ( ( r , d ) ) NEW_LINE else : w [ l ] = { ( r , d ) } NEW_LINE p . add ( l ) NEW_LINE q . add ( r ) NEW_LINE DEDENT s = p - q NEW_LINE chk = set ( ) NEW_LINE if len ( s ) == 0 : NEW_LINE INDENT print ( [ \" No \" , \" Yes \" ] [ m == 0 ] ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in s : NEW_LINE INDENT chk . add ( ( i , 0 ) ) NEW_LINE while len ( chk ) : NEW_LINE INDENT x = chk . pop ( ) NEW_LINE if x [ 0 ] in w : NEW_LINE INDENT for j in w [ x [ 0 ] ] : NEW_LINE INDENT if ( i , j [ 0 ] ) in t and t [ ( i , j [ 0 ] ) ] != t [ ( i , x [ 0 ] ) ] + j [ 1 ] : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( ) NEW_LINE DEDENT elif ( i , j [ 0 ] ) not in t : NEW_LINE INDENT t [ ( i , j [ 0 ] ) ] = x [ 1 ] + j [ 1 ] NEW_LINE chk . add ( ( j [ 0 ] , x [ 1 ] + j [ 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT print ( \" Yes \" ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT sol ( ) NEW_LINE DEDENT", "class WeightedUF : NEW_LINE INDENT def __init__ ( self , n ) : NEW_LINE INDENT self . par = [ i for i in range ( n ) ] NEW_LINE self . rank = [ 0 ] * n NEW_LINE self . weight = [ 0 ] * n NEW_LINE DEDENT def find ( self , x ) : NEW_LINE INDENT if self . par [ x ] == x : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT y = self . find ( self . par [ x ] ) NEW_LINE self . weight [ x ] += self . weight [ self . par [ x ] ] NEW_LINE self . par [ x ] = y NEW_LINE return y NEW_LINE DEDENT DEDENT def unite ( self , x , y , w ) : NEW_LINE INDENT rx = self . find ( x ) NEW_LINE ry = self . find ( y ) NEW_LINE if self . rank [ rx ] < self . rank [ ry ] : NEW_LINE INDENT self . par [ rx ] = ry NEW_LINE self . weight [ rx ] = w - self . weight [ x ] + self . weight [ y ] NEW_LINE DEDENT else : NEW_LINE INDENT self . par [ ry ] = rx NEW_LINE self . weight [ ry ] = - w - self . weight [ y ] + self . weight [ x ] NEW_LINE if self . rank [ rx ] == self . rank [ ry ] : NEW_LINE INDENT self . rank [ rx ] += 1 NEW_LINE DEDENT DEDENT DEDENT def same ( self , x , y ) : NEW_LINE INDENT return self . find ( x ) == self . find ( y ) NEW_LINE DEDENT def diff ( self , x , y ) : NEW_LINE INDENT return self . weight [ x ] - self . weight [ y ] NEW_LINE DEDENT DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE wuf = WeightedUF ( n ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT l , r , d = map ( int , input ( ) . split ( ) ) NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE if wuf . same ( l , r ) : NEW_LINE INDENT if wuf . diff ( l , r ) != d : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT wuf . unite ( l , r , d ) NEW_LINE DEDENT DEDENT print ( \" Yes \" ) NEW_LINE", "import sys NEW_LINE import collections NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT N , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE LRD = [ [ int ( x ) for x in input ( ) . split ( ) ] for _ in range ( M ) ] NEW_LINE A = [ [ ] for j in range ( N + 1 ) ] NEW_LINE if M == 0 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT slist = set ( ) NEW_LINE for l , r , d in LRD : NEW_LINE INDENT A [ l ] . append ( [ r , d ] ) NEW_LINE A [ r ] . append ( [ l , - d ] ) NEW_LINE slist . add ( l ) NEW_LINE slist . add ( r ) NEW_LINE DEDENT dmemo = [ None ] * ( N + 1 ) NEW_LINE f = False NEW_LINE for i in list ( slist ) : NEW_LINE INDENT if dmemo [ i ] is not None : NEW_LINE INDENT continue NEW_LINE DEDENT s = collections . deque ( ) NEW_LINE s . append ( i ) NEW_LINE dmemo [ i ] = 0 NEW_LINE while s : NEW_LINE INDENT c = s . pop ( ) NEW_LINE for r , d in A [ c ] : NEW_LINE INDENT if dmemo [ r ] is not None : NEW_LINE INDENT if dmemo [ r ] - dmemo [ c ] != d : NEW_LINE INDENT f = True NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dmemo [ r ] = dmemo [ c ] + d NEW_LINE s . append ( r ) NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "def dfs ( graph , start , visited ) : NEW_LINE INDENT if visited [ start ] != - 99999 : NEW_LINE INDENT return True NEW_LINE DEDENT stack = [ start ] NEW_LINE visited [ start ] = 0 NEW_LINE while stack : NEW_LINE INDENT label = stack . pop ( ) NEW_LINE for nextnode , distance in graph [ label ] : NEW_LINE INDENT if visited [ nextnode ] == - 99999 : NEW_LINE INDENT stack . append ( nextnode ) NEW_LINE visited [ nextnode ] = visited [ label ] + distance NEW_LINE DEDENT elif visited [ nextnode ] != visited [ label ] + distance : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT N , M = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE graph = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT L , R , D = ( int ( i ) for i in input ( ) . split ( ) ) NEW_LINE graph [ L ] . append ( ( R , D ) ) NEW_LINE graph [ R ] . append ( ( L , - 1 * D ) ) NEW_LINE DEDENT visited = [ - 99999 for i in range ( N + 1 ) ] NEW_LINE flag = True NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans = dfs ( graph , i , visited ) NEW_LINE if not ans : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT", "queue = [ ] NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE NE = 9223372036854775807 NEW_LINE mp = [ NE ] * ( N + 1 ) NEW_LINE lst = [ [ ] for _ in range ( N + 1 ) ] NEW_LINE for _ in range ( M ) : NEW_LINE INDENT L , R , D = map ( int , input ( ) . split ( ) ) NEW_LINE lst [ L ] . append ( ( L , R , D ) ) NEW_LINE lst [ R ] . append ( ( L , R , D ) ) NEW_LINE DEDENT def check ( L , R , D ) : NEW_LINE INDENT if mp [ L ] == NE : NEW_LINE INDENT mp [ L ] = mp [ R ] - D NEW_LINE DEDENT elif mp [ R ] == NE : NEW_LINE INDENT mp [ R ] = mp [ L ] + D NEW_LINE DEDENT else : NEW_LINE INDENT if mp [ L ] + D != mp [ R ] : NEW_LINE INDENT print ( \" No \" ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT DEDENT def check_list ( ls , checking ) : NEW_LINE INDENT while len ( ls ) : NEW_LINE INDENT L , R , D = ls . pop ( ) NEW_LINE check ( L , R , D ) NEW_LINE nx = R if L == checking else L NEW_LINE if len ( lst [ nx ] ) : queue . append ( nx ) NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if mp [ i ] == NE : mp [ i ] = 0 NEW_LINE check_list ( lst [ i ] , i ) NEW_LINE while ( len ( queue ) > 0 ) : NEW_LINE INDENT num = queue . pop ( ) NEW_LINE check_list ( lst [ num ] , num ) NEW_LINE DEDENT DEDENT print ( \" Yes \" ) NEW_LINE"]}
{"id": "codeforces_572_A", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int nA = sc . nextInt ( ) ; int nB = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ nA ] ; int [ ] b = new int [ nB ] ; for ( int i = 0 ; i < nA ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < nB ; i ++ ) b [ i ] = sc . nextInt ( ) ; if ( a [ k - 1 ] < b [ nB - m ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } catch ( Exception e ) { } } }", "import java . util . Scanner ; public class MainClass { public static void main ( String [ ] agrs ) { Scanner sc = new Scanner ( System . in ) ; int nA = sc . nextInt ( ) ; int nB = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ nA ] ; int [ ] b = new int [ nB ] ; for ( int i = 0 ; i < nA ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < nB ; i ++ ) b [ i ] = sc . nextInt ( ) ; if ( a [ k - 1 ] < b [ nB - m ] ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "import java . util . Scanner ; public class Ishu { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int na , nb , k , m , i ; int [ ] A = new int [ 100000 ] ; int [ ] B = new int [ 100000 ] ; na = scan . nextInt ( ) ; nb = scan . nextInt ( ) ; k = scan . nextInt ( ) ; m = scan . nextInt ( ) ; for ( i = 0 ; i < na ; ++ i ) A [ i ] = scan . nextInt ( ) ; for ( i = 0 ; i < nb ; ++ i ) B [ i ] = scan . nextInt ( ) ; if ( A [ k - 1 ] < B [ nb - m ] ) System . out . println ( \" Yes \u2581 \" ) ; else System . out . println ( \" No \u2581 \" ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { int i = 0 ; Scanner in = new Scanner ( System . in ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int [ ] arr = new int [ a ] ; int [ ] nums = new int [ b ] ; int k = in . nextInt ( ) ; int m = in . nextInt ( ) ; for ( i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } for ( int j = 0 ; j < nums . length ; j ++ ) { nums [ j ] = in . nextInt ( ) ; } if ( arr [ k - 1 ] < nums [ b - m ] ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } }"], "python": ["a = input ( ) . split ( ) NEW_LINE len_a = int ( a [ 0 ] ) NEW_LINE len_b = int ( a [ 1 ] ) NEW_LINE a = input ( ) . split ( ) NEW_LINE k = int ( a [ 0 ] ) NEW_LINE m = int ( a [ 1 ] ) NEW_LINE array_a = input ( ) . split ( ) NEW_LINE array_b = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < len_a : NEW_LINE INDENT array_a [ a ] = int ( array_a [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT a = 0 NEW_LINE while a < len_b : NEW_LINE INDENT array_b [ a ] = int ( array_b [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT if array_a [ k - 1 ] < array_b [ len_b - m ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "n1 , n2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE k , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if a [ k - 1 ] < b [ n2 - m ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "z = lambda : tuple ( map ( int , input ( ) . split ( ) ) ) ; s , s1 = z ( ) ; a , b = z ( ) ; print ( \" YES \" if z ( ) [ a - 1 ] < z ( ) [ - b ] else \" NO \" ) NEW_LINE", "a , b = input ( ) . split ( ) NEW_LINE k , m = input ( ) . split ( ) NEW_LINE k = int ( k ) NEW_LINE m = int ( m ) NEW_LINE first = input ( ) . split ( ) NEW_LINE second = input ( ) . split ( ) NEW_LINE if int ( first [ k - 1 ] ) < int ( second [ - m ] ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT", "na , nb = map ( int , input ( ) . split ( ) ) NEW_LINE k , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if b [ nb - m ] > a [ k - 1 ] : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "codeforces_20_B", "java": ["import java . util . * ; import java . math . * ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; long A = s . nextLong ( ) , B = s . nextLong ( ) , C = s . nextLong ( ) ; if ( A == 0 && B == 0 ) { System . out . println ( C == 0 ? - 1 : 0 ) ; } else if ( A == 0 ) { System . out . println ( 1 ) ; System . out . println ( 1.0 * - C / B ) ; } else { long discriminant = B * B - 4 * A * C ; if ( discriminant < 0 ) System . out . println ( 0 ) ; else if ( discriminant == 0 ) { System . out . println ( 1 ) ; System . out . println ( 1.0 * - B / ( 2.0 * A ) ) ; } else { System . out . println ( 2 ) ; double num1 = ( - B - Math . sqrt ( discriminant ) ) / ( 2.0 * A ) ; double num2 = ( - B + Math . sqrt ( discriminant ) ) / ( 2.0 * A ) ; if ( num1 < num2 ) { System . out . println ( num1 ) ; System . out . println ( num2 ) ; } else { System . out . println ( num2 ) ; System . out . println ( num1 ) ; } } } s . close ( ) ; } }", "import java . io . * ; import java . util . * ; import java . lang . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; double a = sc . nextDouble ( ) ; double b = sc . nextDouble ( ) ; double c = sc . nextDouble ( ) ; if ( a == 0 && b != 0 ) { double ans = - ( c / b ) ; System . out . format ( \"1 \\n % .5f \" , ans ) ; } else if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( \" - 1\" ) ; } else if ( a == 0 && b == 0 && c != 0 ) { System . out . println ( \"0\" ) ; } else { double r1 , r2 ; double det = b * b - 4 * a * c ; if ( det > 0 ) { System . out . println ( \"2\" ) ; r1 = ( - b + Math . sqrt ( det ) ) / ( 2 * a ) ; r2 = ( - b - Math . sqrt ( det ) ) / ( 2 * a ) ; double x = ( r1 < r2 ) ? r1 : r2 ; double y = ( r1 > r2 ) ? r1 : r2 ; System . out . format ( \" % .5f \\n % .5f \\n \" , x , y ) ; } else if ( det == 0 ) { r1 = ( - b + Math . sqrt ( det ) ) / ( 2 * a ) ; System . out . format ( \"1 \\n % .5f \" , r1 ) ; } else System . out . println ( \"0\" ) ; } } }"], "python": ["a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT elif a == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( - c / b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT root1 = ( - b + ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE root2 = ( - b - ( b ** 2 - 4 * a * c ) ** 0.5 ) / ( 2 * a ) NEW_LINE if root1 == root2 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT elif type ( root1 ) == complex and type ( root2 ) == complex : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif type ( root1 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE DEDENT elif type ( root2 ) == complex : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT elif root1 > root2 : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root1 ) ) NEW_LINE print ( \" { 0 : . 5f } \" . format ( root2 ) ) NEW_LINE DEDENT DEDENT", "x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = x [ 0 ] NEW_LINE b = x [ 1 ] NEW_LINE c = x [ 2 ] NEW_LINE import math NEW_LINE if a == 0 : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE if c != 0 : NEW_LINE INDENT r = - c / b NEW_LINE DEDENT else : NEW_LINE INDENT r = abs ( c / b ) NEW_LINE DEDENT print ( \" { : . 10f } \" . format ( r ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT d = ( b * b ) - ( 4 * a * c ) NEW_LINE if d < 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE r = ( - b ) / ( 2 * a ) NEW_LINE print ( \" { : . 10f } \" . format ( r ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r1 = math . sqrt ( d ) NEW_LINE r11 = ( - b + r1 ) / ( 2 * a ) NEW_LINE r12 = ( - b - r1 ) / ( 2 * a ) NEW_LINE r = [ ] NEW_LINE r . append ( min ( r11 , r12 ) ) NEW_LINE r . append ( max ( r11 , r12 ) ) NEW_LINE print ( 2 ) NEW_LINE for i in r : NEW_LINE INDENT print ( \" { : . 10f } \" . format ( i ) ) NEW_LINE DEDENT DEDENT DEDENT", "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( - c / b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT D = b ** 2 - 4 * a * c NEW_LINE if D == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE DEDENT elif D < 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE ans = sorted ( [ ( - b - D ** 0.5 ) / ( 2 * a ) , ( - b + D ** 0.5 ) / ( 2 * a ) ] ) NEW_LINE print ( * ans , sep = \" \\n \" ) NEW_LINE DEDENT DEDENT", "a , b , c = [ int ( a ) for a in input ( ) . split ( ) ] NEW_LINE if a == 0 : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( - c / b ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT D = b ** 2 - 4 * a * c NEW_LINE if D == 0 : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE DEDENT elif D < 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE ans = sorted ( [ ( - b - D ** 0.5 ) / ( 2 * a ) , ( - b + D ** 0.5 ) / ( 2 * a ) ] ) NEW_LINE print ( * ans , sep = \" \\n \" ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE import time NEW_LINE import sys NEW_LINE import os NEW_LINE from math import gcd , floor , sqrt , log NEW_LINE start_time = time . time ( ) NEW_LINE def iin ( ) : return int ( input ( ) ) NEW_LINE def sin ( ) : return input ( ) . strip ( ) NEW_LINE def listin ( ) : return list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE def liststr ( ) : return list ( map ( str , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE def ceill ( x ) : return int ( x ) if ( x == int ( x ) ) else int ( x ) + 1 NEW_LINE def ceilldiv ( x , d ) : x // d if ( x % d == 0 ) else x // d + 1 NEW_LINE def LCM ( a , b ) : return ( a * b ) // gcd ( a , b ) NEW_LINE def solve ( ) : NEW_LINE INDENT a , b , c = listin ( ) NEW_LINE if a == 0 : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT print ( 1 ) NEW_LINE print ( \" { 0 : . 10f } \" . format ( ( - 1 * c ) / b ) ) NEW_LINE return NEW_LINE DEDENT d = b ** 2 - ( 4 * a * c ) NEW_LINE if d < 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT x = set ( ) NEW_LINE x . add ( ( ( - 1 * b ) - sqrt ( d ) ) / ( 2 * a ) ) NEW_LINE x . add ( ( ( - 1 * b ) + sqrt ( d ) ) / ( 2 * a ) ) NEW_LINE x = list ( x ) NEW_LINE x . sort ( ) NEW_LINE print ( len ( x ) ) NEW_LINE for i in x : NEW_LINE INDENT print ( \" { 0 : . 10f } \" . format ( i ) ) NEW_LINE DEDENT DEDENT t = 1 NEW_LINE for hula in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT sys . stderr . write ( str ( time . time ( ) - start_time ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3188_A", "java": ["class GFG { static double average ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return sum / n ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( average ( arr , n ) ) ; } }"], "python": ["def average ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return sum / n ; NEW_LINE DEDENT arr = [ 10 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( average ( arr , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4965_A", "java": ["import java . util . Arrays ; class Test { static String isKSortedArray ( int arr [ ] , int n , int k ) { int aux [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = arr [ i ] ; Arrays . sort ( aux ) ; for ( int i = 0 ; i < n ; i ++ ) { int j = Arrays . binarySearch ( aux , arr [ i ] ) ; if ( Math . abs ( i - j ) > k ) return \" No \" ; } return \" Yes \" ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 2 , 1 , 5 , 6 , 4 } ; int k = 2 ; System . out . println ( \" Is \u2581 it \u2581 a \u2581 k \u2581 sorted \u2581 array \u2581 ? : \u2581 \" + isKSortedArray ( arr , arr . length , k ) ) ; } }"], "python": ["def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( arr [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT DEDENT def isKSortedArray ( arr , n , k ) : NEW_LINE INDENT aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = arr [ i ] NEW_LINE DEDENT aux . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT j = binarySearch ( aux , 0 , n - 1 , arr [ i ] ) NEW_LINE if ( abs ( i - j ) > k ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT DEDENT return \" Yes \" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 5 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( \" Is \u2581 it \u2581 a \u2581 k \u2581 sorted \u2581 array ? : \" , isKSortedArray ( arr , n , k ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2268_A", "java": ["import java . io . * ; class GFG { static int nCr ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } static double resultOfAllSubsets ( int arr [ ] , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int N = arr . length ; System . out . println ( resultOfAllSubsets ( arr , N ) ) ; } }"], "python": ["def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT result = 0.0 NEW_LINE sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( resultOfAllSubsets ( arr , N ) ) NEW_LINE"]}
{"id": "geeksforgeeks_556_A", "java": ["import java . util . * ; import java . lang . * ; class GFG { public static long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; } public static void main ( String [ ] args ) { int n = 44 ; System . out . print ( productPrimeFactors ( n ) ) ; } }"], "python": ["import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( int ( productPrimeFactors ( n ) ) ) NEW_LINE"]}
{"id": "codeforces_266_A", "java": ["import java . util . * ; public class Codeforces { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int temp = 0 ; String s = in . next ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) { temp ++ ; } } System . out . println ( temp ) ; in . close ( ) ; } }", "import java . util . Scanner ; public class Stones_on_the_Table { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; String s = scan . next ( ) ; char [ ] array = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = s . charAt ( i ) ; } int counter = 0 ; int R = 0 ; int G = 0 ; int B = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter ++ ; if ( n > 1 ) { if ( array [ i ] == ' R ' && array [ counter ] == ' R ' ) { R ++ ; } else if ( array [ i ] == ' G ' && array [ counter ] == ' G ' ) { G ++ ; } else if ( array [ i ] == ' B ' && array [ counter ] == ' B ' ) { B ++ ; } if ( counter == n - 1 ) { break ; } } else { R = 0 ; G = 0 ; B = 0 ; } } int max = R + G + B ; System . out . println ( max ) ; } }", "import java . util . * ; public class Rough { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String name = sc . next ( ) ; char c [ ] = name . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( c [ i ] == c [ i + 1 ] ) { count ++ ; } } System . out . println ( count ) ; } }", "import java . util . Scanner ; public class Codeforces { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; String str = input . next ( ) ; int count = 0 , first = 0 , second = 1 , i = 1 ; while ( i < str . length ( ) ) { if ( str . charAt ( first ) == str . charAt ( second ) ) count ++ ; i ++ ; first ++ ; second ++ ; } System . out . println ( count ) ; } }", "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int numStones = in . nextInt ( ) ; char [ ] stonesColor = in . next ( ) . toCharArray ( ) ; char previousColor = stonesColor [ 0 ] ; int ans = 0 ; for ( int i = 1 ; i < numStones ; i ++ ) { char currentColor = stonesColor [ i ] ; if ( currentColor == previousColor ) ans ++ ; previousColor = currentColor ; } out . println ( ans ) ; out . close ( ) ; } static class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( ) { try { br = new BufferedReader ( new FileReader ( \" sub . in \" ) ) ; } catch ( FileNotFoundException ex ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } } public String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException ex ) { } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } public float nextFloat ( ) { return Float . parseFloat ( next ( ) ) ; } public String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException ex ) { } return str ; } } }"], "python": ["n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE s = str ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE arr = input ( ) NEW_LINE out = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT out += 1 NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE arr = input ( ) NEW_LINE out = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT out += 1 NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE rocks = str ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( len ( rocks ) - 1 ) : NEW_LINE INDENT if rocks [ i ] == rocks [ i + 1 ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE"]}
{"id": "codeforces_1670_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] nums = new int [ n ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { nums [ i ] = sc . nextInt ( ) ; if ( nums [ i ] < 0 ) { count ++ ; nums [ i ] = - nums [ i ] ; } } int i = 0 ; while ( count -- > 0 ) { nums [ i ] = - nums [ i ] ; i ++ ; } int flag = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( nums [ j ] < nums [ j - 1 ] ) { flag ++ ; } } if ( flag == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }", "import java . io . * ; import java . util . StringTokenizer ; public class A { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int tc = sc . nextInt ( ) ; for ( int test = 1 ; test <= tc ; test ++ ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; int i = 0 , j = 0 ; while ( i < n ) { if ( arr [ i ] < 0 ) { arr [ j ++ ] *= - 1 ; arr [ i ] *= - 1 ; } i ++ ; } if ( isSorted ( arr ) ) { pw . println ( \" YES \" ) ; } else pw . println ( \" NO \" ) ; } pw . flush ( ) ; } private static boolean isSorted ( int [ ] arr ) { for ( int i = 1 ; i < arr . length ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; } static class Scanner { BufferedReader br ; StringTokenizer st ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Scanner ( FileReader f ) { br = new BufferedReader ( f ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public int [ ] nextIntArr ( int n ) throws IOException { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( next ( ) ) ; } return arr ; } } }"], "python": ["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if l [ i ] < 0 : NEW_LINE INDENT m += 1 NEW_LINE l [ i ] = - l [ i ] NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT l [ i ] = - l [ i ] NEW_LINE DEDENT r = l . copy ( ) NEW_LINE r . sort ( ) NEW_LINE if r == l : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "xx = int ( input ( ) ) NEW_LINE def cal ( n , arr ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < 0 : NEW_LINE INDENT x += 1 NEW_LINE arr [ i ] = - arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( x ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT if sorted ( arr ) == arr : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT for jj in range ( xx ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( i ) for i in input ( ) . split ( ' \u2581 ' ) ] NEW_LINE if cal ( n , arr ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "from collections import Counter NEW_LINE def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE minus = len ( list ( filter ( lambda x : x < 0 , arr ) ) ) NEW_LINE flag = False NEW_LINE for i in range ( minus - 1 ) : NEW_LINE INDENT if abs ( arr [ i ] ) >= abs ( arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( minus , n - 1 ) : NEW_LINE INDENT if abs ( arr [ i ] ) <= abs ( arr [ i + 1 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT print ( \" YES \" if not flag else \" NO \" ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for case_num in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE neg = len ( [ x for x in a if x < 0 ] ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i < neg : NEW_LINE INDENT a [ i ] = - abs ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT DEDENT print ( ' YES ' if a == sorted ( a ) else ' NO ' ) NEW_LINE DEDENT", "for f in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , a = int ( input ( ) ) , [ * map ( int , input ( ) . split ( ) ) ] NEW_LINE h = sum ( 1 for v in a if v < 0 ) NEW_LINE b = [ abs ( a [ i ] ) * ( - 1 if i < h else 1 ) for i in range ( n ) ] NEW_LINE print ( ' YES ' if sorted ( b ) == b else ' NO ' ) NEW_LINE DEDENT"]}
{"id": "codeforces_990_B", "java": ["import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Comparator ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; Integer [ ] a = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextInt ( ) ; Arrays . sort ( a ) ; int num = n ; int num1 = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] <= a [ i - 1 ] + k ) num -= num1 ; else if ( a [ i ] . equals ( a [ i - 1 ] ) ) num1 ++ ; if ( ! a [ i ] . equals ( a [ i - 1 ] ) ) num1 = 1 ; } out . println ( num ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }"], "python": ["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE j = 0 NEW_LINE for i in l : NEW_LINE INDENT while l [ j ] < i : NEW_LINE INDENT if i <= k + l [ j ] : n -= 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE dic = { } NEW_LINE for i in a : NEW_LINE INDENT if i in dic . keys ( ) : dic [ i ] += 1 NEW_LINE else : dic [ i ] = 1 NEW_LINE DEDENT s = list ( set ( a ) ) NEW_LINE s . sort ( ) NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if s [ i + 1 ] - s [ i ] > k : c += dic [ s [ i ] ] NEW_LINE DEDENT c += dic [ s [ - 1 ] ] NEW_LINE print ( c ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE j = 0 NEW_LINE for i in a : NEW_LINE INDENT while a [ j ] < i : NEW_LINE INDENT if i - a [ j ] <= k : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE", "from collections import Counter NEW_LINE n , k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] ) NEW_LINE cnt = Counter ( a ) NEW_LINE ans = 0 NEW_LINE l = list ( zip ( a , [ cnt [ i ] for i in a ] ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if l [ i ] [ 0 ] > l [ i - 1 ] [ 0 ] and l [ i - 1 ] [ 0 ] + k >= l [ i ] [ 0 ] : NEW_LINE INDENT ans += l [ i - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT print ( n - ans ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE w = sorted ( map ( int , input ( ) . split ( ) ) ) NEW_LINE j = 0 NEW_LINE for i in w : NEW_LINE INDENT while w [ j ] < i : NEW_LINE INDENT if i <= k + w [ j ] : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE"]}
{"id": "geeksforgeeks_344_A", "java": ["class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . printf ( \" % d \" , power ( x , y ) ) ; } }"], "python": ["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT x = 2 ; y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3362_A", "java": ["class GFG { static int charVal ( String s , int i ) { if ( s . charAt ( i ) == '0' ) { return 0 ; } else if ( s . charAt ( i ) == '1' ) { return 1 ; } else { return 2 ; } } static int countMinimalReplacements ( String s , int i , int prev , int dp [ ] [ ] , int n ) { if ( i == n ) { return 0 ; } if ( dp [ i ] [ prev ] != - 1 ) { return dp [ i ] [ prev ] ; } int val = charVal ( s , i ) ; int ans = Integer . MAX_VALUE ; if ( val == prev ) { val = 0 ; for ( int cur = 0 ; cur <= 2 ; cur ++ ) { if ( cur == prev ) { continue ; } val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) ; ans = Math . min ( ans , val ) ; } } else { ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) ; } return dp [ i ] [ val ] = ans ; } public static void main ( String [ ] args ) { String s = \"201220211\" ; int n = s . length ( ) ; int dp [ ] [ ] = new int [ n ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } int val = charVal ( s , 0 ) ; System . out . println ( countMinimalReplacements ( s , 1 , val , dp , n ) ) ; } }"], "python": ["import sys NEW_LINE def charVal ( s , i ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( s [ i ] == '1' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT def countMinimalReplacements ( s , i , prev , dp , n ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ prev ] NEW_LINE DEDENT val = charVal ( s , i ) NEW_LINE ans = sys . maxsize NEW_LINE if ( val == prev ) : NEW_LINE INDENT val = 0 NEW_LINE for cur in range ( 3 ) : NEW_LINE INDENT if ( cur == prev ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) NEW_LINE ans = min ( ans , val ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) NEW_LINE DEDENT dp [ i ] [ val ] = ans NEW_LINE return dp [ i ] [ val ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"201220211\" NEW_LINE n = len ( s ) NEW_LINE dp = [ [ - 1 for i in range ( 3 ) ] for i in range ( n ) ] NEW_LINE val = charVal ( s , 0 ) NEW_LINE print ( countMinimalReplacements ( s , 1 , val , dp , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3194_A", "java": ["import java . util . * ; class GFG { static int xorRange ( int pre [ ] , int l , int r ) { int cntOnes = pre [ r ] ; if ( l - 1 >= 0 ) cntOnes -= pre [ l - 1 ] ; if ( cntOnes % 2 == 0 ) return 0 ; else return 1 ; } static void performQueries ( int queries [ ] [ ] , int q , int a [ ] , int n ) { int [ ] pre = new int [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + a [ i ] ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 } ; int n = a . length ; int queries [ ] [ ] = { { 0 , 3 } , { 0 , 2 } } ; int q = queries . length ; performQueries ( queries , q , a , n ) ; } }"], "python": ["def xorRange ( pre , l , r ) : NEW_LINE INDENT cntOnes = pre [ r ] NEW_LINE if ( l - 1 >= 0 ) : NEW_LINE INDENT cntOnes -= pre [ l - 1 ] NEW_LINE DEDENT if ( cntOnes % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT def performQueries ( queries , q , a , n ) : NEW_LINE INDENT pre = [ 0 for i in range ( n ) ] NEW_LINE pre [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i ] NEW_LINE DEDENT for i in range ( q ) : NEW_LINE INDENT print ( xorRange ( pre , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT a = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE queries = [ [ 0 , 3 ] , [ 0 , 2 ] ] NEW_LINE q = len ( queries ) NEW_LINE performQueries ( queries , q , a , n ) NEW_LINE"]}
{"id": "codejam_17_33", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class ProblemC { public static void main ( String [ ] args ) throws Exception { try ( Scanner sc = new Scanner ( System . in ) ) { int cases = sc . nextInt ( ) ; for ( int caseNum = 1 ; caseNum <= cases ; caseNum ++ ) { solve ( sc , caseNum ) ; } } } static void solve ( Scanner sc , int caseNum ) { int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; double U = sc . nextDouble ( ) ; double [ ] P = new double [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { P [ i ] = sc . nextDouble ( ) ; } Arrays . sort ( P ) ; double eps = 1e-8 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { double add = P [ i + 1 ] - P [ i ] ; if ( add * ( i + 1 ) > U + eps ) { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += U / ( i + 1 ) ; } U = 0 ; break ; } else { for ( int j = 0 ; j <= i ; j ++ ) { P [ j ] += add ; } U -= add * ( i + 1 ) ; } } if ( U > 0 ) { for ( int j = 0 ; j < N ; j ++ ) { P [ j ] += U / N ; } } double res = 1 ; for ( int j = 0 ; j < N ; j ++ ) { res *= P [ j ] ; } System . out . printf ( \" Case \u2581 # % d : \u2581 % .8f \\n \" , caseNum , res ) ; } }", "package round1c ; import java . util . Arrays ; public class ProbC extends Prob { void setup ( ) { bin = true ; bout = true ; in = \" C - small - 1 - attempt0 . in \" ; out = \" cout . txt \" ; } @ Override public void main ( ) { setup ( ) ; reDirect ( ) ; int T = scanner . nextInt ( ) ; for ( int cas = 1 ; cas <= T ; cas ++ ) { double ans = run ( ) ; System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % f \" , cas , ans ) ) ; } } double run ( ) { int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; double u = scanner . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = scanner . nextDouble ( ) ; } Arrays . sort ( p ) ; double limit = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 || ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) > u ) { limit = u / ( i + 1 ) + p [ i ] ; break ; } else { u -= ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) ; } } double poss = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] < limit ) poss *= limit ; else poss *= p [ i ] ; } return poss ; } }", "package gcj2017 . r1c ; import java . io . * ; import java . util . Arrays ; import java . util . Scanner ; public class Training { static PrintWriter out ; public static void main ( String [ ] args ) throws IOException { String name = \" gcj2017 / r1c / C - small - 1\" ; Scanner s = new Scanner ( new File ( name + \" . in \" ) ) ; int count = s . nextInt ( ) ; out = new PrintWriter ( new BufferedWriter ( new FileWriter ( name + \" . out \" ) ) ) ; for ( int ii = 1 ; ii <= count ; ii ++ ) { out . print ( \" Case \u2581 # \" + ii + \" : \u2581 \" ) ; int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; double u = s . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = s . nextDouble ( ) ; } double res = solve ( n , k , u , p ) ; out . print ( String . format ( \" % .8f \" , res ) ) ; out . println ( ) ; } out . close ( ) ; } static double solve ( int n , int k , double u , double [ ] p ) { Arrays . sort ( p ) ; while ( u > 0.000000001 ) { double min = p [ 0 ] ; int ni = n ; double np = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] == min ) { continue ; } np = p [ i ] ; ni = i ; break ; } if ( ni * ( np - min ) <= u ) { for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] = np ; } u -= ni * ( np - min ) ; } else { double d = u / ni ; for ( int i = 0 ; i < ni ; i ++ ) { p [ i ] += d ; } u = 0 ; } } double res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { res *= p [ i ] ; } return res ; } }", "import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( new File ( \" output . txt \" ) ) ; int T = in . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = in . nextInt ( ) ; int k = in . nextInt ( ) ; double budget = in . nextDouble ( ) ; double [ ] p = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = in . nextDouble ( ) ; } out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + calc ( p , budget ) ) ; } out . close ( ) ; } static double calc ( double [ ] p , double budget ) { double ans = 1.0 ; int n = p . length ; Arrays . sort ( p ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { double d = p [ i + 1 ] - p [ i ] ; double need = d * ( i + 1 ) ; if ( budget < need ) { double minP = p [ i ] + budget / ( i + 1 ) ; for ( int j = 0 ; j <= i ; j ++ ) { ans *= minP ; } for ( int j = i + 1 ; j < n ; j ++ ) { ans *= p [ j ] ; } return ans ; } budget -= need ; } double minP = p [ n - 1 ] + budget / n ; return Math . pow ( minP , n ) ; } }", "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" C - small - 1 - attempt2 . in \" ) ) ; BufferedWriter bw = new BufferedWriter ( new FileWriter ( \" solve . txt \" ) ) ; int T = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; StringTokenizer s ; for ( int t = 1 ; t <= T ; t ++ ) { s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; int N = Integer . parseInt ( s . nextToken ( ) ) ; int K = Integer . parseInt ( s . nextToken ( ) ) ; double [ ] arr = new double [ N ] ; double U = Double . parseDouble ( br . readLine ( ) . trim ( ) ) ; s = new StringTokenizer ( br . readLine ( ) . trim ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = Double . parseDouble ( s . nextToken ( ) ) ; } Arrays . sort ( arr ) ; double pro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != N - 1 ) { if ( U > ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ) { U -= ( ( i + 1 ) * ( arr [ i + 1 ] - arr [ i ] ) ) ; } else { pro = Math . pow ( ( arr [ i ] + ( U / ( i + 1 ) ) ) , i + 1 ) ; for ( int j = i + 1 ; j < N ; j ++ ) { pro *= arr [ j ] ; } break ; } } else { pro = Math . pow ( ( U / N ) + arr [ i ] , N ) ; } } bw . write ( \" Case \u2581 # \" + t + \" : \u2581 \" ) ; bw . write ( String . format ( \" % .6f \\n \" , pro ) ) ; } br . close ( ) ; bw . close ( ) ; return ; } }"], "python": ["import math NEW_LINE CONVERT = 10000 NEW_LINE def f ( nums , power , k ) : NEW_LINE INDENT for i in range ( power ) : NEW_LINE INDENT nums [ nums . index ( min ( nums ) ) ] += 1 NEW_LINE DEDENT ans = 1 NEW_LINE for n in nums : NEW_LINE INDENT ans *= n / CONVERT NEW_LINE DEDENT return ans NEW_LINE DEDENT def logs ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return - 100000 NEW_LINE DEDENT return math . log ( x ) NEW_LINE DEDENT def logadd ( a , b ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT return a + logs ( 1 + math . exp ( b - a ) ) NEW_LINE DEDENT def p ( nums , K ) : NEW_LINE INDENT store = [ ] NEW_LINE for i in range ( K + 1 ) : NEW_LINE INDENT store . append ( [ 0 ] * len ( nums ) ) NEW_LINE DEDENT for k in range ( K + 1 ) : NEW_LINE INDENT for i in range ( len ( nums ) ) : NEW_LINE INDENT if k == 0 : NEW_LINE INDENT store [ k ] [ i ] = 0 NEW_LINE DEDENT elif i == 0 : NEW_LINE INDENT store [ k ] [ i ] = - 100000 NEW_LINE DEDENT else : NEW_LINE INDENT store [ k ] [ i ] = logadd ( store [ k - 1 ] [ i - 1 ] + logs ( nums [ i ] ) , store [ k ] [ i - 1 ] + logs ( 1 - nums [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT return store [ K ] [ len ( nums ) - 1 ] NEW_LINE DEDENT T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE power = float ( input ( ) ) NEW_LINE power *= CONVERT NEW_LINE power = round ( power ) NEW_LINE starts = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE for i in range ( len ( starts ) ) : NEW_LINE INDENT starts [ i ] = round ( starts [ i ] * CONVERT ) NEW_LINE DEDENT ans = f ( starts , power , k ) NEW_LINE print ( \" Case \u2581 # % s : \u2581 % s \" % ( case , ans ) ) NEW_LINE DEDENT", "import sys NEW_LINE import math NEW_LINE from functools import reduce NEW_LINE lines = [ l . strip ( ) for l in sys . stdin . readlines ( ) ] NEW_LINE T = int ( lines [ 0 ] ) NEW_LINE i = 1 NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , lines [ i ] . split ( ' \u2581 ' ) ) NEW_LINE i += 1 NEW_LINE U = float ( lines [ i ] ) NEW_LINE i += 1 NEW_LINE P = list ( map ( float , lines [ i ] . split ( ' \u2581 ' ) ) ) NEW_LINE i += 1 NEW_LINE P . sort ( ) NEW_LINE j = 0 NEW_LINE while j < N and U > 0.000000000001 : NEW_LINE INDENT while j < N - 1 and P [ j ] == P [ j + 1 ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT target = P [ j + 1 ] if j < N - 1 else 1 NEW_LINE required = ( target - P [ j ] ) * ( j + 1 ) NEW_LINE if required <= U : NEW_LINE INDENT U -= required NEW_LINE P [ 0 : j + 1 ] = [ target ] * ( j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT target = P [ j ] + U / ( j + 1 ) NEW_LINE U = 0 NEW_LINE P [ 0 : j + 1 ] = [ target ] * ( j + 1 ) NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % f \" % ( t + 1 , reduce ( lambda x , y : x * y , P , 1.0 ) ) ) NEW_LINE DEDENT", "with open ( ' C - small - 1 - attempt0 . in ' ) as infile : NEW_LINE INDENT with open ( ' C - small - 1 - attempt0 . out ' , ' w ' ) as outfile : NEW_LINE INDENT cases = int ( next ( infile ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT n , k = map ( int , next ( infile ) . split ( ) ) NEW_LINE u = round ( float ( next ( infile ) ) * 10000 ) NEW_LINE p = list ( map ( lambda x : round ( float ( x ) * 10000 ) , next ( infile ) . split ( ) ) ) NEW_LINE p . sort ( ) NEW_LINE p . append ( 10000 ) NEW_LINE i = 0 NEW_LINE while u > 0 and i < len ( p ) : NEW_LINE INDENT while i < len ( p ) and p [ i ] == p [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT x = min ( ( p [ i + 1 ] - p [ i ] ) * ( i + 1 ) , u ) NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT p [ j ] += x / ( i + 1 ) NEW_LINE DEDENT u -= x NEW_LINE DEDENT product = 1 NEW_LINE for x in p : NEW_LINE INDENT product *= x / 10000 NEW_LINE DEDENT print ( case , product ) NEW_LINE print ( \" Case \u2581 # { } : \u2581 { } \" . format ( case , product ) , file = outfile ) NEW_LINE DEDENT DEDENT DEDENT", "import sys NEW_LINE def problem ( success , units , cores ) : NEW_LINE INDENT cores . sort ( ) NEW_LINE cores . append ( 1.0 ) NEW_LINE spent = 0.0 NEW_LINE min_prob = 0.0 NEW_LINE for i , core in enumerate ( cores ) : NEW_LINE INDENT if core == 1.0 : NEW_LINE INDENT min_prob = 1.0 NEW_LINE break NEW_LINE DEDENT plan = ( cores [ i + 1 ] - cores [ i ] ) * ( i + 1 ) NEW_LINE if plan > units - spent : NEW_LINE INDENT min_prob = core + ( units - spent ) / ( i + 1 ) NEW_LINE break NEW_LINE DEDENT spent += plan NEW_LINE DEDENT prob = 1.0 NEW_LINE for n in cores : NEW_LINE INDENT prob *= max ( min_prob , n ) NEW_LINE DEDENT return prob NEW_LINE DEDENT def nextline ( input_file ) : NEW_LINE INDENT data = \" \" NEW_LINE while not data : NEW_LINE INDENT data = input_file . readline ( ) NEW_LINE DEDENT return data [ : - 1 ] NEW_LINE DEDENT def intsplit ( s ) : NEW_LINE INDENT return [ int ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT def floatsplit ( s ) : NEW_LINE INDENT return [ float ( x ) for x in s . split ( \" \u2581 \" ) ] NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT result = \" \" NEW_LINE with sys . stdin if len ( sys . argv ) == 1 else open ( sys . argv [ 1 ] , ' r ' ) as infile : NEW_LINE INDENT number = int ( nextline ( infile ) ) NEW_LINE for run in range ( number ) : NEW_LINE INDENT case = nextline ( infile ) NEW_LINE total , success = intsplit ( case ) NEW_LINE units = float ( nextline ( infile ) ) NEW_LINE cores = floatsplit ( nextline ( infile ) ) NEW_LINE result += ' Case \u2581 # { } : \u2581 { } \\n ' . format ( 1 + run , problem ( success , units , cores ) ) NEW_LINE DEDENT DEDENT if len ( sys . argv ) == 1 : NEW_LINE INDENT print ( result , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT with open ( sys . argv [ 1 ] . replace ( ' in ' , ' sol ' ) , ' w ' ) as result_file : NEW_LINE INDENT result_file . write ( result ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import functools NEW_LINE import operator NEW_LINE def work ( ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE u = float ( input ( ) ) NEW_LINE ps = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE def f ( v ) : NEW_LINE INDENT return functools . reduce ( operator . mul , ( max ( p , v ) for p in ps ) ) NEW_LINE DEDENT def search ( a , b , it ) : NEW_LINE INDENT if it == 100 : NEW_LINE INDENT return a NEW_LINE DEDENT c = 0.5 * ( a + b ) NEW_LINE return search ( c , b , it + 1 ) if sum ( max ( 0 , c - p ) for p in ps ) <= u else search ( a , c , it + 1 ) NEW_LINE DEDENT return f ( search ( 0 , 1 , 0 ) ) NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { : . 7f } ' . format ( t + 1 , work ( ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3854_A", "java": ["import java . io . * ; class GFG { static void printArray ( int [ ] A , int n , int K ) { int minEle = Integer . MAX_VALUE , maxEle = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { minEle = Math . min ( minEle , A [ i ] ) ; maxEle = Math . max ( maxEle , A [ i ] ) ; } if ( K != 0 ) { if ( K % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = maxEle - A [ i ] ; } else { for ( int i = 0 ; i < n ; i ++ ) A [ i ] = A [ i ] - minEle ; } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + \" \u2581 \" ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 12 , 16 } ; int K = 4 ; int N = arr . length ; printArray ( arr , N , K ) ; } }"], "python": ["def printArray ( A , n , K ) : NEW_LINE INDENT minEle = 10 ** 9 NEW_LINE maxEle = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT minEle = min ( minEle , A [ i ] ) NEW_LINE maxEle = max ( maxEle , A [ i ] ) NEW_LINE DEDENT if ( K != 0 ) : NEW_LINE INDENT if ( K % 2 == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = maxEle - A [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT A [ i ] = A [ i ] - minEle NEW_LINE DEDENT DEDENT DEDENT for i in A : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) NEW_LINE printArray ( arr , N , K ) NEW_LINE DEDENT"]}
{"id": "aizu_p00848_A", "java": ["import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; void run ( ) { boolean [ ] isPrime = new boolean [ 1121 ] ; Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1120 ; i ++ ) { if ( ! isPrime [ i ] ) continue ; for ( int j = i * 2 ; j <= 1120 ; j += i ) isPrime [ j ] = false ; } ArrayList < Integer > l = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= 1120 ; i ++ ) { if ( isPrime [ i ] ) l . add ( i ) ; } int [ ] [ ] dp = new int [ 15 ] [ 1121 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) { for ( int j = 13 ; j >= 0 ; j -- ) { for ( int k = 0 ; k <= 1120 ; k ++ ) { if ( dp [ j ] [ k ] != 0 && k + l . get ( i ) <= 1120 ) { dp [ j + 1 ] [ k + l . get ( i ) ] += dp [ j ] [ k ] ; } } } } for ( ; ; ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( ( n | k ) == 0 ) return ; System . out . println ( dp [ k ] [ n ] ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . util . * ; class Main { void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int max = 1200 ; boolean [ ] p = new boolean [ max ] ; for ( int i = 2 ; i < max ; i ++ ) p [ i ] = true ; for ( int i = 2 ; i < Math . sqrt ( max ) ; i ++ ) { if ( ! p [ i * i ] ) continue ; for ( int j = i * i ; j < max ; j += i ) p [ j ] = false ; } int [ ] [ ] dp = new int [ max ] [ 15 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int k = 1 ; k < max ; k ++ ) { if ( ! p [ k ] ) continue ; for ( int i = max - 1 ; i >= 0 ; i -- ) { if ( i - k < 0 ) continue ; for ( int j = 14 ; j >= 1 ; j -- ) { dp [ i ] [ j ] += dp [ i - k ] [ j - 1 ] ; } } } while ( true ) { int n = sc . nextInt ( ) , K = sc . nextInt ( ) ; if ( n == 0 && K == 0 ) break ; System . out . println ( dp [ n ] [ K ] ) ; } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }", "import java . util . * ; public class Main { static int [ ] p = new int [ 1130 ] ; static int pnum ; static int [ ] [ ] [ ] dp ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; calcPrimes ( ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; while ( n != 0 ) { dp = new int [ 1121 ] [ 15 ] [ 188 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) for ( int l = 0 ; l < 188 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; System . out . println ( solve ( n , k , 0 ) ) ; n = sc . nextInt ( ) ; k = sc . nextInt ( ) ; } } public static int solve ( int n , int k , int idx ) { if ( n == 0 && k == 0 ) { return 1 ; } else if ( n == 0 || k == 0 ) { return 0 ; } if ( dp [ n ] [ k ] [ idx ] >= 0 ) { return dp [ n ] [ k ] [ idx ] ; } int res = 0 ; for ( int i = idx ; i < pnum ; i ++ ) { if ( p [ i ] > n ) { break ; } else { res += solve ( n - p [ i ] , k - 1 , i + 1 ) ; } } return dp [ n ] [ k ] [ idx ] = res ; } public static void calcPrimes ( ) { p [ 0 ] = 2 ; pnum = 1 ; for ( int i = 3 ; i <= 1120 ; i += 2 ) { boolean add = true ; for ( int j = 0 ; j < pnum ; j ++ ) { if ( p [ j ] * p [ j ] > i ) { break ; } if ( i % p [ j ] == 0 ) { add = false ; break ; } } if ( add ) { p [ pnum ++ ] = i ; } } } }", "import java . util . * ; import java . awt . geom . * ; import java . io . * ; public class Main { int [ ] [ ] dp ; int MAX = 1120 ; int K = 14 ; boolean [ ] isprime ; private void doit ( ) { Scanner sc = new Scanner ( System . in ) ; isprime = new boolean [ MAX + 1 ] ; eratos ( ) ; dp = new int [ K + 1 ] [ MAX + 1 ] ; dp ( ) ; while ( true ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( ( n | k ) == 0 ) break ; int ans = dp [ k ] [ n ] ; System . out . println ( ans ) ; } } private void dp ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { dp [ 1 ] [ i ] = isprime [ i ] ? 1 : 0 ; } for ( int i = MAX ; i >= 2 ; i -- ) { if ( ! isprime [ i ] ) continue ; for ( int j = MAX ; j >= i ; j -- ) { for ( int k = K - 1 ; k >= 1 ; k -- ) { if ( k == 1 && j == i ) continue ; if ( j + i > MAX ) continue ; dp [ k + 1 ] [ j + i ] += dp [ k ] [ j ] ; } } } } private void eratos ( ) { Arrays . fill ( isprime , true ) ; isprime [ 0 ] = false ; isprime [ 1 ] = false ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( isprime [ i ] ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { isprime [ j ] = false ; } } } } public static void main ( String [ ] args ) { new Main ( ) . doit ( ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { Scanner sc ; int nn = 1121 ; int kk = 15 ; int dp [ ] [ ] = new int [ nn ] [ kk ] ; Main ( ) { sc = new Scanner ( System . in ) ; dp [ 0 ] [ 0 ] = 1 ; boolean pp [ ] = new boolean [ nn ] ; Arrays . fill ( pp , true ) ; pp [ 0 ] = false ; pp [ 1 ] = false ; pp [ 2 ] = true ; for ( int i = 0 ; i < nn ; i ++ ) { if ( pp [ i ] ) { for ( int j = i << 1 ; j < nn ; j += i ) { pp [ j ] = false ; } } } for ( int k = 0 ; k < nn ; k ++ ) { if ( ! pp [ k ] ) { continue ; } for ( int i = nn - 1 ; i >= k ; i -- ) { for ( int j = 14 ; j > 0 ; j -- ) { dp [ i ] [ j ] += dp [ i - k ] [ j - 1 ] ; } } } } void run ( ) { for ( ; ; ) { int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( n + k == 0 ) { break ; } System . out . println ( dp [ n ] [ k ] ) ; } } public static void main ( String args [ ] ) { Main m = new Main ( ) ; m . run ( ) ; } }"], "python": ["p = [ ] NEW_LINE for i in range ( 2 , 1121 ) : NEW_LINE INDENT for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if not i % j : break NEW_LINE DEDENT else : p += [ i ] NEW_LINE DEDENT dp = [ [ 0 ] * 1121 for _ in range ( 15 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for x , y in enumerate ( p ) : NEW_LINE INDENT for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( y , 1121 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j - y ] NEW_LINE DEDENT DEDENT DEDENT while 1 : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : break NEW_LINE print ( dp [ k ] [ n ] ) NEW_LINE DEDENT", "primes = [ ] NEW_LINE flag = [ 0 for i in range ( 1121 ) ] NEW_LINE for i in range ( 2 , 1121 ) : NEW_LINE INDENT if flag [ i ] == 0 : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT count = 2 NEW_LINE while i * count < 1121 : NEW_LINE INDENT flag [ i * count ] = 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT dp = [ [ 0 for i in range ( 15 ) ] for j in range ( 1121 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for p in primes : NEW_LINE INDENT for k in range ( 13 , - 1 , - 1 ) : NEW_LINE INDENT for n in range ( 1121 ) : NEW_LINE INDENT if n + p < 1121 : NEW_LINE INDENT dp [ n + p ] [ k + 1 ] += dp [ n ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT while True : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE if ( N | K == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( dp [ N ] [ K ] ) NEW_LINE DEDENT", "import sys NEW_LINE import math NEW_LINE import string NEW_LINE import collections NEW_LINE import fractions NEW_LINE import random NEW_LINE from operator import itemgetter NEW_LINE import itertools NEW_LINE from collections import deque NEW_LINE import copy NEW_LINE import heapq NEW_LINE import bisect NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE INF = float ( ' inf ' ) NEW_LINE input = lambda : sys . stdin . readline ( ) . strip ( ) NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE def judge_prime_num ( n ) : NEW_LINE INDENT if n % 2 == 0 and n != 2 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT for num in range ( 3 , int ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if n % num == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT prime_list = [ ] NEW_LINE for i in range ( 2 , 1121 ) : NEW_LINE INDENT if judge_prime_num ( i ) : NEW_LINE INDENT prime_list . append ( i ) NEW_LINE DEDENT DEDENT dp = [ [ [ 0 ] * 1122 for _ in range ( 16 ) ] for _ in range ( 190 ) ] NEW_LINE dp [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( len ( prime_list ) ) : NEW_LINE INDENT for j in range ( 15 ) : NEW_LINE INDENT for k in range ( 1121 ) : NEW_LINE INDENT if k + prime_list [ i ] <= 1120 : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] [ k + prime_list [ i ] ] += dp [ i ] [ j ] [ k ] NEW_LINE DEDENT dp [ i + 1 ] [ j ] [ k ] += dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE while not n == k == 0 : NEW_LINE INDENT print ( dp [ len ( prime_list ) ] [ k ] [ n ] ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_64_A", "java": ["class GFG { static int MAX = 64 ; static int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; lbit = ( L >> i ) & 1 ; rbit = ( R >> i ) & 1 ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; } public static void main ( String [ ] args ) { int L = 4 , R = 5 ; System . out . println ( maxOR ( L , R ) ) ; } }"], "python": ["MAX = 64 ; NEW_LINE def maxOR ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT ans = 0 ; NEW_LINE for i in range ( MAX - 1 , - 1 , - 1 ) : NEW_LINE INDENT p = 1 << i ; NEW_LINE lbit = ( L >> i ) & 1 ; NEW_LINE rbit = ( R >> i ) & 1 ; NEW_LINE if ( ( rbit == 1 ) and ( lbit == 0 ) ) : NEW_LINE INDENT ans += ( p << 1 ) - 1 ; NEW_LINE break ; NEW_LINE DEDENT if ( rbit == 1 ) : NEW_LINE INDENT ans += p ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 4 ; R = 5 ; NEW_LINE print ( maxOR ( L , R ) ) ; NEW_LINE DEDENT"]}
{"id": "aizu_p01515_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main p = new Main ( ) ; } public Main ( ) { Scanner sc = new Scanner ( System . in ) ; alphav = new boolean [ 11 ] ; while ( true ) { String s = sc . next ( ) ; if ( s . equals ( \" # \" ) ) break ; solve ( s ) ; } } public void solve ( String s ) { String [ ] fs = s . split ( \" = \" ) ; boolean res = true ; for ( int i = 0 ; i < ( 1 << 11 ) ; i ++ ) { for ( int j = 0 ; j < alphav . length ; j ++ ) alphav [ j ] = ( i & ( 1 << j ) ) > 0 ; cur = 0 ; f = fs [ 0 ] ; boolean r0 = fomula ( ) ; cur = 0 ; f = fs [ 1 ] ; boolean r1 = fomula ( ) ; if ( r0 != r1 ) { res = false ; break ; } } System . out . println ( res ? \" YES \" : \" NO \" ) ; } boolean [ ] alphav ; String f ; int cur = 0 ; private boolean fomula ( ) { boolean ret = false ; char nc = nextc ( ) ; if ( ' a ' <= nc && nc <= ' k ' ) return alphav [ nc - ' a ' ] ; switch ( nc ) { case ' T ' : ret = true ; break ; case ' F ' : ret = false ; break ; case ' - ' : ret = ! fomula ( ) ; break ; case ' ( ' : ret = fomula ( ) ; nc = nextc ( ) ; switch ( nc ) { case ' * ' : ret &= fomula ( ) ; break ; case ' + ' : ret |= fomula ( ) ; break ; case ' - ' : nextc ( ) ; ret = ! ( ! fomula ( ) && ret ) ; break ; } nextc ( ) ; break ; } return ret ; } private char nextc ( ) { char c = f . charAt ( cur ) ; cur ++ ; return c ; } }", "import java . util . * ; import java . math . * ; import java . awt . geom . * ; import java . io . * ; public class Main { static int id ; static String S ; static int V ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { S = sc . next ( ) ; if ( S . equals ( \" # \" ) ) break ; boolean ans = true ; for ( V = 0 ; V < ( 1 << 12 ) ; V ++ ) { id = 0 ; ans &= equation ( ) ; if ( ! ans ) break ; } System . out . println ( ans ? \" YES \" : \" NO \" ) ; } } static boolean equation ( ) { boolean a = formula ( ) ; id ++ ; boolean b = formula ( ) ; return a == b ; } static boolean formula ( ) { if ( S . charAt ( id ) == ' T ' ) { id ++ ; return true ; } if ( S . charAt ( id ) == ' F ' ) { id ++ ; return false ; } for ( int i = 0 ; i < 12 ; i ++ ) { if ( S . charAt ( id ) == ( char ) ( ' a ' + i ) ) { id ++ ; return ( V & ( 1 << i ) ) != 0 ; } } if ( S . charAt ( id ) == ' - ' ) { id ++ ; return ! formula ( ) ; } if ( S . charAt ( id ) == ' ( ' ) { id ++ ; boolean A = formula ( ) ; char B = S . charAt ( id ) ; if ( B == ' - ' ) { id ++ ; } id ++ ; boolean C = formula ( ) ; id ++ ; if ( B == ' - ' ) { if ( A && ! C ) return false ; return true ; } if ( B == ' + ' ) { return A | C ; } if ( B == ' * ' ) { return A & C ; } } return true ; } }", "import java . util . Scanner ; public class Main { boolean [ ] assign ; char [ ] s ; int idx ; char get ( ) { return s [ idx ++ ] ; } String s1 , s2 ; boolean f ( int k ) { if ( k == 11 ) { s = s1 . toCharArray ( ) ; idx = 0 ; boolean f1 = formula ( ) ; s = s2 . toCharArray ( ) ; idx = 0 ; return f1 == formula ( ) ; } assign [ k ] = false ; if ( ! f ( k + 1 ) ) return false ; assign [ k ] = true ; return f ( k + 1 ) ; } boolean formula ( ) { char ch = get ( ) ; if ( ch == ' ( ' ) { boolean f1 = formula ( ) ; ch = get ( ) ; if ( ch == ' * ' ) { boolean f2 = formula ( ) ; get ( ) ; return f1 && f2 ; } else if ( ch == ' + ' ) { boolean f2 = formula ( ) ; get ( ) ; return f1 || f2 ; } else { get ( ) ; boolean f2 = formula ( ) ; get ( ) ; return ! f1 || f2 ; } } else if ( ch == ' - ' ) { return ! formula ( ) ; } else if ( ch == ' T ' ) { return true ; } else if ( ch == ' F ' ) { return false ; } else return assign [ ch - ' a ' ] ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; assign = new boolean [ 11 ] ; for ( ; ; ) { String t = sc . next ( ) ; if ( \" # \" . equals ( t ) ) break ; String [ ] tt = t . split ( \" = \" ) ; s1 = tt [ 0 ] + \" $ \" ; s2 = tt [ 1 ] + \" $ \" ; System . out . println ( f ( 0 ) ? \" YES \" : \" NO \" ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String s = sc . next ( ) ; if ( s . equals ( \" # \" ) ) { break ; } if ( isEquation ( s ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } public static boolean isEquation ( String s ) { for ( int i = 0 ; i < ( 1 << 11 ) ; i ++ ) { String s2 = String . valueOf ( s ) ; for ( int j = 0 ; j < 11 ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) { s2 = s2 . replaceAll ( String . valueOf ( ( char ) ( ' a ' + j ) ) , \" T \" ) ; } else { s2 = s2 . replaceAll ( String . valueOf ( ( char ) ( ' a ' + j ) ) , \" F \" ) ; } } String [ ] exp = s2 . split ( \" = \" ) ; if ( evaluate ( exp [ 0 ] ) != evaluate ( exp [ 1 ] ) ) { return false ; } } return true ; } public static int index = 0 ; public static boolean evaluate ( String s ) { index = 0 ; boolean ret = expression ( s ) ; return ret ; } public static boolean expression ( String s ) { char c = s . charAt ( index ) ; if ( c == ' T ' || c == ' F ' ) { index ++ ; return c == ' T ' ; } if ( c == ' - ' ) { index ++ ; return ! expression ( s ) ; } if ( c == ' ( ' ) { index ++ ; boolean temp = term ( s ) ; index ++ ; return temp ; } return false ; } public static boolean term ( String s ) { boolean first = expression ( s ) ; char c = s . charAt ( index ) ; index += c == ' - ' ? 2 : 1 ; boolean second = expression ( s ) ; if ( c == ' * ' ) { return first && second ; } else if ( c == ' + ' ) { return first || second ; } else { return ! ( first && ! second ) ; } } }"], "python": ["from itertools import product NEW_LINE variables = set ( list ( \" abcdefghijk \" ) ) NEW_LINE def formula ( S , X , i ) : NEW_LINE INDENT if S [ i ] == \" T \" : NEW_LINE INDENT return 1 , i + 1 NEW_LINE DEDENT elif S [ i ] == \" F \" : NEW_LINE INDENT return 0 , i + 1 NEW_LINE DEDENT elif S [ i ] in variables : NEW_LINE INDENT return X [ S [ i ] ] , i + 1 NEW_LINE DEDENT elif S [ i ] == \" - \" : NEW_LINE INDENT i += 1 NEW_LINE that , i = formula ( S , X , i ) NEW_LINE return ( not that ) , i NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE this , i = formula ( S , X , i ) NEW_LINE op = S [ i ] NEW_LINE i += 1 NEW_LINE that , i = formula ( S , X , i ) NEW_LINE i += 1 NEW_LINE if op == \" * \" : NEW_LINE INDENT return this & that , i NEW_LINE DEDENT elif op == \" + \" : NEW_LINE INDENT return this | that , i NEW_LINE DEDENT elif op == \" @ \" : NEW_LINE INDENT return ( not this ) | that , i NEW_LINE DEDENT else : NEW_LINE INDENT raise NEW_LINE DEDENT DEDENT DEDENT S = input ( ) NEW_LINE T , F = 1 , 0 NEW_LINE while S != \" # \" : NEW_LINE INDENT S = S . replace ( \" - > \" , \" @ \" ) NEW_LINE while \" - - \" in S : NEW_LINE INDENT S = S . replace ( \" - - \" , \" \" ) NEW_LINE DEDENT L , R = S . split ( \" = \" ) NEW_LINE for v in range ( 2 ** 11 ) : NEW_LINE INDENT X = { } NEW_LINE for a , x in zip ( list ( \" abcdefghijk \" ) , format ( v , \" b \" ) . zfill ( 11 ) ) : NEW_LINE INDENT X [ a ] = int ( x ) NEW_LINE DEDENT l , _ = formula ( L , X , 0 ) NEW_LINE r , _ = formula ( R , X , 0 ) NEW_LINE if int ( l ) != int ( r ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT S = input ( ) NEW_LINE DEDENT", "while True : NEW_LINE INDENT s = input ( ) NEW_LINE if s == \" # \" : NEW_LINE INDENT break NEW_LINE DEDENT index = - 1 NEW_LINE bits = [ ] NEW_LINE for i in range ( 2 << 11 ) : NEW_LINE INDENT bit = [ ] NEW_LINE for j in range ( 11 ) : NEW_LINE INDENT bit . append ( i >> j & 1 == 1 ) NEW_LINE DEDENT bits . append ( bit ) NEW_LINE DEDENT def formula ( string ) : NEW_LINE INDENT global index NEW_LINE index += 1 NEW_LINE if string [ index ] == \" T \" : NEW_LINE INDENT return True NEW_LINE DEDENT elif string [ index ] == \" F \" : NEW_LINE INDENT return False NEW_LINE DEDENT elif string [ index ] == \" - \" : NEW_LINE INDENT return not formula ( string ) NEW_LINE DEDENT elif string [ index ] == \" ( \" : NEW_LINE INDENT left = formula ( string ) NEW_LINE index += 1 NEW_LINE ope = string [ index ] NEW_LINE if ope == \" - \" : NEW_LINE INDENT index += 1 NEW_LINE DEDENT right = formula ( string ) NEW_LINE index += 1 NEW_LINE if ope == \" + \" : NEW_LINE INDENT return left or right NEW_LINE DEDENT elif ope == \" * \" : NEW_LINE INDENT return left and right NEW_LINE DEDENT else : NEW_LINE INDENT return False if left and not right else True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return bit [ ord ( string [ index ] ) - ord ( \" a \" ) ] NEW_LINE DEDENT DEDENT f = True NEW_LINE for bit in bits : NEW_LINE INDENT l , r = s . split ( \" = \" ) NEW_LINE index = - 1 NEW_LINE l_b = formula ( l ) NEW_LINE index = - 1 NEW_LINE r_b = formula ( r ) NEW_LINE if l_b != r_b : NEW_LINE INDENT f = False NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_245_A", "java": ["import java . io . * ; import java . util . * ; public class GFG { static int findSplit ( int [ ] arr , int n ) { int i ; int preSum = 0 ; int ind1 = - 1 , ind2 = - 1 ; int S ; S = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) S += arr [ i ] ; if ( S % 3 != 0 ) return 0 ; int S1 = S / 3 ; int S2 = 2 * S1 ; for ( i = 0 ; i < n ; i ++ ) { preSum += arr [ i ] ; if ( preSum % S1 == 0 && ind1 == - 1 ) ind1 = i ; else if ( preSum % S2 == 0 ) { ind2 = i ; break ; } } if ( ind1 != - 1 && ind2 != - 1 ) { System . out . print ( \" ( \" + ind1 + \" , \u2581 \" + ind2 + \" ) \" ) ; return 1 ; } return 0 ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 3 , 4 , 0 , 4 } ; int n = arr . length ; if ( findSplit ( arr , n ) == 0 ) System . out . print ( \" - 1\" ) ; } }"], "python": ["def findSplit ( arr , n ) : NEW_LINE INDENT preSum = 0 NEW_LINE ind1 = - 1 NEW_LINE ind2 = - 1 NEW_LINE S = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT if ( S % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT S1 = S / 3 NEW_LINE S2 = 2 * S1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum += arr [ i ] NEW_LINE if ( preSum % S1 == 0 and ind1 == - 1 ) : NEW_LINE INDENT ind1 = i NEW_LINE DEDENT elif ( preSum % S2 == 0 ) : NEW_LINE INDENT ind2 = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( ind1 != - 1 and ind2 != - 1 ) : NEW_LINE INDENT print ( \" ( { } , \u2581 { } ) \" . format ( ind1 , ind2 ) ) NEW_LINE return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 0 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( findSplit ( arr , n ) == 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4716_A", "java": ["import java . util . Arrays ; class GFG { static int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Arrays . fill ( cnt , 0 , cnt . length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } } public static void main ( String [ ] args ) { int N = 3 , K = 2 ; System . out . println ( NoofTriplets ( N , K ) ) ; } }"], "python": ["def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4537_A", "java": ["import java . io . * ; class GFG { static void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { System . out . print ( ( ( 1 << x ) + ( 1 << y ) ) + \" \u2581 \" ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } public static void main ( String [ ] args ) { int n = 4 ; printTwoSetBitNums ( n ) ; } }"], "python": ["def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = \" \u2581 \" ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE"]}
{"id": "geeksforgeeks_984_A", "java": ["import java . util . Arrays ; class GFG { static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; Arrays . fill ( dp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; } public static void main ( String [ ] args ) { int val [ ] = { 7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; System . out . println ( KnapSack ( val , wt , n , W ) ) ; } }"], "python": ["def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT val = [ 7 , 8 , 4 ] ; NEW_LINE wt = [ 3 , 8 , 6 ] ; NEW_LINE W = 10 ; n = 3 ; NEW_LINE print ( KnapSack ( val , wt , n , W ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_1454_A", "java": ["import java . io . * ; class GFG { static int twoEggDrop ( int k ) { return ( int ) Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; } public static void main ( String [ ] args ) { int k = 100 ; System . out . println ( twoEggDrop ( k ) ) ; } }"], "python": ["import math as mt NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2346_A", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; } public static void main ( String args [ ] ) { int n = 35 ; System . out . println ( nextPerfectSquare ( n ) ) ; } }"], "python": ["import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectSquare ( N ) ) NEW_LINE DEDENT"]}
{"id": "aizu_p02399_A", "java": ["import java . util . Scanner ; import java . math . BigDecimal ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; System . out . print ( x / y + \" \u2581 \" + x % y ) ; System . out . printf ( \" \u2581 % 5.8f \\n \" , ( double ) x / y ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder sb = new StringBuilder ( ) ; String num = br . readLine ( ) ; String [ ] set = num . split ( \" \u2581 \" ) ; int a = Integer . parseInt ( set [ 0 ] ) ; int b = Integer . parseInt ( set [ 1 ] ) ; int c = a / b ; int d = a % b ; String f = String . format ( \" % .5f \" , ( ( double ) a / ( double ) b ) ) ; System . out . println ( sb . append ( c ) . append ( \" \u2581 \" ) . append ( d ) . append ( \" \u2581 \" ) . append ( f ) ) ; } }", "import java . math . BigDecimal ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; scan . close ( ) ; int t1 = a / b ; int t2 = a % b ; double t3 = ( double ) a / b ; if ( b == 1 ) { System . out . println ( t1 + \" \u2581 \" + t2 + \" \u2581 \" + t1 ) ; } else { System . out . println ( t1 + \" \u2581 \" + t2 + \" \u2581 \" + BigDecimal . valueOf ( t3 ) . toPlainString ( ) ) ; } } }", "import java . text . DecimalFormat ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; long a = scanner . nextInt ( ) ; long b = scanner . nextInt ( ) ; scanner . close ( ) ; DecimalFormat df = new DecimalFormat ( \"0.00000\" ) ; System . out . println ( ( a / b ) + \" \u2581 \" + ( a % b ) + \" \u2581 \" + df . format ( ( ( double ) a / b ) ) ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws Exception { String str [ ] , ans ; int a , b ; int d , r ; String f ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; str = br . readLine ( ) . split ( \" \u2581 \" ) ; a = Integer . parseInt ( str [ 0 ] ) ; b = Integer . parseInt ( str [ 1 ] ) ; d = a / b ; r = a % b ; f = String . format ( \" % .5f \" , ( ( double ) a / ( double ) b ) ) ; System . out . println ( d + \" \u2581 \" + r + \" \u2581 \" + f ) ; } }"], "python": ["a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a // b , a % b , \" % .9f \" % ( a / b ) ) NEW_LINE", "a , b = input ( ) . split ( ) NEW_LINE a , b = int ( a ) , int ( b ) NEW_LINE d = a // b NEW_LINE r = a % b NEW_LINE f = a / b NEW_LINE print ( d , r , \" { 0 : . 5f } \" . format ( f ) ) NEW_LINE", "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d , r , f = a / b , a % b , float ( a / b ) NEW_LINE print ( \" % d \u2581 % d \u2581 % 0.5f \" % ( d , r , f ) ) NEW_LINE DEDENT", "l = input ( ) . split ( ) NEW_LINE a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) NEW_LINE print ( f \" { a / / b } \u2581 { a % b } \u2581 { a / b : .5f } \" ) NEW_LINE", "a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( \" % d \u2581 % d \u2581 % .10f \" % ( a // b , a % b , a / b ) ) NEW_LINE"]}
{"id": "geeksforgeeks_804_A", "java": ["public class GFG { final static double eps = ( double ) 1e-6 ; static double getArea ( double base , double hypotenuse ) { double height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; } static void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { System . out . print ( \" Not \u2581 possible \" ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } double height = Math . sqrt ( hsquare - base * base ) ; System . out . println ( Math . round ( base ) + \" \u2581 \" + Math . round ( height ) ) ; } static public void main ( String [ ] args ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; } }"], "python": ["import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( \" Not \u2581 possiblen \" ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_588_A", "java": ["class GFG { static int n = 3 ; static int MAX = 30 ; static int dp [ ] [ ] [ ] = new int [ n ] [ n ] [ MAX ] ; static boolean v [ ] [ ] [ ] = new boolean [ n ] [ n ] [ MAX ] ; static int findCount ( int mat [ ] [ ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 || j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; System . out . println ( findCount ( mat , n - 1 , n - 1 , m ) ) ; } }"], "python": ["n = 3 NEW_LINE MAX = 60 NEW_LINE dp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE v = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE m = 5 NEW_LINE print ( findCount ( mat , n - 1 , n - 1 , m ) ) NEW_LINE"]}
{"id": "codeforces_145_A", "java": ["import java . util . Scanner ; public class Ishu { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int i , no4 = 0 , no7 = 0 , max = 0 , min = 0 ; String a , b ; a = scan . next ( ) ; b = scan . next ( ) ; for ( i = 0 ; i < a . length ( ) ; ++ i ) { if ( ! ( a . substring ( i , i + 1 ) . equals ( b . substring ( i , i + 1 ) ) ) ) { if ( a . substring ( i , i + 1 ) . equals ( \"4\" ) ) no4 ++ ; else no7 ++ ; } } max = no4 >= no7 ? no4 : no7 ; System . out . println ( max ) ; } }", "import java . io . * ; import java . util . * ; public class CF145A extends PrintWriter { CF145A ( ) { super ( System . out , true ) ; } Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] $ ) { CF145A o = new CF145A ( ) ; o . main ( ) ; o . flush ( ) ; } void main ( ) { byte [ ] aa = sc . next ( ) . getBytes ( ) ; byte [ ] bb = sc . next ( ) . getBytes ( ) ; int n = aa . length , n47 = 0 , n74 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { byte a = aa [ i ] ; byte b = bb [ i ] ; if ( a == '4' && b == '7' ) n47 ++ ; else if ( a == '7' && b == '4' ) n74 ++ ; } println ( Math . max ( n47 , n74 ) ) ; } }", "import java . util . * ; public class CF_145A { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String temp = in . nextLine ( ) ; char [ ] a = temp . toCharArray ( ) ; temp = in . nextLine ( ) ; char [ ] b = temp . toCharArray ( ) ; int aNum7s = 0 ; int bNum7s = 0 ; int numDiffs = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] == '7' ) { aNum7s ++ ; } if ( b [ i ] == '7' ) { bNum7s ++ ; } if ( a [ i ] != b [ i ] ) { numDiffs ++ ; } } int numOps = ( Math . abs ( aNum7s - bNum7s ) + numDiffs ) / 2 ; System . out . println ( numOps ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; char [ ] list1 = scanner . next ( ) . toCharArray ( ) ; char [ ] list2 = scanner . next ( ) . toCharArray ( ) ; char [ ] temp1 = list1 . clone ( ) ; char [ ] temp2 = list2 . clone ( ) ; int numDif1 = 0 ; int numDif2 = 0 ; int count = 0 ; Arrays . sort ( list1 ) ; Arrays . sort ( list2 ) ; for ( int i = 0 ; i < list1 . length ; i ++ ) { if ( list1 [ i ] != list2 [ i ] ) { numDif1 ++ ; } } count = numDif1 ; int i = 0 ; while ( count > 0 ) { if ( temp1 [ i ] == '7' && temp2 [ i ] == '4' ) { temp1 [ i ] = '4' ; count -- ; } else if ( temp1 [ i ] == '4' && temp2 [ i ] == '7' ) { temp1 [ i ] = '7' ; count -- ; } i ++ ; } for ( int k = 0 ; k < temp1 . length ; k ++ ) { if ( temp1 [ k ] != temp2 [ k ] ) { numDif2 ++ ; } } System . out . println ( ( int ) ( numDif1 + Math . ceil ( numDif2 / 2.0 ) ) ) ; } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE a = input ( ) [ : - 1 ] NEW_LINE b = input ( ) [ : - 1 ] NEW_LINE x = len ( a ) NEW_LINE c , d = 0 , 0 NEW_LINE for i in range ( x ) : NEW_LINE INDENT if a [ i ] == '7' and b [ i ] == '4' : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if a [ i ] == '4' and b [ i ] == '7' : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT print ( min ( c , d ) + c - min ( c , d ) + d - min ( c , d ) ) NEW_LINE", "a = input ( ) ; b = input ( ) NEW_LINE c4 , c7 = 0 , 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT if a [ i ] == '4' : c4 += 1 NEW_LINE else : c7 += 1 NEW_LINE DEDENT DEDENT print ( max ( c4 , c7 ) ) NEW_LINE", "import math NEW_LINE def solve ( ) : NEW_LINE INDENT a = list ( input ( ) ) NEW_LINE b = list ( input ( ) ) NEW_LINE n = len ( a ) NEW_LINE seven_a = a . count ( '7' ) NEW_LINE seven_b = b . count ( '7' ) NEW_LINE if seven_a == seven_b : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count // 2 NEW_LINE DEDENT count_s = 0 NEW_LINE count_f = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == '7' and b [ i ] == '4' : NEW_LINE INDENT count_s += 1 NEW_LINE DEDENT elif a [ i ] == '4' and b [ i ] == '7' : NEW_LINE INDENT count_f += 1 NEW_LINE DEDENT DEDENT return max ( count_f , count_s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT", "a , b = input ( ) , input ( ) NEW_LINE l = [ a [ i ] + b [ i ] for i in range ( len ( a ) ) ] NEW_LINE print ( max ( l . count ( '47' ) , l . count ( '74' ) ) ) NEW_LINE", "a = input ( ) . rstrip ( ) NEW_LINE b = input ( ) . rstrip ( ) NEW_LINE n = len ( a ) NEW_LINE p4 = [ ] NEW_LINE p7 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] != b [ i ] : NEW_LINE INDENT if a [ i ] == '7' : p7 . append ( i ) NEW_LINE else : p4 . append ( i ) NEW_LINE DEDENT DEDENT print ( max ( len ( p4 ) , len ( p7 ) ) ) NEW_LINE"]}
{"id": "aizu_p01443_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . solver ( ) ; } void solver ( ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long p = sc . nextLong ( ) ; if ( a == 0 && b == 0 && p == 0 ) break ; long [ ] dp = new long [ 111111 ] ; dp [ 0 ] = 1 ; long ans = 0 ; for ( long i = a ; i <= b ; i ++ ) { if ( i > a ) { dp [ ( int ) ( i - a ) ] += dp [ ( int ) ( i - a - 1 ) ] ; } ans += dp [ ( int ) ( i - a ) ] ; ans %= p ; for ( long j = i ; j <= b ; j *= 10 ) { long t = 1 ; while ( t <= j ) t *= 10 ; long l = Math . max ( i - a + 1 , j - a ) , r = Math . min ( b - a + 1 , t - a ) ; dp [ ( int ) l ] += dp [ ( int ) ( i - a ) ] ; dp [ ( int ) r ] -= dp [ ( int ) ( i - a ) ] ; dp [ ( int ) l ] %= p ; dp [ ( int ) r ] %= p ; } } System . out . println ( ans ) ; } } }"], "python": ["import sys NEW_LINE readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE def solve ( ) : NEW_LINE INDENT A , B , P = map ( int , readline ( ) . split ( ) ) NEW_LINE if A == B == P == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT N = ( B - A + 1 ) NEW_LINE data = [ 0 ] * ( N + 1 ) NEW_LINE def get ( k ) : NEW_LINE INDENT s = 0 NEW_LINE while k : NEW_LINE INDENT s += data [ k ] NEW_LINE k -= k & - k NEW_LINE DEDENT return s % P NEW_LINE DEDENT * V , = range ( A , B + 1 ) NEW_LINE V . sort ( key = str ) NEW_LINE for v in V : NEW_LINE INDENT k = v + 1 - A NEW_LINE x = get ( k ) + 1 NEW_LINE while k <= N : NEW_LINE INDENT data [ k ] += x NEW_LINE k += k & - k NEW_LINE DEDENT DEDENT write ( \" % d \\n \" % ( get ( N ) % P ) ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4192_A", "java": ["import java . io . * ; class GFG { static void findNormal ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . print ( ( 0 - dif ) + \" y \u2581 = \u2581 \" + \" x \" + ( ( 0 - x ) + ( y * dif ) ) ) ; else if ( dif > 0 ) System . out . print ( dif + \" y \u2581 = \u2581 \" + \" - x + \" + ( x + dif * y ) ) ; else System . out . print ( \" x \u2581 = \u2581 \" + x ) ; } else System . out . println ( \" Not \u2581 possible \" ) ; } public static void main ( String [ ] args ) { int A = 2 , x = 2 , y = 0 ; findNormal ( A , x , y ) ; ; } }"], "python": ["def findNormal ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if ( y == ( 2 * x - x * x ) ) : NEW_LINE INDENT if ( dif < 0 ) : NEW_LINE INDENT print ( 0 - dif , \" y \u2581 = \" , \" x \" , ( 0 - x ) + ( y * dif ) ) NEW_LINE DEDENT elif ( dif > 0 ) : NEW_LINE INDENT print ( dif , \" y \u2581 = \" , \" - \u2581 x \u2581 + \" , x + dif * y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" x \u2581 = \" , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE x = 2 NEW_LINE y = 0 NEW_LINE findNormal ( A , x , y ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4486_A", "java": ["import java . io . * ; class GFG { static void pattern ( ) { int i , j , k = 0 , spaces = 1 , n = 7 ; for ( i = n ; i >= 1 ; i -- ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( i ) ; } if ( i != n ) { for ( k = 1 ; k <= spaces ; k ++ ) { System . out . print ( \" \u2581 \" ) ; } spaces = spaces + 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != n ) System . out . print ( i ) ; } System . out . println ( ) ; } spaces = spaces - 4 ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( i ) ; } if ( i != n ) { for ( k = 1 ; k <= spaces ; k ++ ) { System . out . printf ( \" \u2581 \" ) ; } spaces = spaces - 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != n ) System . out . print ( i ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { pattern ( ) ; } }"], "python": ["def pattern ( ) : NEW_LINE INDENT k = 0 NEW_LINE spaces = 1 NEW_LINE n = 7 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT spaces = spaces + 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT spaces = spaces - 4 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT if ( i != n ) : NEW_LINE INDENT for k in range ( 1 , spaces + 1 ) : NEW_LINE INDENT print ( end = \" \u2581 \" ) NEW_LINE DEDENT spaces = spaces - 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if ( j != n ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT pattern ( ) NEW_LINE"]}
{"id": "atcoder_ABC160_E", "java": ["import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int x = Integer . parseInt ( sc . next ( ) ) ; int y = Integer . parseInt ( sc . next ( ) ) ; int a = Integer . parseInt ( sc . next ( ) ) ; int b = Integer . parseInt ( sc . next ( ) ) ; int c = Integer . parseInt ( sc . next ( ) ) ; Integer [ ] p = new Integer [ a ] ; Integer [ ] q = new Integer [ b ] ; Integer [ ] r = new Integer [ c ] ; Arrays . setAll ( p , i -> Integer . parseInt ( sc . next ( ) ) ) ; Arrays . setAll ( q , i -> Integer . parseInt ( sc . next ( ) ) ) ; Arrays . setAll ( r , i -> Integer . parseInt ( sc . next ( ) ) ) ; PriorityQueue < Integer > eat = new PriorityQueue < > ( ) ; Arrays . sort ( p , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < x ; i ++ ) { eat . add ( p [ i ] ) ; } Arrays . sort ( q , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < y ; i ++ ) { eat . add ( q [ i ] ) ; } for ( int num : r ) { eat . add ( num ) ; eat . poll ( ) ; } long result = eat . stream ( ) . mapToLong ( i -> i ) . sum ( ) ; System . out . println ( result ) ; sc . close ( ) ; } }", "import javax . swing . plaf . basic . BasicInternalFrameTitlePane ; import java . io . * ; import java . math . * ; import java . nio . Buffer ; import java . sql . SQLSyntaxErrorException ; import java . util . * ; import java . text . * ; import java . util . regex . Pattern ; import java . util . stream . Collectors ; public class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int X = cin . nextInt ( ) ; int Y = cin . nextInt ( ) ; int A = cin . nextInt ( ) ; int B = cin . nextInt ( ) ; int C = cin . nextInt ( ) ; Integer [ ] num = new Integer [ A ] ; Integer [ ] num1 = new Integer [ B ] ; Integer [ ] num2 = new Integer [ C + X + Y ] ; for ( int i = 0 ; i < A ; i ++ ) { num [ i ] = cin . nextInt ( ) ; } Arrays . sort ( num , 0 , A , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < B ; i ++ ) { num1 [ i ] = cin . nextInt ( ) ; } Arrays . sort ( num1 , 0 , B , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < C ; i ++ ) { num2 [ i ] = cin . nextInt ( ) ; } for ( int i = C ; i < C + X ; i ++ ) { num2 [ i ] = num [ i - C ] ; } for ( int i = C + X ; i < C + X + Y ; i ++ ) { num2 [ i ] = num1 [ i - C - X ] ; } Arrays . sort ( num2 , 0 , C + X + Y , Collections . reverseOrder ( ) ) ; long sum = 0 ; for ( int i = 0 ; i < X + Y ; i ++ ) { sum += num2 [ i ] ; } System . out . println ( sum ) ; } }", "import java . util . * ; import java . math . * ; public class Main { public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; int x = cin . nextInt ( ) ; int y = cin . nextInt ( ) ; int A = cin . nextInt ( ) ; int B = cin . nextInt ( ) ; int C = cin . nextInt ( ) ; Integer [ ] a = new Integer [ A ] ; Integer [ ] b = new Integer [ B ] ; Integer [ ] c = new Integer [ C + x + y ] ; for ( int i = 0 ; i < A ; i ++ ) { a [ i ] = cin . nextInt ( ) ; } Arrays . sort ( a , 0 , A , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < B ; i ++ ) { b [ i ] = cin . nextInt ( ) ; } Arrays . sort ( b , 0 , B , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < C ; i ++ ) { c [ i ] = cin . nextInt ( ) ; } for ( int i = C ; i < C + x ; i ++ ) { c [ i ] = a [ i - C ] ; } for ( int i = C + x ; i < C + x + y ; i ++ ) { c [ i ] = b [ i - C - x ] ; } Arrays . sort ( c , 0 , C + x + y , Collections . reverseOrder ( ) ) ; long ans = 0 ; for ( int i = 0 ; i < x + y ; i ++ ) { ans += c [ i ] ; } System . out . println ( ans ) ; } }", "import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; import java . util . List ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; List < Integer > A = new ArrayList < > ( ) ; List < Integer > B = new ArrayList < > ( ) ; List < Integer > C = new ArrayList < > ( ) ; for ( int i = 0 ; i < a ; i ++ ) { A . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < b ; i ++ ) { B . add ( sc . nextInt ( ) ) ; } for ( int i = 0 ; i < c ; i ++ ) { C . add ( sc . nextInt ( ) ) ; } Collections . sort ( A , Collections . reverseOrder ( ) ) ; Collections . sort ( B , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < x ; i ++ ) { C . add ( A . get ( i ) ) ; } for ( int i = 0 ; i < y ; i ++ ) { C . add ( B . get ( i ) ) ; } long ans = 0 ; Collections . sort ( C , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < x + y ; i ++ ) { ans += C . get ( i ) ; } System . out . println ( ans ) ; } }", "import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int X = sc . nextInt ( ) ; int Y = sc . nextInt ( ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; Integer red [ ] = new Integer [ A ] ; Integer green [ ] = new Integer [ B ] ; Integer clear [ ] = new Integer [ C ] ; for ( int i = 0 ; i < A ; i ++ ) { red [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < B ; i ++ ) { green [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < C ; i ++ ) { clear [ i ] = sc . nextInt ( ) ; } Arrays . sort ( red , Collections . reverseOrder ( ) ) ; Arrays . sort ( green , Collections . reverseOrder ( ) ) ; Integer apple [ ] = new Integer [ X + Y + C ] ; for ( int i = 0 ; i < X ; i ++ ) apple [ i ] = red [ i ] ; for ( int i = 0 ; i < Y ; i ++ ) apple [ i + X ] = green [ i ] ; for ( int i = 0 ; i < C ; i ++ ) apple [ i + X + Y ] = clear [ i ] ; Arrays . sort ( apple , Collections . reverseOrder ( ) ) ; long sum = 0 ; for ( int i = 0 ; i < X + Y ; i ++ ) { sum += apple [ i ] ; } System . out . println ( sum ) ; } }"], "python": ["x , y , a , b , c = ( int ( x ) for x in input ( ) . split ( ) ) NEW_LINE list_p = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list_q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list_r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE list_p . sort ( ) NEW_LINE list_q . sort ( ) NEW_LINE list_p . reverse ( ) NEW_LINE list_q . reverse ( ) NEW_LINE for i in range ( x ) : NEW_LINE INDENT list_r . append ( list_p [ i ] ) NEW_LINE DEDENT for i in range ( y ) : NEW_LINE INDENT list_r . append ( list_q [ i ] ) NEW_LINE DEDENT list_r . sort ( ) NEW_LINE list_r . reverse ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( x + y ) : NEW_LINE INDENT sum += list_r [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE", "import numpy as np NEW_LINE X , Y , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE p = np . array ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE q = np . array ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE r = np . array ( tuple ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE p = np . partition ( p , A - X ) NEW_LINE q = np . partition ( q , B - Y ) NEW_LINE pqr = np . concatenate ( ( p [ - X : ] , q [ - Y : ] , r ) ) NEW_LINE pqr = np . partition ( pqr , len ( pqr ) - ( X + Y ) ) NEW_LINE ans = sum ( pqr [ - ( X + Y ) : ] ) NEW_LINE print ( ans ) NEW_LINE", "from pprint import pprint NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE X , Y , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE apples_A = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE apples_B = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE apples_C = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE apples_rest = sorted ( apples_A [ - X : ] + apples_B [ - Y : ] + apples_C ) NEW_LINE ans = sum ( apples_rest [ - ( X + Y ) : ] ) NEW_LINE print ( ans ) NEW_LINE", "def merge ( A , B ) : NEW_LINE INDENT C = [ ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while i < len ( A ) and j < len ( B ) : NEW_LINE INDENT if A [ i ] > B [ j ] : NEW_LINE INDENT C . append ( A [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT C . append ( B [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if len ( A ) - i > len ( B ) - j : NEW_LINE INDENT C . extend ( A [ i : ] ) NEW_LINE DEDENT else : NEW_LINE INDENT C . extend ( B [ j : ] ) NEW_LINE DEDENT return C NEW_LINE DEDENT X , Y , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE P = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE Q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE R = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE P . sort ( reverse = True ) NEW_LINE Q . sort ( reverse = True ) NEW_LINE R . sort ( reverse = True ) NEW_LINE S = merge ( P [ : X ] , Q [ : Y ] ) NEW_LINE S = merge ( S , R ) NEW_LINE score = 0 NEW_LINE for i in range ( X + Y ) : NEW_LINE INDENT score += S [ i ] NEW_LINE DEDENT print ( score ) NEW_LINE", "from collections import deque NEW_LINE X , Y , A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE P = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE Q = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE R = [ int ( n ) for n in input ( ) . split ( ) ] NEW_LINE P . sort ( ) NEW_LINE Q . sort ( ) NEW_LINE R . sort ( reverse = True ) NEW_LINE PQ = deque ( sorted ( P [ - X : ] + Q [ - Y : ] ) ) NEW_LINE R = deque ( R ) NEW_LINE while True : NEW_LINE INDENT if not R or R [ 0 ] <= PQ [ 0 ] : NEW_LINE INDENT break NEW_LINE DEDENT if R [ 0 ] > PQ [ 0 ] : NEW_LINE INDENT PQ . append ( R . popleft ( ) ) NEW_LINE PQ . popleft ( ) NEW_LINE DEDENT DEDENT print ( sum ( PQ ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2446_A", "java": ["public class GFG { static long answer ( long n ) { long m = 2 ; long ans = 1 ; long r = 1 ; while ( r < n ) { r = ( ( long ) Math . pow ( 2 , m ) - 1 ) * ( ( long ) Math . pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } public static void main ( String args [ ] ) { long n = 7 ; System . out . println ( answer ( n ) ) ; } }"], "python": ["import math NEW_LINE def answer ( n ) : NEW_LINE INDENT m = 2 ; NEW_LINE ans = 1 ; NEW_LINE r = 1 ; NEW_LINE while r < n : NEW_LINE INDENT r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT m = m + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT print ( answer ( 7 ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_5033_A", "java": ["import java . util . * ; class GFG { static void nPermute ( char [ ] str , int n ) { Arrays . sort ( str ) ; int i = 1 ; do { if ( i == n ) break ; i ++ ; } while ( next_permutation ( str ) ) ; System . out . println ( String . valueOf ( str ) ) ; } static boolean next_permutation ( char [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { char t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { String str = \" GEEKSFORGEEKS \" ; int n = 100 ; nPermute ( str . toCharArray ( ) , n ) ; } }"], "python": ["def next_permutation ( L ) : NEW_LINE INDENT n = len ( L ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 and L [ i ] >= L [ i + 1 ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i + 1 NEW_LINE while j < n and L [ j ] > L [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT j -= 1 NEW_LINE L [ i ] , L [ j ] = L [ j ] , L [ i ] NEW_LINE left = i + 1 NEW_LINE right = n - 1 NEW_LINE while left < right : NEW_LINE INDENT L [ left ] , L [ right ] = L [ right ] , L [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def nPermute ( string , n ) : NEW_LINE INDENT string = list ( string ) NEW_LINE new_string = [ ] NEW_LINE string . sort ( ) NEW_LINE j = 2 NEW_LINE while next_permutation ( string ) : NEW_LINE INDENT new_string = string NEW_LINE if j == n : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( ' ' . join ( new_string ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" GEEKSFORGEEKS \" NEW_LINE n = 100 NEW_LINE nPermute ( string , n ) NEW_LINE DEDENT"]}
{"id": "atcoder_AGC007_A", "java": ["import java . util . Scanner ; public class Main { static Scanner scanner ; public static void main ( String [ ] args ) { scanner = new Scanner ( System . in ) ; int H = gi ( ) ; int W = gi ( ) ; int k = 0 ; for ( int i = 0 ; i < H ; i ++ ) { String s = gs ( ) ; for ( int j = 0 ; j < W ; j ++ ) { char c = s . charAt ( j ) ; if ( c == ' # ' ) k ++ ; } } if ( k == H + W - 1 ) { System . out . println ( \" Possible \" ) ; } else { System . out . println ( \" Impossible \" ) ; } } public static String gs ( ) { return scanner . next ( ) ; } public static int gi ( ) { return Integer . parseInt ( scanner . next ( ) ) ; } public static long gl ( ) { return Long . parseLong ( scanner . next ( ) ) ; } public static double gd ( ) { return Double . parseDouble ( scanner . next ( ) ) ; } }", "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int h ; static int w ; static char [ ] [ ] road ; public static void main ( String [ ] args ) { h = sc . nextInt ( ) ; w = sc . nextInt ( ) ; road = new char [ h ] [ w ] ; for ( int y = 0 ; y < h ; ++ y ) road [ y ] = sc . next ( ) . toCharArray ( ) ; dfs ( 0 , 0 ) ; String ans = ( hasVisitedAllGrids ( ) ) ? \" Possible \" : \" Impossible \" ; System . out . println ( ans ) ; } static int [ ] dy = { 0 , 1 } ; static int [ ] dx = { 1 , 0 } ; static void dfs ( int y , int x ) { road [ y ] [ x ] = ' ! ' ; for ( int i = 0 ; i < 2 ; ++ i ) { int ty = y + dy [ i ] ; int tx = x + dx [ i ] ; if ( isOutside ( ty , tx ) || road [ ty ] [ tx ] != ' # ' ) continue ; dfs ( ty , tx ) ; return ; } } static boolean isOutside ( int y , int x ) { return ( y < 0 || h <= y || x < 0 || w <= x ) ; } static boolean hasVisitedAllGrids ( ) { for ( int y = 0 ; y < h ; ++ y ) { for ( int x = 0 ; x < w ; ++ x ) { if ( road [ y ] [ x ] == ' # ' ) return false ; } } return true ; } }", "import java . util . * ; public class Main { private static int w , h ; private static char [ ] [ ] grid ; private static int count ; private static boolean valid ; private static void dfs ( int x , int y , int len ) { if ( x == w - 1 && y == h - 1 ) { if ( len == count ) valid = true ; return ; } if ( x < w - 1 && grid [ y ] [ x + 1 ] == ' # ' ) { dfs ( x + 1 , y , len + 1 ) ; } if ( y < h - 1 && grid [ y + 1 ] [ x ] == ' # ' ) { dfs ( x , y + 1 , len + 1 ) ; } } public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; h = input . nextInt ( ) ; w = input . nextInt ( ) ; input . nextLine ( ) ; grid = new char [ h ] [ ] ; for ( int y = 0 ; y < h ; y ++ ) { grid [ y ] = input . nextLine ( ) . toCharArray ( ) ; for ( int x = 0 ; x < w ; x ++ ) { if ( grid [ y ] [ x ] == ' # ' ) count ++ ; } } if ( grid [ 0 ] [ 0 ] != ' # ' ) { System . out . println ( \" Impossible \" ) ; return ; } valid = false ; dfs ( 0 , 0 , 1 ) ; System . out . println ( valid ? \" Possible \" : \" Impossible \" ) ; } }", "import java . util . * ; import java . math . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int h = s . nextInt ( ) ; int w = s . nextInt ( ) ; boolean [ ] [ ] visited = new boolean [ h + 1 ] [ w + 1 ] ; for ( int i = 0 ; i < h ; i ++ ) { String line = s . next ( ) ; for ( int j = 0 ; j < w ; j ++ ) { visited [ i ] [ j ] = line . charAt ( j ) == ' # ' ; } } int pi = 0 ; int pj = 0 ; while ( pi != h - 1 || pj != w - 1 ) { visited [ pi ] [ pj ] = false ; if ( visited [ pi ] [ pj + 1 ] ) { pj ++ ; } else if ( visited [ pi + 1 ] [ pj ] ) { pi ++ ; } else { throw new RuntimeException ( \" No \u2581 destination \" ) ; } for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( i < pi || j < pj ) { if ( visited [ i ] [ j ] ) { System . out . println ( \" Impossible \" ) ; return ; } } } } } System . out . println ( \" Possible \" ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; char [ ] [ ] map = new char [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { map [ i ] = sc . next ( ) . toCharArray ( ) ; } int cnt = 0 ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( map [ i ] [ j ] == ' # ' ) { cnt ++ ; } } } System . out . println ( ( cnt == h + w - 1 ) ? \" Possible \" : \" Impossible \" ) ; } }"], "python": ["import sys , math , copy NEW_LINE HUGE = 2147483647 NEW_LINE HUGEL = 9223372036854775807 NEW_LINE ABC = \" abcdefghijklmnopqrstuvwxyz \" NEW_LINE def main ( ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE su = 0 NEW_LINE for i in range ( h ) : NEW_LINE INDENT line = input ( ) NEW_LINE su += line . count ( \" # \" ) NEW_LINE DEDENT print ( \" Possible \" if su == h + w - 1 else \" Impossible \" ) NEW_LINE DEDENT main ( ) NEW_LINE", "import sys NEW_LINE stdin = sys . stdin NEW_LINE ri = lambda : int ( rs ( ) ) NEW_LINE rl = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE rs = lambda : stdin . readline ( ) . rstrip ( ) NEW_LINE H , W = rl ( ) NEW_LINE A = [ list ( rs ( ) ) for _ in range ( H ) ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if A [ i ] [ j ] == ' # ' : NEW_LINE INDENT A [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT A [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT A [ i ] . append ( 0 ) NEW_LINE DEDENT A . append ( [ 0 ] * ( W + 1 ) ) NEW_LINE bool = True NEW_LINE for i in range ( H ) : NEW_LINE INDENT for j in range ( W ) : NEW_LINE INDENT if i == 0 and j == 0 : NEW_LINE INDENT if A [ i + 1 ] [ j ] + A [ i ] [ j + 1 ] != 1 : NEW_LINE INDENT bool = False NEW_LINE DEDENT continue NEW_LINE DEDENT if i == H - 1 and j == W - 1 : NEW_LINE INDENT if A [ i - 1 ] [ j ] + A [ i ] [ j - 1 ] != 1 : NEW_LINE INDENT bool = False NEW_LINE DEDENT continue NEW_LINE DEDENT if A [ i ] [ j ] == 1 : NEW_LINE INDENT if A [ i + 1 ] [ j ] + A [ i ] [ j + 1 ] != 1 : NEW_LINE INDENT bool = False NEW_LINE DEDENT if A [ i - 1 ] [ j ] + A [ i ] [ j - 1 ] != 1 : NEW_LINE INDENT bool = False NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ' Possible ' if bool else ' Impossible ' ) NEW_LINE", "import sys NEW_LINE from sys import stdin NEW_LINE h , w = map ( int , stdin . readline ( ) . rstrip ( ) . split ( ) ) NEW_LINE a = [ stdin . readline ( ) . rstrip ( ) for i in range ( h ) ] NEW_LINE count = 0 NEW_LINE for i in a : NEW_LINE INDENT for j in i : NEW_LINE INDENT if j == ' # ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if h + w - 1 == count : NEW_LINE INDENT print ( ' Possible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT", "def main ( ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ [ \" . \" for j in range ( w + 2 ) ] for i in range ( h + 2 ) ] NEW_LINE for i in range ( h ) : NEW_LINE INDENT s = list ( input ( ) . rstrip ( ) ) NEW_LINE for j in range ( w ) : NEW_LINE INDENT a [ i + 1 ] [ j + 1 ] = s [ j ] NEW_LINE DEDENT DEDENT y , x = 1 , 1 NEW_LINE f = True NEW_LINE while y != h or x != w : NEW_LINE INDENT a [ y ] [ x ] = \" . \" NEW_LINE if a [ y - 1 ] [ x ] == \" # \" or a [ y ] [ x - 1 ] == \" # \" or ( a [ y + 1 ] [ x ] == \" # \" and a [ y ] [ x + 1 ] == \" # \" ) : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if a [ y + 1 ] [ x ] == \" # \" : NEW_LINE INDENT y += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT if a [ y - 1 ] [ x ] == \" # \" or a [ y ] [ x - 1 ] == \" # \" : NEW_LINE INDENT f = False NEW_LINE DEDENT if f : NEW_LINE INDENT print ( \" Possible \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "def resolve ( ) : NEW_LINE INDENT import collections NEW_LINE H , W = [ int ( item ) for item in input ( ) . split ( ) ] NEW_LINE grid = [ [ item for item in input ( ) ] for _ in range ( H ) ] NEW_LINE cnt = 0 NEW_LINE for line in grid : NEW_LINE INDENT for i in line : NEW_LINE INDENT if i == ' # ' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT if cnt > H + W - 1 : NEW_LINE INDENT print ( ' Impossible ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Possible ' ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT resolve ( ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p116_A", "java": ["public final class p116 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p116 ( ) . run ( ) ) ; } private static final int LENGTH = 50 ; public String run ( ) { return Long . toString ( countWays ( LENGTH , 2 ) + countWays ( LENGTH , 3 ) + countWays ( LENGTH , 4 ) ) ; } private static long countWays ( int length , int m ) { long [ ] ways = new long [ length + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= length ; n ++ ) { ways [ n ] += ways [ n - 1 ] ; if ( n >= m ) ways [ n ] += ways [ n - m ] ; } return ways [ length ] - 1 ; } }"], "python": ["def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE return str ( sum ( count_ways ( LENGTH , i ) for i in range ( 2 , 5 ) ) ) NEW_LINE DEDENT def count_ways ( length , m ) : NEW_LINE INDENT ways = [ 1 ] + [ 0 ] * length NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ - 1 ] - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3241_A", "java": ["import java . util . * ; class GFG { static boolean check ( int arr [ ] , int n ) { int k = Integer . MIN_VALUE ; int r = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { k = Math . max ( k , arr [ i ] ) ; r = Math . min ( r , arr [ i ] ) ; } k += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = k - arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) - 1 < n && arr [ Math . abs ( arr [ i ] ) - 1 ] > 0 ) { arr [ Math . abs ( arr [ i ] ) - 1 ] = - arr [ Math . abs ( arr [ i ] ) - 1 ] ; } } int flag = 0 ; for ( int i = 0 ; i <= k - r - 1 ; i ++ ) { if ( arr [ i ] > 0 ) { flag = 1 ; break ; } } return flag == 0 ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( check ( arr , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def check ( arr , n ) : NEW_LINE INDENT k = - 10 ** 9 NEW_LINE r = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT k = max ( k , arr [ i ] ) NEW_LINE r = min ( r , arr [ i ] ) NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] = k - arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) - 1 < n and arr [ abs ( arr [ i ] ) - 1 ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT DEDENT flag = 0 NEW_LINE for i in range ( k - r ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT return flag == 0 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( check ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4464_A", "java": ["import java . io . * ; class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } static void sieveOfEratosthenes ( int n , boolean isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static boolean leftTruPrime ( int n ) { int temp = n , cnt = 0 , temp1 ; while ( temp != 0 ) { cnt ++ ; temp1 = temp % 10 ; if ( temp1 == 0 ) return false ; temp = temp / 10 ; } boolean isPrime [ ] = new boolean [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; for ( int i = cnt ; i > 0 ; i -- ) { int mod = power ( 10 , i ) ; if ( ! isPrime [ n % mod ] ) return false ; } return true ; } public static void main ( String args [ ] ) { int n = 113 ; if ( leftTruPrime ( n ) ) System . out . println ( n + \" \u2581 is \u2581 left \u2581 truncatable \u2581 prime \" ) ; else System . out . println ( n + \" \u2581 is \u2581 not \u2581 left \u2581 truncatable \u2581 prime \" ) ; } }"], "python": ["def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( y % 2 == 0 ) : NEW_LINE INDENT return ( power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , y // 2 ) * power ( x , y // 2 ) ) NEW_LINE DEDENT DEDENT def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def leftTruPrime ( n ) : NEW_LINE INDENT temp = n NEW_LINE cnt = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE temp1 = temp % 10 ; NEW_LINE if ( temp1 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = temp // 10 NEW_LINE DEDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( cnt , 0 , - 1 ) : NEW_LINE INDENT mod = power ( 10 , i ) NEW_LINE if ( isPrime [ n % mod ] != True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 113 NEW_LINE if ( leftTruPrime ( n ) ) : NEW_LINE INDENT print ( n , \" is \u2581 left \u2581 truncatable \u2581 prime \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 not \u2581 left \u2581 truncatable \u2581 prime \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3268_A", "java": ["class GFG { static int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s . charAt ( i ) == '1' ) ans ++ ; if ( i % 2 == 1 && s . charAt ( i ) == '0' ) ans ++ ; } return Math . min ( ans , len - ans ) ; } public static void main ( String args [ ] ) { String s = \"1100\" ; int len = s . length ( ) ; System . out . print ( minReplacement ( s , len ) ) ; } }"], "python": ["def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1100\" NEW_LINE length = len ( s ) NEW_LINE print ( minReplacement ( s , length ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2208_A", "java": ["import java . util . * ; class GFG { static void right_left ( int a [ ] , int n ) { Map < Integer , Integer > total = new HashMap < > ( ) ; Map < Integer , Integer > left = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) total . put ( a [ i ] , total . get ( a [ i ] ) == null ? 1 : total . get ( a [ i ] ) + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ( total . get ( a [ i ] ) - 1 - ( 2 * ( left . containsKey ( a [ i ] ) == true ? left . get ( a [ i ] ) : 0 ) ) ) + \" \u2581 \" ) ; left . put ( a [ i ] , left . get ( a [ i ] ) == null ? 1 : left . get ( a [ i ] ) + 1 ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 2 , 1 } ; int n = a . length ; right_left ( a , n ) ; } }"], "python": ["def right_left ( a , n ) : NEW_LINE INDENT total = dict . fromkeys ( a , 0 ) ; NEW_LINE left = dict . fromkeys ( a , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in total : NEW_LINE INDENT total [ a [ i ] ] = 1 NEW_LINE DEDENT total [ a [ i ] ] += 1 ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( total [ a [ i ] ] - 1 - ( 2 * left [ a [ i ] ] ) , end = \" \u2581 \" ) ; NEW_LINE left [ a [ i ] ] += 1 ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE right_left ( a , n ) ; NEW_LINE DEDENT"]}
{"id": "aizu_p02259_A", "java": ["import java . util . Scanner ; public class Main { public Main ( ) { } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } private Scanner sc ; private void solve ( ) { sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } boolean flag = true ; int cnt = 0 ; int i = 0 ; while ( flag ) { flag = false ; for ( int j = N - 1 ; j >= i + 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { int tmp = A [ j - 1 ] ; A [ j - 1 ] = A [ j ] ; A [ j ] = tmp ; flag = true ; cnt ++ ; } } i ++ ; } String ans = \" \" ; for ( int num : A ) { ans += num ; ans += \" \u2581 \" ; } System . out . println ( ans . trim ( ) ) ; System . out . println ( cnt ) ; } }", "import java . util . * ; import static java . lang . System . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; int [ ] ar = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = sc . nextInt ( ) ; } boolean F = true ; int j = 0 ; int times = 0 ; while ( F == true ) { F = false ; for ( int i = n - 1 ; i >= j + 1 ; i -- ) { if ( ar [ i ] < ar [ i - 1 ] ) { int temp = ar [ i ] ; ar [ i ] = ar [ i - 1 ] ; ar [ i - 1 ] = temp ; times ++ ; F = true ; } } j ++ ; } for ( int x = 0 ; x < n ; x ++ ) { out . print ( ( x == 0 ? \" \" : \" \u2581 \" ) + ar [ x ] ) ; } out . println ( ) ; out . println ( times ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] strs = br . readLine ( ) . split ( \" \u2581 \" ) ; int [ ] inputData = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { inputData [ i ] = Integer . parseInt ( strs [ i ] ) ; } int swapCnt = bubbleSort ( inputData , n ) ; printArray ( inputData ) ; System . out . println ( swapCnt ) ; } public static int bubbleSort ( int [ ] A , int N ) { int swapCnt = 0 ; boolean flag = true ; while ( flag ) { flag = false ; for ( int i = N - 1 ; i > 0 ; i -- ) { if ( A [ i ] < A [ i - 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = temp ; swapCnt ++ ; flag = true ; } } } return swapCnt ; } public static void printArray ( int [ ] target ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < target . length ; i ++ ) { sb . append ( target [ i ] ) ; if ( i < target . length - 1 ) { sb . append ( \" \u2581 \" ) ; } } System . out . println ( sb . toString ( ) ) ; } }", "import java . io . * ; class Main { public static void main ( String [ ] args ) { BufferedReader kb = new BufferedReader ( new InputStreamReader ( System . in ) ) ; try { int n = Integer . parseInt ( kb . readLine ( ) ) ; String [ ] nums = kb . readLine ( ) . split ( \" \u2581 \" ) ; int [ ] A = new int [ n ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { A [ i ] = Integer . parseInt ( nums [ i ] ) ; } int cnt = 0 ; cnt = bubbleSort ( A , n ) ; StringBuilder output = new StringBuilder ( 200 + 1 ) ; for ( i = 0 ; i < n ; i ++ ) { output . append ( A [ i ] ) ; output . append ( \" \u2581 \" ) ; } output . deleteCharAt ( output . lastIndexOf ( \" \u2581 \" ) ) ; System . out . println ( output ) ; System . out . println ( cnt ) ; kb . close ( ) ; } catch ( IOException e ) { System . err . println ( e ) ; } } static int bubbleSort ( int [ ] A , int n ) { int tmp ; int i , j , cnt ; cnt = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = n - 1 ; i < j ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { tmp = A [ j - 1 ] ; A [ j - 1 ] = A [ j ] ; A [ j ] = tmp ; cnt ++ ; } } } return cnt ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; class Main { public static void main ( String [ ] args ) { BufferedReader bfr = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str = \" \" ; StringTokenizer stk ; int [ ] arrays ; int youso = 0 ; int counter = 0 ; try { str = bfr . readLine ( ) ; youso = Integer . parseInt ( str ) ; arrays = new int [ youso ] ; str = bfr . readLine ( ) ; stk = new StringTokenizer ( str , \" \u2581 \" ) ; while ( stk . hasMoreTokens ( ) ) { arrays [ counter ] = Integer . parseInt ( stk . nextToken ( ) ) ; counter ++ ; } Bubble ( arrays ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } static void Bubble ( int [ ] a ) { int tmp1 , tmp2 = 0 ; int ookisa = a . length ; int kaisu = 0 ; for ( int i = 0 ; i < ookisa - 1 ; i ++ ) { for ( int j = ookisa - 1 ; j >= i + 1 ; j -- ) { if ( a [ j ] < a [ j - 1 ] ) { tmp1 = a [ j ] ; tmp2 = a [ j - 1 ] ; a [ j ] = tmp2 ; a [ j - 1 ] = tmp1 ; kaisu ++ ; } } } String moji = \" \" ; for ( int i = 0 ; i < ookisa - 1 ; i ++ ) { moji = moji + a [ i ] + \" \u2581 \" ; } moji = moji + a [ ookisa - 1 ] ; System . out . println ( moji ) ; System . out . println ( kaisu ) ; } }"], "python": ["from sys import stdin NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in stdin . readline ( ) . split ( ' \u2581 ' ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - 1 - i ) : NEW_LINE INDENT if ( A [ j ] > A [ j + 1 ] ) : NEW_LINE INDENT A [ j ] , A [ j + 1 ] = ( A [ j + 1 ] , A [ j ] ) NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , A ) ) ) NEW_LINE print ( cnt ) NEW_LINE", "def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE bubbleSort ( A , N ) NEW_LINE DEDENT def bubbleSort ( A , N ) : NEW_LINE INDENT flag = 1 NEW_LINE i = 0 NEW_LINE while flag : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT if A [ j ] < A [ j - 1 ] : NEW_LINE INDENT A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] NEW_LINE flag = 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , A ) ) ) NEW_LINE print ( i ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE num = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE flag = 1 NEW_LINE count = 0 NEW_LINE while flag != 0 : NEW_LINE INDENT flag = 0 NEW_LINE rev = list ( range ( 1 , n ) ) NEW_LINE rev . reverse ( ) NEW_LINE for j in rev : NEW_LINE INDENT if num [ j ] < num [ j - 1 ] : NEW_LINE INDENT tmp = num [ j ] NEW_LINE num [ j ] = num [ j - 1 ] NEW_LINE num [ j - 1 ] = tmp NEW_LINE flag = 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if i != n - 1 : NEW_LINE INDENT print ( \" % d \" % ( num [ i ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" % d \" % ( num [ i ] ) ) NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT", "n = input ( ) NEW_LINE nums = input ( ) NEW_LINE nums = nums . split ( ) NEW_LINE nums = list ( map ( int , nums ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( int ( n ) - 1 ) : NEW_LINE INDENT for j in range ( int ( n ) - 1 ) : NEW_LINE INDENT if nums [ j ] > nums [ j + 1 ] : NEW_LINE INDENT tmp = nums [ j + 1 ] NEW_LINE nums [ j + 1 ] = nums [ j ] NEW_LINE nums [ j ] = tmp NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , nums ) ) ) NEW_LINE print ( cnt ) NEW_LINE", "N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def bubble_sort ( A , N ) : NEW_LINE INDENT cnt = 0 NEW_LINE flag = True NEW_LINE while ( flag ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( N - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( A [ i - 1 ] > A [ i ] ) : NEW_LINE INDENT tmp = A [ i - 1 ] NEW_LINE A [ i - 1 ] = A [ i ] NEW_LINE A [ i ] = tmp NEW_LINE cnt += 1 NEW_LINE flag = True NEW_LINE DEDENT DEDENT DEDENT print ( \" \u2581 \" . join ( list ( map ( str , A ) ) ) ) NEW_LINE print ( cnt ) NEW_LINE DEDENT bubble_sort ( A , N ) NEW_LINE"]}
{"id": "geeksforgeeks_2449_A", "java": ["import java . util . * ; class solution { static int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } public static void main ( String args [ ] ) { int n = 500 ; String pat = \"10\" ; System . out . println ( countPattern ( n , pat ) ) ; } }"], "python": ["def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE i = len ( pat ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE i -= 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 500 NEW_LINE pat = \"10\" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1100_B", "java": ["import java . util . Scanner ; public class test2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int m = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int [ ] mCnt = new int [ m ] ; int totalCnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = sc . nextInt ( ) - 1 ; mCnt [ temp ] ++ ; if ( mCnt [ temp ] == 1 ) { totalCnt ++ ; } if ( totalCnt < m ) { System . out . print ( 0 ) ; } else { System . out . print ( 1 ) ; totalCnt = 0 ; for ( int j = 0 ; j < m ; j ++ ) { mCnt [ j ] -- ; if ( mCnt [ j ] >= 1 ) { totalCnt ++ ; } } } } } }", "import java . util . HashMap ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; StringBuffer strbuf = new StringBuffer ( ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int key = in . nextInt ( ) ; if ( ! map . containsKey ( key ) ) { map . put ( key , 1 ) ; } else { int val = map . get ( key ) ; map . put ( key , ++ val ) ; } if ( map . size ( ) == n ) { for ( int j = 1 ; j <= n ; j ++ ) { int temp = map . get ( j ) ; if ( map . put ( j , -- temp ) == 1 ) { map . remove ( j ) ; } } strbuf . append ( 1 ) ; } else { strbuf . append ( 0 ) ; } } System . out . print ( strbuf . toString ( ) ) ; } }", "import java . io . * ; import java . util . * ; public class Fibonacci { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; HashMap < Integer , Integer > count = new HashMap < > ( ) ; StringBuilder res = new StringBuilder ( ) ; while ( m -- > 0 ) { int cur = sc . nextInt ( ) ; if ( count . containsKey ( cur ) ) { count . put ( cur , count . get ( cur ) + 1 ) ; } else { count . put ( cur , 1 ) ; } if ( count . size ( ) == n ) { res . append ( \"1\" ) ; for ( int i = 1 ; i <= n ; i ++ ) { count . put ( i , count . get ( i ) - 1 ) ; if ( count . get ( i ) == 0 ) { count . remove ( i ) ; } } } else { res . append ( \"0\" ) ; } } pw . println ( res ) ; pw . flush ( ) ; } static class Scanner { BufferedReader br ; StringTokenizer st ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Scanner ( FileReader f ) { br = new BufferedReader ( f ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } public int [ ] nextIntArr ( int n ) throws IOException { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( next ( ) ) ; } return arr ; } } }"], "python": ["def main ( ) : NEW_LINE INDENT n , m = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE a = [ int ( u ) for u in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE hash_a = [ 0 for i in range ( n + 2 ) ] NEW_LINE counters = [ 0 for i in range ( 2 * m ) ] NEW_LINE collector = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT hash_a [ a [ i ] ] += 1 NEW_LINE counters [ hash_a [ a [ i ] ] ] += 1 NEW_LINE if counters [ hash_a [ a [ i ] ] ] == n : NEW_LINE INDENT collector . append ( \"1\" ) NEW_LINE DEDENT else : NEW_LINE INDENT collector . append ( \"0\" ) NEW_LINE DEDENT DEDENT print ( \" \" . join ( collector ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE problems = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE freq = [ 0 ] * ( n + 1 ) NEW_LINE answer = ' ' NEW_LINE contador = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if freq [ problems [ i ] ] == 0 : NEW_LINE INDENT contador += 1 NEW_LINE freq [ problems [ i ] ] += 1 NEW_LINE if contador == n : NEW_LINE INDENT answer += '1' NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if freq [ j ] - 1 == 0 : NEW_LINE INDENT contador -= 1 NEW_LINE DEDENT freq [ j ] -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT answer += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT freq [ problems [ i ] ] += 1 NEW_LINE answer += '0' NEW_LINE DEDENT DEDENT print ( answer ) NEW_LINE", "lista = [ 0 ] NEW_LINE final = [ ] NEW_LINE contador = 0 NEW_LINE controles = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sequencia = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lista = lista * controles [ 0 ] NEW_LINE for a in range ( controles [ 1 ] ) : NEW_LINE INDENT lista [ sequencia [ a ] - 1 ] += 1 NEW_LINE if lista [ sequencia [ a ] - 1 ] == 1 : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT if contador == len ( lista ) : NEW_LINE INDENT contador = 0 NEW_LINE final . append ( \"1\" ) NEW_LINE for b in range ( len ( lista ) ) : NEW_LINE INDENT lista [ b ] -= 1 NEW_LINE if lista [ b ] >= 1 : NEW_LINE INDENT contador += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT final . append ( \"0\" ) NEW_LINE DEDENT DEDENT print ( ' ' . join ( final ) ) NEW_LINE", "n , m = [ int ( num ) for num in input ( ) . split ( ) ] NEW_LINE table = [ 0 ] * n NEW_LINE size = 0 NEW_LINE problems = [ int ( num ) for num in input ( ) . split ( ) ] NEW_LINE saida = ' ' NEW_LINE for problem in problems : NEW_LINE INDENT table [ problem - 1 ] += 1 NEW_LINE if table [ problem - 1 ] == 1 : NEW_LINE INDENT size += 1 NEW_LINE if size == n : NEW_LINE INDENT saida += '1' NEW_LINE for i in range ( n ) : NEW_LINE INDENT table [ i ] -= 1 NEW_LINE if table [ i ] == 0 : NEW_LINE INDENT size -= 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT saida += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT saida += '0' NEW_LINE DEDENT DEDENT print ( saida ) NEW_LINE", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = [ 0 ] * ( n + 1 ) NEW_LINE c = 0 NEW_LINE ans = [ ] NEW_LINE for i in a : NEW_LINE INDENT if not cnt [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT cnt [ i ] += 1 NEW_LINE ans . append ( \"0\" if c ^ n else \"1\" ) NEW_LINE if c == n : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt [ j ] -= 1 NEW_LINE if not cnt [ j ] : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT sys . stdout . write ( \" \" . join ( ans ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1868_A", "java": ["import java . io . * ; class GFG { static int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . pow ( 4 , num ) ; num = ( int ) Math . floor ( num / 3.0 ) ; return num ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( findNumber ( n ) ) ; } }"], "python": ["def findNumber ( n ) : NEW_LINE INDENT num = n - 1 ; NEW_LINE num = 2 * ( 4 ** num ) ; NEW_LINE num = num // 3 ; NEW_LINE return num ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( findNumber ( n ) ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1778_A", "java": ["class GFG { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void main ( String [ ] args ) { System . out . print ( \" \\n \" + multiply ( 5 , - 11 ) ) ; } }"], "python": ["def multiply ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT DEDENT print ( multiply ( 5 , - 11 ) ) NEW_LINE"]}
{"id": "geeksforgeeks_645_A", "java": ["import java . util . * ; class GFG { static int sz = ( int ) 1e3 ; static HashSet < Integer > fib = new HashSet < Integer > ( ) ; static void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . add ( prev ) ; fib . add ( curr ) ; while ( len <= sz ) { int temp = curr + prev ; fib . add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } } static void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } static void removeFibonacci ( int arr [ ] , int len ) { fibonacci ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( fib . contains ( arr [ i ] ) ) { for ( int j = i ; j < len - 1 ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 } ; int len = arr . length ; removeFibonacci ( arr , len ) ; } }"], "python": ["sz = 1000 NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev , curr , length = 0 , 1 , 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( length <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE length += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT def removeFibonacci ( arr , length ) : NEW_LINE INDENT fibonacci ( ) NEW_LINE for i in fib : NEW_LINE INDENT if i in arr : NEW_LINE INDENT arr . remove ( i ) NEW_LINE length -= 1 NEW_LINE DEDENT DEDENT printArray ( arr , length ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ] NEW_LINE length = len ( arr ) NEW_LINE removeFibonacci ( arr , length ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4681_A", "java": ["class GFG { static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( minAbsDiff ( n ) ) ; } }"], "python": ["import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4867_A", "java": ["import java . util . Arrays ; class GFG { static void bitonicGenerator ( int arr [ ] , int n ) { int i = 1 ; int j = n - 1 ; if ( j % 2 != 0 ) j -- ; while ( i < j ) { arr = swap ( arr , i , j ) ; i += 2 ; j -= 2 ; } Arrays . sort ( arr , 0 , ( n + 1 ) / 2 ) ; Arrays . sort ( arr , ( n + 1 ) / 2 , n ) ; int low = ( n + 1 ) / 2 , high = n - 1 ; while ( low < high ) { Integer temp = arr [ low ] ; arr [ low ] = arr [ high ] ; arr [ high ] = temp ; low ++ ; high -- ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; bitonicGenerator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"], "python": ["def bitonicGenerator ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE if ( j % 2 != 0 ) : NEW_LINE INDENT j = j - 1 NEW_LINE DEDENT while ( i < j ) : NEW_LINE INDENT arr [ j ] , arr [ i ] = arr [ i ] , arr [ j ] NEW_LINE i = i + 2 NEW_LINE j = j - 2 NEW_LINE DEDENT arr_f = [ ] NEW_LINE arr_s = [ ] NEW_LINE for i in range ( int ( ( n + 1 ) / 2 ) ) : NEW_LINE INDENT arr_f . append ( arr [ i ] ) NEW_LINE DEDENT i = int ( ( n + 1 ) / 2 ) NEW_LINE while ( i < n ) : NEW_LINE INDENT arr_s . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT arr_f . sort ( ) NEW_LINE arr_s . sort ( reverse = True ) NEW_LINE for i in arr_s : NEW_LINE INDENT arr_f . append ( i ) NEW_LINE DEDENT return arr_f NEW_LINE DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr = bitonicGenerator ( arr , n ) NEW_LINE print ( arr ) NEW_LINE"]}
{"id": "geeksforgeeks_726_A", "java": ["class GFG { static final int n = 5 ; static void printSumSimple ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; System . out . print ( sum + \" \u2581 \" ) ; } System . out . println ( ) ; } } public static void main ( String arg [ ] ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } } ; int k = 3 ; printSumSimple ( mat , k ) ; } }"], "python": ["n = 5 NEW_LINE def printSumSimple ( mat , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - k + 1 ) : NEW_LINE INDENT for j in range ( n - k + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE DEDENT"]}
{"id": "codeforces_322_A", "java": ["import java . util . * ; import java . io . * ; import java . math . BigDecimal ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; System . out . println ( a + b - 1 ) ; int i = 1 ; while ( i <= b ) { System . out . println ( \"1 \u2581 \" + i ) ; i ++ ; } i = 2 ; while ( i <= a ) { System . out . println ( i + \" \u2581 1\" ) ; i ++ ; } } }", "import java . util . Scanner ; public class Solution { @ SuppressWarnings ( \" resource \" ) public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) , m = in . nextInt ( ) ; System . out . println ( n + m - 1 ) ; for ( int i = 0 ; i < m ; i ++ ) System . out . println ( \"1 \u2581 \" + ( i + 1 ) ) ; for ( int i = 1 ; i < n ; i ++ ) System . out . println ( ( i + 1 ) + \" \u2581 \" + m ) ; } }", "import java . util . Scanner ; import java . util . Arrays ; import java . io . * ; public class CielDancing { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; StringBuilder sb = new StringBuilder ( ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; boolean b [ ] = new boolean [ n ] ; boolean g [ ] = new boolean [ m ] ; int i = 0 , j = 0 ; int count = 0 ; while ( i < n || j < m ) { if ( ( i < n && b [ i ] == false ) || ( j < m && g [ j ] == false ) ) { sb . append ( ( i == n ? i : ( i + 1 ) ) + \" \u2581 \" + ( j + 1 ) + \" \\n \" ) ; count ++ ; if ( i < n ) b [ i ] = true ; if ( j < m ) g [ j ] = true ; } else { if ( i < n && b [ i ] == true ) i ++ ; else j ++ ; } } System . out . println ( count ) ; System . out . println ( sb . toString ( ) ) ; } }"], "python": ["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( m + n - 1 ) NEW_LINE if n == 1 and m == 1 : NEW_LINE INDENT print ( 1 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i , 1 ) NEW_LINE DEDENT for i in range ( 2 , m + 1 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE DEDENT DEDENT", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b - 1 ) NEW_LINE for i in range ( 1 , a + b ) : NEW_LINE INDENT print ( max ( 1 , i - b + 1 ) , min ( i , b ) ) NEW_LINE DEDENT", "num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( n + m - 1 ) NEW_LINE for i in range ( n ) : print ( i + 1 , 1 ) NEW_LINE for i in range ( m - 1 ) : print ( 1 , i + 2 ) NEW_LINE", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE print ( a + b - 1 ) NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( i , 1 ) NEW_LINE DEDENT for i in range ( 2 , b + 1 ) : NEW_LINE INDENT print ( 1 , i ) NEW_LINE DEDENT", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE z = a - 1 + b NEW_LINE print ( z ) NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( 1 , i + 1 ) NEW_LINE DEDENT for i in range ( 1 , a ) : NEW_LINE INDENT print ( i + 1 , 1 ) NEW_LINE DEDENT"]}
{"id": "codeforces_784_B", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a ; int i ; char [ ] ch ; int x ; String [ ] c = { \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \" A \" , \" B \" , \" C \" , \" D \" , \" E \" , \" F \" , } ; String s = \" \" ; if ( n == 0 ) { System . out . println ( 1 ) ; } else { while ( n != 0 ) { a = n % 16 ; s = c [ a ] + s ; n = n / 16 ; } ch = s . toCharArray ( ) ; x = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ch [ i ] == '0' || ch [ i ] == '4' || ch [ i ] == '6' || ch [ i ] == '9' || ch [ i ] == ' A ' || ch [ i ] == ' D ' ) { x ++ ; } else if ( ch [ i ] == '8' || ch [ i ] == ' B ' ) { x += 2 ; } } System . out . println ( x ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a ; int i ; char [ ] ch ; int x ; String [ ] c = { \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \" A \" , \" B \" , \" C \" , \" D \" , \" E \" , \" F \" , } ; String s = \" \" ; if ( n == 0 ) { System . out . println ( 1 ) ; } else { while ( n != 0 ) { a = n % 16 ; s = c [ a ] + s ; n = n / 16 ; } ch = s . toCharArray ( ) ; x = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ch [ i ] == '0' || ch [ i ] == '4' || ch [ i ] == '6' || ch [ i ] == '9' || ch [ i ] == ' A ' || ch [ i ] == ' D ' ) { x ++ ; } else if ( ch [ i ] == '8' || ch [ i ] == ' B ' ) { x += 2 ; } } System . out . println ( x ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int a ; int i ; char [ ] ch ; int x ; String [ ] c = { \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \" A \" , \" B \" , \" C \" , \" D \" , \" E \" , \" F \" , } ; String s = \" \" ; if ( n == 0 ) { System . out . println ( 1 ) ; } else { while ( n != 0 ) { a = n % 16 ; s = c [ a ] + s ; n = n / 16 ; } ch = s . toCharArray ( ) ; x = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( ch [ i ] == '0' || ch [ i ] == '4' || ch [ i ] == '6' || ch [ i ] == '9' || ch [ i ] == ' A ' || ch [ i ] == ' D ' ) { x ++ ; } else if ( ch [ i ] == '8' || ch [ i ] == ' B ' ) { x += 2 ; } } System . out . println ( x ) ; } } }"], "python": ["v = [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 2 , 1 , 1 , 2 , 0 , 1 , 0 , 0 ] NEW_LINE n = int ( input ( ) ) NEW_LINE a = 1 if n == 0 else 0 NEW_LINE while n > 0 : NEW_LINE INDENT a += v [ n % 16 ] NEW_LINE n //= 16 NEW_LINE DEDENT print ( a ) NEW_LINE", "a = int ( input ( ) ) NEW_LINE h = hex ( a ) NEW_LINE s = str ( h ) [ 2 : ] NEW_LINE oneHole = [ '0' , '4' , '6' , '9' , ' a ' , ' d ' ] NEW_LINE twoHoles = [ '8' , ' b ' ] NEW_LINE count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in oneHole : NEW_LINE INDENT count += 1 NEW_LINE DEDENT elif s [ i ] in twoHoles : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "def to_hex ( n ) : NEW_LINE INDENT return hex ( n ) [ 2 : ] . upper ( ) NEW_LINE DEDENT def closed_loops ( x ) : NEW_LINE INDENT d = { '0' : 1 , '1' : 0 , '2' : 0 , '3' : 0 , '4' : 1 , '5' : 0 , '6' : 1 , '7' : 0 , '8' : 2 , '9' : 1 , ' A ' : 1 , ' B ' : 2 , ' C ' : 0 , ' D ' : 1 , ' E ' : 0 , ' F ' : 0 } NEW_LINE total = 0 NEW_LINE a = to_hex ( x ) NEW_LINE for c in a : NEW_LINE INDENT total += d [ c ] NEW_LINE DEDENT return total NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( closed_loops ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n = hex ( int ( input ( ) ) ) [ 2 : ] NEW_LINE sum = 0 NEW_LINE for i in n : NEW_LINE INDENT sum += [ 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 2 , 1 , 1 , 2 , 0 , 1 , 0 , 0 ] [ int ( i , 16 ) ] NEW_LINE DEDENT print ( sum ) NEW_LINE", "a = { '0' : 1 , '1' : 0 , '2' : 0 , '3' : 0 , '4' : 1 , '5' : 0 , '6' : 1 , '7' : 0 , '8' : 2 , '9' : 1 , ' a ' : 1 , ' b ' : 2 , ' c ' : 0 , ' d ' : 1 , ' e ' : 0 , ' f ' : 0 } NEW_LINE s = 0 NEW_LINE for i in hex ( int ( input ( ) ) ) . replace ( '0x ' , ' ' ) : NEW_LINE INDENT s += a [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE"]}
{"id": "geeksforgeeks_3215_A", "java": ["import java . util . Arrays ; class GFG { static int numOfWhiteHats ( int arr [ ] , int n ) { int freq [ ] = new int [ n + 1 ] ; Arrays . fill ( freq , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= n ) return - 1 ; freq [ arr [ i ] ] ++ ; } int diffFreq = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( freq [ i ] > 0 ) diffFreq ++ ; if ( diffFreq == 1 && freq [ n - 1 ] == n ) return n ; if ( diffFreq == 1 && freq [ 0 ] == n ) return 0 ; if ( diffFreq != 2 ) return - 1 ; int k ; for ( k = n - 1 ; k >= 1 ; k -- ) if ( freq [ k ] > 0 ) break ; if ( freq [ k - 1 ] == k && freq [ k ] + k == n ) return freq [ k - 1 ] ; else return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 , 3 , 3 } ; int n = arr . length ; System . out . print ( numOfWhiteHats ( arr , n ) ) ; } }"], "python": ["def numOfWhiteHats ( arr , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT diffFreq = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT diffFreq += 1 NEW_LINE DEDENT DEDENT if ( diffFreq == 1 and freq [ n - 1 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( diffFreq == 1 and freq [ 0 ] == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( diffFreq != 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for k in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( freq [ k ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( freq [ k - 1 ] == k and freq [ k ] + k == n ) : NEW_LINE INDENT return freq [ k - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfWhiteHats ( arr , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5066_A", "java": ["class GFG { static boolean canBeBalanced ( String s , int n ) { int count = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) count ++ ; else count -- ; count_1 = Math . min ( count_1 , count ) ; } if ( count_1 >= - 1 && count == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { String s = \" ( ) ) ( ) ( \" ; int n = s . length ( ) ; if ( canBeBalanced ( s , n ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def canBeBalanced ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE count_1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT count_1 = min ( count_1 , count ) NEW_LINE DEDENT if ( count_1 >= - 1 and count == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT s = \" ( ) ) ( ) ( \" NEW_LINE n = len ( s ) NEW_LINE if ( canBeBalanced ( s , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "codeforces_1615_B", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; int arr [ ] [ ] = new int [ ( int ) ( 2 * ( 1e5 ) + 1 ) ] [ 31 ] ; int ans = Integer . bitCount ( ( int ) 1e9 ) ; int x = 1 ; int presum [ ] = new int [ ( int ) ( 2 * 1e5 ) + 1 ] ; for ( int i = 1 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < arr [ i ] . length ; j ++ ) { if ( ( i & 1 << j ) == 0 ) arr [ i ] [ j ] = 1 ; else arr [ i ] [ j ] = 0 ; arr [ i ] [ j ] += arr [ i - 1 ] [ j ] ; } } while ( t -- > 0 ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int l = Integer . parseInt ( st . nextToken ( ) ) ; int r = Integer . parseInt ( st . nextToken ( ) ) ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < 31 ; i ++ ) { min = Math . min ( min , arr [ r ] [ i ] - arr [ l - 1 ] [ i ] ) ; } System . out . println ( min ) ; } } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE cur = [ 0 for i in range ( 20 ) ] NEW_LINE counts = { 0 : cur . copy ( ) } NEW_LINE for i in range ( 1 , 200001 ) : NEW_LINE INDENT b = bin ( i ) NEW_LINE for j in range ( len ( b ) - 2 ) : NEW_LINE INDENT if b [ - j - 1 ] == '1' : cur [ j ] += 1 NEW_LINE DEDENT counts [ i ] = cur . copy ( ) NEW_LINE DEDENT for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ar = counts [ r ] NEW_LINE al = counts [ l - 1 ] NEW_LINE cc = [ ar [ i ] - al [ i ] for i in range ( len ( ar ) ) ] NEW_LINE print ( r - l + 1 - max ( cc ) ) NEW_LINE DEDENT", "lis = [ ] NEW_LINE k = 25 NEW_LINE mp = { } NEW_LINE for i in range ( 2 * ( 10 ** 5 ) + 3 ) : NEW_LINE INDENT s = bin ( i ) [ 2 : ] [ : : - 1 ] NEW_LINE s += '0' * ( k - len ( s ) ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i not in mp ) : NEW_LINE INDENT mp [ i ] = 0 NEW_LINE DEDENT if s [ i ] == \"0\" : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT DEDENT lis . append ( mp . copy ( ) ) NEW_LINE DEDENT for p in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 2 ** 31 NEW_LINE for i in range ( k ) : NEW_LINE INDENT ans = min ( ans , lis [ r ] [ i ] - lis [ l - 1 ] [ i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "import math NEW_LINE L = [ [ 0 for i in range ( 20 ) ] for i in range ( 2 * ( 10 ** 5 ) + 1 ) ] NEW_LINE for j in range ( 0 , 2 * ( 10 ** 5 ) + 1 ) : NEW_LINE INDENT for k in range ( 0 , 20 ) : NEW_LINE INDENT L [ j ] [ k ] = L [ j - 1 ] [ k ] NEW_LINE if ( ( j & ( 1 << k ) ) >> k == 1 ) : NEW_LINE INDENT L [ j ] [ k ] += 1 NEW_LINE DEDENT DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE u = 0 NEW_LINE for k in range ( 0 , 20 ) : NEW_LINE INDENT u = max ( u , L [ r ] [ k ] - L [ l - 1 ] [ k ] ) NEW_LINE DEDENT print ( ( r - l + 1 ) - u ) NEW_LINE DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ps ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE arr = [ ps [ r ] [ i ] - ps [ l - 1 ] [ i ] for i in range ( 20 ) ] NEW_LINE return min ( arr ) NEW_LINE DEDENT ps = [ [ 0 ] * 20 for _ in range ( 2 * ( 10 ** 5 ) + 1 ) ] NEW_LINE n = len ( ps ) NEW_LINE for i in range ( 1 , 2 * ( 10 ** 5 ) + 1 ) : NEW_LINE INDENT ps [ i ] = list ( ps [ i - 1 ] ) NEW_LINE num = i NEW_LINE for j in range ( 20 ) : NEW_LINE INDENT ps [ i ] [ j ] += 0 if num & 1 else 1 NEW_LINE num >>= 1 NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT print ( main ( ps ) ) NEW_LINE DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE maxx = 100000 << 1 NEW_LINE d = [ [ 0 ] * 18 ] NEW_LINE for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT d . append ( [ d [ - 1 ] [ j ] + ( i & ( 1 << j ) != 0 ) for j in range ( 18 ) ] ) NEW_LINE DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE print ( str ( r - l + 1 - max ( d [ r ] [ i ] - d [ l - 1 ] [ i ] for i in range ( 18 ) ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3458_A", "java": ["import java . util . * ; class GFG { static String minInt ( String str ) { String s = \" \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= '5' ) { s += ( char ) ( ( '9' - str . charAt ( i ) ) + '0' ) ; } else { s += str . charAt ( i ) ; } } if ( str . charAt ( 0 ) == '0' ) s += '9' ; return s ; } public static void main ( String [ ] args ) { String str = \"589\" ; System . out . println ( minInt ( str ) ) ; } }"], "python": ["def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = \" \" NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT str1 = \"589\" NEW_LINE str1 = [ int ( i ) for i in str1 ] NEW_LINE print ( minInt ( str1 ) ) NEW_LINE"]}
{"id": "codejam_08_11", "java": ["import java . io . * ; import java . util . StringTokenizer ; import java . util . Arrays ; public class A { private String solve ( ) throws IOException { int n = nextInt ( ) ; long [ ] x = new long [ n ] ; long [ ] y = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { y [ i ] = nextInt ( ) ; } Arrays . sort ( x ) ; Arrays . sort ( y ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += x [ i ] * y [ n - 1 - i ] ; } return \" \" + ans ; } private BufferedReader reader ; private StringTokenizer tt = new StringTokenizer ( \" \" ) ; private String nextToken ( ) throws IOException { while ( ! tt . hasMoreTokens ( ) ) { tt = new StringTokenizer ( reader . readLine ( ) ) ; } return tt . nextToken ( ) ; } private int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } private void run ( ) throws IOException { reader = new BufferedReader ( new FileReader ( \" A - large . in \" ) ) ; PrintWriter writer = new PrintWriter ( new File ( \" A - large . out \" ) ) ; try { int n = nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { writer . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; writer . print ( solve ( ) ) ; writer . println ( ) ; } } finally { reader . close ( ) ; writer . close ( ) ; } } public static void main ( String [ ] args ) { try { new A ( ) . run ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . FileWriter ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class P1 { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( \" p1 . in \" ) ) ; String line = \" \" ; int t = Integer . parseInt ( br . readLine ( ) ) ; FileWriter out = new FileWriter ( \" p1 . out \" ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = Integer . parseInt ( br . readLine ( ) ) ; String v1 = br . readLine ( ) ; String v2 = br . readLine ( ) ; String [ ] vv1 = v1 . split ( \" \\\\ s + \" ) ; String [ ] vv2 = v2 . split ( \" \\\\ s + \" ) ; List < Long > iv1 = s2l ( vv1 ) ; List < Long > iv2 = s2l ( vv2 ) ; Collections . sort ( iv1 ) ; Collections . sort ( iv2 ) ; if ( iv1 . size ( ) != iv2 . size ( ) ) System . out . println ( \" Oops ! \" ) ; long res = 0 ; for ( int j = 0 ; j < iv1 . size ( ) ; j ++ ) { System . out . println ( iv1 . get ( j ) + \" \u2581 * \u2581 \" + iv2 . get ( iv1 . size ( ) - 1 - j ) ) ; res += iv1 . get ( j ) * iv2 . get ( iv1 . size ( ) - 1 - j ) ; } out . write ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" + res + \" \\n \" ) ; System . out . println ( res ) ; } br . close ( ) ; out . close ( ) ; } private static List < Long > s2l ( String [ ] vv1 ) { List < Long > ret = new ArrayList < Long > ( vv1 . length ) ; for ( int i = 0 ; i < vv1 . length ; i ++ ) ret . add ( Long . parseLong ( vv1 [ i ] ) ) ; return ret ; } }", "import java . io . * ; import java . util . * ; public class SolutionA implements Runnable { public static void main ( String [ ] args ) { new Thread ( new SolutionA ( ) ) . run ( ) ; } public void run ( ) { try { Locale . setDefault ( Locale . US ) ; br = new BufferedReader ( new FileReader ( FILENAME + \" . in \" ) ) ; out = new PrintWriter ( FILENAME + \" . out \" ) ; solve ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } BufferedReader br ; PrintWriter out ; StringTokenizer st ; boolean eof ; String nextToken ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { eof = true ; return \"0\" ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } private static final String FILENAME = \" A - large \" ; public void solve ( ) throws IOException { int testsn = nextInt ( ) ; for ( int test = 0 ; test < testsn ; test ++ ) { out . print ( \" Case \u2581 # \" + ( test + 1 ) + \" : \u2581 \" ) ; int n = nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = nextLong ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += a [ i ] * b [ n - 1 - i ] ; } out . println ( ans ) ; } } }", "import java . util . * ; public class MinimumProduct { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int numCases = in . nextInt ( ) ; for ( int i = 0 ; i < numCases ; i ++ ) doCase ( i + 1 , in ) ; } private static void doCase ( int caseNum , Scanner in ) { int dims = in . nextInt ( ) ; List < Integer > v1 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v1 . add ( in . nextInt ( ) ) ; Collections . sort ( v1 ) ; List < Integer > v2 = new ArrayList < Integer > ( dims ) ; for ( int i = 0 ; i < dims ; i ++ ) v2 . add ( in . nextInt ( ) ) ; Collections . sort ( v2 , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return - o1 . compareTo ( o2 ) ; } } ) ; long prod = 0 ; for ( int i = 0 ; i < dims ; i ++ ) prod += v1 . get ( i ) * ( long ) v2 . get ( i ) ; System . out . println ( \" Case \u2581 # \" + caseNum + \" : \u2581 \" + prod ) ; } }", "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . StringTokenizer ; public class Solution implements Runnable { private static final String INPUT_FILE_NAME = \" a . big . in . txt \" ; private static final String OUTPUT_FILE_NAME = \" a . big . out . txt \" ; private BufferedReader rd ; private PrintWriter wr ; public static void main ( String [ ] args ) { new Thread ( new Solution ( ) ) . start ( ) ; } public void run ( ) { try { solve ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } void solve ( ) throws IOException { rd = new BufferedReader ( new FileReader ( Solution . INPUT_FILE_NAME ) ) ; wr = new PrintWriter ( Solution . OUTPUT_FILE_NAME ) ; String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int nn = Integer . parseInt ( st . nextToken ( ) ) ; for ( int ii = 0 ; ii < nn ; ++ ii ) { subSolve ( ii ) ; } rd . close ( ) ; wr . close ( ) ; } private void subSolve ( int ii ) throws IOException { String line = rd . readLine ( ) ; StringTokenizer st = new StringTokenizer ( line ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } line = rd . readLine ( ) ; st = new StringTokenizer ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { b [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result += ( a [ i ] * b [ n - i - 1 ] ) ; } wr . println ( String . format ( \" Case \u2581 # % d : \u2581 % d \" , ii + 1 , result ) ) ; } }"], "python": ["import sys NEW_LINE if ( __name__ == ' _ _ main _ _ ' ) : NEW_LINE INDENT tc_count = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE for i in range ( tc_count ) : NEW_LINE INDENT sys . stdin . readline ( ) NEW_LINE v1 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v2 = [ int ( x ) for x in sys . stdin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE v2 . reverse ( ) NEW_LINE msp = 0 NEW_LINE assert ( len ( v1 ) == len ( v2 ) ) NEW_LINE for j in range ( len ( v1 ) ) : NEW_LINE INDENT msp += v1 [ j ] * v2 [ j ] NEW_LINE DEDENT sys . stdout . write ( ' Case \u2581 # % d : \u2581 % d \\n ' % ( i + 1 , msp ) ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE argv = sys . argv [ 1 : ] NEW_LINE testFile = open ( argv [ 0 ] + ' . in ' , ' rb ' ) NEW_LINE outFile = open ( argv [ 0 ] + ' . out ' , ' wb ' ) NEW_LINE nCases = int ( testFile . readline ( ) ) NEW_LINE for i in xrange ( 1 , nCases + 1 ) : NEW_LINE INDENT n = int ( testFile . readline ( ) ) NEW_LINE v1 = sorted ( int ( val ) for val in testFile . readline ( ) . split ( ) ) NEW_LINE v2 = sorted ( int ( val ) for val in testFile . readline ( ) . split ( ) ) NEW_LINE v2 = v2 [ : : - 1 ] NEW_LINE outFile . write ( ' Case \u2581 # % i : \u2581 % i \\n ' % ( i , sum ( a * b for a , b in zip ( v1 , v2 ) ) ) ) NEW_LINE DEDENT", "import sys NEW_LINE _TYPE = { ' d ' : int , ' l ' : long , ' f ' : float , ' s ' : str } NEW_LINE _buffer = [ ] NEW_LINE def next_token ( ) : NEW_LINE INDENT if not _buffer : NEW_LINE INDENT line = sys . stdin . readline ( ) NEW_LINE _buffer . extend ( line . split ( ) ) NEW_LINE DEDENT return _buffer . pop ( 0 ) NEW_LINE DEDENT def scanf ( format ) : NEW_LINE INDENT if len ( format ) % 2 != 0 : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT for i in xrange ( 0 , len ( format ) , 2 ) : NEW_LINE INDENT if format [ i ] != ' % ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT if format [ i + 1 ] not in ' dfs ' : NEW_LINE INDENT raise ValueError NEW_LINE DEDENT DEDENT result = [ ] NEW_LINE for i in xrange ( 1 , len ( format ) , 2 ) : NEW_LINE INDENT token = next_token ( ) NEW_LINE value = _TYPE [ format [ i ] ] ( token ) NEW_LINE result . append ( value ) NEW_LINE DEDENT return tuple ( result ) NEW_LINE DEDENT def printf ( format , * args ) : NEW_LINE INDENT message = format % args NEW_LINE sys . stdout . write ( message ) NEW_LINE return len ( message ) NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n , = scanf ( ' % d ' ) NEW_LINE v1 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v2 = list ( scanf ( ' % d ' * n ) ) NEW_LINE v1 . sort ( ) NEW_LINE v2 . sort ( ) NEW_LINE msp = sum ( x * y for x , y in zip ( v1 , v2 [ : : - 1 ] ) ) NEW_LINE return msp NEW_LINE DEDENT num_cases , = scanf ( ' % d ' ) NEW_LINE for case_num in xrange ( num_cases ) : NEW_LINE INDENT result = solve ( ) NEW_LINE printf ( ' Case \u2581 # % d : \u2581 % s \\n ' , case_num + 1 , result ) NEW_LINE DEDENT", "import sys , math NEW_LINE def dist ( p1 , p2 ) : NEW_LINE INDENT x1 , y1 = p1 NEW_LINE x2 , y2 = p2 NEW_LINE return pyth ( x2 - x1 , y2 - y1 ) NEW_LINE DEDENT def pyth ( s1 , s2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( s1 , 2 ) + math . pow ( s2 , 2 ) ) NEW_LINE DEDENT def cArea ( r ) : NEW_LINE INDENT return math . pi * math . pow ( r , 2 ) NEW_LINE DEDENT def rectArea ( l , w ) : NEW_LINE INDENT return l * w NEW_LINE DEDENT def triArea ( s1 , s2 , s3 ) : NEW_LINE INDENT s = ( s1 + s2 + s3 ) / 2 NEW_LINE return s * ( s - s1 ) * ( s - s2 ) * ( s - s3 ) NEW_LINE DEDENT def main ( v1 , v2 ) : NEW_LINE INDENT v1 . sort ( ) NEW_LINE v2 . sort ( lambda a , b : cmp ( b , a ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT sum += ( v1 [ i ] * v2 [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def getline ( fpin , types ) : NEW_LINE INDENT args = fpin . readline ( ) . strip ( ) . split ( ) NEW_LINE for i in range ( len ( types ) ) : NEW_LINE INDENT args [ i ] = types [ i ] ( args [ i ] ) NEW_LINE DEDENT return args NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT fpin = open ( sys . argv [ 1 ] ) NEW_LINE if len ( sys . argv ) > 2 : NEW_LINE INDENT fpout = open ( sys . argv [ 2 ] , ' w ' ) NEW_LINE DEDENT else : NEW_LINE INDENT fpout = sys . stdout NEW_LINE DEDENT cases = int ( fpin . readline ( ) . strip ( ) ) NEW_LINE for case in range ( 1 , cases + 1 ) : NEW_LINE INDENT s = int ( fpin . readline ( ) . strip ( ) ) NEW_LINE v1 = [ int ( x ) for x in fpin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE v2 = [ int ( x ) for x in fpin . readline ( ) . strip ( ) . split ( ) ] NEW_LINE fpout . write ( \" Case \u2581 # % d : \u2581 % s \\n \" % ( case , main ( v1 , v2 ) ) ) NEW_LINE DEDENT DEDENT", "filename = \" A - large . in \" NEW_LINE f = open ( filename , ' r ' ) NEW_LINE of = open ( \" A - large . out \" , ' w ' ) NEW_LINE N = int ( f . readline ( ) ) NEW_LINE for x in xrange ( N ) : NEW_LINE INDENT n = int ( f . readline ( ) ) NEW_LINE a = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE b = f . readline ( ) . split ( ' \u2581 ' ) NEW_LINE a = [ int ( y ) for y in a ] NEW_LINE b = [ int ( y ) for y in b ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( reverse = True ) NEW_LINE s = 0 NEW_LINE for y in xrange ( len ( a ) ) : NEW_LINE INDENT s += a [ y ] * b [ y ] NEW_LINE DEDENT print >> of , \" Case \u2581 # % d : \u2581 % d \" % ( x + 1 , s ) NEW_LINE DEDENT f . close ( ) NEW_LINE of . close ( ) NEW_LINE"]}
{"id": "geeksforgeeks_1433_A", "java": ["import java . io . * ; class GFG { static int MAX = 100001 ; static int prefix [ ] = new int [ MAX ] ; static void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } static int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void main ( String [ ] args ) { sieve_modified ( ) ; int l = 6 , r = 10 ; System . out . println ( sumOddFactors ( l , r ) ) ; } }"], "python": ["MAX = 100001 ; NEW_LINE prefix = [ 0 ] * MAX ; NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i ; NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) ; NEW_LINE DEDENT sieve_modified ( ) ; NEW_LINE l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( sumOddFactors ( l , r ) ) ; NEW_LINE"]}
{"id": "codeforces_1369_A", "java": ["import java . util . Scanner ; public class test170 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { if ( in . nextInt ( ) % 4 == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } in . close ( ) ; } }", "import java . util . * ; import static java . lang . Integer . parseInt ; public class _1369A_FashionableLee { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int test = parseInt ( input . nextLine ( ) ) ; while ( test -- > 0 ) { int sides = parseInt ( input . nextLine ( ) ) ; if ( sides % 4 == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }", "import java . util . * ; public class codforce { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; while ( a -- > 0 ) { int s = sc . nextInt ( ) ; if ( s % 4 == 0 ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } } }", "import java . util . Scanner ; public class Fashionablee { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { int n = sc . nextInt ( ) ; if ( n % 4 == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } t -- ; } } }", "import java . util . Scanner ; public class rotate { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int a = in . nextInt ( ) ; if ( a % 4 == 0 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }"], "python": ["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( \" YES \" ) if n % 4 == 0 else print ( \" NO \" ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE if m % 4 == 0 and m >= 4 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE if m % 4 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "def solve ( n ) : NEW_LINE INDENT return ' YES ' if n % 4 == 0 else ' NO ' NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( solve ( n ) ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for test in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1199_B", "java": ["import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { waterLily1199B ( ) ; } public static void waterLily1199B ( ) { Scanner scan = new Scanner ( System . in ) ; long h = scan . nextLong ( ) ; long l = scan . nextLong ( ) ; double l2 = l * l ; double h2 = h * h ; double twoh = 2 * h ; System . out . println ( ( l2 - h2 ) / ( twoh ) ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; double H = sc . nextDouble ( ) ; double L = sc . nextDouble ( ) ; System . out . println ( ( L * L - H * H ) / ( 2 * H ) ) ; sc . close ( ) ; } }", "import java . util . * ; public class IntInput { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; double h = in . nextDouble ( ) , l = in . nextDouble ( ) ; System . out . println ( ( l * l - h * h ) / ( 2 * h ) ) ; } }"], "python": ["h , l = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( h * h + l * l ) / ( 2 * h ) - h ) NEW_LINE", "li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = li [ 0 ] NEW_LINE m = li [ 1 ] NEW_LINE if ( n < m ) : NEW_LINE INDENT n , m = m , n NEW_LINE DEDENT num = ( n ** 2 ) - ( m ** 2 ) NEW_LINE dem = 2 * m NEW_LINE print ( num / dem ) NEW_LINE", "li = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = li [ 0 ] NEW_LINE m = li [ 1 ] NEW_LINE if ( n < m ) : NEW_LINE INDENT n , m = m , n NEW_LINE DEDENT num = ( n ** 2 ) - ( m ** 2 ) NEW_LINE dem = 2 * m NEW_LINE print ( num / dem ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE H , L = map ( int , input ( ) . split ( ) ) NEW_LINE print ( ( L ** 2 - H ** 2 ) / ( 2 * H ) ) NEW_LINE", "h , l = map ( float , input ( ) . split ( ) ) NEW_LINE print ( - ( h ** 2 - l ** 2 ) / ( 2 * h ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1364_A", "java": ["import java . io . * ; import java . util . * ; class GFG { static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return ( int ) ( Math . floor ( digits ) ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 5 ) ) ; System . out . println ( findDigits ( 10 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }"], "python": ["import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT digits = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) ; NEW_LINE DEDENT return math . floor ( digits ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 5 ) ) ; NEW_LINE print ( findDigits ( 10 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE"]}
{"id": "aizu_p02239_A", "java": ["import java . util . LinkedList ; import java . util . Queue ; import java . util . Scanner ; class Graph2 { int totalVertex ; Queue < Integer > toVisit ; int [ ] distance ; public LinkedList < LinkedList < Integer > > adjList ; public Graph2 ( ) { totalVertex = 0 ; } public void loadAdjList ( ) { Scanner in = new Scanner ( System . in ) ; totalVertex = in . nextInt ( ) ; toVisit = new LinkedList < Integer > ( ) ; distance = new int [ totalVertex ] ; adjList = new LinkedList < LinkedList < Integer > > ( ) ; for ( int i = 0 ; i < totalVertex ; i ++ ) { LinkedList < Integer > tmp = new LinkedList < Integer > ( ) ; int idx1 = in . nextInt ( ) - 1 ; int degree = in . nextInt ( ) ; for ( int j = 0 ; j < degree ; j ++ ) { int idx2 = in . nextInt ( ) - 1 ; tmp . add ( idx2 ) ; } adjList . add ( tmp ) ; } for ( int i = 1 ; i < totalVertex ; i ++ ) { distance [ i ] = Integer . MAX_VALUE ; } in . close ( ) ; } public void BFS ( int v ) { toVisit . add ( v ) ; while ( ! toVisit . isEmpty ( ) ) { int next = toVisit . remove ( ) ; for ( int neighbor : adjList . get ( next ) ) { if ( ! toVisit . contains ( neighbor ) ) { if ( distance [ neighbor ] > distance [ next ] + 1 ) { toVisit . add ( neighbor ) ; distance [ neighbor ] = distance [ next ] + 1 ; } } } } } public void SearchGraph ( ) { BFS ( 0 ) ; for ( int i = 0 ; i < totalVertex ; i ++ ) { if ( distance [ i ] == Integer . MAX_VALUE ) { distance [ i ] = - 1 ; } System . out . println ( i + 1 + \" \u2581 \" + distance [ i ] ) ; } } } public class Main { public static void main ( String argv [ ] ) { Graph2 g = new Graph2 ( ) ; g . loadAdjList ( ) ; g . SearchGraph ( ) ; } }", "import java . util . * ; public class Main { static int [ ] check ; static int [ ] [ ] graph ; static int [ ] dis ; static int n ; final static int MAX = 100 ; public static void main ( String [ ] args ) { int i , j , s , pn , num ; Scanner sca = new Scanner ( System . in ) ; n = sca . nextInt ( ) ; check = new int [ MAX + 1 ] ; dis = new int [ MAX + 1 ] ; graph = new int [ MAX + 1 ] [ MAX + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) { num = sca . nextInt ( ) ; pn = sca . nextInt ( ) ; for ( j = 0 ; j < pn ; j ++ ) { s = sca . nextInt ( ) ; graph [ num ] [ s ] = 1 ; } } breadthexpl ( 1 ) ; } public static void breadthexpl ( int now ) { int i , j , hz ; Queue < Integer > que = new ArrayDeque < > ( ) ; que . offer ( now ) ; while ( que . peek ( ) != null ) { hz = que . poll ( ) ; for ( j = 1 ; j <= n ; j ++ ) { if ( graph [ hz ] [ j ] != 0 && check [ j ] == 0 ) { check [ j ] = 2 ; dis [ j ] = dis [ hz ] + 1 ; if ( dis [ hz ] == - 1 && dis [ j ] != - 1 ) dis [ hz ] ++ ; que . offer ( j ) ; } check [ hz ] = 1 ; } } for ( i = 1 ; i <= n ; i ++ ) { if ( check [ i ] == 0 ) dis [ i ] = - 1 ; System . out . println ( i + \" \u2581 \" + dis [ i ] ) ; } } }", "import java . util . Iterator ; import java . util . LinkedList ; import java . util . Scanner ; import java . util . Queue ; import java . util . Arrays ; class GraphBFS { private int totalVertex ; private LinkedList < LinkedList < Integer > > adjList ; public GraphBFS ( ) { totalVertex = 0 ; } public void loadAdjList ( ) { Scanner in = new Scanner ( System . in ) ; totalVertex = in . nextInt ( ) ; adjList = new LinkedList < LinkedList < Integer > > ( ) ; for ( int i = 0 ; i < totalVertex ; i ++ ) { LinkedList < Integer > tmp = new LinkedList < Integer > ( ) ; int idx1 = in . nextInt ( ) - 1 ; int degree = in . nextInt ( ) ; for ( int j = 0 ; j < degree ; j ++ ) { int idx2 = in . nextInt ( ) ; tmp . add ( idx2 ) ; } adjList . add ( tmp ) ; } in . close ( ) ; } public int [ ] BFS ( int start ) { Queue < Integer > Q = new LinkedList < > ( ) ; int [ ] Dist = new int [ totalVertex ] ; Arrays . fill ( Dist , - 1 ) ; Q . add ( start ) ; Dist [ start - 1 ] = 0 ; while ( Q . size ( ) > 0 ) { int v = Q . remove ( ) ; Iterator < Integer > it = adjList . get ( v - 1 ) . iterator ( ) ; while ( it . hasNext ( ) ) { int tmp = it . next ( ) ; if ( Dist [ tmp - 1 ] == - 1 ) { Q . add ( tmp ) ; Dist [ tmp - 1 ] = Dist [ v - 1 ] + 1 ; } } } return Dist ; } public void printDist ( int start ) { int [ ] Dist = BFS ( start ) ; for ( int i = 0 ; i < totalVertex ; i ++ ) { System . out . println ( ( i + 1 ) + \" \u2581 \" + Dist [ i ] ) ; } } } public class Main { public static void main ( String argv [ ] ) { GraphBFS g = new GraphBFS ( ) ; g . loadAdjList ( ) ; g . printDist ( 1 ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . Arrays ; import java . util . Deque ; class Main { static int n ; static int [ ] v ; static int [ ] [ ] graph ; static int time ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; n = Integer . parseInt ( br . readLine ( ) ) ; graph = new int [ n ] [ n ] ; v = new int [ n ] ; Arrays . fill ( v , Integer . MAX_VALUE ) ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] u_k_v = br . readLine ( ) . split ( \" \u2581 \" ) ; int u = Integer . parseInt ( u_k_v [ 0 ] ) ; for ( int k = 0 ; k < Integer . parseInt ( u_k_v [ 1 ] ) ; k ++ ) { graph [ u - 1 ] [ Integer . parseInt ( u_k_v [ 2 + k ] ) - 1 ] = 1 ; } } Deque < Integer > q = new ArrayDeque < > ( ) ; q . offer ( 0 ) ; v [ 0 ] = 0 ; while ( ! ( q . isEmpty ( ) ) ) { int node = q . poll ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( graph [ node ] [ j ] == 1 && v [ j ] > v [ node ] + 1 ) { v [ j ] = v [ node ] + 1 ; q . offer ( j ) ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i == 0 ) ) { System . out . println ( ( i + 1 ) + \" \u2581 \" + ( v [ i ] == Integer . MAX_VALUE ? \" - 1\" : v [ i ] ) ) ; } else { System . out . println ( ( i + 1 ) + \" \u2581 \" + v [ i ] ) ; } } } }", "import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static final int N = 100 ; static final int NOT_VISITED = - 1 ; static int n ; static int [ ] [ ] mat = new int [ N ] [ N ] ; static Queue < Integer > q = new ArrayDeque < Integer > ( ) ; static int [ ] d = new int [ N ] ; public static void main ( String [ ] args ) { read ( ) ; init ( ) ; bfs ( ) ; out ( ) ; } static void read ( ) { int u , k , v ; n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { u = sc . nextInt ( ) ; k = sc . nextInt ( ) ; for ( int j = 0 ; j < k ; j ++ ) { v = sc . nextInt ( ) ; mat [ u - 1 ] [ v - 1 ] = 1 ; } } } static void init ( ) { for ( int i = 0 ; i < n ; i ++ ) { d [ i ] = NOT_VISITED ; } d [ 0 ] = 0 ; } static void bfs ( ) { q . add ( 0 ) ; while ( ! q . isEmpty ( ) ) { int e = q . element ( ) ; q . remove ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ e ] [ i ] == 1 ) { if ( d [ i ] == NOT_VISITED ) { d [ i ] = d [ e ] + 1 ; q . add ( i ) ; } } } } } static void out ( ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( String . format ( \" % d \u2581 % d \" , i + 1 , d [ i ] ) ) ; } } }"], "python": ["import sys NEW_LINE input = lambda : sys . stdin . readline ( ) [ : - 1 ] NEW_LINE sys . setrecursionlimit ( 10 ** 8 ) NEW_LINE from collections import deque NEW_LINE n = int ( input ( ) ) NEW_LINE G = [ 0 ] * n NEW_LINE memo = [ 0 ] * n NEW_LINE dis = [ 0 ] * n NEW_LINE dis [ 0 ] = 1 NEW_LINE que = deque ( ) NEW_LINE que . append ( ( 0 , 1 ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT inp = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE G [ inp [ 0 ] - 1 ] = inp [ 2 : ] NEW_LINE DEDENT while que : NEW_LINE INDENT vertex , d = que . popleft ( ) NEW_LINE for v in G [ vertex ] : NEW_LINE INDENT if not dis [ v - 1 ] : NEW_LINE INDENT dis [ v - 1 ] = d + 1 NEW_LINE que . append ( ( v - 1 , d + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , dis [ i ] - 1 ) NEW_LINE DEDENT", "import math NEW_LINE import copy NEW_LINE import sys NEW_LINE import fractions NEW_LINE import decimal NEW_LINE import heapq NEW_LINE import collections NEW_LINE import itertools NEW_LINE import bisect NEW_LINE sys . setrecursionlimit ( 100001 ) NEW_LINE def getInputIntList ( ) : NEW_LINE INDENT outputDataList = [ ] NEW_LINE inputData = input ( ) . split ( ) NEW_LINE outputDataList = [ int ( n ) for n in inputData ] NEW_LINE return outputDataList NEW_LINE DEDENT def getSomeInputInt ( n ) : NEW_LINE INDENT outputDataList = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT inputData = int ( input ( ) ) NEW_LINE outputDataList . append ( inputData ) NEW_LINE DEDENT return outputDataList NEW_LINE DEDENT def getSomeInputListInt ( n ) : NEW_LINE INDENT inputDataList = [ ] NEW_LINE outputDataList = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT inputData = input ( ) . split ( ) NEW_LINE inputDataList = [ int ( n ) for n in inputData ] NEW_LINE outputDataList . append ( inputDataList ) NEW_LINE DEDENT return outputDataList NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE adj = [ list ( map ( int , input ( ) . split ( ) ) ) [ 2 : ] for _ in range ( n ) ] NEW_LINE d = [ - 1 ] * n NEW_LINE for a in adj : NEW_LINE INDENT for i in range ( len ( a ) ) : NEW_LINE INDENT a [ i ] -= 1 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE q = collections . deque ( [ ] ) NEW_LINE d [ s ] = 0 NEW_LINE q . append ( s ) NEW_LINE while len ( q ) : NEW_LINE INDENT u = q . popleft ( ) NEW_LINE v = adj [ u ] NEW_LINE for vi in v : NEW_LINE INDENT if d [ vi ] == - 1 : NEW_LINE INDENT d [ vi ] = d [ u ] + 1 NEW_LINE q . append ( vi ) NEW_LINE DEDENT elif d [ vi ] > d [ u ] + 1 : NEW_LINE INDENT d [ vi ] = d [ u ] + 1 NEW_LINE q . append ( vi ) NEW_LINE DEDENT DEDENT DEDENT for i , di in enumerate ( d ) : NEW_LINE INDENT print ( i + 1 , di ) NEW_LINE DEDENT", "from collections import deque NEW_LINE from typing import List NEW_LINE import sys NEW_LINE def bfs ( adj_list : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT n = len ( adj_list ) NEW_LINE result : List [ int ] = [ sys . maxsize for _ in range ( n ) ] NEW_LINE result [ 0 ] = 0 NEW_LINE queue : deque = deque ( ) NEW_LINE queue . append ( 0 ) NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT cur = queue . popleft ( ) NEW_LINE for vertex in adj_list [ cur ] : NEW_LINE INDENT if result [ cur ] + 1 < result [ vertex ] : NEW_LINE INDENT result [ vertex ] = result [ cur ] + 1 NEW_LINE queue . append ( vertex ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num_vertices = int ( input ( ) ) NEW_LINE adj_list : List [ List [ int ] ] = [ [ ] for _ in range ( num_vertices ) ] NEW_LINE for _ in range ( num_vertices ) : NEW_LINE INDENT vertex , num_adjs , * adjs = map ( lambda x : int ( x ) , input ( ) . split ( ) ) NEW_LINE for i in range ( num_adjs ) : NEW_LINE INDENT adj_list [ vertex - 1 ] . append ( adjs [ i ] - 1 ) NEW_LINE DEDENT DEDENT result = bfs ( adj_list ) NEW_LINE for i in range ( num_vertices ) : NEW_LINE INDENT if sys . maxsize == result [ i ] : NEW_LINE INDENT result [ i ] = - 1 NEW_LINE DEDENT print ( f \" { i \u2581 + \u2581 1 } \u2581 { result [ i ] } \" ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , idd , neighbors ) : NEW_LINE INDENT self . idd = idd NEW_LINE self . neighbors = neighbors NEW_LINE self . dist = - 1 NEW_LINE DEDENT def __repr__ ( self ) : NEW_LINE INDENT return \" { 0 } \u2581 { 1 } \" . format ( self . idd , self . dist ) NEW_LINE DEDENT DEDENT def breadthFirstSearch ( Nodes ) : NEW_LINE INDENT stack = [ Nodes [ 0 ] ] NEW_LINE Nodes [ 0 ] . dist = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT current = stack . pop ( 0 ) NEW_LINE for v in current . neighbors : NEW_LINE INDENT v_node = Nodes [ v - 1 ] NEW_LINE if ( v_node . dist == - 1 ) : NEW_LINE INDENT v_node . dist = current . dist + 1 NEW_LINE stack . append ( v_node ) NEW_LINE DEDENT else : NEW_LINE INDENT v_node . dist = v_node . dist if v_node . dist < current . dist + 1 else current . dist + 1 NEW_LINE DEDENT DEDENT DEDENT return Nodes NEW_LINE DEDENT Nodes = [ None ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = [ int ( tt ) for tt in input ( ) . split ( ) ] NEW_LINE Nodes [ row [ 0 ] - 1 ] = Node ( row [ 0 ] , [ row [ j + 2 ] for j in range ( row [ 1 ] ) ] ) NEW_LINE DEDENT Nodes = breadthFirstSearch ( Nodes ) NEW_LINE for node in Nodes : NEW_LINE INDENT print ( node ) NEW_LINE DEDENT", "from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE from itertools import permutations NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : NEW_LINE INDENT res = list ( sys . stdin . readline ( ) ) NEW_LINE if res [ - 1 ] == \" \\n \" : NEW_LINE INDENT return res [ : - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE v = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT e = LI ( ) NEW_LINE u = e [ 2 : ] NEW_LINE for i in range ( len ( u ) ) : NEW_LINE INDENT u [ i ] -= 1 NEW_LINE DEDENT v . append ( u ) NEW_LINE DEDENT d = [ - 1 ] * n NEW_LINE d [ 0 ] = 0 NEW_LINE q = deque ( [ 0 ] ) NEW_LINE while q : NEW_LINE INDENT x = q . popleft ( ) NEW_LINE nd = d [ x ] + 1 NEW_LINE for y in v [ x ] : NEW_LINE INDENT if d [ y ] < 0 : NEW_LINE INDENT d [ y ] = nd NEW_LINE q . append ( y ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , d [ i ] ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2052_A", "java": ["import java . util . * ; class Solution { static float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . sqrt ( 3 ) ; return a ; } public static void main ( String args [ ] ) { float r = 5 ; System . out . println ( largestCube ( r ) ) ; } }"], "python": ["from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( largestCube ( r ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_460_A", "java": ["class GFG { static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; } public static void main ( String [ ] args ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }"], "python": ["def numberOfPaths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i ; NEW_LINE path //= ( i - n + 1 ) ; NEW_LINE DEDENT return path ; NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEW_LINE"]}
{"id": "aizu_p01558_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashSet ; import java . util . Set ; import static java . lang . Integer . parseInt ; public class Main { static final long B = 37 ; static final long Binv = 1495681951922396077L ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; line = br . readLine ( ) ; int n , m ; n = parseInt ( line . substring ( 0 , line . indexOf ( ' \u2581 ' ) ) ) ; m = parseInt ( line . substring ( line . indexOf ( ' \u2581 ' ) + 1 ) ) ; char [ ] s = br . readLine ( ) . toCharArray ( ) ; int l = 0 , r = 0 ; long hash = s [ 0 ] ; Set < Long > hashs = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { switch ( br . readLine ( ) ) { case \" L + + \" : hash -= s [ l ] * power ( B , r - l ) ; l ++ ; break ; case \" L - - \" : l -- ; hash += s [ l ] * power ( B , r - l ) ; break ; case \" R + + \" : r ++ ; hash = hash * B + s [ r ] ; break ; case \" R - - \" : hash = ( hash - s [ r ] ) * Binv ; r -- ; break ; } hashs . add ( hash ) ; } System . out . println ( hashs . size ( ) ) ; } static long power ( long m , long n ) { if ( n == 0 ) return 1 ; if ( n % 2 == 0 ) { return power ( m * m , n / 2 ) ; } else { return power ( m * m , n / 2 ) * m ; } } }", "import java . io . IOException ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class Main { public static final long B = 1000000007L ; public static long inv ( long a , long p ) { return ( a == 1 ? 1 : ( 1 - p * inv ( p % a , a ) ) / a + p ) ; } public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; final int n = sc . nextInt ( ) ; final int m = sc . nextInt ( ) ; String str = sc . next ( ) ; char [ ] input = str . toCharArray ( ) ; HashSet < Long > set = new HashSet < Long > ( ) ; long [ ] pow = new long [ n + 1 ] ; pow [ 0 ] = 1L ; for ( int i = 1 ; i <= n ; i ++ ) { pow [ i ] = ( pow [ i - 1 ] * B ) ; } long [ ] hash_p = new long [ n + 1 ] ; hash_p [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash_p [ i + 1 ] = ( hash_p [ i ] * B + ( input [ i ] - ' a ' + 1 ) ) ; } int l = 0 , r = 0 ; long hash = input [ l ] ; for ( int i = 0 ; i < m ; i ++ ) { String in = sc . next ( ) ; if ( \" L + + \" . equals ( in ) ) { l ++ ; } else if ( \" L - - \" . equals ( in ) ) { l -- ; } else if ( \" R + + \" . equals ( in ) ) { r ++ ; } else if ( \" R - - \" . equals ( in ) ) { r -- ; } hash = hash_p [ r + 1 ] - hash_p [ l ] * pow [ r + 1 - l ] ; if ( ! set . contains ( hash ) ) { set . add ( hash ) ; } else { } } System . out . println ( set . size ( ) ) ; } }"], "python": ["def main ( ) : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE mem = set ( ) NEW_LINE base = ord ( \" a \" ) - 1 NEW_LINE mod1 = 1000000007 NEW_LINE mod2 = 2147483647 NEW_LINE h1 = [ 0 ] NEW_LINE h2 = [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT h1 . append ( ( h1 [ - 1 ] * 27 + ord ( c ) - base ) % mod1 ) NEW_LINE h2 . append ( ( h2 [ - 1 ] * 27 + ord ( c ) - base ) % mod2 ) NEW_LINE DEDENT pow_mem1 = { 0 : 1 } NEW_LINE pow_mem2 = { 0 : 1 } NEW_LINE def my_pow1 ( x ) : NEW_LINE INDENT if x in pow_mem1 : return pow_mem1 [ x ] NEW_LINE pow_mem1 [ x ] = my_pow1 ( x - 1 ) * 27 % mod1 NEW_LINE return pow_mem1 [ x ] NEW_LINE DEDENT def my_pow2 ( x ) : NEW_LINE INDENT if x in pow_mem2 : return pow_mem2 [ x ] NEW_LINE pow_mem2 [ x ] = my_pow2 ( x - 1 ) * 27 % mod2 NEW_LINE return pow_mem2 [ x ] NEW_LINE DEDENT left = right = 1 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT com = input ( ) NEW_LINE if com == \" L + + \" : NEW_LINE INDENT left += 1 NEW_LINE DEDENT if com == \" L - - \" : NEW_LINE INDENT left -= 1 NEW_LINE DEDENT if com == \" R + + \" : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if com == \" R - - \" : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT x = ( h1 [ right ] - h1 [ left - 1 ] * my_pow1 ( right - left + 1 ) ) % mod1 NEW_LINE y = ( h2 [ right ] - h2 [ left - 1 ] * my_pow2 ( right - left + 1 ) ) % mod2 NEW_LINE mem . add ( ( x , y ) ) NEW_LINE DEDENT print ( len ( mem ) ) NEW_LINE DEDENT main ( ) NEW_LINE", "import random NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE base1 = 1007 NEW_LINE mod1 = 10 ** 9 + 7 NEW_LINE base2 = 2009 NEW_LINE mod2 = 10 ** 9 + 9 NEW_LINE modTank1 = [ 3000012541 , 3000012553 , 3000012563 , 3000012649 , 3000012683 , 3000012709 ] NEW_LINE mod1 = modTank1 [ random . randint ( 0 , 5 ) ] NEW_LINE modTank2 = [ 3000014753 , 3000014783 , 3000014833 , 3000014839 , 3000014891 , 3000015433 ] NEW_LINE mod2 = modTank2 [ random . randint ( 0 , 5 ) ] NEW_LINE hash1 = [ 0 ] * ( n + 1 ) NEW_LINE power1 = [ 1 ] * ( n + 1 ) NEW_LINE hash2 = [ 0 ] * ( n + 1 ) NEW_LINE power2 = [ 1 ] * ( n + 1 ) NEW_LINE for i , e in enumerate ( s ) : NEW_LINE INDENT hash1 [ i + 1 ] = ( hash1 [ i ] * base1 + ord ( e ) ) % mod1 NEW_LINE power1 [ i + 1 ] = ( power1 [ i ] * base1 ) % mod1 NEW_LINE hash2 [ i + 1 ] = ( hash2 [ i ] * base2 + ord ( e ) ) % mod2 NEW_LINE power2 [ i + 1 ] = ( power2 [ i ] * base2 ) % mod2 NEW_LINE DEDENT res = 0 NEW_LINE tank1 = set ( ) NEW_LINE L = 0 NEW_LINE R = 1 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT q = input ( ) NEW_LINE if q == ' L + + ' : NEW_LINE INDENT L += 1 NEW_LINE DEDENT elif q == ' L - - ' : NEW_LINE INDENT L -= 1 NEW_LINE DEDENT elif q == ' R + + ' : NEW_LINE INDENT R += 1 NEW_LINE DEDENT else : NEW_LINE INDENT R -= 1 NEW_LINE DEDENT hashData1 = ( ( hash1 [ R ] - hash1 [ L ] * power1 [ R - L ] % mod1 ) % mod1 ) * ( 10 ** 10 ) + ( hash2 [ R ] - hash2 [ L ] * power2 [ R - L ] % mod2 ) % mod2 NEW_LINE if hashData1 in tank1 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT tank1 . add ( hashData1 ) NEW_LINE DEDENT print ( len ( tank1 ) ) NEW_LINE", "INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE class RollingHash : NEW_LINE INDENT def __init__ ( self , s , base , mod ) : NEW_LINE INDENT self . s = s NEW_LINE self . length = length = len ( s ) NEW_LINE self . base = base NEW_LINE self . mod = mod NEW_LINE self . h = h = [ 0 ] * ( length + 1 ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT h [ i + 1 ] = ( h [ i ] * base + ord ( s [ i ] ) ) % mod NEW_LINE DEDENT self . p = p = [ 1 ] * ( length + 1 ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT p [ i + 1 ] = pow ( base , i + 1 , mod ) NEW_LINE DEDENT DEDENT def get ( self , l , r ) : NEW_LINE INDENT mod = self . mod NEW_LINE return ( ( self . h [ r ] - self . h [ l ] * self . p [ r - l ] ) + mod ) % mod NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT N , M = inpl ( ) NEW_LINE S = input ( ) NEW_LINE h1 = RollingHash ( S , 13 , MOD ) NEW_LINE h2 = RollingHash ( S , 17 , MOD ) NEW_LINE left , right = 0 , 1 NEW_LINE vs = set ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT q = input ( ) NEW_LINE if q == ' R + + ' : NEW_LINE INDENT right += 1 NEW_LINE DEDENT elif q == ' R - - ' : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT elif q == ' L + + ' : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT left -= 1 NEW_LINE DEDENT v = ( h1 . get ( left , right ) , h2 . get ( left , right ) ) NEW_LINE if v not in vs : NEW_LINE INDENT ans += 1 NEW_LINE vs . add ( v ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5055_A", "java": ["import java . io . * ; import java . util . * ; class Node { int data ; Node left , right ; Node ( int key ) { data = key ; left = right = null ; } } class GFG { static int maxOfRightElement ( Node root ) { int res = Integer . MIN_VALUE ; if ( root == null ) return - 1 ; if ( root . right != null ) res = root . right . data ; return Math . max ( maxOfRightElement ( root . right ) , Math . max ( res , maxOfRightElement ( root . left ) ) ) ; } public static void main ( String args [ ] ) { Node root = new Node ( 7 ) ; root . left = new Node ( 6 ) ; root . right = new Node ( 5 ) ; root . left . left = new Node ( 4 ) ; root . left . right = new Node ( 3 ) ; root . right . left = new Node ( 2 ) ; root . right . right = new Node ( 1 ) ; System . out . println ( maxOfRightElement ( root ) ) ; } }"], "python": ["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . left = temp . right = None NEW_LINE return temp NEW_LINE DEDENT def maxOfRightElement ( root ) : NEW_LINE INDENT res = - 999999 NEW_LINE if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT res = root . right . data NEW_LINE DEDENT return max ( maxOfRightElement ( root . right ) , res , maxOfRightElement ( root . left ) ) NEW_LINE DEDENT root = newNode ( 7 ) NEW_LINE root . left = newNode ( 6 ) NEW_LINE root . right = newNode ( 5 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 2 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( maxOfRightElement ( root ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1020_A", "java": ["class GFG { static void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + \" \u2581 \" ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = arr . length ; removeElements ( arr , n ) ; } }"], "python": ["def removeElements ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * n ; l = 1 ; NEW_LINE brr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( brr [ l - 1 ] <= arr [ i ] ) : NEW_LINE INDENT brr [ l ] = arr [ i ] ; NEW_LINE l += 1 ; NEW_LINE DEDENT DEDENT for i in range ( l ) : NEW_LINE INDENT print ( brr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 12 , 9 , 10 , 2 , 13 , 14 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE removeElements ( arr , n ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3094_A", "java": ["import java . util . * ; class GFG { static class Node { int elementID ; int stepsToeliminate ; public Node ( int elementID , int stepsToeliminate ) { super ( ) ; this . elementID = elementID ; this . stepsToeliminate = stepsToeliminate ; } } ; static void minSteps ( int arr [ ] , int N ) { Stack < Node > s = new Stack < Node > ( ) ; s . add ( new Node ( 0 , - 1 ) ) ; int maxStepsToeliminate = - 1 ; for ( int i = 1 ; i < N ; i ++ ) { int stepsToeliminate = 1 ; while ( ! s . isEmpty ( ) ) { if ( arr [ s . peek ( ) . elementID ] >= arr [ i ] ) { stepsToeliminate = Math . max ( stepsToeliminate , s . peek ( ) . stepsToeliminate + 1 ) ; s . pop ( ) ; } else { break ; } } if ( s . isEmpty ( ) ) { stepsToeliminate = - 1 ; } maxStepsToeliminate = Math . max ( maxStepsToeliminate , stepsToeliminate ) ; s . add ( new Node ( i , stepsToeliminate ) ) ; } System . out . print ( ( maxStepsToeliminate < 0 ? 0 : maxStepsToeliminate ) + \" \\n \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 7 , 5 } ; int size = arr . length ; minSteps ( arr , size ) ; } }"], "python": ["def minSteps ( arr , N ) : NEW_LINE INDENT s = [ ] ; NEW_LINE s . append ( ( 0 , - 1 ) ) ; NEW_LINE maxStepsToeliminate = - 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT stepsToeliminate = 1 ; NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT if ( arr [ s [ - 1 ] [ 0 ] ] >= arr [ i ] ) : NEW_LINE INDENT stepsToeliminate = max ( stepsToeliminate , s [ - 1 ] [ 1 ] + 1 ) ; NEW_LINE s . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT stepsToeliminate = - 1 ; NEW_LINE DEDENT maxStepsToeliminate = max ( maxStepsToeliminate , stepsToeliminate ) ; NEW_LINE s . append ( ( i , stepsToeliminate ) ) ; NEW_LINE DEDENT print ( 0 if ( maxStepsToeliminate < 0 ) else maxStepsToeliminate ) ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 7 , 5 ] ; NEW_LINE size = len ( arr ) ; NEW_LINE minSteps ( arr , size ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_499_B", "java": ["import java . util . * ; public class B499 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; ArrayList < String > arr = new ArrayList < String > ( ) ; String [ ] [ ] w = new String [ m ] [ 2 ] ; String s = \" \" ; for ( int k = 0 ; k < m ; k ++ ) { for ( int y = 0 ; y < 2 ; y ++ ) { w [ k ] [ y ] = sc . next ( ) ; } } for ( int i = 0 ; i < n ; i ++ ) { arr . add ( i , sc . next ( ) ) ; } for ( int k = 0 ; k < n ; k ++ ) { for ( int x = 0 ; x < m ; x ++ ) { if ( arr . get ( k ) . equals ( w [ x ] [ 0 ] ) ) { if ( w [ x ] [ 0 ] . length ( ) <= w [ x ] [ 1 ] . length ( ) ) { s = w [ x ] [ 0 ] ; arr . set ( k , s ) ; } else { s = w [ x ] [ 1 ] ; arr . set ( k , s ) ; } break ; } } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr . get ( i ) + \" \u2581 \" ) ; } } }", "import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class lecture { public static void main ( String [ ] args ) { String original = null , second = null ; int numOfWords , numOfLine ; Scanner scan = new Scanner ( System . in ) ; numOfWords = scan . nextInt ( ) ; numOfLine = scan . nextInt ( ) ; Map < String , String > wordSets = new HashMap < > ( ) ; StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < numOfLine ; i ++ ) { original = scan . next ( ) ; second = scan . next ( ) ; wordSets . put ( original , ( original . length ( ) <= second . length ( ) ) ? original : second ) ; } for ( int k = 0 ; k < numOfWords ; k ++ ) { String temp ; temp = wordSets . get ( scan . next ( ) ) ; result . append ( temp + \" \u2581 \" ) ; } System . out . println ( result . toString ( ) . trim ( ) ) ; } }", "import java . util . HashMap ; import java . util . Scanner ; public class Lecture { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int profWords = scn . nextInt ( ) ; int dictWords = scn . nextInt ( ) ; HashMap < String , Integer > first = new HashMap < > ( ) ; HashMap < String , Integer > second = new HashMap < > ( ) ; HashMap < String , String > correlation1 = new HashMap < > ( ) ; HashMap < String , String > correlation2 = new HashMap < > ( ) ; for ( int i = 0 ; i < dictWords ; i ++ ) { String one = scn . next ( ) ; String two = scn . next ( ) ; first . put ( one , one . length ( ) ) ; second . put ( two , two . length ( ) ) ; correlation1 . put ( one , two ) ; correlation2 . put ( two , one ) ; } String [ ] input = new String [ profWords ] ; String [ ] output = new String [ profWords ] ; for ( int i = 0 ; i < profWords ; i ++ ) { input [ i ] = scn . next ( ) ; if ( first . containsKey ( input [ i ] ) ) { String correspondingSecondLang = correlation1 . get ( input [ i ] ) ; if ( first . get ( input [ i ] ) > second . get ( correspondingSecondLang ) ) { output [ i ] = correspondingSecondLang ; } else { output [ i ] = input [ i ] ; } } else { String correspondingFirstLang = correlation2 . get ( input [ i ] ) ; if ( first . get ( correspondingFirstLang ) <= second . get ( input [ i ] ) ) { output [ i ] = correspondingFirstLang ; } else { output [ i ] = input [ i ] ; } } } for ( int i = 0 ; i < profWords ; i ++ ) { System . out . print ( output [ i ] + \" \u2581 \" ) ; } } }", "import java . io . PrintWriter ; import java . util . Scanner ; import java . io . IOException ; import java . util . HashMap ; public class Answer { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; HashMap < String , String > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { hm . put ( sc . next ( ) , sc . next ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { String s = sc . next ( ) ; if ( s . length ( ) <= hm . get ( s ) . length ( ) ) pw . print ( s ) ; else pw . print ( hm . get ( s ) ) ; if ( i != n - 1 ) pw . print ( \" \u2581 \" ) ; } pw . flush ( ) ; sc . close ( ) ; } }", "import java . io . PrintWriter ; import java . util . HashMap ; import java . util . Scanner ; public class Dragons { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter p = new PrintWriter ( System . out ) ; HashMap < String , String > hm = new HashMap < > ( ) ; StringBuilder sb = new StringBuilder ( ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) { hm . put ( in . next ( ) , in . next ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { String s = in . next ( ) ; if ( s . length ( ) > hm . get ( s ) . length ( ) ) { sb . append ( hm . get ( s ) + \" \u2581 \" ) ; } else { sb . append ( s + \" \u2581 \" ) ; } } p . println ( sb ) ; p . flush ( ) ; } }"], "python": ["m = int ( input ( ) . split ( \" \u2581 \" ) [ 1 ] ) NEW_LINE lookup_table = { } NEW_LINE for _ in range ( m ) : NEW_LINE INDENT word_one , word_two = input ( ) . split ( \" \u2581 \" ) NEW_LINE min_word = min ( word_one , word_two , key = len ) NEW_LINE lookup_table [ word_one ] = min_word NEW_LINE lookup_table [ word_two ] = min_word NEW_LINE DEDENT final_sentence = input ( ) . split ( \" \u2581 \" ) NEW_LINE print ( \" \u2581 \" . join ( [ lookup_table [ word ] for word in final_sentence ] ) ) NEW_LINE", "inp1 = input ( ) NEW_LINE n , m = int ( inp1 . split ( ' \u2581 ' ) [ 0 ] ) , int ( inp1 . split ( ' \u2581 ' ) [ 1 ] ) NEW_LINE l = [ ] NEW_LINE d = { } NEW_LINE for i in range ( m ) : NEW_LINE INDENT inp2 = input ( ) NEW_LINE s1 , s2 = ( inp2 . split ( ' \u2581 ' ) [ 0 ] ) , ( inp2 . split ( ' \u2581 ' ) [ 1 ] ) NEW_LINE l1 , l2 = len ( inp2 . split ( ' \u2581 ' ) [ 0 ] ) , len ( inp2 . split ( ' \u2581 ' ) [ 1 ] ) NEW_LINE if l1 <= l2 : NEW_LINE INDENT d [ s2 ] = s1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ s1 ] = s2 NEW_LINE DEDENT DEDENT inp3 = input ( ) NEW_LINE lis1 = inp3 . split ( ' \u2581 ' ) NEW_LINE lis2 = [ ] NEW_LINE for i in lis1 : NEW_LINE INDENT if i in d . keys ( ) : NEW_LINE INDENT lis2 . append ( d [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT lis2 . append ( i ) NEW_LINE DEDENT DEDENT output = \" \" NEW_LINE for i in lis2 : NEW_LINE INDENT output = output + i + ' \u2581 ' NEW_LINE DEDENT print ( output ) NEW_LINE", "first_line = input ( ) . split ( ) NEW_LINE dic = { } NEW_LINE for i in range ( int ( first_line [ 1 ] ) ) : NEW_LINE INDENT second_line = input ( ) . split ( ) NEW_LINE dic [ second_line [ 0 ] ] = second_line [ 1 ] NEW_LINE DEDENT last_line = input ( ) . split ( ) NEW_LINE for i in last_line : NEW_LINE INDENT if len ( i ) == len ( dic [ i ] ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT elif len ( i ) < len ( dic [ i ] ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dic [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT", "n , l = tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = ' ' NEW_LINE wordlist = { } NEW_LINE for i in range ( l ) : NEW_LINE INDENT x , y = tuple ( input ( ) . split ( ) ) NEW_LINE wordlist [ x ] = y NEW_LINE DEDENT prof = input ( ) NEW_LINE for i in prof . split ( ) : NEW_LINE INDENT if len ( wordlist [ i ] ) < len ( i ) : NEW_LINE INDENT ans += wordlist [ i ] + \" \u2581 \" NEW_LINE DEDENT else : NEW_LINE INDENT ans += i + \" \u2581 \" NEW_LINE DEDENT DEDENT print ( ans [ : - 1 ] ) NEW_LINE", "p = dict ( ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = input ( ) . split ( ) NEW_LINE p [ a ] = [ a , b ] [ len ( b ) < len ( a ) ] NEW_LINE DEDENT print ( * ( p [ w ] for w in input ( ) . split ( ) ) ) NEW_LINE"]}
{"id": "geeksforgeeks_191_A", "java": ["class GFG { static boolean check ( int H , int S ) { return H * H >= 4 * S ; } static int findPairs ( int H [ ] , int n , int S [ ] , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( check ( H [ i ] , S [ j ] ) ) count ++ ; } } return count ; } public static void main ( String args [ ] ) { int H [ ] = { 1 , 6 , 4 } ; int n = H . length ; int S [ ] = { 23 , 3 , 42 , 14 } ; int m = S . length ; System . out . println ( findPairs ( H , n , S , m ) ) ; } }"], "python": ["def check ( H , S ) : NEW_LINE INDENT return H * H >= 4 * S NEW_LINE DEDENT def findPairs ( H , n , S , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if check ( H [ i ] , S [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT H = [ 1 , 6 , 4 ] NEW_LINE n = len ( H ) NEW_LINE S = [ 23 , 3 , 42 , 14 ] NEW_LINE m = len ( S ) NEW_LINE print ( findPairs ( H , n , S , m ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3774_A", "java": ["import java . util . * ; public class GFG { static void Print3Smallest ( int array [ ] , int n ) { int firstmin = Integer . MAX_VALUE ; int secmin = Integer . MAX_VALUE ; int thirdmin = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } System . out . println ( \" First \u2581 min \u2581 = \u2581 \" + firstmin ) ; System . out . println ( \" Second \u2581 min \u2581 = \u2581 \" + secmin ) ; System . out . println ( \" Third \u2581 min \u2581 = \u2581 \" + thirdmin ) ; } public static void main ( String [ ] args ) { int array [ ] = { 4 , 9 , 1 , 32 , 12 } ; int n = array . length ; Print3Smallest ( array , n ) ; } }"], "python": ["MAX = 100000 NEW_LINE def Print3Smallest ( arr , n ) : NEW_LINE INDENT firstmin = MAX NEW_LINE secmin = MAX NEW_LINE thirdmin = MAX NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < firstmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = firstmin NEW_LINE firstmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < secmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < thirdmin : NEW_LINE INDENT thirdmin = arr [ i ] NEW_LINE DEDENT DEDENT print ( \" First \u2581 min \u2581 = \u2581 \" , firstmin ) NEW_LINE print ( \" Second \u2581 min \u2581 = \u2581 \" , secmin ) NEW_LINE print ( \" Third \u2581 min \u2581 = \u2581 \" , thirdmin ) NEW_LINE DEDENT arr = [ 4 , 9 , 1 , 32 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE Print3Smallest ( arr , n ) NEW_LINE"]}
{"id": "codeforces_758_B", "java": ["import java . io . * ; import java . util . * ; import java . text . * ; import java . math . * ; import java . util . regex . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; char [ ] garlands = st . nextToken ( ) . toCharArray ( ) ; int [ ] counts = new int [ 4 ] ; char [ ] colors = new char [ 4 ] ; for ( int i = 0 ; i < garlands . length ; i ++ ) { char current = garlands [ i ] ; if ( current == ' ! ' ) { counts [ i % 4 ] ++ ; continue ; } colors [ i % 4 ] = current ; } for ( int i = 0 ; i < 4 ; i ++ ) { if ( ( int ) colors [ i ] != 0 ) continue ; colors [ i ] = ( char ) ( ( int ) colors [ 0 ] + ( int ) colors [ 1 ] + ( int ) colors [ 2 ] + ( int ) colors [ 3 ] ) ; break ; } char [ ] c = { ' R ' , ' B ' , ' Y ' , ' G ' } ; for ( int i = 0 ; i < 4 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( colors [ j ] == c [ i ] ) { System . out . print ( counts [ j ] + \" \u2581 \" ) ; break ; } } } } }", "import java . util . Scanner ; public class Blown758B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String s = in . next ( ) ; StringBuffer sb = new StringBuffer ( s ) ; int size = s . length ( ) ; int kr = 0 ; int kb = 0 ; int ky = 0 ; int kg = 0 ; if ( s . contains ( \" ! \" ) == false ) { System . out . println ( \"0 \u2581 0 \u2581 0 \u2581 0\" ) ; return ; } String s2 = s . substring ( 0 , 4 ) ; int index = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( s2 . charAt ( i ) == ' ! ' ) { for ( int j = i + 4 ; j < size ; j += 4 ) { if ( s . charAt ( j ) != ' ! ' ) index = j ; } s2 = s2 . substring ( 0 , i ) + s . charAt ( index ) + s2 . substring ( i + 1 ) ; } } for ( int i = 0 , j = 0 ; i < size ; i ++ , j ++ ) { if ( i % 4 == 0 ) j = 0 ; if ( s . charAt ( i ) == ' ! ' ) { if ( s2 . charAt ( j ) == ' R ' ) kr ++ ; else if ( s2 . charAt ( j ) == ' B ' ) kb ++ ; else if ( s2 . charAt ( j ) == ' Y ' ) ky ++ ; else kg ++ ; } } System . out . println ( kr + \" \u2581 \" + kb + \" \u2581 \" + ky + \" \u2581 \" + kg ) ; } }"], "python": ["s = input ( ) NEW_LINE s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE s3 = [ ] NEW_LINE s4 = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i % 4 == 0 : NEW_LINE INDENT s1 . append ( s [ i ] ) NEW_LINE DEDENT elif i % 4 == 1 : NEW_LINE INDENT s2 . append ( s [ i ] ) NEW_LINE DEDENT elif i % 4 == 2 : NEW_LINE INDENT s3 . append ( s [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT s4 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT if ' R ' in s1 : NEW_LINE INDENT ls_R = s1 NEW_LINE DEDENT elif ' R ' in s2 : NEW_LINE INDENT ls_R = s2 NEW_LINE DEDENT elif ' R ' in s3 : NEW_LINE INDENT ls_R = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_R = s4 NEW_LINE DEDENT if ' B ' in s1 : NEW_LINE INDENT ls_B = s1 NEW_LINE DEDENT elif ' B ' in s2 : NEW_LINE INDENT ls_B = s2 NEW_LINE DEDENT elif ' B ' in s3 : NEW_LINE INDENT ls_B = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_B = s4 NEW_LINE DEDENT if ' Y ' in s1 : NEW_LINE INDENT ls_Y = s1 NEW_LINE DEDENT elif ' Y ' in s2 : NEW_LINE INDENT ls_Y = s2 NEW_LINE DEDENT elif ' Y ' in s3 : NEW_LINE INDENT ls_Y = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_Y = s4 NEW_LINE DEDENT if ' G ' in s1 : NEW_LINE INDENT ls_G = s1 NEW_LINE DEDENT elif ' G ' in s2 : NEW_LINE INDENT ls_G = s2 NEW_LINE DEDENT elif ' G ' in s3 : NEW_LINE INDENT ls_G = s3 NEW_LINE DEDENT else : NEW_LINE INDENT ls_G = s4 NEW_LINE DEDENT print ( ls_R . count ( ' ! ' ) , ls_B . count ( ' ! ' ) , ls_Y . count ( ' ! ' ) , ls_G . count ( ' ! ' ) ) NEW_LINE", "from collections import defaultdict NEW_LINE s = ( input ( ) ) NEW_LINE d = defaultdict ( int ) NEW_LINE for i , el in enumerate ( s ) : NEW_LINE INDENT if s != \" ! \" : NEW_LINE INDENT d [ el ] = i % 4 NEW_LINE DEDENT DEDENT e = defaultdict ( int ) NEW_LINE for i , el in enumerate ( s ) : NEW_LINE INDENT if el == \" ! \" : NEW_LINE INDENT e [ i % 4 ] += 1 NEW_LINE DEDENT DEDENT print ( e [ d [ \" R \" ] ] , e [ d [ \" B \" ] ] , e [ d [ \" Y \" ] ] , e [ d [ \" G \" ] ] ) NEW_LINE", "import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE s = input ( ) NEW_LINE res = [ 0 ] * 4 NEW_LINE i = 0 NEW_LINE ss = ' ' NEW_LINE while i < len ( s ) and len ( ss ) < 4 : NEW_LINE INDENT if s [ i ] != ' ! ' : ss += s [ i ] NEW_LINE else : NEW_LINE INDENT j = i + 4 NEW_LINE while j < len ( s ) and s [ j ] == ' ! ' : j += 4 NEW_LINE ss += s [ j ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ! ' : NEW_LINE INDENT k = ss [ i % 4 ] NEW_LINE if k == ' R ' : res [ 0 ] += 1 NEW_LINE if k == ' B ' : res [ 1 ] += 1 NEW_LINE if k == ' Y ' : res [ 2 ] += 1 NEW_LINE if k == ' G ' : res [ 3 ] += 1 NEW_LINE DEDENT DEDENT print ( * res ) NEW_LINE", "s = input ( ) NEW_LINE countR = 0 NEW_LINE countB = 0 NEW_LINE countY = 0 NEW_LINE countG = 0 NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT j = i NEW_LINE count = 0 NEW_LINE letter = None NEW_LINE while j < len ( s ) : NEW_LINE INDENT if s [ j ] == ' ! ' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT letter = s [ j ] NEW_LINE DEDENT j += 4 NEW_LINE DEDENT if letter == ' R ' : NEW_LINE INDENT countR += count NEW_LINE DEDENT elif letter == ' B ' : NEW_LINE INDENT countB += count NEW_LINE DEDENT elif letter == ' Y ' : NEW_LINE INDENT countY += count NEW_LINE DEDENT elif letter == ' G ' : NEW_LINE INDENT countG += count NEW_LINE DEDENT DEDENT print ( countR , countB , countY , countG ) NEW_LINE"]}
{"id": "geeksforgeeks_1754_A", "java": ["class GFG { static int dayofweek ( int d , int m , int y ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; y -= ( m < 3 ) ? 1 : 0 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; } public static void main ( String arg [ ] ) { int day = dayofweek ( 30 , 8 , 2010 ) ; System . out . print ( day ) ; } }"], "python": ["def dayofweek ( d , m , y ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE y -= m < 3 NEW_LINE return ( ( y + int ( y / 4 ) - int ( y / 100 ) + int ( y / 400 ) + t [ m - 1 ] + d ) % 7 ) NEW_LINE DEDENT day = dayofweek ( 30 , 8 , 2010 ) NEW_LINE print ( day ) NEW_LINE"]}
{"id": "geeksforgeeks_261_A", "java": ["import java . io . * ; import java . util . * ; public class GFG { static int powerNumbers ( int n ) { HashSet < Integer > v = new HashSet < Integer > ( ) ; v . add ( 1 ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i * i ; v . add ( j ) ; while ( j * i <= n ) { v . add ( j * i ) ; j = j * i ; } } return v . size ( ) ; } public static void main ( String args [ ] ) { System . out . print ( powerNumbers ( 50 ) ) ; } }"], "python": ["def powerNumbers ( n ) : NEW_LINE INDENT v = set ( ) ; NEW_LINE v . add ( 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i * i <= n ) : NEW_LINE INDENT j = i * i ; NEW_LINE v . add ( j ) ; NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT v . add ( j * i ) ; NEW_LINE j = j * i ; NEW_LINE DEDENT DEDENT DEDENT return len ( v ) ; NEW_LINE DEDENT print ( powerNumbers ( 50 ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_2231_A", "java": ["class GFG { static boolean productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) { product *= n % 10 ; } n = n / 10 ; position ++ ; } if ( product % k == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n / 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1818_A", "java": ["import java . io . * ; class GFG { static boolean isDivisibleBy10 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } static boolean isDivisibleBy20 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } public static void main ( String args [ ] ) { char bin [ ] = \"101000\" . toCharArray ( ) ; int n = bin . length ; if ( isDivisibleBy20 ( bin , n - 1 ) ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } }"], "python": ["def isDivisibleBy10 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( bin [ i ] == '1' ) : NEW_LINE INDENT posFromRight = n - i - 1 NEW_LINE if ( posFromRight % 4 == 1 ) : NEW_LINE INDENT sum = sum + 2 NEW_LINE DEDENT elif ( posFromRight % 4 == 2 ) : NEW_LINE INDENT sum = sum + 4 NEW_LINE DEDENT elif ( posFromRight % 4 == 3 ) : NEW_LINE INDENT sum = sum + 8 NEW_LINE DEDENT elif ( posFromRight % 4 == 0 ) : NEW_LINE INDENT sum = sum + 6 NEW_LINE DEDENT DEDENT DEDENT if ( sum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isDivisibleBy20 ( bin , n ) : NEW_LINE INDENT if ( bin [ n - 1 ] == '1' ) : NEW_LINE INDENT return false NEW_LINE DEDENT return isDivisibleBy10 ( bin , n - 1 ) NEW_LINE DEDENT bin = [ '1' , '0' , '1' , '0' , '0' , '0' ] NEW_LINE n = len ( bin ) NEW_LINE if ( isDivisibleBy20 ( bin , n - 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3603_A", "java": ["import java . io . * ; class GFG { static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x || half == x - 1 ) && ( half == y || half == y - 1 ) ) System . out . println ( \" NO \" ) ; else System . out . println ( \" YES \" ) ; } public static void main ( String [ ] args ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; } }"], "python": ["def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 100 NEW_LINE x , y = 51 , 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC141_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s1 = \" Sunny \" ; String s2 = \" Cloudy \" ; String s3 = \" Rainy \" ; String s = sc . next ( ) ; String ans = \" \" ; if ( s . equals ( s1 ) ) ans = s2 ; else if ( s . equals ( s2 ) ) ans = s3 ; else if ( s . equals ( s3 ) ) ans = s1 ; sc . close ( ) ; System . out . println ( ans ) ; } }", "import java . util . Scanner ; public class Main { public static final String SUUNY = \" Sunny \" ; public static final String CLOUDY = \" Cloudy \" ; public static final String RAINY = \" Rainy \" ; static Main instance = new Main ( ) ; public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String str = scan . next ( ) ; String result = null ; if ( str . equals ( SUUNY ) ) { result = CLOUDY ; } else if ( str . equals ( CLOUDY ) ) { result = RAINY ; } else if ( str . equals ( RAINY ) ) { result = SUUNY ; } System . out . println ( result ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { String [ ] weather = { \" Sunny \" , \" Cloudy \" , \" Rainy \" } ; Scanner sc = new Scanner ( System . in ) ; String S = sc . next ( ) ; sc . close ( ) ; TommorowWeather ( 0 , weather , S ) ; } public static void TommorowWeather ( int index , String [ ] weather , String S ) { if ( index >= 3 ) { return ; } if ( S . equals ( weather [ index ] ) ) { int ans = index + 1 ; if ( ans >= 3 ) { ans = 0 ; } System . out . println ( weather [ ans ] ) ; return ; } TommorowWeather ( index + 1 , weather , S ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; String S = scan . next ( ) ; String [ ] tenki = { \" Sunny \" , \" Cloudy \" , \" Rainy \" } ; String rlt = \" \" ; if ( S . equals ( tenki [ 0 ] ) ) { rlt = tenki [ 1 ] ; } if ( S . equals ( tenki [ 1 ] ) ) { rlt = tenki [ 2 ] ; } if ( S . equals ( tenki [ 2 ] ) ) { rlt = tenki [ 0 ] ; } System . out . println ( rlt ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; System . out . println ( new Main ( ) . weather_prediction ( scanner . nextLine ( ) ) ) ; scanner . close ( ) ; } public String weather_prediction ( String weather ) { String [ ] predictions = { \" Sunny \" , \" Cloudy \" , \" Rainy \" } ; int i ; for ( i = 0 ; i < 3 ; i ++ ) { if ( weather . equals ( predictions [ i ] ) ) { break ; } } return predictions [ ( i + 1 ) % 3 ] ; } }"], "python": ["s = str ( input ( ) ) NEW_LINE if s == ' Sunny ' : NEW_LINE INDENT print ( ' Cloudy ' ) NEW_LINE DEDENT elif s == ' Cloudy ' : NEW_LINE INDENT print ( ' Rainy ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Sunny ' ) NEW_LINE DEDENT", "S = input ( ) NEW_LINE sun = \" Sunny \" NEW_LINE cloud = \" Cloudy \" NEW_LINE rain = \" Rainy \" NEW_LINE if S == sun : NEW_LINE INDENT print ( cloud ) NEW_LINE DEDENT elif S == cloud : NEW_LINE INDENT print ( rain ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sun ) NEW_LINE DEDENT", "l = [ \" Sunny \" , \" Cloudy \" , \" Rainy \" ] NEW_LINE s = input ( ) NEW_LINE print ( l [ ( l . index ( s ) + 1 ) % 3 ] ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def main ( ) : NEW_LINE INDENT S = input ( ) . strip ( ) NEW_LINE if S == \" Sunny \" : NEW_LINE INDENT print ( \" Cloudy \" ) NEW_LINE DEDENT elif S == \" Cloudy \" : NEW_LINE INDENT print ( \" Rainy \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Sunny \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE tenki = [ ' Sunny ' , ' Cloudy ' , ' Rainy ' ] NEW_LINE index = tenki . index ( s ) NEW_LINE print ( tenki [ ( index + 1 ) % 3 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_575_A", "java": ["import java . io . * ; class GFG { static int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; } static void forbenius ( int X , int Y ) { if ( gcd ( X , Y ) != 1 ) { System . out . println ( \" NA \" ) ; return ; } int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; System . out . println ( \" Largest \u2581 Amount \u2581 = \u2581 \" + A ) ; System . out . println ( \" Total \u2581 Count \u2581 = \u2581 \" + N ) ; } public static void main ( String [ ] args ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 ; Y = 10 ; System . out . println ( ) ; forbenius ( X , Y ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a ; NEW_LINE a = b % a ; NEW_LINE b = c ; NEW_LINE DEDENT return b ; NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( \" NA \" ) ; NEW_LINE return ; NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) ; NEW_LINE N = ( X - 1 ) * ( Y - 1 ) // 2 ; NEW_LINE print ( \" Largest \u2581 Amount \u2581 = \" , A ) ; NEW_LINE print ( \" Total \u2581 Count \u2581 = \" , N ) ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 5 ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE X = 5 ; NEW_LINE Y = 10 ; NEW_LINE print ( \" \" ) ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE"]}
{"id": "geeksforgeeks_1634_A", "java": ["import java . util . * ; class GFG { static void reverse ( int a [ ] ) { int i , k , n = a . length ; int t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; Arrays . sort ( arr ) ; reverse ( arr ) ; System . out . println ( \" Array \u2581 after \u2581 sorting \u2581 : \u2581 \\n \" ) ; for ( int i = 0 ; i < n ; ++ i ) { System . out . print ( arr [ i ] + \" \u2581 \" ) ; } } }"], "python": ["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( reverse = True ) NEW_LINE print ( \" Array \u2581 after \u2581 sorting \u2581 : \u2581 \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1297_A", "java": ["import java . io . * ; import static java . lang . Math . pow ; public class A { static void bestApproximate ( int x [ ] , int y [ ] ) { int n = x . length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; System . out . println ( \" m \u2581 = \u2581 \" + m ) ; System . out . println ( \" c \u2581 = \u2581 \" + c ) ; } public static void main ( String args [ ] ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; bestApproximate ( x , y ) ; } }"], "python": ["def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( \" m \u2581 = \u2581 \" , m ) ; NEW_LINE print ( \" c \u2581 = \u2581 \" , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE"]}
{"id": "geeksforgeeks_2479_A", "java": ["import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node head ; static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; head = head_ref ; } static int productOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; int prod = 1 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { prod *= st . peek ( ) ; st . pop ( ) ; } return prod ; } public static void main ( String [ ] args ) { head = null ; push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; int n = 2 ; System . out . println ( productOfLastN_NodesUtil ( head , n ) ) ; } }"], "python": ["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT head = None NEW_LINE def push ( head_ref , new_data ) : NEW_LINE INDENT global head NEW_LINE new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = ( head_ref ) NEW_LINE ( head_ref ) = new_node NEW_LINE head = head_ref NEW_LINE DEDENT def productOfLastN_NodesUtil ( head , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT st = [ ] NEW_LINE prod = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT st . append ( head . data ) NEW_LINE head = head . next NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 1 NEW_LINE prod *= st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT return prod NEW_LINE DEDENT head = None NEW_LINE push ( head , 12 ) NEW_LINE push ( head , 4 ) NEW_LINE push ( head , 8 ) NEW_LINE push ( head , 6 ) NEW_LINE push ( head , 10 ) NEW_LINE n = 2 NEW_LINE print ( productOfLastN_NodesUtil ( head , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_760_A", "java": ["import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 || num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } public static void main ( String [ ] args ) { int num = 10 ; System . out . print ( check ( num ) ) ; } }"], "python": ["def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( int ( b ) & 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b /= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num & 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num / 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 10 NEW_LINE print ( int ( check ( num ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3892_A", "java": ["public class DLL { Node head ; class Node { int data ; Node prev ; Node next ; Node ( int d ) { data = d ; } } }"], "python": ["class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1510_A", "java": ["import java . util . * ; class GFG { static int findMaxDiff ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( \" Invalid \u2581 \" ) ; return 0 ; } int res = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) res = ( arr [ i ] - arr [ j ] - i + j ) ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 9 , 15 , 4 , 12 , 13 } ; int n = arr . length ; System . out . print ( findMaxDiff ( arr , n ) ) ; } }"], "python": ["def findMaxDiff ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT print ( \" Invalid \u2581 \" ) NEW_LINE return 0 NEW_LINE DEDENT res = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( res < ( arr [ i ] - arr [ j ] - i + j ) ) : NEW_LINE INDENT res = ( arr [ i ] - arr [ j ] - i + j ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 9 , 15 , 4 , 12 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxDiff ( arr , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5145_A", "java": ["import java . util . Scanner ; class GFG { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a , b , i , j , flag ; System . out . printf ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \u2581 \" ) ; a = sc . nextInt ( ) ; System . out . printf ( \" \\n Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \u2581 \" ) ; b = sc . nextInt ( ) ; System . out . printf ( \" \\n Prime \u2581 numbers \u2581 between \u2581 % d \u2581 and \u2581 % d \u2581 are : \u2581 \" , a , b ) ; if ( a == 1 ) { System . out . println ( a ) ; a ++ ; if ( b >= 2 ) { System . out . println ( a ) ; a ++ ; } } if ( a == 2 ) System . out . println ( a ) ; if ( a % 2 == 0 ) a ++ ; for ( i = a ; i <= b ; i = i + 2 ) { flag = 1 ; for ( j = 2 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . println ( i ) ; } } }"], "python": ["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j = 0 , 0 , 0 , 0 NEW_LINE print ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( a ) NEW_LINE print ( \" Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b ) NEW_LINE print ( \" Prime \u2581 numbers \u2581 between \" , a , \" and \" , b , \" are : \" , end = \" \" ) NEW_LINE if ( a == 1 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE a += 1 NEW_LINE if ( b >= 2 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE a += 1 NEW_LINE DEDENT DEDENT if ( a == 2 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE DEDENT if ( a % 2 == 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT for i in range ( a , b + 1 , 2 ) : NEW_LINE INDENT flag = 1 NEW_LINE j = 2 NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "geeksforgeeks_5144_A", "java": ["import java . util . Scanner ; public class GFG { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a , b , i , j , flag ; System . out . printf ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \u2581 \" ) ; a = sc . nextInt ( ) ; System . out . printf ( \" \\n Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \u2581 \" ) ; b = sc . nextInt ( ) ; System . out . printf ( \" \\n Prime \u2581 numbers \u2581 between \u2581 % d \u2581 and \u2581 % d \u2581 are : \u2581 \" , a , b ) ; for ( i = a ; i <= b ; i ++ ) { if ( i == 1 || i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) System . out . println ( i ) ; } } }"], "python": ["if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , i , j , flag = 0 , 0 , 0 , 0 , 0 NEW_LINE print ( \" Enter \u2581 lower \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE a = int ( input ( ) ) NEW_LINE print ( a ) NEW_LINE print ( \" Enter \u2581 upper \u2581 bound \u2581 of \u2581 the \u2581 interval : \" , end = \" \" ) NEW_LINE b = int ( input ( ) ) NEW_LINE print ( b ) NEW_LINE print ( \" Prime \u2581 numbers \u2581 between \" , a , \" and \" , b , \" are : \" , end = \" \" ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT flag = 1 NEW_LINE for j in range ( 2 , i // 2 + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT"]}
{"id": "geeksforgeeks_1606_A", "java": ["public class GFG { final static int MAX = 100 ; static void smallestInRow ( int mat [ ] [ ] , int n , int m ) { System . out . print ( \" \u2581 { \u2581 \" ) ; for ( int i = 0 ; i < n ; i ++ ) { int minm = mat [ i ] [ 0 ] ; for ( int j = 1 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] < minm ) { minm = mat [ i ] [ j ] ; } } System . out . print ( minm + \" , \u2581 \" ) ; } System . out . println ( \" } \" ) ; } static void smallestInCol ( int mat [ ] [ ] , int n , int m ) { System . out . print ( \" \u2581 { \u2581 \" ) ; for ( int i = 0 ; i < m ; i ++ ) { int minm = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ j ] [ i ] < minm ) { minm = mat [ j ] [ i ] ; } } System . out . print ( minm + \" , \u2581 \" ) ; } System . out . print ( \" } \" ) ; } public static void main ( String args [ ] ) { int n = 3 , m = 3 ; int mat [ ] [ ] = { { 2 , 1 , 7 } , { 3 , 7 , 2 } , { 5 , 4 , 9 } } ; System . out . print ( \" Minimum \u2581 element \u2581 of \u2581 each \u2581 row \u2581 is \u2581 \" ) ; smallestInRow ( mat , n , m ) ; System . out . print ( \" \\n Minimum \u2581 element \u2581 of \u2581 each \u2581 column \u2581 is \u2581 \" ) ; smallestInCol ( mat , n , m ) ; } }"], "python": ["MAX = 100 NEW_LINE def smallestInRow ( mat , n , m ) : NEW_LINE INDENT print ( \" { \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT minm = mat [ i ] [ 0 ] NEW_LINE for j in range ( 1 , m , 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < minm ) : NEW_LINE INDENT minm = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT print ( minm , end = \" , \" ) NEW_LINE DEDENT print ( \" } \" ) NEW_LINE DEDENT def smallestInCol ( mat , n , m ) : NEW_LINE INDENT print ( \" { \" , end = \" \" ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT minm = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( mat [ j ] [ i ] < minm ) : NEW_LINE INDENT minm = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT print ( minm , end = \" , \" ) NEW_LINE DEDENT print ( \" } \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE mat = [ [ 2 , 1 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 4 , 9 ] ] ; NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 each \u2581 row \u2581 is \" , end = \" \u2581 \" ) NEW_LINE smallestInRow ( mat , n , m ) NEW_LINE print ( \" Minimum \u2581 element \u2581 of \u2581 each \u2581 column \u2581 is \" , end = \" \u2581 \" ) NEW_LINE smallestInCol ( mat , n , m ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4570_A", "java": ["class GFG { static int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 || mod == 3 ) { return 0 ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( minAbsDiff ( n ) ) ; } }"], "python": ["def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT"]}
{"id": "aizu_p00914_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; while ( true ) { int n = stdIn . nextInt ( ) ; int k = stdIn . nextInt ( ) ; int s = stdIn . nextInt ( ) ; if ( n == 0 && k == 0 && s == 0 ) break ; int ans = solve ( n , k , s ) ; System . out . println ( ans ) ; } } public static int solve ( int n , int k , int s ) { int ret = 0 ; for ( int i = n ; i > 0 ; i -- ) { ret += solv ( n , k - 1 , s - i , i ) ; } return ret ; } public static int solv ( int n , int k , int s , int l ) { if ( s < 0 ) return 0 ; if ( s == 0 && k == 0 ) return 1 ; if ( s == 0 && k > 0 ) return 0 ; if ( s != 0 && k < 0 ) return 0 ; int ret = 0 ; for ( int i = l - 1 ; i > 0 ; i -- ) { ret += solv ( n , k - 1 , s - i , i ) ; } return ret ; } }", "import java . awt . Point ; import java . io . FileInputStream ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . Scanner ; public class Main { static int n , k , s ; static int count ; static int [ ] shugo ; static void dfs ( int index ) { if ( index == k ) { int sum = 0 ; for ( int i = 0 ; i < shugo . length ; i ++ ) sum += shugo [ i ] ; if ( sum == s ) count ++ ; return ; } int prenum = 0 ; if ( index != 0 ) prenum = shugo [ index - 1 ] ; for ( int i = prenum + 1 ; i <= n ; i ++ ) { shugo [ index ] = i ; dfs ( index + 1 ) ; } } static void start ( ) { count = 0 ; shugo = new int [ k ] ; dfs ( 0 ) ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { Scanner sca = new Scanner ( System . in ) ; while ( true ) { n = sca . nextInt ( ) ; k = sca . nextInt ( ) ; s = sca . nextInt ( ) ; if ( n == 0 ) break ; start ( ) ; } } }", "import java . util . * ; import java . io . * ; import java . awt . geom . * ; import java . math . * ; public class Main { static final Scanner in = new Scanner ( System . in ) ; static final PrintWriter out = new PrintWriter ( System . out , false ) ; static boolean debug = false ; static int [ ] [ ] [ ] dp ; static boolean solve ( ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int S = in . nextInt ( ) ; if ( N + K + S == 0 ) return false ; dp = new int [ 11 ] [ 30 ] [ 200 ] ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 30 ; j ++ ) { for ( int k = 0 ; k < 200 ; k ++ ) { for ( int l = j + 1 ; l <= N ; l ++ ) { if ( k + l < 200 ) dp [ i + 1 ] [ l ] [ k + l ] += dp [ i ] [ j ] [ k ] ; } } } } int ans = 0 ; for ( int j = 1 ; j <= N ; j ++ ) { ans += dp [ K ] [ j ] [ S ] ; } out . println ( ans ) ; return true ; } public static void main ( String [ ] args ) { debug = args . length > 0 ; long start = System . nanoTime ( ) ; while ( solve ( ) ) ; out . flush ( ) ; long end = System . nanoTime ( ) ; dump ( ( end - start ) / 1000000 + \" \u2581 ms \" ) ; in . close ( ) ; out . close ( ) ; } static void dump ( Object ... o ) { if ( debug ) System . err . println ( Arrays . deepToString ( o ) ) ; } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int n , k , s , i , j ; for ( ; ; ) { n = sc . nextInt ( ) ; k = sc . nextInt ( ) ; s = sc . nextInt ( ) ; if ( n == 0 && k == 0 && s == 0 ) break ; out . println ( solve ( n , k , s ) ) ; } sc . close ( ) ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } private static int solve ( int n , int k , int s ) { if ( k == 0 && s == 0 ) return 1 ; if ( n == 0 ) return 0 ; return solve ( n - 1 , k - 1 , s - n ) + solve ( n - 1 , k , s ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . LinkedList ; import java . util . Scanner ; import java . util . StringTokenizer ; public class Main { public static final int N_MAX = 20 + 1 ; public static final int K_MAX = 10 + 1 ; public static final int S_MAX = 155 + 1 ; public static int memo ( final int n , final int k , final int s , int [ ] [ ] [ ] memo ) { if ( memo [ n ] [ k ] [ s ] >= 0 ) { return memo [ n ] [ k ] [ s ] ; } else if ( k == 0 && s == 0 ) { return memo [ n ] [ k ] [ s ] = 1 ; } else if ( k == 0 ) { return memo [ n ] [ k ] [ s ] = 0 ; } int ret = 0 ; for ( int next_use_value = 1 ; next_use_value <= n ; next_use_value ++ ) { if ( s < next_use_value ) { break ; } ret += memo ( next_use_value - 1 , k - 1 , s - next_use_value , memo ) ; } return memo [ n ] [ k ] [ s ] = ret ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] [ ] memo = new int [ N_MAX ] [ K_MAX ] [ S_MAX ] ; for ( int n = 0 ; n < N_MAX ; n ++ ) { for ( int k = 0 ; k < K_MAX ; k ++ ) { for ( int s = 0 ; s < S_MAX ; s ++ ) { memo [ n ] [ k ] [ s ] = - 1 ; } } } while ( true ) { final int n = sc . nextInt ( ) ; final int k = sc . nextInt ( ) ; final int s = sc . nextInt ( ) ; if ( n == 0 && k == 0 && s == 0 ) { break ; } System . out . println ( memo ( n , k , s , memo ) ) ; } } }"], "python": ["def dfs ( v , k , s ) : NEW_LINE INDENT if k == K : NEW_LINE INDENT return 1 if s == S else 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( v + 1 , N + 1 ) : NEW_LINE INDENT res += dfs ( i , k + 1 , s + i ) NEW_LINE DEDENT return res NEW_LINE DEDENT while True : NEW_LINE INDENT N , K , S = map ( int , input ( ) . split ( ) ) NEW_LINE if not N : NEW_LINE INDENT break NEW_LINE DEDENT print ( dfs ( 0 , 0 , 0 ) ) NEW_LINE DEDENT", "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n , k , s = LI ( ) NEW_LINE if n == 0 and k == 0 and s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT d = collections . defaultdict ( int ) NEW_LINE d [ ( 0 , 0 ) ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for kk , vv in list ( d . items ( ) ) : NEW_LINE INDENT if kk [ 0 ] == k or kk [ 1 ] + i > s : NEW_LINE INDENT continue NEW_LINE DEDENT d [ ( kk [ 0 ] + 1 , kk [ 1 ] + i ) ] += vv NEW_LINE DEDENT DEDENT rr . append ( d [ ( k , s ) ] ) NEW_LINE DEDENT return ' \\n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE", "from itertools import combinations NEW_LINE while 1 : NEW_LINE INDENT n , k , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == k == s == 0 : break NEW_LINE a = 0 NEW_LINE for i in combinations ( range ( 1 , n + 1 ) , k ) : NEW_LINE INDENT if len ( set ( i ) ) < k : continue NEW_LINE a += sum ( i ) == s NEW_LINE DEDENT print ( a ) NEW_LINE DEDENT", "import itertools NEW_LINE while True : NEW_LINE INDENT N , K , S = map ( int , input ( ) . split ( ) ) NEW_LINE if N == 0 : break NEW_LINE cnt = 0 NEW_LINE for comb in itertools . combinations ( range ( 1 , N + 1 ) , K ) : NEW_LINE INDENT if sum ( comb ) == S : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT", "def rec ( n , u , k , s ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT if u < s <= n : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ret = 0 NEW_LINE for i in range ( u + 1 , n - k + 2 ) : NEW_LINE INDENT ret += rec ( n , i , k - 1 , s - i ) NEW_LINE DEDENT return ret NEW_LINE DEDENT while True : NEW_LINE INDENT n , k , s = map ( int , input ( ) . split ( ) ) NEW_LINE if n == k == s == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( rec ( n , 0 , k , s ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_332_A", "java": ["import java . io . * ; class GFG { public static int countP ( int n , int k ) { if ( n == 0 || k == 0 || k > n ) return 0 ; if ( k == 1 || k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; } public static void main ( String args [ ] ) { System . out . println ( countP ( 3 , 2 ) ) ; } }"], "python": ["def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( countP ( 3 , 2 ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_12_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char arr [ ] [ ] = new char [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { String str = sc . nextLine ( ) ; arr [ i ] [ 0 ] = str . charAt ( 0 ) ; arr [ i ] [ 1 ] = str . charAt ( 1 ) ; arr [ i ] [ 2 ] = str . charAt ( 2 ) ; } int flag = 0 ; if ( arr [ 0 ] [ 0 ] == arr [ 2 ] [ 2 ] && arr [ 0 ] [ 2 ] == arr [ 2 ] [ 0 ] && arr [ 1 ] [ 0 ] == arr [ 1 ] [ 2 ] && arr [ 0 ] [ 1 ] == arr [ 2 ] [ 1 ] ) { flag = 1 ; } if ( flag == 1 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } sc . close ( ) ; } }", "import java . util . * ; public class SuperAgent { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; char [ ] [ ] A = new char [ 3 ] [ 3 ] ; for ( int x = 0 ; x < 3 ; x ++ ) { String s = scan . nextLine ( ) ; for ( int y = 0 ; y < 3 ; y ++ ) { A [ x ] [ y ] = s . charAt ( y ) ; } } String res = \" YES \" ; if ( A [ 0 ] [ 0 ] != A [ 2 ] [ 2 ] ) { res = \" NO \" ; } if ( A [ 2 ] [ 0 ] != A [ 0 ] [ 2 ] ) { res = \" NO \" ; } if ( A [ 0 ] [ 1 ] != A [ 2 ] [ 1 ] ) { res = \" NO \" ; } if ( A [ 1 ] [ 0 ] != A [ 1 ] [ 2 ] ) { res = \" NO \" ; } System . out . println ( res ) ; } }", "import java . util . Scanner ; public class No2_9_17 { public static void main ( String [ ] args ) { char [ ] [ ] a = new char [ 3 ] [ 3 ] ; Scanner c = new Scanner ( System . in ) ; for ( int i = 0 ; i < 3 ; i ++ ) { String str = c . next ( ) ; a [ i ] = str . toCharArray ( ) ; } if ( a [ 0 ] [ 0 ] == a [ 2 ] [ 2 ] && a [ 0 ] [ 1 ] == a [ 2 ] [ 1 ] && a [ 0 ] [ 2 ] == a [ 2 ] [ 0 ] && a [ 1 ] [ 0 ] == a [ 1 ] [ 2 ] ) { System . out . println ( \" YES \" ) ; } else System . out . println ( \" NO \" ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; Character [ ] pressed = new Character [ 9 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { String line = in . nextLine ( ) . trim ( ) ; pressed [ i * 3 ] = line . charAt ( 0 ) ; pressed [ i * 3 + 1 ] = line . charAt ( 1 ) ; pressed [ i * 3 + 2 ] = line . charAt ( 2 ) ; } boolean result = true ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( pressed [ i ] != pressed [ 8 - i ] ) { result = false ; } } System . out . println ( result ? \" YES \" : \" NO \" ) ; in . close ( ) ; } }", "import java . util . Scanner ; public class SuperAgent { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String one = in . nextLine ( ) ; String two = in . nextLine ( ) ; String three = in . nextLine ( ) ; String all = one + two + three ; int n = all . length ( ) ; char [ ] reverse = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { reverse [ n - i - 1 ] = all . charAt ( i ) ; } String res = String . copyValueOf ( reverse ) ; if ( all . equals ( res ) ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } }"], "python": ["def check ( ) : NEW_LINE INDENT mat = [ ] NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT mat . append ( list ( input ( ) ) ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < len ( mat ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ( mat [ 2 - i ] [ 2 - j ] ) ) : NEW_LINE INDENT j += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" YES \" ) NEW_LINE DEDENT check ( ) NEW_LINE", "matrix = [ ] NEW_LINE for x in range ( 3 ) : NEW_LINE INDENT a = input ( ) NEW_LINE matrix . append ( a ) NEW_LINE DEDENT result = 0 NEW_LINE for x in range ( 3 ) : NEW_LINE INDENT for y in range ( 3 ) : NEW_LINE INDENT if matrix [ x ] [ y ] == matrix [ 2 - x ] [ 2 - y ] : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT if result == 9 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "kl = \" \" ; NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT kl += input ( ) ; NEW_LINE DEDENT print ( [ ' NO ' , ' YES ' ] [ kl == kl [ : : - 1 ] ] ) ; NEW_LINE", "s = input ( ) NEW_LINE s1 = input ( ) NEW_LINE s2 = input ( ) NEW_LINE if s [ 0 ] == s2 [ 2 ] and s [ 1 ] == s2 [ 1 ] and s [ 2 ] == s2 [ 0 ] and s1 [ 0 ] == s1 [ 2 ] : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT", "l = \" \" ; NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT l += input ( ) ; NEW_LINE DEDENT print ( [ ' NO ' , ' YES ' ] [ l == l [ : : - 1 ] ] ) ; NEW_LINE"]}
{"id": "geeksforgeeks_2962_A", "java": ["import java . util . * ; class GFG { static int calculate ( String N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { String s = N . substring ( 0 , i ) ; int l1 = s . length ( ) ; String t = N . substring ( i , l1 + i ) ; if ( s . charAt ( 0 ) == '0' || t . charAt ( 0 ) == '0' ) continue ; if ( s . compareTo ( t ) == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { String N = \"2202200\" ; System . out . print ( calculate ( N ) ) ; } }"], "python": ["def calculate ( N ) : NEW_LINE INDENT length = len ( N ) NEW_LINE l = int ( ( length ) / 2 ) NEW_LINE count = 0 NEW_LINE for i in range ( l + 1 ) : NEW_LINE INDENT s = N [ 0 : 0 + i ] NEW_LINE l1 = len ( s ) NEW_LINE t = N [ i : l1 + i ] NEW_LINE try : NEW_LINE INDENT if s [ 0 ] == '0' or t [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT except : NEW_LINE INDENT continue NEW_LINE DEDENT if s == t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = str ( \"2202200\" ) NEW_LINE print ( calculate ( N ) ) NEW_LINE"]}
{"id": "aizu_p00265_A", "java": ["import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int N = Integer . parseInt ( s . next ( ) ) ; int Q = Integer . parseInt ( s . next ( ) ) ; int [ ] ar = new int [ N ] ; TreeSet < Integer > set = new TreeSet < Integer > ( ) ; int max_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int c = Integer . parseInt ( s . next ( ) ) ; ar [ i ] = c ; set . add ( c ) ; max_val = Math . max ( max_val , c ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int q = Integer . parseInt ( s . next ( ) ) ; int ans = 0 ; if ( q < 100 ) { for ( int j = 0 ; j < N ; j ++ ) { ans = Math . max ( ans , ar [ j ] % q ) ; } } else { for ( int j = q ; j <= max_val ; j += q ) { Integer v = set . lower ( j ) ; if ( v == null ) continue ; ans = Math . max ( ans , ( int ) ( v ) % q ) ; } } System . out . println ( ans ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int N = parseInt ( line . substring ( 0 , line . indexOf ( ' \u2581 ' ) ) ) ; int Q = parseInt ( line . substring ( line . indexOf ( ' \u2581 ' ) + 1 ) ) ; boolean [ ] cs = new boolean [ 300001 ] ; int max = 0 ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; while ( st . hasMoreTokens ( ) ) { int c = parseInt ( st . nextToken ( ) ) ; cs [ c ] = true ; max = Math . max ( max , c ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int q = parseInt ( br . readLine ( ) ) ; int j = q - 1 ; found : for ( ; j >= 1 ; j -- ) { for ( int k = j ; k <= max ; k += q ) { if ( cs [ k ] ) break found ; } } System . out . println ( j ) ; } } } }", "import java . util . * ; class Main { static final int MAX = 300000 ; boolean [ ] T ; int [ ] L ; void solve ( ) { int N , Q , q , x ; T = new boolean [ MAX + 1 ] ; L = new int [ MAX + 1 ] ; Scanner sc = new Scanner ( System . in ) ; N = sc . nextInt ( ) ; Q = sc . nextInt ( ) ; for ( int i = 0 ; i < N ; i ++ ) { x = sc . nextInt ( ) ; T [ x ] = true ; } int m = 0 ; for ( int i = 1 ; i <= MAX ; i ++ ) { L [ i ] = m ; if ( T [ i ] ) m = i ; } for ( int i = 0 ; i < Q ; i ++ ) { q = sc . nextInt ( ) ; int maxv = 0 ; int cur = m ; while ( cur > 0 ) { int p = cur % q ; maxv = Math . max ( maxv , p ) ; if ( cur - p < 0 ) break ; cur = L [ cur - p ] ; } System . out . println ( maxv ) ; } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { static int search ( int [ ] c , int lt ) { for ( int i = lt ; i >= 0 ; i -- ) { if ( Arrays . binarySearch ( c , i ) >= 0 ) { return Arrays . binarySearch ( c , i ) ; } } return - 1 ; } public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int N = stdIn . nextInt ( ) ; int Q = stdIn . nextInt ( ) ; int [ ] c = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { c [ i ] = stdIn . nextInt ( ) ; } Arrays . sort ( c ) ; for ( int i = 0 ; i < Q ; i ++ ) { int max = 0 ; int q = stdIn . nextInt ( ) ; for ( int j = c . length - 1 ; j >= 0 ; j -- ) { if ( c [ j ] % q > max ) max = c [ j ] % q ; int tmp = search ( c , c [ j ] - c [ j ] % q - 1 ) ; if ( tmp == - 1 ) { break ; } else { j = tmp + 1 ; } } System . out . println ( max ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } private void run ( ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int q = scanner . nextInt ( ) ; boolean [ ] b = new boolean [ 300001 ] ; while ( n -- > 0 ) { b [ scanner . nextInt ( ) ] = true ; } loop : while ( q -- > 0 ) { int m = scanner . nextInt ( ) ; for ( int res = m - 1 ; res >= 0 ; res -- ) { for ( int i = res ; i <= 300000 ; i += m ) { if ( b [ i ] ) { System . out . println ( res ) ; continue loop ; } } } } } }"], "python": ["N , Q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = max ( C ) + 1 NEW_LINE t1 = [ 0 ] * ( M ) NEW_LINE for v in C : NEW_LINE INDENT t1 [ v ] = 1 NEW_LINE DEDENT t2 = [ 0 ] * ( M ) NEW_LINE v = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if t1 [ i ] : NEW_LINE INDENT v = i NEW_LINE DEDENT t2 [ i ] = v NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE n_v = M - 1 NEW_LINE m = 0 NEW_LINE while n_v != 0 : NEW_LINE INDENT amr = n_v % t NEW_LINE m = max ( m , amr ) NEW_LINE tmp = n_v - m - 1 NEW_LINE if tmp <= 0 : break NEW_LINE n_v = t2 [ tmp ] NEW_LINE DEDENT print ( m ) NEW_LINE DEDENT", "N , Q = map ( int , input ( ) . split ( ) ) NEW_LINE tbl = [ 0 ] * 300005 NEW_LINE nmax , tbl [ 0 ] = 0 , 1 NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for k in c : NEW_LINE INDENT tbl [ k ] = 1 NEW_LINE if k > nmax : nmax = k NEW_LINE tbl [ k & 1 ] = 1 NEW_LINE tbl [ k & 3 ] = 1 NEW_LINE tbl [ k & 7 ] = 1 NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE if q > nmax : print ( nmax ) NEW_LINE else : NEW_LINE INDENT f = 0 NEW_LINE for k in range ( q - 1 , - 1 , - 1 ) : NEW_LINE INDENT for i in range ( k , nmax + 1 , q ) : NEW_LINE INDENT if tbl [ i ] : NEW_LINE INDENT print ( k ) NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if f : break NEW_LINE DEDENT DEDENT DEDENT", "import bisect NEW_LINE n , q = map ( int , input ( ) . split ( ) ) NEW_LINE c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = sorted ( c ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT query = int ( input ( ) ) NEW_LINE num = query NEW_LINE ans = 0 NEW_LINE while True : NEW_LINE INDENT if c [ - 1 ] + query < num : NEW_LINE INDENT break NEW_LINE DEDENT end = bisect . bisect_left ( c , num ) NEW_LINE if end - 1 >= 0 : NEW_LINE INDENT ans = max ( ans , c [ end - 1 ] % query ) NEW_LINE DEDENT num += query NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "N , Q = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE M = max ( C ) + 1 NEW_LINE T = [ 0 ] * ( M ) NEW_LINE for v in C : T [ v ] = 1 NEW_LINE L = [ 0 ] * ( M ) NEW_LINE m = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT L [ i ] = m NEW_LINE if T [ i ] : m = i NEW_LINE DEDENT for i in range ( Q ) : NEW_LINE INDENT q = int ( input ( ) ) NEW_LINE maxv = 0 NEW_LINE cur = m NEW_LINE while 0 < cur : NEW_LINE INDENT p = cur % q NEW_LINE maxv = max ( maxv , p ) NEW_LINE if cur - p < 0 : break NEW_LINE cur = L [ cur - p ] NEW_LINE DEDENT print ( maxv ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4178_A", "java": ["import java . util . * ; class GFG { static class pair { int first , second ; pair ( ) { first = 0 ; second = 0 ; } } static void printIndices ( int n , pair a [ ] ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] . second + \" \u2581 \" ) ; System . out . println ( ) ; } static class sort implements Comparator < pair > { public int compare ( pair a , pair b ) { return a . first < b . first ? - 1 : 1 ; } } static void printPermutations ( int n , int a [ ] , int k ) { pair arr [ ] = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = new pair ( ) ; arr [ i ] . first = a [ i ] ; arr [ i ] . second = i ; } Arrays . sort ( arr , new sort ( ) ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] . first == arr [ i - 1 ] . first ) count ++ ; if ( count < k ) { System . out . print ( \" - 1\" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) { printIndices ( n , arr ) ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] . first == arr [ j - 1 ] . first ) { pair t = arr [ j ] ; arr [ j ] = arr [ j - 1 ] ; arr [ j - 1 ] = t ; break ; } } } printIndices ( n , arr ) ; } public static void main ( String arsg [ ] ) { int a [ ] = { 1 , 3 , 3 , 1 } ; int n = a . length ; int k = 3 ; printPermutations ( n , a , k ) ; } }"], "python": ["def printIndices ( n , a ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] [ 1 ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE DEDENT def printPermutations ( n , a , k ) : NEW_LINE INDENT arr = [ [ 0 , 0 ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ 0 ] = a [ i ] NEW_LINE arr [ i ] [ 1 ] = i NEW_LINE DEDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] == arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < k ) : NEW_LINE INDENT print ( \" - 1\" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT printIndices ( n , arr ) NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] == arr [ j - 1 ] [ 0 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j - 1 ] NEW_LINE arr [ j - 1 ] = temp NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT printIndices ( n , arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE printPermutations ( n , a , k ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_48_A", "java": ["public class GFG { static int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . sqrt ( n ) ; int prime [ ] = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; } public static void main ( String [ ] args ) { int n = 1000 ; System . out . println ( countNumbers ( n ) ) ; } }"], "python": ["def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1359_A", "java": ["import java . util . Scanner ; public class Solution { public static int solve ( int n , int m , int k ) { int t = n / k ; if ( m <= t ) return m ; m = m - t ; if ( m % ( k - 1 ) == 0 ) m = m / ( k - 1 ) ; else m = m / ( k - 1 ) + 1 ; return t - m ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; System . out . println ( solve ( n , m , k ) ) ; } } }", "import java . util . * ; public final class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int t = 1 ; t <= T ; t ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int c = n / k ; if ( m <= c ) { System . out . println ( m ) ; } else { m -= c ; k -- ; int rem_max = ( int ) Math . ceil ( ( double ) m / k ) ; System . out . println ( Math . max ( 0 , c - rem_max ) ) ; } } sc . close ( ) ; } }", "import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; while ( t -- > 0 ) { int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; int a = n / k ; if ( a >= m ) { System . out . println ( m ) ; } else { int d = a ; int e = ( int ) Math . ceil ( 1.0 * ( m - a ) / ( k - 1 ) ) ; System . out . println ( d - e ) ; } } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( m == 0 ) System . out . println ( 0 ) ; else if ( m <= n / k ) System . out . println ( m ) ; else { int left = m - ( n / k ) ; int other = ( int ) ( Math . ceil ( 1.0 * left / ( k - 1 ) ) ) ; System . out . println ( ( n / k ) - other ) ; } } } }"], "python": ["for s in [ * open ( 0 ) ] [ 1 : ] : n , m , k = map ( int , s . split ( ) ) ; print ( ( min ( m , n // k ) * k - m ) // ( k - 1 ) ) NEW_LINE", "from math import ceil NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT s = input ( ) NEW_LINE n , m , k = map ( int , s . split ( ) ) NEW_LINE c = n / k NEW_LINE if m < 2 or c >= m : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT elif n == m or c == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT j = m - c NEW_LINE ans = int ( c - ceil ( j / ( k - 1 ) ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( min ( m , ( n - m ) // ( k - 1 ) ) ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = n // k NEW_LINE if c >= m : NEW_LINE INDENT print ( m ) NEW_LINE DEDENT else : NEW_LINE INDENT m -= c NEW_LINE d = 0 NEW_LINE while m > 0 : NEW_LINE INDENT d += 1 NEW_LINE m -= ( k - 1 ) NEW_LINE DEDENT print ( c - d ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE j = min ( m , n // k ) NEW_LINE lj = m - j NEW_LINE lj = math . ceil ( lj / ( k - 1 ) ) NEW_LINE print ( j - lj ) NEW_LINE DEDENT"]}
{"id": "aizu_p00532_A", "java": ["import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) , Q = sc . nextInt ( ) ; int A [ ] = new int [ Q ] , B [ ] = new int [ N ] ; for ( int i = 0 ; i < Q ; i ++ ) A [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = sc . nextInt ( ) ; if ( A [ i ] == r ) B [ j ] ++ ; else B [ A [ i ] - 1 ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . println ( B [ i ] ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; int N = parseInt ( br . readLine ( ) ) ; int [ ] points = new int [ N + 1 ] ; int M = parseInt ( br . readLine ( ) ) ; int [ ] targets = new int [ M ] ; StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { targets [ i ] = parseInt ( st . nextToken ( ) ) ; } for ( int i = 0 ; i < M ; i ++ ) { st = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int a = parseInt ( st . nextToken ( ) ) ; if ( a == targets [ i ] ) { points [ j + 1 ] ++ ; } else { points [ targets [ i ] ] ++ ; } } } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 1 ; i < N + 1 ; i ++ ) { sb . append ( points [ i ] ) . append ( \" \\n \" ) ; } System . out . print ( sb . toString ( ) ) ; } }", "import java . io . * ; import java . util . StringTokenizer ; class Main { static final PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = \" \" ; while ( ( line = br . readLine ( ) ) != null && ! line . isEmpty ( ) ) { int n = Integer . parseInt ( line ) ; int m = Integer . parseInt ( br . readLine ( ) ) ; int [ ] t = new int [ m ] ; int [ ] p = new int [ n ] ; int [ ] [ ] sel = new int [ m ] [ n ] ; StringTokenizer st1 = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) t [ i ] = Integer . parseInt ( st1 . nextToken ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { StringTokenizer st2 = new StringTokenizer ( br . readLine ( ) ) ; for ( int j = 0 ; j < n ; j ++ ) { sel [ i ] [ j ] = Integer . parseInt ( st2 . nextToken ( ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { int cnt = n ; for ( int j = 0 ; j < n ; j ++ ) { if ( sel [ i ] [ j ] == t [ i ] ) { p [ j ] ++ ; cnt -- ; } } p [ t [ i ] - 1 ] += cnt ; } for ( int i = 0 ; i < n ; i ++ ) out . println ( p [ i ] ) ; out . flush ( ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int human = sc . nextInt ( ) ; int playedgame = sc . nextInt ( ) ; int [ ] points = new int [ human ] ; int [ ] tag = new int [ playedgame ] ; int missct = 0 ; for ( int i = 0 ; i < playedgame ; i ++ ) tag [ i ] = sc . nextInt ( ) ; for ( int target : tag ) { for ( int i = 0 ; i < human ; i ++ ) { int vote = sc . nextInt ( ) ; if ( vote - 1 == target - 1 ) points [ i ] ++ ; else missct ++ ; } points [ target - 1 ] += missct ; missct = 0 ; } for ( int pt : points ) System . out . println ( pt ) ; } }", "import java . util . * ; class Main { static Scanner s = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int [ ] points = new int [ s . nextInt ( ) ] ; int [ ] targets = new int [ s . nextInt ( ) ] ; for ( int i = 0 ; i < targets . length ; i ++ ) targets [ i ] = s . nextInt ( ) ; int c ; for ( int t : targets ) { c = 0 ; for ( int j = 0 ; j < points . length ; ++ j ) { if ( t == s . nextInt ( ) ) points [ j ] ++ ; else c ++ ; } points [ t - 1 ] += c ; } for ( int i : points ) System . out . println ( i ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE ans = [ 0 ] * n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT cnt = 0 NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT if b [ j ] == a [ i ] : NEW_LINE INDENT ans [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans [ a [ i ] - 1 ] += cnt NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT", "p , t = [ int ( input ( ) ) for i in range ( 2 ) ] NEW_LINE tg = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE pts = [ 0 for i in range ( p ) ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT ex = [ int ( s ) for s in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE c_wr = 0 NEW_LINE for j in range ( p ) : NEW_LINE INDENT if ex [ j ] == tg [ i ] : pts [ j ] += 1 NEW_LINE else : c_wr += 1 NEW_LINE DEDENT pts [ tg [ i ] - 1 ] += c_wr NEW_LINE DEDENT for pt in pts : print ( pt ) NEW_LINE", "peopleCounts = int ( input ( ) ) NEW_LINE gameCounts = int ( input ( ) ) NEW_LINE targets = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE result = [ 0 ] * peopleCounts NEW_LINE for i in range ( gameCounts ) : NEW_LINE INDENT judges = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = targets [ i ] NEW_LINE for judgeIndex in range ( len ( judges ) ) : NEW_LINE INDENT if ans == judges [ judgeIndex ] : NEW_LINE INDENT result [ judgeIndex ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result [ ans - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT for v in result : NEW_LINE INDENT print ( v ) NEW_LINE DEDENT", "N = int ( input ( ) ) NEW_LINE M = int ( input ( ) ) NEW_LINE target_list = [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] NEW_LINE vote_list = [ [ int ( i ) for i in input ( ) . split ( \" \u2581 \" ) ] for j in range ( M ) ] NEW_LINE score_list = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT target = target_list [ i ] NEW_LINE vote = vote_list [ i ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if vote [ j ] == target : NEW_LINE INDENT score_list [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT score_list [ target - 1 ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in score_list : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT", "import math NEW_LINE n = int ( input ( ) ) NEW_LINE m = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( m ) ] NEW_LINE p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if B [ i ] [ j ] == A [ i ] : NEW_LINE INDENT p [ j + 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p [ A [ i ] ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_222_A", "java": ["class GFG { static String smallestPoss ( String s , int n ) { String ans = \" \" ; int arr [ ] = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s . charAt ( i ) - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + String . valueOf ( i ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 15 ; String K = \"325343273113434\" ; System . out . print ( smallestPoss ( K , N ) ) ; } }"], "python": ["def smallestPoss ( s , n ) : NEW_LINE INDENT ans = \" \" ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE K = \"325343273113434\" ; NEW_LINE print ( smallestPoss ( K , N ) ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_244_B", "java": ["import java . util . * ; public class Assignment2 { static Long n ; static Set < Long > s ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextLong ( ) ; s = new HashSet < > ( ) ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) find ( i , j , 0L ) ; System . out . println ( s . size ( ) - 1 ) ; } public static void find ( int x , int y , Long c ) { s . add ( c ) ; Long xx = x + 10 * c ; Long yy = y + 10 * c ; if ( xx <= n && xx != 0 ) find ( x , y , xx ) ; if ( yy <= n && yy != 0 ) find ( x , y , yy ) ; return ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . util . HashSet ; import java . util . Set ; import java . util . StringTokenizer ; public class UndoubtedlyLuckyNumbers { public void solve ( ) { FastScanner in = new FastScanner ( System . in ) ; int n = in . nextInt ( ) ; Set < Integer > set = new HashSet < > ( ) ; for ( int x = 0 ; x < 10 ; x ++ ) { for ( int y = x + 1 ; y < 10 ; y ++ ) { for ( int L = 1 ; L < 10 ; L ++ ) { for ( int mask = 0 ; mask < 1 << L ; mask ++ ) { int m = 0 ; for ( int i = 0 ; i < L ; i ++ ) { m *= 10 ; if ( ( 1 & ( mask >> i ) ) == 0 ) m += x ; else m += y ; } if ( m > 0 && m <= n ) set . add ( m ) ; } } } } if ( n == 1000000000 ) set . add ( 1000000000 ) ; System . out . println ( set . size ( ) ) ; } public static void main ( String [ ] args ) { UndoubtedlyLuckyNumbers x = new UndoubtedlyLuckyNumbers ( ) ; x . solve ( ) ; } private class FastScanner { public BufferedReader r ; public StringTokenizer st = null ; public FastScanner ( InputStream stream ) { r = new BufferedReader ( new InputStreamReader ( stream ) , 32728 ) ; } public String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( r . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public Long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } }"], "python": ["list1 = [ ] NEW_LINE for x in range ( 0 , 10 ) : NEW_LINE INDENT for y in range ( 0 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( 0 , ( 2 ** i ) + 1 ) : NEW_LINE INDENT bn = bin ( j ) NEW_LINE bn = bn [ 2 : ] NEW_LINE c = bn . zfill ( i ) NEW_LINE temp = c . replace ( \"0\" , str ( x ) ) NEW_LINE res = temp . replace ( \"1\" , str ( y ) ) NEW_LINE list1 . append ( int ( res ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT list1 = sorted ( list ( set ( list1 ) ) ) NEW_LINE inp1 = int ( input ( ) ) NEW_LINE ans = - 1 NEW_LINE for x in range ( len ( list1 ) ) : NEW_LINE INDENT if int ( list1 [ x ] ) <= inp1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "inp = int ( input ( ) ) NEW_LINE l1 = [ ] NEW_LINE c = - 1 NEW_LINE for x in range ( 0 , 10 ) : NEW_LINE INDENT for y in range ( 0 , 10 ) : NEW_LINE INDENT for l in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( 0 , 2 ** l ) : NEW_LINE INDENT b = bin ( j ) NEW_LINE b = b [ 2 : ] NEW_LINE b = b . zfill ( l ) NEW_LINE f = b . replace ( '0' , str ( x ) ) NEW_LINE last = f . replace ( '1' , str ( y ) ) NEW_LINE l1 . append ( int ( last ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT u = ( set ( l1 ) ) NEW_LINE for m in u : NEW_LINE INDENT if int ( m ) <= inp : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if inp == 1000000000 : NEW_LINE INDENT print ( c + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c ) NEW_LINE DEDENT", "array = [ ] NEW_LINE for x in range ( 0 , 10 ) : NEW_LINE INDENT for y in range ( 0 , 10 ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( 0 , 2 ** i ) : NEW_LINE INDENT b = bin ( j ) [ 2 : ] NEW_LINE b = b . zfill ( i ) NEW_LINE b = b . replace ( \"0\" , str ( x ) ) NEW_LINE b = b . replace ( \"1\" , str ( y ) ) NEW_LINE array . append ( int ( b ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT cout = 0 NEW_LINE array = set ( array ) NEW_LINE a = int ( input ( ) ) NEW_LINE for k in array : NEW_LINE INDENT if int ( k ) <= a : NEW_LINE INDENT cout += 1 NEW_LINE DEDENT DEDENT if a == 10 ** 9 : NEW_LINE INDENT print ( cout ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( cout - 1 ) NEW_LINE DEDENT", "lis = [ ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT for k in range ( 0 , 10 ) : NEW_LINE INDENT for l in range ( 0 , 2 ** k ) : NEW_LINE INDENT b = bin ( l ) [ 2 : ] NEW_LINE b = b . zfill ( k ) NEW_LINE b = b . replace ( \"0\" , str ( i ) ) NEW_LINE b = b . replace ( \"1\" , str ( j ) ) NEW_LINE lis . append ( int ( b ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT count = 0 NEW_LINE lis = set ( lis ) NEW_LINE a = int ( input ( ) ) NEW_LINE for m in lis : NEW_LINE INDENT if int ( m ) <= a : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if a == 10 ** 9 : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( count - 1 ) NEW_LINE DEDENT"]}
{"id": "codeforces_505_A", "java": ["import java . util . Scanner ; public class MrKitayutasGift { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; String s = scan . nextLine ( ) ; char [ ] letter = new char [ 26 ] ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) letter [ c - ' a ' ] = c ; for ( int i = 0 ; i <= s . length ( ) ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { String curr = s . substring ( 0 , i ) + letter [ j ] + s . substring ( i , s . length ( ) ) ; if ( check ( curr ) ) { System . out . println ( curr ) ; return ; } } } System . out . println ( \" NA \" ) ; } static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) != s . charAt ( s . length ( ) - i - 1 ) ) return false ; return true ; } }", "import java . util . Scanner ; public class Test505A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; String str = input . nextLine ( ) ; String result = null ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { for ( int i = 0 ; i <= str . length ( ) ; i ++ ) { StringBuffer sb = new StringBuffer ( ) ; if ( i == 0 ) { sb . append ( c ) ; sb . append ( str ) ; } else if ( i == str . length ( ) ) { sb . append ( str ) ; sb . append ( c ) ; } else { sb . append ( str . substring ( 0 , i ) ) ; sb . append ( c ) ; sb . append ( str . substring ( i , str . length ( ) ) ) ; } String newStr = sb . toString ( ) ; String reverseStr = sb . reverse ( ) . toString ( ) ; if ( newStr . equals ( reverseStr ) ) { result = reverseStr ; break ; } } } if ( result != null ) { System . out . println ( result ) ; } else { System . out . println ( \" NA \" ) ; } } }"], "python": ["def return_palindrome ( s : str , c : str , i : int ) : NEW_LINE INDENT new_s = s [ : i ] + c + s [ i : ] NEW_LINE if new_s == new_s [ : : - 1 ] : NEW_LINE INDENT return new_s NEW_LINE DEDENT else : NEW_LINE INDENT return \" NA \" NEW_LINE DEDENT DEDENT s = input ( ) NEW_LINE found = False NEW_LINE for i in range ( len ( s ) + 1 ) : NEW_LINE INDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT for c in \" abcdefghijklmnopqrstuvwxyz \" : NEW_LINE INDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT palindrome = return_palindrome ( s , c , i ) NEW_LINE if palindrome != \" NA \" : NEW_LINE INDENT print ( palindrome ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT if not found : NEW_LINE INDENT print ( \" NA \" ) NEW_LINE DEDENT", "from string import ascii_lowercase NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for c in ascii_lowercase : NEW_LINE INDENT t = s NEW_LINE t = t [ : i ] + c + t [ i : ] NEW_LINE if t == t [ : : - 1 ] : NEW_LINE INDENT print ( t ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( \" NA \" ) NEW_LINE DEDENT main ( ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE s = input ( ) [ : - 1 ] NEW_LINE x = len ( s ) NEW_LINE ans = ' ' NEW_LINE for i in range ( x // 2 ) : NEW_LINE INDENT if s [ i ] != s [ x - i - 1 ] : NEW_LINE INDENT d = s [ : i ] + s [ x - i - 1 ] + s [ i : ] NEW_LINE e = s [ : x - i ] + s [ i ] + s [ x - i : ] NEW_LINE for j in range ( ( x + 1 ) // 2 ) : NEW_LINE INDENT if d [ j ] != d [ x - j ] : NEW_LINE INDENT ans = \" NA \" NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = d NEW_LINE DEDENT if ans == ' NA ' : NEW_LINE INDENT for j in range ( ( x + 1 ) // 2 ) : NEW_LINE INDENT if e [ j ] != e [ x - j ] : NEW_LINE INDENT ans = \" NA \" NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = e NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s = s [ : x // 2 ] + s [ x // 2 ] + s [ x // 2 : ] NEW_LINE ans = s NEW_LINE DEDENT print ( ans ) NEW_LINE", "def f ( s ) : NEW_LINE INDENT def d ( s ) : NEW_LINE INDENT return s == s [ : : - 1 ] NEW_LINE DEDENT s = \" . \" + s + \" . \" NEW_LINE for letter in list ( set ( s . replace ( \" . \" , \" \" ) ) ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if d ( ( s [ : i ] + letter + s [ i : ] ) . replace ( \" . \" , \" \" ) ) : NEW_LINE INDENT return ( s [ : i ] + letter + s [ i : ] ) . replace ( \" . \" , \" \" ) NEW_LINE DEDENT DEDENT DEDENT return \" NA \" NEW_LINE DEDENT s = input ( ) NEW_LINE print ( f ( s ) ) NEW_LINE", "s = input ( ) NEW_LINE n = len ( s ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT s2 = s [ : i ] + chr ( j + 97 ) + s [ i : ] NEW_LINE if s2 == s2 [ : : - 1 ] : print ( s2 ) ; exit ( ) NEW_LINE DEDENT DEDENT print ( \" NA \" ) NEW_LINE"]}
{"id": "projecteuler_p123_A", "java": ["public final class p123 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p123 ( ) . run ( ) ) ; } private static final int PRIME_LIMIT = 1000000 ; private static final long THRESHOLD = 10000000000L ; public String run ( ) { int [ ] primes = Library . listPrimes ( PRIME_LIMIT ) ; for ( int n = 5 ; n <= primes . length ; n += 2 ) { long rem = ( long ) n * primes [ n - 1 ] * 2 ; if ( rem > THRESHOLD ) return Integer . toString ( n ) ; } throw new AssertionError ( \" Not \u2581 found \" ) ; } }"], "python": ["import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE for n in range ( 5 , len ( primes ) , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > 10000000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_980_A", "java": ["import java . io . * ; import java . util . StringTokenizer ; import static java . lang . Double . parseDouble ; import static java . lang . Integer . parseInt ; import static java . lang . Long . parseLong ; public class Main { static BufferedWriter of = null ; static { try { of = new BufferedWriter ( new FileWriter ( new File ( \" filee . txt \" ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private static BufferedWriter ifile = null ; static { try { ifile = new BufferedWriter ( new FileWriter ( String . valueOf ( System . in ) ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } private static final BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; private static final Fast in = new Fast ( ) ; public static void main ( String [ ] args ) throws IOException { String s = in . next ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' - ' ) c1 ++ ; else c2 ++ ; } if ( c2 == 0 ) System . out . println ( \" YES \" ) ; else if ( c1 % c2 == 0 ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } public static class Fast { BufferedReader br ; StringTokenizer st ; public Fast ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public Fast ( FileReader f ) { br = new BufferedReader ( f ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return parseLong ( next ( ) ) ; } public double nextDouble ( ) throws IOException { return parseDouble ( next ( ) ) ; } public float nextFloat ( ) throws IOException { return Float . parseFloat ( next ( ) ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String a = in . nextLine ( ) ; int b = a . length ( ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < b ; i ++ ) { char c = a . charAt ( i ) ; if ( c == 45 ) { x ++ ; } else if ( c == 111 ) { y ++ ; } } if ( y == 0 ) { System . out . println ( \" YES \" ) ; } else { if ( x % y == 0 ) { System . out . println ( \" YES \" ) ; } else if ( y == 1 ) { System . out . println ( \" YES \" ) ; } else { System . out . println ( \" NO \" ) ; } } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; String s = in . nextLine ( ) ; int l = s . length ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == ' - ' ) a ++ ; else b ++ ; } if ( b != 0 ) { if ( a % b == 0 ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } else System . out . println ( \" YES \" ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Beta { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' o ' ) a ++ ; else if ( s . charAt ( i ) == ' - ' ) b ++ ; } if ( a == 0 ) System . out . println ( \" YES \" ) ; else if ( b % a == 0 ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"], "python": ["necklace = input ( ) NEW_LINE strings = necklace . count ( ' - ' ) NEW_LINE pearls = necklace . count ( ' o ' ) NEW_LINE if pearls == 0 : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT elif strings == 0 : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT elif ( strings % pearls ) == 0 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT", "s = input ( ) NEW_LINE print ( \" YES \" if s . count ( ' - ' ) % max ( s . count ( ' o ' ) , 1 ) == 0 else \" NO \" ) NEW_LINE", "s = input ( ) NEW_LINE print ( ' NO ' if len ( s ) % ( s . count ( ' o ' ) or 1 ) else ' YES ' ) NEW_LINE", "v = input ( ) NEW_LINE print ( ' NO ' if len ( v ) % ( v . count ( ' o ' ) or 1 ) else ' YES ' ) NEW_LINE", "pearl = input ( ) NEW_LINE print ( ' NO ' if len ( pearl ) % ( pearl . count ( ' o ' ) or 1 ) else ' YES ' ) NEW_LINE"]}
{"id": "atcoder_AGC022_C", "java": ["import java . util . * ; public class Main { static public int n ; static int [ ] A = new int [ 50 ] ; static int [ ] B = new int [ 50 ] ; public Boolean fun ( Long bit ) { boolean [ ] [ ] arr = new boolean [ 51 ] [ 51 ] ; for ( int i = 0 ; i <= 50 ; i ++ ) { arr [ i ] [ i ] = true ; } for ( int i = 1 ; i <= 50 ; i ++ ) { if ( ( bit & ( 1L << i ) ) != 0 ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ j ] [ j % i ] = true ; } } } for ( int k = 0 ; k <= 50 ; k ++ ) { for ( int i = 0 ; i <= 50 ; i ++ ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ i ] [ j ] |= arr [ i ] [ k ] & arr [ k ] [ j ] ; } } } Boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! arr [ A [ i ] ] [ B [ i ] ] ) flag = false ; } return flag ; } public void solve ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = sc . nextInt ( ) ; } Long ans = ( 1L << 51 ) - 1 ; if ( ! fun ( ans ) ) { System . out . println ( - 1 ) ; return ; } for ( int i = 51 ; i >= 0 ; i -- ) { Long tmp = ans & ~ ( 1L << i ) ; if ( fun ( tmp ) ) ans = tmp ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } } ;", "import java . util . * ; public class Main { static public int n ; static int [ ] A = new int [ 50 ] ; static int [ ] B = new int [ 50 ] ; public Boolean fun ( Long bit ) { boolean [ ] [ ] arr = new boolean [ 51 ] [ 51 ] ; for ( int i = 0 ; i <= 50 ; i ++ ) { arr [ i ] [ i ] = true ; } for ( int i = 1 ; i <= 50 ; i ++ ) { if ( ( bit & ( 1L << i ) ) != 0 ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ j ] [ j % i ] = true ; } } } for ( int k = 0 ; k <= 50 ; k ++ ) { for ( int i = 0 ; i <= 50 ; i ++ ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ i ] [ j ] |= arr [ i ] [ k ] & arr [ k ] [ j ] ; } } } Boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! arr [ A [ i ] ] [ B [ i ] ] ) flag = false ; } return flag ; } public void solve ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = sc . nextInt ( ) ; } Long ans = ( 1L << 50 ) - 1 ; if ( ! fun ( ans ) ) { System . out . println ( - 1 ) ; return ; } for ( int i = 50 ; i >= 0 ; i -- ) { Long tmp = ans & ~ ( 1L << i ) ; if ( fun ( tmp ) ) ans = tmp ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } } ;"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT graph = [ [ ] for _ in range ( 51 ) ] NEW_LINE for start in range ( 51 ) : NEW_LINE INDENT for cost in range ( 1 , 51 ) : NEW_LINE INDENT if start % cost == 0 : NEW_LINE INDENT graph [ 0 ] . append ( ( cost , start ) ) NEW_LINE DEDENT DEDENT DEDENT for end in range ( 1 , 51 ) : NEW_LINE INDENT for cost in range ( end + 1 , 51 ) : NEW_LINE INDENT start = end + cost NEW_LINE while start <= 50 : NEW_LINE INDENT graph [ end ] . append ( ( cost , start ) ) NEW_LINE start += cost NEW_LINE DEDENT DEDENT DEDENT use = 0 NEW_LINE for l in reversed ( range ( 1 , 52 ) ) : NEW_LINE INDENT for a , b in zip ( A , B ) : NEW_LINE INDENT ok = False NEW_LINE q = [ b ] NEW_LINE checked = [ False ] * 51 NEW_LINE checked [ b ] = True NEW_LINE while q : NEW_LINE INDENT qq = [ ] NEW_LINE for p in q : NEW_LINE INDENT if p == a : NEW_LINE INDENT ok = True NEW_LINE break NEW_LINE DEDENT for cost , np in graph [ p ] : NEW_LINE INDENT if not checked [ np ] and ( cost < l or use & ( 1 << cost ) ) : NEW_LINE INDENT checked [ np ] = True NEW_LINE qq . append ( np ) NEW_LINE DEDENT DEDENT DEDENT if ok : break NEW_LINE q = qq NEW_LINE DEDENT if not ok : NEW_LINE INDENT if l == 51 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT use |= ( 1 << l ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return use NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT", "from scipy . sparse . csgraph import floyd_warshall NEW_LINE n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE a , b = a [ : n ] , a [ n : ] NEW_LINE for x , y in zip ( a , b ) : NEW_LINE INDENT if x == y : continue NEW_LINE if y > x : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if x - y <= y : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT M = max ( a ) NEW_LINE d = [ ] NEW_LINE for k in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT s = set ( a ) NEW_LINE e = [ [ 0 ] * ( M + 1 ) for _ in range ( M + 1 ) ] NEW_LINE for i in range ( M + 1 ) : e [ i ] [ i ] = 1 NEW_LINE for i in d + list ( range ( k , 0 , - 1 ) ) : NEW_LINE INDENT t = s . copy ( ) NEW_LINE for x in s : NEW_LINE INDENT e [ x ] [ x % i ] = 1 NEW_LINE t |= { x % i } NEW_LINE DEDENT s = t NEW_LINE DEDENT c = floyd_warshall ( e ) NEW_LINE for x , y in zip ( a , b ) : NEW_LINE INDENT if c [ x , y ] == float ( ' inf ' ) : NEW_LINE INDENT d += k + 1 , NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( sum ( 2 ** k for k in d ) ) NEW_LINE", "def warshall_floyd ( d ) : NEW_LINE INDENT r = range ( M + 1 ) NEW_LINE for k in r : NEW_LINE INDENT for i in r : NEW_LINE INDENT for j in r : NEW_LINE INDENT t = d [ i ] [ k ] + d [ k ] [ j ] NEW_LINE if t < d [ i ] [ j ] : NEW_LINE INDENT d [ i ] [ j ] = t NEW_LINE DEDENT DEDENT DEDENT DEDENT return d NEW_LINE DEDENT n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE a , b = a [ : n ] , a [ n : ] NEW_LINE for x , y in zip ( a , b ) : NEW_LINE INDENT if x == y : continue NEW_LINE if y > x : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if x - y <= y : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT M = max ( a ) NEW_LINE d = [ ] NEW_LINE for k in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT s = set ( a ) NEW_LINE e = [ [ 10 ** 18 ] * ( M + 1 ) for _ in range ( M + 1 ) ] NEW_LINE for i in range ( M + 1 ) : e [ i ] [ i ] = 1 NEW_LINE for i in d + list ( range ( k , 0 , - 1 ) ) : NEW_LINE INDENT t = s . copy ( ) NEW_LINE for x in s : NEW_LINE INDENT e [ x ] [ x % i ] = 1 NEW_LINE t |= { x % i } NEW_LINE DEDENT s = t NEW_LINE DEDENT c = warshall_floyd ( e ) NEW_LINE for x , y in zip ( a , b ) : NEW_LINE INDENT if c [ x ] [ y ] >= 10 ** 18 : NEW_LINE INDENT d += k + 1 , NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( sum ( 2 ** k for k in d ) ) NEW_LINE", "from scipy . sparse . csgraph import dijkstra NEW_LINE def make_graph ( m , subset ) : NEW_LINE INDENT matrix = [ [ 0 ] * ( m + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for k in subset : NEW_LINE INDENT for s in range ( k , m + 1 ) : NEW_LINE INDENT matrix [ s ] [ s % k ] = 1 NEW_LINE DEDENT DEDENT return dijkstra ( matrix ) NEW_LINE DEDENT def solve ( n , aaa , bbb ) : NEW_LINE INDENT for a , b in zip ( aaa , bbb ) : NEW_LINE INDENT if a < b : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT m = max ( aaa ) NEW_LINE subset = set ( range ( 1 , m + 1 ) ) NEW_LINE sp = make_graph ( m , subset ) NEW_LINE if any ( sp [ a , b ] > 50 for a , b in zip ( aaa , bbb ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for k in range ( m , 0 , - 1 ) : NEW_LINE INDENT subset . remove ( k ) NEW_LINE sp = make_graph ( m , subset ) NEW_LINE if any ( sp [ a , b ] > 50 for a , b in zip ( aaa , bbb ) ) : NEW_LINE INDENT subset . add ( k ) NEW_LINE DEDENT DEDENT return sum ( 1 << k for k in subset ) NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE aaa = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE bbb = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( solve ( n , aaa , bbb ) ) NEW_LINE", "def inpl ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE from collections import defaultdict NEW_LINE import sys NEW_LINE def edge ( S ) : NEW_LINE INDENT e = defaultdict ( lambda : set ( ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in S : NEW_LINE INDENT e [ i ] . add ( i % j ) NEW_LINE DEDENT e [ i ] = e [ i ] | { i } NEW_LINE DEDENT return e NEW_LINE DEDENT def path ( edge ) : NEW_LINE INDENT p = defaultdict ( lambda : set ( ) ) NEW_LINE for st in range ( N + 1 ) : NEW_LINE INDENT Q , p [ st ] , new = [ edge [ st ] ] * 3 NEW_LINE while Q : NEW_LINE INDENT for j in Q : NEW_LINE INDENT new = new | edge [ j ] NEW_LINE DEDENT Q = new - p [ st ] NEW_LINE p [ st ] = p [ st ] | new NEW_LINE DEDENT DEDENT return p NEW_LINE DEDENT K = int ( input ( ) ) NEW_LINE A = inpl ( ) NEW_LINE B = inpl ( ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT if A [ i ] < B [ i ] : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT DEDENT if A == B : NEW_LINE INDENT print ( 0 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT N = max ( A ) NEW_LINE T = [ ] NEW_LINE for l in range ( N , - 1 , - 1 ) : NEW_LINE INDENT S = T + list ( range ( 1 , 1 + l ) ) NEW_LINE Pa = path ( edge ( S ) ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT if B [ i ] not in Pa [ A [ i ] ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT T . append ( l + 1 ) NEW_LINE DEDENT if not T : NEW_LINE INDENT print ( 2 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT if N + 1 in T : NEW_LINE INDENT print ( - 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT print ( sum ( [ 2 ** i for i in T ] ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3055_A", "java": ["class GFG { static final int INT_SIZE = 32 ; static class TrieNode { int value ; TrieNode [ ] arr = new TrieNode [ 2 ] ; public TrieNode ( ) { value = 0 ; arr [ 0 ] = null ; arr [ 1 ] = null ; } } static TrieNode root ; static void insert ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ val ] == null ) temp . arr [ val ] = new TrieNode ( ) ; temp = temp . arr [ val ] ; } temp . value = pre_xor ; } static int query ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ 1 - val ] != null ) temp = temp . arr [ 1 - val ] ; else if ( temp . arr [ val ] != null ) temp = temp . arr [ val ] ; } return pre_xor ^ ( temp . value ) ; } static int maxSubarrayXOR ( int arr [ ] , int n ) { root = new TrieNode ( ) ; insert ( 0 ) ; int result = Integer . MIN_VALUE ; int pre_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre_xor = pre_xor ^ arr [ i ] ; insert ( pre_xor ) ; result = Math . max ( result , query ( pre_xor ) ) ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 2 , 12 } ; int n = arr . length ; System . out . println ( \" Max \u2581 subarray \u2581 XOR \u2581 is \u2581 \" + maxSubarrayXOR ( arr , n ) ) ; } }"], "python": ["class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Trie : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = Node ( 0 ) NEW_LINE DEDENT def insert ( self , pre_xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = pre_xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if not self . temp . right : NEW_LINE INDENT self . temp . right = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . right NEW_LINE DEDENT if not val : NEW_LINE INDENT if not self . temp . left : NEW_LINE INDENT self . temp . left = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT self . temp . data = pre_xor NEW_LINE DEDENT def query ( self , xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT elif self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT elif self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT DEDENT return xor ^ self . temp . data NEW_LINE DEDENT def maxSubArrayXOR ( self , n , Arr ) : NEW_LINE INDENT self . insert ( 0 ) NEW_LINE result = - float ( ' inf ' ) NEW_LINE pre_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_xor = pre_xor ^ Arr [ i ] NEW_LINE self . insert ( pre_xor ) NEW_LINE result = max ( result , self . query ( pre_xor ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT Arr = [ 8 , 1 , 2 , 12 ] NEW_LINE n = len ( Arr ) NEW_LINE trie = Trie ( ) NEW_LINE print ( trie . maxSubArrayXOR ( n , Arr ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_676_A", "java": ["import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; ArrayList < Integer > arr = new ArrayList < > ( 100 ) ; Integer n = scanner . nextInt ( ) ; Integer one = 1 , lar = 1 ; for ( int i = 0 ; i < n ; i ++ ) { arr . add ( scanner . nextInt ( ) ) ; if ( arr . get ( i ) == 1 ) one = i ; if ( arr . get ( i ) == n ) lar = i ; } ArrayList < Integer > ans = new ArrayList < > ( 5 ) ; ans . add ( one ) ; ans . add ( n - one - 1 ) ; ans . add ( lar ) ; ans . add ( n - lar - 1 ) ; Integer Answer = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { if ( Answer < ans . get ( i ) ) Answer = ans . get ( i ) ; } System . out . println ( Answer ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . Reader ; import java . util . StringTokenizer ; public class Main { public Main ( ) { FastScanner input = new FastScanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] arr = new int [ n ] ; int minIndex = 0 ; int maxIndex = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = input . nextInt ( ) ; if ( arr [ i ] > arr [ maxIndex ] ) { maxIndex = i ; } if ( arr [ i ] < arr [ minIndex ] ) { minIndex = i ; } } int maxMin = Math . max ( minIndex , n - minIndex - 1 ) ; int maxMax = Math . max ( maxIndex , n - maxIndex - 1 ) ; System . out . println ( Math . max ( maxMin , maxMax ) ) ; } public static void main ( String [ ] args ) { new Main ( ) ; } class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( Reader in ) { br = new BufferedReader ( in ) ; } public FastScanner ( InputStream in ) { this ( new InputStreamReader ( in ) ) ; } public String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; public class test { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; int [ ] a = new int [ n ] ; String [ ] input = br . readLine ( ) . split ( \" \u2581 \" ) ; int minIndex = 0 ; int maxIndex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Integer . parseInt ( input [ i ] ) ; if ( a [ i ] == 1 ) minIndex = i ; else if ( a [ i ] == n ) maxIndex = i ; } minIndex ++ ; maxIndex ++ ; if ( minIndex > maxIndex ) { pw . println ( Math . max ( n - maxIndex , minIndex - 1 ) ) ; } else { pw . println ( Math . max ( maxIndex - 1 , n - minIndex ) ) ; } pw . flush ( ) ; pw . close ( ) ; br . close ( ) ; } }", "import java . util . Scanner ; public class JavaApplication111 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; int least = 10000 ; int most = 0 ; int leastId = 0 ; int mostId = 0 ; for ( int i = 0 ; i < num ; i ++ ) { int h = sc . nextInt ( ) ; if ( h < least ) { least = h ; leastId = i ; } if ( h > most ) { most = h ; mostId = i ; } } if ( Math . abs ( mostId - leastId ) == num - 2 ) { System . out . println ( Math . abs ( mostId - leastId ) + 1 ) ; } else if ( Math . abs ( mostId - leastId ) == num - 1 ) { System . out . println ( Math . abs ( mostId - leastId ) ) ; } else { System . out . println ( Math . abs ( mostId - leastId ) + Math . max ( Math . min ( ( num - 1 ) - mostId , ( num - 1 ) - leastId ) , Math . min ( mostId , leastId ) ) ) ; } } }"], "python": ["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE x = a . index ( 1 ) + 1 NEW_LINE y = a . index ( n ) + 1 NEW_LINE print ( max ( abs ( n - x ) , abs ( n - y ) , abs ( 1 - x ) , abs ( 1 - y ) ) ) NEW_LINE", "n = input ( ) NEW_LINE s = input ( ) . split ( ) NEW_LINE M = s . index ( n ) NEW_LINE n = int ( n ) NEW_LINE m = s . index ( '1' ) NEW_LINE print ( max ( m , M , n - m - 1 , n - 1 - M ) ) NEW_LINE", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE def inp ( ) : NEW_LINE INDENT return ( int ( input ( ) ) ) NEW_LINE DEDENT def inlt ( ) : NEW_LINE INDENT return ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT def insr ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE return ( list ( s [ : len ( s ) - 1 ] ) ) NEW_LINE DEDENT def invr ( ) : NEW_LINE INDENT return ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def printList ( strings ) : NEW_LINE INDENT for string in strings : NEW_LINE INDENT print ( string ) NEW_LINE DEDENT DEDENT n = inp ( ) NEW_LINE a = invr ( ) NEW_LINE list_a = list ( a ) NEW_LINE idx_max = list_a . index ( n ) NEW_LINE idx_min = list_a . index ( 1 ) NEW_LINE max_idx = max ( idx_max , idx_min , abs ( n - 1 - idx_max ) , abs ( n - 1 - idx_min ) ) NEW_LINE print ( max_idx ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE numbers = input ( ) . split ( ' \u2581 ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT numbers [ i ] = int ( numbers [ i ] ) NEW_LINE DEDENT max_number_index = numbers . index ( max ( numbers ) ) NEW_LINE min_number_index = numbers . index ( min ( numbers ) ) NEW_LINE initial_distance = abs ( min_number_index - max_number_index ) NEW_LINE if max_number_index == 0 or min_number_index == 0 or max_number_index == n - 1 or min_number_index == n - 1 : NEW_LINE INDENT print ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( max ( initial_distance , n - 1 - max_number_index , n - 1 - min_number_index , max_number_index , min_number_index ) ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE a = * map ( int , input ( ) . split ( ) ) , NEW_LINE x , y = sorted ( [ a . index ( 1 ) , a . index ( n ) ] ) NEW_LINE print ( max ( y , n - 1 - x ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3797_A", "java": ["import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int sumSubarrayMins ( int A [ ] , int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; Stack < pair > s1 = new Stack < pair > ( ) ; Stack < pair > s2 = new Stack < pair > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { int cnt = 1 ; while ( ! s1 . isEmpty ( ) && ( s1 . peek ( ) . first ) > A [ i ] ) { cnt += s1 . peek ( ) . second ; s1 . pop ( ) ; } s1 . push ( new pair ( A [ i ] , cnt ) ) ; left [ i ] = cnt ; } for ( int i = n - 1 ; i >= 0 ; -- i ) { int cnt = 1 ; while ( ! s2 . isEmpty ( ) && ( s2 . peek ( ) . first ) >= A [ i ] ) { cnt += s2 . peek ( ) . second ; s2 . pop ( ) ; } s2 . push ( new pair ( A [ i ] , cnt ) ) ; right [ i ] = cnt ; } int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) result = ( result + A [ i ] * left [ i ] * right [ i ] ) ; return result ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 2 , 4 } ; int n = A . length ; System . out . println ( sumSubarrayMins ( A , n ) ) ; } }"], "python": ["def sumSubarrayMins ( A , n ) : NEW_LINE INDENT left , right = [ None ] * n , [ None ] * n NEW_LINE s1 , s2 = [ ] , [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s1 ) > 0 and s1 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s1 [ - 1 ] [ 1 ] NEW_LINE s1 . pop ( ) NEW_LINE DEDENT s1 . append ( [ A [ i ] , cnt ] ) NEW_LINE left [ i ] = cnt NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT cnt = 1 NEW_LINE while len ( s2 ) > 0 and s2 [ - 1 ] [ 0 ] > A [ i ] : NEW_LINE INDENT cnt += s2 [ - 1 ] [ 1 ] NEW_LINE s2 . pop ( ) NEW_LINE DEDENT s2 . append ( [ A [ i ] , cnt ] ) NEW_LINE right [ i ] = cnt NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT result += A [ i ] * left [ i ] * right [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 1 , 2 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print ( sumSubarrayMins ( A , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_783_A", "java": ["import java . io . * ; class Numbers { static boolean isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d || digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; } static void printGoodNumber ( int L , int R , int d ) { for ( int i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) System . out . print ( i + \" \u2581 \" ) ; } } public static void main ( String [ ] args ) { int L = 410 , R = 520 , d = 3 ; printGoodNumber ( L , R , d ) ; } }"], "python": ["def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE sum = digit ; NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT DEDENT L = 410 ; NEW_LINE R = 520 ; NEW_LINE d = 3 ; NEW_LINE printGoodNumber ( L , R , d ) ; NEW_LINE"]}
{"id": "atcoder_ABC106_B", "java": ["import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int N = Integer . parseInt ( br . readLine ( ) ) ; int count = 0 ; for ( int i = 1 ; i <= N ; i += 2 ) { int divisor = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i % j == 0 ) { divisor ++ ; } } if ( divisor == 8 ) count ++ ; } System . out . println ( count ) ; } }", "import java . util . Scanner ; public class Main { public static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; int ans = 0 ; for ( int i = 8 ; i <= N ; i ++ ) { if ( i % 2 == 1 && yaku ( i ) == 8 ) { ans ++ ; } } System . out . println ( ans ) ; } public static int yaku ( int N ) { int yaku = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 ) { yaku ++ ; } } return yaku ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( n < 105 ) { System . out . println ( 0 ) ; } else if ( n < 135 ) { System . out . println ( 1 ) ; } else if ( n < 165 ) { System . out . println ( 2 ) ; } else if ( n < 189 ) { System . out . println ( 3 ) ; } else if ( n < 195 ) { System . out . println ( 4 ) ; } else { System . out . println ( 5 ) ; } } }", "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws IOException { try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { final String s = reader . readLine ( ) ; int N = Integer . parseInt ( s ) ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j <= i ; j ++ ) { if ( i % 2 == 1 && i % j == 0 ) cnt ++ ; } if ( cnt == 8 ) ans ++ ; } System . out . println ( ans ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , cnt = 1 , tmp ; if ( n < 105 ) { System . out . println ( 0 ) ; return ; } for ( int m = 107 ; m <= n ; m += 2 ) { tmp = 1 ; for ( int k = 3 ; k <= m ; k += 2 ) { if ( m % k == 0 ) tmp ++ ; } if ( tmp == 8 ) cnt ++ ; } System . out . println ( cnt ) ; } }"], "python": ["N = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if cnt == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "inp = input ( ) NEW_LINE n = int ( inp ) NEW_LINE if n < 105 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif 105 <= n < 135 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif 135 <= n < 165 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT elif 165 <= n < 189 : NEW_LINE INDENT print ( 3 ) NEW_LINE DEDENT elif 189 <= n < 195 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif 195 <= n : NEW_LINE INDENT print ( 5 ) NEW_LINE DEDENT", "import copy NEW_LINE import math NEW_LINE def get_int ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def get_string ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def get_int_list ( ) : NEW_LINE INDENT return [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE DEDENT def get_string_list ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def get_int_multi ( ) : NEW_LINE INDENT return map ( int , input ( ) . split ( ) ) NEW_LINE DEDENT def get_string_char_list ( ) : NEW_LINE INDENT return list ( str ( input ( ) ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = get_int ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE for ii in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % ii == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "print ( len ( [ i for i in range ( int ( input ( ) ) ) if i + 1 in [ 105 , 135 , 165 , 189 , 195 ] ] ) ) NEW_LINE", "import math NEW_LINE import collections NEW_LINE import fractions NEW_LINE import itertools NEW_LINE import functools NEW_LINE import operator NEW_LINE def yakusu_rekkyo ( n ) : NEW_LINE INDENT lower_divisors , upper_divisors = [ ] , [ ] NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT lower_divisors . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT upper_divisors . append ( n // i ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return lower_divisors + upper_divisors [ : : - 1 ] NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT hoge = 0 NEW_LINE for j in yakusu_rekkyo ( i ) : NEW_LINE INDENT if j % 2 == 1 : NEW_LINE INDENT hoge += 1 NEW_LINE DEDENT DEDENT if hoge == 8 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE return 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1292_A", "java": ["import static java . lang . Math . pow ; class Test { static void nthprimedigitsnumber ( long n ) { long len = 1 ; long prev_count = 0 ; while ( true ) { long curr_count = ( long ) ( prev_count + pow ( 4 , len ) ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( long j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + pow ( 4 , len - i ) < n ) prev_count += pow ( 4 , len - i ) ; else { if ( j == 1 ) System . out . print ( \"2\" ) ; else if ( j == 2 ) System . out . print ( \"3\" ) ; else if ( j == 3 ) System . out . print ( \"5\" ) ; else if ( j == 4 ) System . out . print ( \"7\" ) ; break ; } } } System . out . println ( ) ; } public static void main ( String args [ ] ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; } }"], "python": ["import math NEW_LINE def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 ; NEW_LINE prev_count = 0 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_count = ( prev_count + math . pow ( 4 , len ) ) ; NEW_LINE if ( prev_count < n and curr_count >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT len += 1 ; NEW_LINE prev_count = curr_count ; NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( prev_count + pow ( 4 , len - i ) < n ) : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( \"2\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 2 ) : NEW_LINE INDENT print ( \"3\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 3 ) : NEW_LINE INDENT print ( \"5\" , end = \" \" ) ; NEW_LINE DEDENT elif ( j == 4 ) : NEW_LINE INDENT print ( \"7\" , end = \" \" ) ; NEW_LINE DEDENT break ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT nthprimedigitsnumber ( 10 ) ; NEW_LINE nthprimedigitsnumber ( 21 ) ; NEW_LINE"]}
{"id": "codeforces_1354_B", "java": ["import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char [ ] string = in . next ( ) . toCharArray ( ) ; int left = 0 ; int right = 0 ; int min = Integer . MAX_VALUE ; Map < Character , Integer > unique = new HashMap < > ( ) ; while ( right < string . length ) { while ( right < string . length && unique . size ( ) < 3 ) { unique . merge ( string [ right ] , 1 , Integer :: sum ) ; right ++ ; } while ( left < right && unique . size ( ) == 3 ) { min = Math . min ( min , right - left ) ; unique . merge ( string [ left ] , - 1 , Integer :: sum ) ; if ( unique . get ( string [ left ] ) == 0 ) { unique . remove ( string [ left ] ) ; } left ++ ; } } System . out . println ( min == Integer . MAX_VALUE ? 0 : min ) ; } } }", "import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int runs = sc . nextInt ( ) ; while ( runs -- > 0 ) { String in = sc . next ( ) ; char [ ] arr = in . toCharArray ( ) ; int n = arr . length ; int [ ] last = new int [ ] { - n , - n , - n } ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr . length ; i ++ ) { last [ arr [ i ] - '1' ] = i ; int dist = 1 + i - Math . min ( Math . min ( last [ 0 ] , last [ 1 ] ) , last [ 2 ] ) ; min = Math . min ( min , dist ) ; } System . out . println ( min > arr . length ? 0 : min ) ; } } }", "import java . util . * ; import java . io . * ; public class Practice { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String num = scan . next ( ) ; int i1 = - 1 ; int i2 = - 1 ; int i3 = - 1 ; int ans = 0 ; for ( int j = 0 ; j < num . length ( ) ; j ++ ) { if ( num . charAt ( j ) == '1' ) { i1 = j ; } else if ( num . charAt ( j ) == '2' ) { i2 = j ; } else { i3 = j ; } if ( i1 != - 1 && i2 != - 1 && i3 != - 1 ) { int b = Math . max ( i1 , Math . max ( i2 , i3 ) ) - Math . min ( i1 , Math . min ( i2 , i3 ) ) + 1 ; if ( ans == 0 ) { ans = b ; } else { ans = Math . min ( ans , b ) ; } } } System . out . println ( ans ) ; } } }", "import java . util . Scanner ; public class cf1354B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { String in = scan . next ( ) ; int i1 = - 1 ; int i2 = - 1 ; int i3 = - 1 ; int ans = 0 ; for ( int j = 0 ; j < in . length ( ) ; j ++ ) { if ( in . charAt ( j ) == '1' ) { i1 = j ; } else if ( in . charAt ( j ) == '2' ) { i2 = j ; } else { i3 = j ; } if ( i1 != - 1 && i2 != - 1 && i3 != - 1 ) { if ( ans == 0 ) { ans = Math . max ( Math . max ( i1 , i2 ) , i3 ) - Math . min ( Math . min ( i1 , i2 ) , i3 ) + 1 ; } else { ans = Math . min ( ans , Math . max ( Math . max ( i1 , i2 ) , i3 ) - Math . min ( Math . min ( i1 , i2 ) , i3 ) + 1 ) ; } } } System . out . println ( ans ) ; } } }"], "python": ["num_lines = int ( input ( ) ) NEW_LINE for iii in range ( num_lines ) : NEW_LINE INDENT s = input ( ) NEW_LINE low_idx = 0 NEW_LINE high_idx = 0 NEW_LINE lowest_amount = - 1 NEW_LINE counts = [ 0 , 0 , 0 ] NEW_LINE counts [ int ( s [ 0 ] ) - 1 ] += 1 NEW_LINE is_valid = True NEW_LINE while ( counts [ 0 ] == 0 or counts [ 1 ] == 0 or counts [ 2 ] == 0 ) : NEW_LINE INDENT high_idx += 1 NEW_LINE if ( high_idx >= len ( s ) ) : NEW_LINE INDENT is_valid = False NEW_LINE break NEW_LINE DEDENT counts [ int ( s [ high_idx ] ) - 1 ] += 1 NEW_LINE DEDENT if ( not is_valid ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT assert ( high_idx >= 2 ) NEW_LINE lowest_amount = high_idx NEW_LINE while ( low_idx != len ( s ) - 1 ) : NEW_LINE INDENT if ( is_valid ) : NEW_LINE INDENT counts [ int ( s [ low_idx ] ) - 1 ] -= 1 NEW_LINE if ( counts [ int ( s [ low_idx ] ) - 1 ] == 0 ) : NEW_LINE INDENT is_valid = False NEW_LINE DEDENT low_idx += 1 NEW_LINE if ( is_valid ) : NEW_LINE INDENT lowest_amount = min ( lowest_amount , high_idx - low_idx ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( high_idx == len ( s ) - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT high_idx += 1 NEW_LINE counts [ int ( s [ high_idx ] ) - 1 ] += 1 NEW_LINE if ( counts [ int ( s [ high_idx ] ) - 1 ] == 1 ) : NEW_LINE INDENT is_valid = True NEW_LINE DEDENT DEDENT DEDENT print ( lowest_amount + 1 ) NEW_LINE DEDENT DEDENT s = \"\"\" STRNEWLINE \u001bc\u001b [ ?7l\u001b [ 2J\u001b [ 0mSeaBIOS \u2581 ( version \u2581 rel - 1.13.0-48 - gd9c812dda519 - prebuilt . qemu . org ) STRNEWLINE STRNEWLINE STRNEWLINE iPXE \u2581 ( http : / / ipxe . org ) \u2581 00:03.0 \u2581 CA00 \u2581 PCI2.10 \u2581 PnP \u2581 PMM + 07F8F290 + 07EEF290 \u2581 CA00 STRNEWLINE Press \u2581 Ctrl - B \u2581 to \u2581 configure \u2581 iPXE \u2581 ( PCI \u2581 00:03.0 ) . . . STRNEWLINE \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 STRNEWLINE STRNEWLINE STRNEWLINE Booting \u2581 from \u2581 Hard \u2581 Disk . . . xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx STRNEWLINE xxxxxxxxxxxxxxxxxxxxxxxxxx STRNEWLINE | \u2581 What \u2581 just \u2581 happened ? \u2581 Why \u2581 am \u2581 I \u2581 here ? STRNEWLINE | \u2581 Discovering \u2581 my \u2581 identity \u2581 and \u2581 features STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 CPUID : \u2581 AuthenticAMD STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 SSE3 STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 MONITOR / MWAIT STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 running \u2581 on \u2581 hypervisor STRNEWLINE | \u2581 totalProcs \u2581 4 STRNEWLINE | \u2581 memSize \u2581 0x7fd0000 \u2581 127MB STRNEWLINE | \u2581 localAPIC \u2581 fee00000 STRNEWLINE | \u2581 ioAPIC \u2581 fec00000 STRNEWLINE | \u2581 heap \u2581 range \u2581 0x100000 \u2581 0x600000 STRNEWLINE | \u2581 switched \u2581 to \u2581 new \u2581 UART STRNEWLINE instantiating \u2581 block \u2581 cahce STRNEWLINE | \u2581 pitInit \u2581 freq \u2581 1000Hz STRNEWLINE | \u2581 pitInit \u2581 divider \u2581 59659 STRNEWLINE | \u2581 APIT \u2581 running \u2581 at \u2581 1000116744Hz STRNEWLINE | \u2581 APIT \u2581 counter = 1000116 \u2581 for \u2581 1000Hz STRNEWLINE | \u2581 initialize \u2581 1 STRNEWLINE | \u2581 reset \u2581 1 STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 eip : 0x8000 STRNEWLINE | \u2581 initialize \u2581 2 STRNEWLINE | \u2581 reset \u2581 2 STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 eip : 0x8000 STRNEWLINE | \u2581 1 \u2581 enabling \u2581 interrupts , \u2581 I ' m \u2581 scared STRNEWLINE | \u2581 initialize \u2581 3 STRNEWLINE | \u2581 reset \u2581 3 STRNEWLINE | \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 eip : 0x8000 STRNEWLINE | \u2581 2 \u2581 enabling \u2581 interrupts , \u2581 I ' m \u2581 scared STRNEWLINE | \u2581 0 \u2581 enabling \u2581 interrupts , \u2581 I ' m \u2581 scared STRNEWLINE | \u2581 3 \u2581 enabling \u2581 interrupts , \u2581 I ' m \u2581 scared STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 2 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 3 STRNEWLINE instantiating \u2581 this \u2581 guy STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 4 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE * * * \u2581 block \u2581 size \u2581 is \u2581 1024 STRNEWLINE * * * \u2581 inode \u2581 size \u2581 is \u2581 128 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 directory STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1290 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1291 STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 7 \u2581 entries STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 4 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 14 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / hello STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 file STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 23 \u2581 bytes STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 1 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1380 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1381 STRNEWLINE * * * \u2581 you \u2581 can \u2581 read \u2581 files STRNEWLINE STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 13 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / goodbye STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 symbolic \u2581 link STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 link \u2581 size \u2581 is \u2581 5 STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 = > \u2581 hello STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / not _ there STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 does \u2581 not \u2581 exist STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 13 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / fotunes STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 file STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 26637 \u2581 bytes STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 1 \u2581 links STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1348 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1349 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1364 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1365 STRNEWLINE \" Oh , \u2581 that ' s \u2581 the \u2581 name \u2581 of \u2581 the \u2581 song , \u2581 is \u2581 it ? \" \u2581 Alice \u2581 said STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / . STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 directory STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 7 \u2581 entries STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 4 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / . . STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 directory STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 7 \u2581 entries STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 4 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 12 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / data STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 directory STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1316 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1317 STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 4 \u2581 entries STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 2 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 10 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 12 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 13 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / data / data . txt STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 file STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 33 \u2581 bytes STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 1 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1318 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1319 STRNEWLINE * * * \u2581 this \u2581 is \u2581 nice STRNEWLINE * * * \u2581 we \u2581 can \u2581 read STRNEWLINE STRNEWLINE * * * \u2581 STRNEWLINE * * * \u2581 w STRNEWLINE * * * \u2581 we STRNEWLINE * * * \u2581 we \u2581 STRNEWLINE * * * \u2581 we \u2581 c STRNEWLINE * * * \u2581 we \u2581 ca STRNEWLINE * * * \u2581 we \u2581 can STRNEWLINE * * * \u2581 we \u2581 can \u2581 STRNEWLINE * * * \u2581 we \u2581 can \u2581 r STRNEWLINE * * * \u2581 we \u2581 can \u2581 re STRNEWLINE * * * \u2581 we \u2581 can \u2581 rea STRNEWLINE * * * \u2581 we \u2581 can \u2581 read STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 13 STRNEWLINE * * * \u2581 looking \u2581 at \u2581 / data / panic . txt STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 is \u2581 a \u2581 file STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 contains \u2581 1736 \u2581 bytes STRNEWLINE * * * \u2581 \u2581 \u2581 \u2581 \u2581 \u2581 has \u2581 1 \u2581 links STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1320 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1321 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1322 STRNEWLINE STRNEWLINE ! ! ! ! READING \u2581 SECTOR \u2581 1323 STRNEWLINE * * * \u2581 Don ' t \u2581 panic STRNEWLINE * * * \u2581 STRNEWLINE STRNEWLINE shutdown STRNEWLINE \"\"\" NEW_LINE", "def ternary_string ( s ) : NEW_LINE INDENT if len ( s ) < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT shortest = len ( s ) + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE totals = [ 0 ] * 3 NEW_LINE done = False NEW_LINE while not done : NEW_LINE INDENT contains_all = totals [ 0 ] > 0 and totals [ 1 ] > 0 and totals [ 2 ] > 0 NEW_LINE if contains_all : NEW_LINE INDENT shortest = min ( shortest , end - start ) NEW_LINE DEDENT if shortest <= len ( s ) and shortest == 3 : NEW_LINE INDENT return 3 NEW_LINE DEDENT if contains_all : NEW_LINE INDENT removed_index = int ( s [ start ] ) - 1 NEW_LINE totals [ removed_index ] -= 1 NEW_LINE start += 1 NEW_LINE DEDENT elif end < len ( s ) : NEW_LINE INDENT added_index = int ( s [ end ] ) - 1 NEW_LINE totals [ added_index ] += 1 NEW_LINE end += 1 NEW_LINE DEDENT else : NEW_LINE INDENT done = True NEW_LINE DEDENT DEDENT if shortest > len ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return shortest NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT print ( ternary_string ( input ( ) ) ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE numCases = int ( input ( ) ) NEW_LINE while numCases > 0 : NEW_LINE INDENT text = input ( ) NEW_LINE counts = [ 0 ] * 3 NEW_LINE count = sys . maxsize NEW_LINE leftIndex = 0 NEW_LINE for i in range ( len ( text ) ) : NEW_LINE INDENT position = ord ( text [ i ] ) - 49 NEW_LINE counts [ position ] += 1 NEW_LINE while counts [ ord ( text [ leftIndex ] ) - 49 ] > 1 : NEW_LINE INDENT counts [ ord ( text [ leftIndex ] ) - 49 ] -= 1 NEW_LINE leftIndex += 1 NEW_LINE DEDENT if counts [ 0 ] != 0 and counts [ 1 ] != 0 and counts [ 2 ] != 0 : NEW_LINE INDENT count = min ( count , i - leftIndex + 1 ) NEW_LINE DEDENT DEDENT if count == sys . maxsize : NEW_LINE INDENT count = 0 NEW_LINE DEDENT print ( count ) NEW_LINE numCases -= 1 NEW_LINE DEDENT", "import math NEW_LINE def check_has_all_chars ( freq ) : NEW_LINE INDENT for k in freq . keys ( ) : NEW_LINE INDENT if freq [ k ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT t_num_test_cases = int ( input ( ) ) NEW_LINE for t in range ( t_num_test_cases ) : NEW_LINE INDENT given_input = input ( ) NEW_LINE shortest = math . inf NEW_LINE freq = { '1' : 0 , '2' : 0 , '3' : 0 } NEW_LINE lft = 0 NEW_LINE for rt in range ( len ( given_input ) ) : NEW_LINE INDENT freq [ given_input [ rt ] ] += 1 NEW_LINE while ( lft < len ( given_input ) and check_has_all_chars ( freq ) ) : NEW_LINE INDENT shortest = min ( shortest , rt - lft + 1 ) NEW_LINE freq [ given_input [ lft ] ] -= 1 NEW_LINE lft += 1 NEW_LINE DEDENT DEDENT if shortest == math . inf : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( shortest ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_660_B", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class SeatingOnBus { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = br . readLine ( ) . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; int bus [ ] [ ] = new int [ n ] [ 4 ] ; int person = 1 ; int currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 0 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 3 ] = person ; person ++ ; } currentRow ++ ; } currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 1 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 2 ] = person ; person ++ ; } currentRow ++ ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( bus [ i ] [ 1 ] != 0 ) { sb . append ( bus [ i ] [ 1 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 0 ] != 0 ) { sb . append ( bus [ i ] [ 0 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 2 ] != 0 ) { sb . append ( bus [ i ] [ 2 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 3 ] != 0 ) { sb . append ( bus [ i ] [ 3 ] ) ; sb . append ( \" \u2581 \" ) ; } } System . out . print ( sb . toString ( ) ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class SeatingOnBus { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = br . readLine ( ) . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; int bus [ ] [ ] = new int [ n ] [ 4 ] ; int person = 1 ; int currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 0 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 3 ] = person ; person ++ ; } currentRow ++ ; } currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 1 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 2 ] = person ; person ++ ; } currentRow ++ ; } StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( bus [ i ] [ 1 ] != 0 ) { sb . append ( bus [ i ] [ 1 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 0 ] != 0 ) { sb . append ( bus [ i ] [ 0 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 2 ] != 0 ) { sb . append ( bus [ i ] [ 2 ] ) ; sb . append ( \" \u2581 \" ) ; } if ( bus [ i ] [ 3 ] != 0 ) { sb . append ( bus [ i ] [ 3 ] ) ; sb . append ( \" \u2581 \" ) ; } } System . out . print ( sb . toString ( ) ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class SeatingOnBus { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] str = br . readLine ( ) . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( str [ 0 ] ) ; int m = Integer . parseInt ( str [ 1 ] ) ; int bus [ ] [ ] = new int [ n ] [ 4 ] ; int person = 1 ; int currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 0 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 3 ] = person ; person ++ ; } currentRow ++ ; } currentRow = 0 ; while ( ( person <= m ) && currentRow < n ) { bus [ currentRow ] [ 1 ] = person ; person ++ ; if ( person <= m ) { bus [ currentRow ] [ 2 ] = person ; person ++ ; } currentRow ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( bus [ i ] [ 1 ] != 0 ) { System . out . print ( bus [ i ] [ 1 ] + \" \u2581 \" ) ; } if ( bus [ i ] [ 0 ] != 0 ) { System . out . print ( bus [ i ] [ 0 ] + \" \u2581 \" ) ; } if ( bus [ i ] [ 2 ] != 0 ) { System . out . print ( bus [ i ] [ 2 ] + \" \u2581 \" ) ; } if ( bus [ i ] [ 3 ] != 0 ) { System . out . print ( bus [ i ] [ 3 ] + \" \u2581 \" ) ; } } } }", "import java . io . * ; import java . util . * ; import java . util . stream . Collectors ; import java . util . stream . Stream ; public class CodeForces { public static final int BUFFERSIZE = 512000 ; private static Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) , BUFFERSIZE ) ) ; private static PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out , BUFFERSIZE ) ) ; public static void solve ( ) throws Exception { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; final int inOrder [ ] = { 1 , 1 + 2 * n , 2 + 2 * n , 2 } ; final int outOrder [ ] = { 1 , 0 , 2 , 3 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { int seatIn = inOrder [ outOrder [ j ] ] + i * 2 ; if ( seatIn > m ) continue ; System . out . print ( seatIn + \" \u2581 \" ) ; } } } public static void main ( String args [ ] ) throws Exception { in . init ( System . in ) ; solve ( ) ; out . close ( ) ; } public static class in { static BufferedReader reader ; static StringTokenizer tokenizer ; static void init ( InputStream input ) { reader = new BufferedReader ( new InputStreamReader ( input ) , BUFFERSIZE ) ; tokenizer = new StringTokenizer ( \" \" ) ; } static String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; return tokenizer . nextToken ( ) ; } static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } static double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } static long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } } }"], "python": ["from itertools import zip_longest as zl NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if m - n * 2 <= 0 : NEW_LINE INDENT wind = list ( range ( 1 , m + 1 ) ) NEW_LINE prh = [ ] NEW_LINE DEDENT else : NEW_LINE INDENT man = range ( 1 , m + 1 ) NEW_LINE wind = list ( man [ : n * 2 ] ) NEW_LINE prh = list ( man [ n * 2 : ] ) NEW_LINE DEDENT for a , b in zl ( prh , wind , fillvalue = ' ' ) : NEW_LINE INDENT print ( str ( a ) + ' \u2581 ' + str ( b ) , end = ' \u2581 ' ) NEW_LINE DEDENT", "n , m = input ( ) . split ( ) NEW_LINE n , m = int ( n ) , int ( m ) NEW_LINE arr = [ [ 0 ] * n , [ 0 ] * n , [ 0 ] * n , [ 0 ] * n ] NEW_LINE passenger = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arr [ 0 ] [ i ] = passenger + ( 2 * n ) NEW_LINE arr [ 1 ] [ i ] = passenger NEW_LINE arr [ 2 ] [ i ] = passenger + ( 2 * n ) + 1 NEW_LINE arr [ 3 ] [ i ] = passenger + 1 NEW_LINE passenger += 2 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT if ( arr [ j ] [ i ] <= m ) : NEW_LINE INDENT print ( arr [ j ] [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT DEDENT print ( ' \\n ' ) NEW_LINE", "pairs , passa = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE data = [ ] NEW_LINE i = 0 NEW_LINE while i <= 2 * ( pairs - 1 ) : NEW_LINE INDENT if 2 * pairs + 1 + i <= passa : NEW_LINE INDENT data . append ( 2 * pairs + 1 + i ) NEW_LINE DEDENT if 1 + i <= passa : NEW_LINE INDENT data . append ( 1 + i ) NEW_LINE DEDENT if 2 * pairs + 2 + i <= passa : NEW_LINE INDENT data . append ( 2 * pairs + 2 + i ) NEW_LINE DEDENT if 2 + i <= passa : NEW_LINE INDENT data . append ( 2 + i ) NEW_LINE DEDENT i += 2 NEW_LINE DEDENT print ( \" \u2581 \" . join ( map ( str , data ) ) ) NEW_LINE", "num_inp = lambda : int ( input ( ) ) NEW_LINE arr_inp = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sp_inp = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE str_inp = lambda : input ( ) NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE A = [ ] NEW_LINE for i in range ( 1 , 2 * n , 2 ) : NEW_LINE INDENT A += [ 2 * n + i , i , 2 * n + i + 1 , i + 1 ] NEW_LINE DEDENT print ( * ( a for a in A if a <= m ) ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ' \u2581 ' ) ) NEW_LINE rows = [ list ( range ( 1 , 2 * n , 2 ) ) , list ( range ( 2 , 2 * n + 1 , 2 ) ) , list ( range ( 2 * n + 1 , 4 * n + 1 , 2 ) ) , list ( range ( 2 * n + 2 , 4 * n + 1 , 2 ) ) ] NEW_LINE final_list = [ ] NEW_LINE for ( LNW , LW , RNW , RW ) in zip ( rows [ 2 ] , rows [ 0 ] , rows [ 3 ] , rows [ 1 ] ) : NEW_LINE INDENT final_list . extend ( [ LNW , LW , RNW , RW ] ) NEW_LINE DEDENT for element in range ( len ( final_list ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if final_list [ element ] > m : NEW_LINE INDENT final_list . pop ( element ) NEW_LINE DEDENT DEDENT print ( * final_list , sep = ( ' \u2581 ' ) ) NEW_LINE"]}
{"id": "geeksforgeeks_706_A", "java": ["class GFG { static int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; } public static void main ( String [ ] args ) { int L = 1 , R = 632 ; System . out . println ( maxAND ( L , R ) ) ; } }"], "python": ["def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1467_A", "java": ["class GFG { static int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } public static void main ( String args [ ] ) { int [ ] a = { - 1 , 0 , 1 , 2 } ; int n = a . length ; System . out . print ( Minimum_Operations ( a , n ) ) ; } }"], "python": ["def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE"]}
{"id": "atcoder_ABC093_B", "java": ["import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( A + i <= B ) { System . out . println ( A + i ) ; } } for ( int j = K - 1 ; j >= 0 ; j -- ) { if ( B - j > A + K - 1 ) { System . out . println ( B - j ) ; } } } }", "import java . util . HashSet ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { HashSet < Integer > values = new HashSet < > ( ) ; Scanner input = new Scanner ( System . in ) ; int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int k = input . nextInt ( ) ; int acopy = a ; StringBuilder out = new StringBuilder ( ) ; for ( int i = 0 ; i < k && acopy <= b ; i ++ ) { out . append ( acopy ) . append ( \" \\n \" ) ; values . add ( acopy ) ; acopy ++ ; } int secandCopy = Math . max ( a , b - k ) + 1 ; for ( int i = 0 ; i < k && secandCopy <= b ; i ++ ) { if ( ! values . contains ( secandCopy ) ) { out . append ( secandCopy ) . append ( \" \\n \" ) ; values . add ( secandCopy ) ; } secandCopy ++ ; } System . out . print ( out ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String args [ ] ) { FastReader sc = new FastReader ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int i = a ; for ( ; i < a + k && i <= b ; i ++ ) { if ( i <= b ) System . out . println ( i ) ; } i -- ; for ( int j = b - k + 1 ; j <= b ; j ++ ) { if ( i < j ) System . out . println ( j ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long A = in . nextLong ( ) ; long B = in . nextLong ( ) ; long K = in . nextLong ( ) ; long a = A ; long cnt = 0 ; if ( K > B - A ) { K = B - A + 1 ; } while ( cnt < K ) { System . out . println ( a ) ; a ++ ; cnt ++ ; } long cnt2 = 0 ; long b = B - K + 1 ; while ( cnt2 < K ) { if ( b >= a ) { System . out . println ( b ) ; } cnt2 ++ ; b ++ ; } } }", "import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; if ( ( b - a ) < 2 * k ) { for ( int i = a ; i <= b ; i ++ ) { System . out . println ( i ) ; } } else { List < Integer > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { list . add ( a + i ) ; list . add ( b - i ) ; } Collections . sort ( list ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { System . out . println ( list . get ( i ) ) ; } } } }"], "python": ["import math NEW_LINE import itertools NEW_LINE import sys NEW_LINE import copy NEW_LINE A , B , K = map ( int , input ( ) . split ( ) ) NEW_LINE if B - A < K * 2 : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( A , A + K ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT for i in range ( B - K + 1 , B + 1 ) : NEW_LINE INDENT print ( str ( i ) ) NEW_LINE DEDENT DEDENT", "import sys , re NEW_LINE from math import ceil , floor , sqrt , pi , factorial , gcd NEW_LINE from copy import deepcopy NEW_LINE from collections import Counter , deque NEW_LINE from heapq import heapify , heappop , heappush NEW_LINE from itertools import accumulate , product , combinations , combinations_with_replacement NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE from functools import reduce NEW_LINE from decimal import Decimal , getcontext NEW_LINE def i_input ( ) : return int ( input ( ) ) NEW_LINE def i_map ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def i_list ( ) : return list ( i_map ( ) ) NEW_LINE def i_row ( N ) : return [ i_input ( ) for _ in range ( N ) ] NEW_LINE def i_row_list ( N ) : return [ i_list ( ) for _ in range ( N ) ] NEW_LINE def s_input ( ) : return input ( ) NEW_LINE def s_map ( ) : return input ( ) . split ( ) NEW_LINE def s_list ( ) : return list ( s_map ( ) ) NEW_LINE def s_row ( N ) : return [ s_input for _ in range ( N ) ] NEW_LINE def s_row_str ( N ) : return [ s_list ( ) for _ in range ( N ) ] NEW_LINE def s_row_list ( N ) : return [ list ( s_input ( ) ) for _ in range ( N ) ] NEW_LINE def lcm ( a , b ) : return a * b // gcd ( a , b ) NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE INF = float ( ' inf ' ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE num_list = [ ] NEW_LINE str_list = [ ] NEW_LINE def main ( ) : NEW_LINE INDENT a , b , k = i_map ( ) NEW_LINE ans_list = [ ] NEW_LINE for i in range ( a , a + k ) : NEW_LINE INDENT if i > b : NEW_LINE INDENT continue NEW_LINE DEDENT ans_list . append ( i ) NEW_LINE DEDENT for i in range ( b - k + 1 , b + 1 ) : NEW_LINE INDENT if i < a : NEW_LINE INDENT continue NEW_LINE DEDENT ans_list . append ( i ) NEW_LINE DEDENT ans_list = list ( set ( ans_list ) ) NEW_LINE for num in ans_list : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A , B , K = map ( int , input ( ) . split ( ) ) NEW_LINE answer = [ ] NEW_LINE for i in range ( K ) : NEW_LINE INDENT n = A + i NEW_LINE if n <= B : NEW_LINE INDENT answer . append ( n ) NEW_LINE DEDENT m = B - i NEW_LINE if A <= m : NEW_LINE INDENT answer . append ( m ) NEW_LINE DEDENT DEDENT answer = sorted ( list ( set ( answer ) ) ) NEW_LINE for i in range ( len ( answer ) ) : NEW_LINE INDENT print ( answer [ i ] ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE def solve ( A : int , B : int , K : int ) : NEW_LINE INDENT if ( B - A + 1 ) <= 2 * K : NEW_LINE INDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( A , A + K ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT for i in range ( B - K + 1 , B + 1 ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT def iterate_tokens ( ) : NEW_LINE INDENT for line in sys . stdin : NEW_LINE INDENT for word in line . split ( ) : NEW_LINE INDENT yield word NEW_LINE DEDENT DEDENT DEDENT tokens = iterate_tokens ( ) NEW_LINE A = int ( next ( tokens ) ) NEW_LINE B = int ( next ( tokens ) ) NEW_LINE K = int ( next ( tokens ) ) NEW_LINE solve ( A , B , K ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "def resolve ( ) : NEW_LINE INDENT a , b , k = map ( int , input ( ) . split ( ) ) NEW_LINE realk = min ( b - a + 1 , k ) NEW_LINE ans = list ( range ( a , a + realk ) ) NEW_LINE ans += list ( range ( b - realk + 1 , b + 1 ) ) NEW_LINE answer = sorted ( list ( set ( ans ) ) ) NEW_LINE for i in answer : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT resolve ( ) NEW_LINE"]}
{"id": "codeforces_157_A", "java": ["import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; FastReader in = new FastReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , FastReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { mat [ i ] [ j ] = in . nextInt ( ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int col = 0 , raw = 0 ; for ( int k = 0 ; k < n ; k ++ ) { col += mat [ i ] [ k ] ; raw += mat [ k ] [ j ] ; } if ( col < raw ) res ++ ; } } out . println ( res ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public FastReader ( InputStream is ) { br = new BufferedReader ( new InputStreamReader ( is ) ) ; } public String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . List ; import java . util . Scanner ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws FileNotFoundException { Scanner read = new Scanner ( System . in ) ; int n = read . nextInt ( ) , arr [ ] [ ] = new int [ n ] [ n ] , col [ ] = new int [ n ] , row [ ] = new int [ n ] , c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = read . nextInt ( ) ; row [ i ] += arr [ i ] [ j ] ; col [ j ] += arr [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( col [ i ] > row [ j ] ) c ++ ; } } System . out . println ( c ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; TaskA solver = new TaskA ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskA { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; int [ ] cols = new int [ n ] ; int [ ] rows = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { int tmp = in . nextInt ( ) ; rows [ i ] += tmp ; cols [ j ] += tmp ; } } int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( cols [ j ] > rows [ i ] ) ++ ans ; out . println ( ans ) ; } } }", "import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; int size = Integer . parseInt ( reader . readLine ( ) ) ; int [ ] [ ] grid = new int [ size ] [ size ] ; StringTokenizer tok ; for ( int i = 0 ; i < size ; i ++ ) { tok = new StringTokenizer ( reader . readLine ( ) ) ; for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) { grid [ i ] [ j ] = Integer . parseInt ( tok . nextToken ( ) ) ; } } int [ ] col = new int [ size ] , row = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { row [ i ] += grid [ i ] [ j ] ; col [ j ] += grid [ i ] [ j ] ; } } int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { if ( col [ i ] > row [ j ] ) count ++ ; } } System . out . println ( count ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE lst , row , col = [ ] , [ ] , [ ] NEW_LINE ans = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT z = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lst . append ( z ) NEW_LINE row . append ( sum ( z ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT z = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT z . append ( lst [ j ] [ i ] ) NEW_LINE DEDENT col . append ( sum ( z ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if col [ i ] > row [ j ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE", "n , A = int ( input ( ) ) , [ ] NEW_LINE for i in range ( n ) : A . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE print ( sum ( 1 for i in range ( n ) for j in range ( n ) if sum ( A [ i ] ) < sum ( list ( zip ( * A ) ) [ j ] ) ) ) NEW_LINE", "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE def ii ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def li ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT from math import sqrt NEW_LINE def perfect_sq ( n ) : NEW_LINE INDENT x = int ( sqrt ( n ) ) NEW_LINE while x * x < n : NEW_LINE INDENT x += 1 NEW_LINE DEDENT while x * x > n : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT return ( x * x == n ) NEW_LINE DEDENT n = ii ( ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = li ( ) NEW_LINE l . append ( a ) NEW_LINE DEDENT rsum = [ 0 for i in range ( n ) ] NEW_LINE csum = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT rsum [ i ] += l [ i ] [ j ] NEW_LINE csum [ j ] += l [ i ] [ j ] NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if csum [ j ] > rsum [ i ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . append ( l ) NEW_LINE DEDENT sr = [ ] NEW_LINE sc = [ ] NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sr . append ( sum ( a [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT s += a [ j ] [ i ] NEW_LINE DEDENT sc . append ( s ) NEW_LINE DEDENT for x in sc : NEW_LINE INDENT for y in sr : NEW_LINE INDENT if x > y : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = [ [ int ( j ) for j in input ( ) . split ( ) ] for i in range ( n ) ] NEW_LINE r = [ sum ( a [ k ] [ j ] for j in range ( n ) ) for k in range ( n ) ] NEW_LINE c = [ sum ( a [ i ] [ k ] for i in range ( n ) ) for k in range ( n ) ] NEW_LINE res = sum ( 1 for j in range ( n ) for i in range ( n ) if c [ j ] > r [ i ] ) NEW_LINE print ( res ) NEW_LINE"]}
{"id": "geeksforgeeks_2574_A", "java": ["class GFG { static String toNegativeBase ( int n , int negBase ) { if ( n == 0 ) return \"0\" ; String converted = \" \" ; while ( n != 0 ) { int remainder = n % negBase ; n /= negBase ; if ( remainder < 0 ) { remainder += ( - negBase ) ; n += 1 ; } converted = String . valueOf ( remainder ) + converted ; } return converted ; } public static void main ( String [ ] args ) { int n = 13 ; int negBase = - 2 ; System . out . print ( toNegativeBase ( n , negBase ) ) ; } }"], "python": ["def toNegativeBase ( n , negBase ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT converted = \"01\" NEW_LINE while ( n != 0 ) : NEW_LINE INDENT remainder = n % ( negBase ) NEW_LINE n = int ( n / negBase ) NEW_LINE if ( remainder < 0 ) : NEW_LINE INDENT remainder += ( ( - 1 ) * negBase ) NEW_LINE n += 1 NEW_LINE DEDENT converted = str ( remainder ) + converted NEW_LINE DEDENT return converted NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE negBase = - 2 NEW_LINE print ( toNegativeBase ( n , negBase ) ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC103_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String line = sc . nextLine ( ) ; String [ ] s = line . split ( \" \u2581 \" , 0 ) ; int n = s . length ; int num [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( num ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += num [ i + 1 ] - num [ i ] ; } System . out . println ( ans ) ; } }", "import java . util . ArrayList ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; ArrayList < Integer > listA = new ArrayList < Integer > ( ) ; Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; listA . add ( a ) ; listA . add ( b ) ; listA . add ( c ) ; ArrayList < Integer > listB = new ArrayList < Integer > ( new HashSet < > ( listA ) ) ; Collections . sort ( listB ) ; int cost = 0 ; for ( int i = 1 ; i < listB . size ( ) ; i ++ ) { int tmp = listB . get ( i - 1 ) - listB . get ( i ) ; cost = cost + Math . abs ( tmp ) ; } System . out . println ( cost ) ; sc . close ( ) ; return ; } }", "import java . util . * ; public class Main { static long N ; static int M ; static int A ; static long B ; static long C ; static int [ ] [ ] map ; static int min = 9999999 ; static int [ ] moto = new int [ 3 ] ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; moto [ 0 ] = scanner . nextInt ( ) ; moto [ 1 ] = scanner . nextInt ( ) ; moto [ 2 ] = scanner . nextInt ( ) ; Arrays . sort ( moto ) ; System . out . println ( ( moto [ 1 ] - moto [ 0 ] ) + ( moto [ 2 ] - moto [ 1 ] ) ) ; } }", "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner Cf = new Scanner ( System . in ) ; int [ ] A = new int [ 3 ] ; A [ 0 ] = Cf . nextInt ( ) ; A [ 1 ] = Cf . nextInt ( ) ; A [ 2 ] = Cf . nextInt ( ) ; Solver ( A ) ; Cf . close ( ) ; } public static void Solver ( int [ ] A ) { Arrays . sort ( A ) ; int diff = 0 ; for ( int i = 1 ; i < A . length ; i ++ ) { diff = Math . abs ( A [ i ] - A [ i - 1 ] ) + diff ; } System . out . println ( diff ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] ary = new int [ 3 ] ; ary [ 0 ] = sc . nextInt ( ) ; ary [ 1 ] = sc . nextInt ( ) ; ary [ 2 ] = sc . nextInt ( ) ; if ( ary [ 0 ] > ary [ 1 ] ) { int cap = ary [ 0 ] ; ary [ 0 ] = ary [ 1 ] ; ary [ 1 ] = cap ; } if ( ary [ 1 ] > ary [ 2 ] ) { int cap = ary [ 1 ] ; ary [ 1 ] = ary [ 2 ] ; ary [ 2 ] = cap ; } if ( ary [ 0 ] > ary [ 1 ] ) { int cap = ary [ 0 ] ; ary [ 0 ] = ary [ 1 ] ; ary [ 1 ] = cap ; } int cost = 0 ; cost += Math . abs ( ary [ 1 ] - ary [ 0 ] ) ; cost += Math . abs ( ary [ 2 ] - ary [ 1 ] ) ; System . out . println ( cost ) ; } }"], "python": ["a = sorted ( [ int ( j ) for j in input ( ) . split ( ) ] ) NEW_LINE cost = 0 NEW_LINE for j in range ( len ( a ) - 1 ) : NEW_LINE INDENT cost += abs ( a [ j ] - a [ j + 1 ] ) NEW_LINE DEDENT print ( cost ) NEW_LINE", "def main ( ) : NEW_LINE INDENT tasks = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE tasks . sort ( ) NEW_LINE print ( abs ( tasks [ 0 ] - tasks [ 1 ] ) + abs ( tasks [ 1 ] - tasks [ 2 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE ab = abs ( a - b ) NEW_LINE bc = abs ( b - c ) NEW_LINE ca = abs ( c - a ) NEW_LINE print ( min ( [ ab + bc , bc + ca , ca + ab ] ) ) NEW_LINE", "from itertools import combinations NEW_LINE def resolve ( ) : NEW_LINE INDENT seq = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE cos = [ ] NEW_LINE comb = combinations ( seq , 2 ) NEW_LINE for el in comb : NEW_LINE INDENT cos . append ( abs ( el [ 0 ] - el [ 1 ] ) ) NEW_LINE DEDENT print ( sum ( cos ) - max ( cos ) ) NEW_LINE DEDENT resolve ( ) NEW_LINE", "import itertools NEW_LINE a = input ( ) . split ( ) NEW_LINE dict = { } NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT dict [ i ] = int ( a [ i ] ) NEW_LINE DEDENT ans = 1000 NEW_LINE b = list ( itertools . permutations ( [ 0 , 1 , 2 ] ) ) NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT x = abs ( dict [ b [ i ] [ 2 ] ] - dict [ b [ i ] [ 1 ] ] ) + abs ( dict [ b [ i ] [ 1 ] ] - dict [ b [ i ] [ 0 ] ] ) NEW_LINE if x < ans : NEW_LINE INDENT ans = x NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_2912_A", "java": ["class GFG { static int RSF ( int n ) { while ( n >= 10 ) { int x = n ; int l = 0 ; while ( n > 0 ) { n = n / 10 ; l ++ ; } int a [ ] = new int [ l ] ; int i = l - 1 ; while ( x > 0 ) { a [ i ] = x % 10 ; x = x / 10 ; i -- ; } for ( int j = 0 ; j < l - 1 ; j ++ ) { n = n * 10 + Math . abs ( a [ j ] - a [ j + 1 ] ) ; } } return n ; } public static void main ( String [ ] arg ) { int n = 6972 ; int ans = RSF ( n ) ; System . out . println ( ans ) ; } }"], "python": ["def RSF ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT x = n ; NEW_LINE l = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n // 10 ; NEW_LINE l += 1 ; NEW_LINE DEDENT a = [ 0 ] * l ; NEW_LINE i = l - 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT a [ i ] = x % 10 ; NEW_LINE x = x // 10 ; NEW_LINE i -= 1 ; NEW_LINE DEDENT for j in range ( 0 , l - 1 ) : NEW_LINE INDENT n = n * 10 + abs ( a [ j ] - a [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return n ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 614 ; NEW_LINE ans = RSF ( n ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_933_A", "java": ["class GFG { static class Node { int data ; Node next ; } ; static Node circular ( Node head ) { Node start = head ; while ( head . next != null ) head = head . next ; head . next = start ; return start ; } static Node push ( Node head , int data ) { Node newNode = new Node ( ) ; newNode . data = data ; newNode . next = ( head ) ; ( head ) = newNode ; return head ; } static void displayList ( Node node ) { Node start = node ; while ( node . next != start ) { System . out . print ( \" \u2581 \" + node . data ) ; node = node . next ; } System . out . print ( \" \u2581 \" + node . data ) ; } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 15 ) ; head = push ( head , 14 ) ; head = push ( head , 13 ) ; head = push ( head , 22 ) ; head = push ( head , 17 ) ; circular ( head ) ; System . out . print ( \" Display \u2581 list : \u2581 \\n \" ) ; displayList ( head ) ; } }"], "python": ["import sys NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT newNode = Node ( data ) NEW_LINE newNode . next = head NEW_LINE head = newNode NEW_LINE return head NEW_LINE DEDENT def circular ( head ) : NEW_LINE INDENT start = head NEW_LINE while ( head . next is not None ) : NEW_LINE INDENT head = head . next NEW_LINE DEDENT head . next = start NEW_LINE return start NEW_LINE DEDENT def displayList ( node ) : NEW_LINE INDENT start = node NEW_LINE while ( node . next is not start ) : NEW_LINE INDENT print ( \" { } \u2581 \" . format ( node . data ) , end = \" \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" { } \u2581 \" . format ( node . data ) , end = \" \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 15 ) NEW_LINE head = push ( head , 14 ) NEW_LINE head = push ( head , 13 ) NEW_LINE head = push ( head , 22 ) NEW_LINE head = push ( head , 17 ) NEW_LINE circular ( head ) NEW_LINE print ( \" Display \u2581 List : \" ) NEW_LINE displayList ( head ) NEW_LINE DEDENT"]}
{"id": "leetcode_482_A", "java": ["class Solution { public String licenseKeyFormatting ( String s , int k ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) != ' - ' ) sb . append ( sb . length ( ) % ( k + 1 ) == k ? ' - ' : \" \" ) . append ( s . charAt ( i ) ) ; return sb . reverse ( ) . toString ( ) . toUpperCase ( ) ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1122_A", "java": ["class GFG { static double EPS = 1E-15 ; static double findMinValue ( double arr [ ] , double n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( double ) Math . log10 ( arr [ i ] ) + EPS ; double xl = ( double ) ( sum / n + EPS ) ; double res = Math . pow ( ( double ) 10.0 , ( double ) xl ) + EPS ; return ( double ) Math . ceil ( res + EPS ) ; } public static void main ( String [ ] args ) { double arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; double n = arr . length ; System . out . println ( findMinValue ( arr , n ) ) ; } }"], "python": ["import math NEW_LINE EPS = 1E-15 ; NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( arr [ i ] ) + EPS ; NEW_LINE DEDENT xl = ( sum / n + EPS ) ; NEW_LINE res = math . pow ( 10.0 , xl ) + EPS ; NEW_LINE return math . ceil ( res + EPS ) ; NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 10 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinValue ( arr , n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_2784_A", "java": ["import java . util . * ; public class GfG { static int digroot ( int n ) { int root = 0 ; while ( n > 0 || root > 9 ) { if ( n == 0 ) { n = root ; root = 0 ; } root += n % 10 ; n /= 10 ; } return root ; } public static void main ( String argc [ ] ) { int n = 65785412 ; System . out . println ( digroot ( n ) ) ; } }"], "python": ["import math NEW_LINE def digitalRoot ( num ) : NEW_LINE INDENT if ( num == \"0\" ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT ans = ( ans + int ( num [ i ] ) ) % 9 NEW_LINE DEDENT if ( ans == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ans % 9 NEW_LINE DEDENT DEDENT num = \"65785412\" NEW_LINE print ( digitalRoot ( num ) ) NEW_LINE"]}
{"id": "codeforces_727_A", "java": ["import java . util . * ; import java . io . * ; public class Solution { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String str [ ] = br . readLine ( ) . split ( \" \u2581 \" ) ; int m = Integer . parseInt ( str [ 0 ] ) ; int n = Integer . parseInt ( str [ 1 ] ) ; ArrayList < Integer > ans = new ArrayList < Integer > ( ) ; if ( check ( m , n , ans ) ) { System . out . println ( \" YES \" ) ; System . out . println ( ans . size ( ) ) ; for ( int i = ans . size ( ) - 1 ; i >= 0 ; i -- ) System . out . print ( ans . get ( i ) + \" \u2581 \" ) ; } else { System . out . println ( \" NO \" ) ; } } public static boolean check ( int m , int n , ArrayList < Integer > ans ) { if ( m == n ) { ans . add ( m ) ; return true ; } else if ( n < m ) return false ; if ( n % 10 == 1 ) { ans . add ( n ) ; n = n / 10 ; } else if ( n % 2 == 0 ) { ans . add ( n ) ; n = n / 2 ; } else return false ; return check ( m , n , ans ) ; } }", "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int a = in . nextInt ( ) , b = in . nextInt ( ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; list . add ( b ) ; while ( b > a ) { if ( b % 2 == 0 ) { b /= 2 ; } else if ( b % 10 == 1 ) { b = ( b - 1 ) / 10 ; } else { break ; } list . add ( b ) ; } if ( a == b ) { pw . println ( \" YES \" ) ; Collections . sort ( list ) ; Collections . reverse ( list ) ; pw . println ( list . size ( ) ) ; for ( int i = list . size ( ) - 1 ; i >= 0 ; i -- ) { pw . print ( list . get ( i ) + \" \u2581 \" ) ; } } else { pw . println ( \" NO \" ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }", "import java . util . * ; public class transformationab { public static void printSpace ( List < Integer > out ) { for ( int i = out . size ( ) - 1 ; i >= 0 ; i -- ) { System . out . print ( out . get ( i ) + \" \u2581 \" ) ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int start = sc . nextInt ( ) ; int end = sc . nextInt ( ) ; if ( start < 0 || end < 0 ) { System . out . println ( \" NO \" ) ; return ; } List < Integer > out = new ArrayList ( ) ; out . add ( end ) ; while ( end > 0 ) { if ( end % 2 == 0 ) { out . add ( end / 2 ) ; end = end / 2 ; } else if ( ( end - 1 ) % 10 == 0 ) { out . add ( ( end - 1 ) / 10 ) ; end -= 1 ; end = end / 10 ; } else { break ; } if ( start == end ) { break ; } } if ( out . get ( out . size ( ) - 1 ) != start ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; System . out . println ( out . size ( ) ) ; printSpace ( out ) ; } } }", "import java . util . ArrayList ; import java . util . * ; public class Main { public static void printAllValue ( long a , long b , List < Long > temp ) { if ( a == b ) { temp . add ( a ) ; System . out . println ( \" YES \" ) ; System . out . println ( temp . size ( ) ) ; for ( int i = 0 ; i < temp . size ( ) ; i ++ ) { System . out . print ( temp . get ( i ) + \" \u2581 \" ) ; } return ; } if ( a > b ) { return ; } temp . add ( a ) ; printAllValue ( 2 * a , b , temp ) ; printAllValue ( ( 10 * a ) + 1 , b , temp ) ; temp . remove ( temp . size ( ) - 1 ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; List < Long > temp = new ArrayList ( ) ; printAllValue ( a , b , temp ) ; if ( temp . size ( ) == 0 ) { System . out . println ( \" NO \" ) ; } } }", "import java . util . * ; public class test { static List < Long > result = new ArrayList < Long > ( ) ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; Boolean isValid = transform ( a , b , new ArrayList < Long > ( ) ) ; if ( isValid ) { System . out . println ( \" YES \" ) ; System . out . println ( result . size ( ) ) ; for ( Long val : result ) { System . out . print ( val + \" \u2581 \" ) ; } } else { System . out . println ( \" NO \" ) ; } } private static boolean transform ( long curr , long target , List < Long > temp ) { if ( curr > target ) { return false ; } if ( curr == target ) { temp . add ( curr ) ; result = new ArrayList ( temp ) ; return true ; } temp . add ( curr ) ; boolean path1 = transform ( curr * 2 , target , temp ) ; boolean path2 = transform ( curr * 10 + 1 , target , temp ) ; temp . remove ( temp . size ( ) - 1 ) ; return path1 || path2 ; } }"], "python": ["n1 , n2 = map ( int , ( input ( ) . split ( ) ) ) NEW_LINE sequence = [ ] NEW_LINE found = False NEW_LINE def change ( num , seq , n2 ) : NEW_LINE INDENT if num == n2 : NEW_LINE INDENT global found , sequence NEW_LINE found = True NEW_LINE sequence = seq . copy ( ) NEW_LINE return NEW_LINE DEDENT if num > n2 : NEW_LINE INDENT return NEW_LINE DEDENT change ( num * 2 , seq + [ num * 2 ] , n2 ) NEW_LINE change ( ( num * 10 ) + 1 , seq + [ ( num * 10 ) + 1 ] , n2 ) NEW_LINE DEDENT change ( n1 , [ n1 ] , n2 ) NEW_LINE if found : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( len ( sequence ) ) NEW_LINE for n in sequence : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "def transform ( start_num , count , arr ) : NEW_LINE INDENT global b , found NEW_LINE if found : NEW_LINE INDENT return NEW_LINE DEDENT if start_num > b : NEW_LINE INDENT return NEW_LINE DEDENT if start_num == b : NEW_LINE INDENT found = True NEW_LINE print ( ' YES ' ) NEW_LINE print ( count + 1 ) NEW_LINE print ( * arr ) NEW_LINE return NEW_LINE DEDENT n_arr_1 = arr . copy ( ) NEW_LINE n_arr_1 . append ( 2 * start_num ) NEW_LINE transform ( 2 * start_num , count + 1 , n_arr_1 ) NEW_LINE n_arr_2 = arr . copy ( ) NEW_LINE n_arr_2 . append ( 10 * start_num + 1 ) NEW_LINE transform ( 10 * start_num + 1 , count + 1 , n_arr_2 ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE found = False NEW_LINE arr = [ a ] NEW_LINE transform ( a , 0 , arr ) NEW_LINE if not found : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT DEDENT", "a , b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE y = ' ' NEW_LINE l = [ b ] NEW_LINE while b != a : NEW_LINE INDENT if a > b : NEW_LINE INDENT y = ' NO ' NEW_LINE break NEW_LINE DEDENT if b % 2 == 0 : NEW_LINE INDENT b = int ( b / 2 ) NEW_LINE if b == a : NEW_LINE INDENT l . append ( b ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( b ) NEW_LINE DEDENT DEDENT elif str ( b ) [ - 1 ] == '1' : NEW_LINE INDENT b = str ( b ) [ : - 1 ] NEW_LINE b = int ( b ) NEW_LINE l . append ( b ) NEW_LINE DEDENT else : NEW_LINE INDENT y = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT if y == ' NO ' : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( len ( l ) ) NEW_LINE print ( * l [ : : - 1 ] ) NEW_LINE DEDENT", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE def create ( a , b ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT return [ [ ] , 0 ] NEW_LINE DEDENT if a == b : NEW_LINE INDENT return [ [ ] , 1 ] NEW_LINE DEDENT c = create ( a * 2 , b ) NEW_LINE d = create ( 10 * a + 1 , b ) NEW_LINE if c [ 1 ] : NEW_LINE INDENT return [ [ a ] + c [ 0 ] , 1 ] NEW_LINE DEDENT if d [ 1 ] : NEW_LINE INDENT return [ [ a ] + d [ 0 ] , 1 ] NEW_LINE DEDENT return [ [ ] , 0 ] NEW_LINE DEDENT arr = create ( a , b ) NEW_LINE if arr == [ [ ] , 0 ] : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE m = arr [ 0 ] NEW_LINE print ( len ( m ) + 1 ) NEW_LINE for i in m : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT print ( b ) NEW_LINE DEDENT", "import copy NEW_LINE ab = input ( ) NEW_LINE ab = list ( map ( int , ab . split ( ) ) ) NEW_LINE a , b = ab [ 0 ] , ab [ 1 ] NEW_LINE vector = [ a ] NEW_LINE answer = [ ] NEW_LINE def a_to_b ( a , b , vector , answer ) : NEW_LINE INDENT if a > b : NEW_LINE INDENT return False NEW_LINE DEDENT elif a == b : NEW_LINE INDENT answer = copy . deepcopy ( vector ) NEW_LINE print ( ' YES ' ) NEW_LINE print ( len ( answer ) ) NEW_LINE for i in answer : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT return True NEW_LINE DEDENT vector . append ( 2 * a ) NEW_LINE p1 = a_to_b ( 2 * a , b , vector , answer ) NEW_LINE vector . remove ( vector [ - 1 ] ) NEW_LINE vector . append ( 10 * a + 1 ) NEW_LINE p2 = a_to_b ( 10 * a + 1 , b , vector , answer ) NEW_LINE vector . remove ( vector [ - 1 ] ) NEW_LINE return p1 or p2 NEW_LINE DEDENT p = a_to_b ( a , b , vector , answer ) NEW_LINE if p == False : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_622_A", "java": ["class GFG { static int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = a . length ; System . out . println ( k_sum ( a , n , k ) ) ; } }"], "python": ["def k_sum ( a , n , k ) : NEW_LINE INDENT r , sum = 0 , 0 ; NEW_LINE ans = 0 ; NEW_LINE for l in range ( n ) : NEW_LINE INDENT while ( sum < k ) : NEW_LINE INDENT if ( r == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += a [ r ] ; NEW_LINE r += 1 ; NEW_LINE DEDENT DEDENT if ( sum < k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT ans += n - r + 1 ; NEW_LINE sum -= a [ l ] ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT a = [ 6 , 1 , 2 , 7 ] ; k = 10 ; NEW_LINE n = len ( a ) ; NEW_LINE print ( k_sum ( a , n , k ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_3860_A", "java": ["class GFG { static char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { sum += ( str . charAt ( i ) - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } } public static void main ( String [ ] args ) { String str = \" gfg \" ; System . out . println ( getChar ( str ) ) ; } }"], "python": ["def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = \" gfg \" NEW_LINE print ( getChar ( strr ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4604_A", "java": ["public class GFG { static int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int f [ ] = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; } public static void main ( String args [ ] ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int n = 3 ; int m = A . length ; System . out . println ( sumNth ( A , B , m , n ) ) ; } }"], "python": ["def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_4865_A", "java": ["import java . util . * ; class GFG { static void odd_even ( int arr [ ] , int n ) { Vector < Integer > odd_indexes = new Vector < Integer > ( ) ; Vector < Integer > even_indexes = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . add ( arr [ i ] ) ; else even_indexes . add ( arr [ i ] ) ; } Collections . sort ( odd_indexes ) ; Collections . sort ( even_indexes ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) System . out . print ( odd_indexes . get ( i ) + \" \u2581 \" ) ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) System . out . print ( even_indexes . get ( i ) + \" \u2581 \" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 7 , 6 , 8 } ; int n = arr . length ; odd_even ( arr , n ) ; } }"], "python": ["def odd_even ( n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if i % 2 == 0 : odd_indexes . append ( n [ i ] ) NEW_LINE else : even_indexes . append ( n [ i ] ) NEW_LINE DEDENT for i in sorted ( odd_indexes ) : print ( i , end = \" \u2581 \" ) NEW_LINE for i in sorted ( even_indexes ) : print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT n = [ 3 , 2 , 7 , 6 , 8 ] NEW_LINE odd_even ( n ) NEW_LINE"]}
{"id": "geeksforgeeks_1448_A", "java": ["import java . util . * ; class solution { static void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { boolean flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { System . out . print ( ( arr [ i + j ] ) + \" \u2581 \" ) ; flag = true ; break ; } } if ( ! flag ) System . out . print ( \"0\" + \" \u2581 \" ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 } ; int n = arr . length ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; } }"], "python": ["def printFirstNegativeInteger ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , ( n - k + 1 ) ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( 0 , k ) : NEW_LINE INDENT if ( arr [ i + j ] < 0 ) : NEW_LINE INDENT print ( arr [ i + j ] , end = \" \u2581 \" ) NEW_LINE flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( not ( flag ) ) : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 12 , - 1 , - 7 , 8 , - 15 , 30 , 16 , 28 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printFirstNegativeInteger ( arr , n , k ) NEW_LINE"]}
{"id": "geeksforgeeks_750_A", "java": ["class Prefix { static void fillPrefixSum ( int arr [ ] , int n , int prefixSum [ ] ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 4 , 16 , 20 } ; int n = arr . length ; int prefixSum [ ] = new int [ n ] ; fillPrefixSum ( arr , n , prefixSum ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( prefixSum [ i ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; } }"], "python": ["def fillPrefixSum ( arr , n , prefixSum ) : NEW_LINE INDENT prefixSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 10 , 4 , 16 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE prefixSum = [ 0 for i in range ( n + 1 ) ] NEW_LINE fillPrefixSum ( arr , n , prefixSum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( prefixSum [ i ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT"]}
{"id": "aizu_p00081_A", "java": ["import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String format = \" % .6f \u2581 % .6f % n \" ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] input = line . split ( \" , \" ) ; double x1 = Double . parseDouble ( input [ 0 ] ) ; double y1 = Double . parseDouble ( input [ 1 ] ) ; double x2 = Double . parseDouble ( input [ 2 ] ) ; double y2 = Double . parseDouble ( input [ 3 ] ) ; double xq = Double . parseDouble ( input [ 4 ] ) ; double yq = Double . parseDouble ( input [ 5 ] ) ; if ( x1 == x2 ) { double x = ( x1 - xq ) + x1 ; System . out . printf ( format , x , yq ) ; } else if ( y1 == y2 ) { double y = ( y1 - yq ) + y1 ; System . out . printf ( format , xq , y ) ; } else { double alpha = ( y2 - y1 ) / ( x2 - x1 ) ; double x = ( ( 1 - alpha * alpha ) * xq + 2 * alpha * yq + 2 * alpha * alpha * x1 - 2 * alpha * y1 ) / ( alpha * alpha + 1 ) ; double y = ( xq - x ) / alpha + yq ; System . out . printf ( format , x , y ) ; } } } }", "import java . awt . geom . Point2D ; import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; Point2D . Double p1 , p2 , q , r ; String st [ ] ; while ( sc . hasNext ( ) ) { st = sc . next ( ) . split ( \" , \" ) ; p1 = new Point2D . Double ( Double . valueOf ( st [ 0 ] ) , Double . valueOf ( st [ 1 ] ) ) ; p2 = new Point2D . Double ( Double . valueOf ( st [ 2 ] ) , Double . valueOf ( st [ 3 ] ) ) ; q = new Point2D . Double ( Double . valueOf ( st [ 4 ] ) , Double . valueOf ( st [ 5 ] ) ) ; r = new Point2D . Double ( ) ; if ( p1 . x == p2 . x ) { r . x = p1 . x + p1 . x - q . x ; r . y = q . y ; } else if ( p1 . y == p2 . y ) { r . x = q . x ; r . y = p1 . y + p1 . y - q . y ; } else { double a1 , b1 , a2 , b2 ; double x , y ; a1 = ( p2 . y - p1 . y ) / ( p2 . x - p1 . x ) ; b1 = p1 . y - a1 * p1 . x ; a2 = - 1.0 / a1 ; b2 = q . y - a2 * q . x ; x = ( b2 - b1 ) / ( a1 - a2 ) ; y = a1 * x + b1 ; r . x = x + x - q . x ; r . y = y + y - q . y ; } System . out . println ( r . x + \" \u2581 \" + r . y ) ; } } }", "import java . util . * ; class Pair { double x ; double y ; Pair ( double x , double y ) { this . x = x ; this . y = y ; } } public class Main { public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; while ( stdIn . hasNext ( ) ) { String [ ] str = stdIn . next ( ) . split ( \" , \" ) ; Pair [ ] p = new Pair [ 3 ] ; for ( int i = 0 ; i < 3 ; ++ i ) { p [ i ] = new Pair ( Double . parseDouble ( str [ 2 * i ] ) , Double . parseDouble ( str [ 2 * i + 1 ] ) ) ; } if ( p [ 0 ] . y == p [ 1 ] . y ) { System . out . println ( p [ 2 ] . x + \" \u2581 \" + ( p [ 0 ] . y - ( p [ 2 ] . y - p [ 0 ] . y ) ) ) ; } else if ( p [ 0 ] . x == p [ 1 ] . x ) { System . out . println ( ( p [ 0 ] . x + ( p [ 0 ] . x - p [ 2 ] . x ) ) + \" \u2581 \" + p [ 2 ] . y ) ; } else { double a1 = ( p [ 1 ] . y - p [ 0 ] . y ) / ( p [ 1 ] . x - p [ 0 ] . x ) ; double b1 = p [ 0 ] . y - a1 * p [ 0 ] . x ; double a2 = - 1 / a1 ; double b2 = p [ 2 ] . y - a2 * p [ 2 ] . x ; double x = ( b1 - b2 ) / ( a2 - a1 ) ; double y = a2 * x + b2 ; double dx = x - p [ 2 ] . x ; double dy = y - p [ 2 ] . y ; System . out . println ( ( x + dx ) + \" \u2581 \" + ( y + dy ) ) ; } } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintStream ; class Main { public static void main ( String [ ] args ) throws IOException { doit ( args , System . in , System . out ) ; } static void doit ( String [ ] args , InputStream in , PrintStream out ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . isEmpty ( ) ) { continue ; } String [ ] values = line . split ( \" , \" ) ; double x1 = Double . parseDouble ( values [ 0 ] ) ; double y1 = Double . parseDouble ( values [ 1 ] ) ; double x2 = Double . parseDouble ( values [ 2 ] ) ; double y2 = Double . parseDouble ( values [ 3 ] ) ; double xq = Double . parseDouble ( values [ 4 ] ) ; double yq = Double . parseDouble ( values [ 5 ] ) ; double xr = - xq ; double yr = yq ; if ( x1 != x2 ) { double a = ( y2 - y1 ) / ( x2 - x1 ) ; xr = - 2.0 * a / ( 1 + a * a ) * ( y1 - yq - a * ( x1 - xq ) ) + xq ; yr = 2.0 / ( 1 + a * a ) * ( y1 - yq - a * ( x1 - xq ) ) + yq ; } out . println ( xr + \" \u2581 \" + yr ) ; } } }", "import java . util . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { int INF = 1 << 28 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { double x [ ] = new double [ 3 ] ; double y [ ] = new double [ 3 ] ; String [ ] str = sc . next ( ) . split ( \" , \" ) ; for ( int i = 0 ; i < 3 ; i ++ ) { x [ i ] = Double . parseDouble ( str [ 2 * i ] ) ; y [ i ] = Double . parseDouble ( str [ 2 * i + 1 ] ) ; } double dx = x [ 1 ] - x [ 0 ] ; double dy = y [ 1 ] - y [ 0 ] ; double rety = ( x [ 2 ] - 2 * x [ 0 ] ) * dx * dy - ( y [ 2 ] - 2 * y [ 0 ] ) * dx * dx + dy * dx * x [ 2 ] + dy * dy * y [ 2 ] ; double retx = ( y [ 2 ] - 2 * y [ 0 ] ) * dx * dy - ( x [ 2 ] - 2 * x [ 0 ] ) * dy * dy + dx * dx * x [ 2 ] + dx * dy * y [ 2 ] ; rety /= dx * dx + dy * dy ; retx /= dx * dx + dy * dy ; System . out . println ( retx + \" \u2581 \" + rety ) ; } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }"], "python": ["from math import sqrt , atan2 , cos , sin NEW_LINE while ( 1 ) : NEW_LINE INDENT try : NEW_LINE INDENT x1 , y1 , x2 , y2 , xq , yq = [ float ( i ) for i in input ( ) . split ( \" , \" ) ] NEW_LINE r = sqrt ( ( xq - x1 ) ** 2 + ( yq - y1 ) ** 2 ) NEW_LINE th1 = atan2 ( y2 - y1 , x2 - x1 ) NEW_LINE th2 = atan2 ( yq - y1 , xq - x1 ) NEW_LINE th3 = - ( th2 - th1 ) + th1 NEW_LINE print ( \" { : . 6f } \u2581 { : . 6f } \" . format ( x1 + r * cos ( th3 ) , y1 + r * sin ( th3 ) ) ) NEW_LINE DEDENT except EOFError : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT", "def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def norm ( a ) : NEW_LINE INDENT return a . real ** 2 + a . imag ** 2 NEW_LINE DEDENT def project ( line , p ) : NEW_LINE INDENT base = line [ 1 ] - line [ 0 ] NEW_LINE r = dot ( p - line [ 0 ] , base ) / norm ( base ) NEW_LINE return line [ 0 ] + base * r NEW_LINE DEDENT def symmetric_Point ( line , p ) : NEW_LINE INDENT return p + 2 * ( project ( line , p ) - p ) NEW_LINE DEDENT while True : NEW_LINE INDENT try : p = list ( map ( float , input ( ) . split ( ' , ' ) ) ) NEW_LINE except : break NEW_LINE line = [ ] NEW_LINE line . append ( complex ( p [ 0 ] , p [ 1 ] ) ) NEW_LINE line . append ( complex ( p [ 2 ] , p [ 3 ] ) ) NEW_LINE pp = complex ( p [ 4 ] , p [ 5 ] ) NEW_LINE qq = symmetric_Point ( line , pp ) NEW_LINE print ( qq . real , qq . imag ) NEW_LINE DEDENT", "import sys NEW_LINE import os NEW_LINE import math NEW_LINE class Vector2 ( ) : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . _x = float ( x ) NEW_LINE self . _y = float ( y ) NEW_LINE DEDENT def normalize ( self ) : NEW_LINE INDENT norm = self . norm ( ) NEW_LINE return Vector2 ( self . _x / norm , self . _y / norm ) NEW_LINE DEDENT def norm ( self ) : NEW_LINE INDENT return math . sqrt ( self . _x ** 2 + self . _y ** 2 ) NEW_LINE DEDENT def dot ( self , other ) : NEW_LINE INDENT return self . _x * other . _x + self . _y * other . _y NEW_LINE DEDENT def __add__ ( self , other ) : NEW_LINE INDENT return Vector2 ( self . _x + other . _x , self . _y + other . _y ) NEW_LINE DEDENT def __sub__ ( self , other ) : NEW_LINE INDENT return Vector2 ( self . _x - other . _x , self . _y - other . _y ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT round_x = round ( self . _x , 6 ) NEW_LINE round_y = round ( self . _y , 6 ) NEW_LINE return \" { } \u2581 { } \" . format ( round_x , round_y ) NEW_LINE DEDENT def __mul__ ( self , scale ) : NEW_LINE INDENT return Vector2 ( self . _x * scale , self . _y * scale ) NEW_LINE DEDENT DEDENT for s in sys . stdin : NEW_LINE INDENT x1 , y1 , x2 , y2 , xq , yq = map ( float , s . split ( ' , ' ) ) NEW_LINE OP1 = Vector2 ( x1 , y1 ) NEW_LINE OP2 = Vector2 ( x2 , y2 ) NEW_LINE OQ = Vector2 ( xq , yq ) NEW_LINE P2P1 = OP2 - OP1 NEW_LINE N = P2P1 . normalize ( ) NEW_LINE P1Q = OQ - OP1 NEW_LINE dot = P1Q . dot ( N ) NEW_LINE P1O = N * dot NEW_LINE QO = P1O - P1Q NEW_LINE OR = OP1 + P1O + QO NEW_LINE print ( OR ) NEW_LINE DEDENT", "import sys , math , os NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == \" True \" : NEW_LINE INDENT sys . stdin = open ( \" sample - input . txt \" , \" rt \" ) NEW_LINE DEDENT def symmetric_point ( x1 , y1 , x2 , y2 , xq , yq ) : NEW_LINE INDENT rx = x2 - x1 NEW_LINE ry = y2 - y1 NEW_LINE det = - rx ** 2 - ry ** 2 NEW_LINE det_s = rx * ( yq - y1 ) - ry * ( xq - x1 ) NEW_LINE s = det_s / det NEW_LINE xr = xq - 2 * s * ry NEW_LINE yr = yq + 2 * s * rx NEW_LINE return xr , yr NEW_LINE DEDENT for line in sys . stdin : NEW_LINE INDENT x1 , y1 , x2 , y2 , xq , yq = [ float ( _ ) for _ in line . split ( ' , ' ) ] NEW_LINE xr , yr = symmetric_point ( x1 , y1 , x2 , y2 , xq , yq ) NEW_LINE print ( \" % .6f \u2581 % .6f \" % ( xr , yr ) ) NEW_LINE DEDENT", "import sys NEW_LINE from math import * NEW_LINE for e in sys . stdin : NEW_LINE INDENT a , b , c , d , e , f = map ( float , e . split ( ' , ' ) ) NEW_LINE z , w , q = complex ( a , b ) , complex ( c , d ) , complex ( e , f ) NEW_LINE z += ( z - w ) * ( q - z ) . conjugate ( ) / ( z - w ) . conjugate ( ) NEW_LINE print ( z . real , z . imag ) NEW_LINE DEDENT"]}
{"id": "codeforces_1554_B", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class cobb { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int tcase = Integer . parseInt ( f . readLine ( ) ) ; for ( int p = 0 ; p < tcase ; p ++ ) { StringTokenizer st1 = new StringTokenizer ( f . readLine ( ) ) ; int n = Integer . parseInt ( st1 . nextToken ( ) ) ; int k = Integer . parseInt ( st1 . nextToken ( ) ) ; long [ ] vals = new long [ n ] ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { vals [ i ] = Long . parseLong ( st . nextToken ( ) ) ; } long ans = Long . MIN_VALUE ; int start = Math . max ( 0 , n - 201 ) ; for ( int i = start ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = Math . max ( ans , ( ( long ) ( i + 1 ) * ( long ) ( j + 1 ) ) - k * ( vals [ i ] | vals [ j ] ) ) ; } } System . out . println ( ans ) ; } } }", "import java . io . * ; import java . util . * ; public class new1 { public static void main ( String [ ] args ) throws IOException { FastReader s = new FastReader ( ) ; int t = s . nextInt ( ) ; for ( int z = 0 ; z < t ; z ++ ) { int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; int [ ] arr = new int [ n ] ; long max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = s . nextInt ( ) ; for ( int i = n - 1 ; i >= Math . max ( 0 , n - 210 ) ; i -- ) { for ( int j = n - 1 ; j >= Math . max ( 0 , n - 210 ) ; j -- ) { if ( i == j ) continue ; long val = ( i + 1 ) * ( long ) ( j + 1 ) - k * ( long ) ( arr [ i ] | arr [ j ] ) ; max = Math . max ( max , val ) ; } } System . out . println ( max ) ; } } } class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE bit = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE low = n * ( n - 1 ) - 2 * k * n NEW_LINE maxvalue = low NEW_LINE for ni in range ( 2 , n + 1 ) : NEW_LINE INDENT a = max ( int ( low // ni ) + 1 , 1 ) NEW_LINE if a < ni : NEW_LINE INDENT for nj in range ( a , ni ) : NEW_LINE INDENT maxvalue = max ( maxvalue , ni * nj - k * ( bit [ nj - 1 ] | bit [ ni - 1 ] ) ) NEW_LINE DEDENT DEDENT DEDENT print ( maxvalue ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l = max ( 0 , n - 2 * k - 1 ) NEW_LINE ans = - 1e12 NEW_LINE for i in range ( l , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans = max ( ans , ( i + 1 ) * ( j + 1 ) - k * ( a [ i ] | a [ j ] ) ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE t -= 1 NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxi = - 99999999999999 NEW_LINE l1 = max ( 0 , n - 2 * k - 1 ) NEW_LINE for i in range ( l1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = ( i + 1 ) * ( j + 1 ) - k * ( l [ i ] | l [ j ] ) NEW_LINE maxi = max ( res , maxi ) NEW_LINE DEDENT DEDENT print ( maxi ) NEW_LINE DEDENT", "from sys import stdin NEW_LINE input = stdin . readline NEW_LINE MX = int ( 2e5 + 5 ) NEW_LINE MOD = int ( 1e9 + 7 ) NEW_LINE def main ( ) : NEW_LINE INDENT test = int ( input ( ) ) NEW_LINE for _ in range ( test ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ara = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE idx = max ( 0 , n - 2 * k ) NEW_LINE ans = - n * n NEW_LINE for i in range ( idx , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT temp = ( i + 1 ) * ( j + 1 ) - k * ( ara [ i ] | ara [ j ] ) NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE inpu = sys . stdin . readline NEW_LINE prin = sys . stdout . write NEW_LINE for _ in range ( int ( inpu ( ) ) ) : NEW_LINE INDENT n , k = map ( int , inpu ( ) . split ( ) ) NEW_LINE lis = list ( map ( int , inpu ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE ans = n * ( n - 1 ) - k * ( lis [ n - 1 ] | lis [ n - 2 ] ) NEW_LINE for i in range ( n , 1 , - 1 ) : NEW_LINE INDENT a = lis [ i - 1 ] NEW_LINE if i * ( i - 1 ) < ans : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT ans = max ( ans , i * j - k * ( a | lis [ j - 1 ] ) ) NEW_LINE DEDENT DEDENT prin ( str ( ans ) + ' \\n ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2663_A", "java": ["import java . util . * ; import java . lang . * ; class GFG { static int MAX_CHAR = 26 ; public static void commonCharacters ( String str [ ] , int n ) { Boolean [ ] prim = new Boolean [ MAX_CHAR ] ; Arrays . fill ( prim , new Boolean ( true ) ) ; for ( int i = 0 ; i < n ; i ++ ) { Boolean [ ] sec = new Boolean [ MAX_CHAR ] ; Arrays . fill ( sec , new Boolean ( false ) ) ; for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { if ( prim [ str [ i ] . charAt ( j ) - ' a ' ] ) sec [ str [ i ] . charAt ( j ) - ' a ' ] = true ; } System . arraycopy ( sec , 0 , prim , 0 , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) { System . out . print ( Character . toChars ( i + 97 ) ) ; System . out . print ( \" \u2581 \" ) ; } } public static void main ( String [ ] args ) { String str [ ] = { \" geeksforgeeks \" , \" gemkstones \" , \" acknowledges \" , \" aguelikes \" } ; int n = str . length ; commonCharacters ( str , n ) ; } }"], "python": ["MAX_CHAR = 26 NEW_LINE def commonCharacters ( strings , n ) : NEW_LINE INDENT prim = [ True ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT sec = [ False ] * MAX_CHAR NEW_LINE for j in range ( len ( strings [ i ] ) ) : NEW_LINE INDENT if ( prim [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT sec [ ord ( strings [ i ] [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT prim [ i ] = sec [ i ] NEW_LINE DEDENT DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( prim [ i ] ) : NEW_LINE INDENT print ( \" % c \u2581 \" % ( i + ord ( ' a ' ) ) , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT strings = [ \" geeksforgeeks \" , \" gemkstones \" , \" acknowledges \" , \" aguelikes \" ] NEW_LINE n = len ( strings ) NEW_LINE commonCharacters ( strings , n ) NEW_LINE"]}
{"id": "leetcode_448_A", "java": ["class Solution { public List < Integer > findDisappearedNumbers ( int [ ] nums ) { List < Integer > ret = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int val = Math . abs ( nums [ i ] ) - 1 ; if ( nums [ val ] > 0 ) { nums [ val ] = - nums [ val ] ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { ret . add ( i + 1 ) ; } } return ret ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_3028_A", "java": ["import java . io . * ; import java . util . * ; class GFG { public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } public static void main ( String [ ] args ) { System . out . println ( \" Maximum \u2581 value \u2581 of \" + \" \u2581 integer \u2581 \" + findMaxValue ( ) ) ; } }"], "python": ["import sys NEW_LINE def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( \" Maximum \u2581 value \u2581 of \u2581 integer : \" , findMaxValue ( ) ) ; NEW_LINE DEDENT"]}
{"id": "aizu_p02385_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { static String [ ] a ; static String [ ] b ; static String temp ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; a = scanner . nextLine ( ) . split ( \" \u2581 \" ) ; b = scanner . nextLine ( ) . split ( \" \u2581 \" ) ; char [ ] c = { ' E ' , ' E ' , ' E ' , ' N ' , ' W ' , ' W ' , ' W ' , ' S ' } ; boolean flag = false ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( char d : c ) { roll ( d ) ; if ( Arrays . equals ( a , b ) ) { flag = true ; break ; } } } if ( flag ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void roll ( char c ) { switch ( c ) { case ' E ' : temp = a [ 0 ] ; a [ 0 ] = a [ 3 ] ; a [ 3 ] = a [ 5 ] ; a [ 5 ] = a [ 2 ] ; a [ 2 ] = temp ; break ; case ' N ' : temp = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = a [ 5 ] ; a [ 5 ] = a [ 4 ] ; a [ 4 ] = temp ; break ; case ' W ' : temp = a [ 0 ] ; a [ 0 ] = a [ 2 ] ; a [ 2 ] = a [ 5 ] ; a [ 5 ] = a [ 3 ] ; a [ 3 ] = temp ; break ; default : temp = a [ 0 ] ; a [ 0 ] = a [ 4 ] ; a [ 4 ] = a [ 5 ] ; a [ 5 ] = a [ 1 ] ; a [ 1 ] = temp ; break ; } } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . HashMap ; public class Main { public static void main ( String [ ] args ) throws Exception { String [ ] strRing = { \"24532453\" , \"64136413\" , \"56215621\" , \"51265126\" , \"63146314\" , \"54235423\" } ; String strT , strS , strB ; int nE = 0 , nW = 0 ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] strValue = br . readLine ( ) . split ( \" \u2581 \" ) ; HashMap < String , String > map = new HashMap < String , String > ( ) ; for ( int i = 0 ; i < 6 ; i ++ ) { map . put ( strValue [ i ] , Integer . toString ( i + 1 ) ) ; } String [ ] str = br . readLine ( ) . split ( \" \u2581 \" ) ; strT = map . get ( str [ 0 ] ) ; strS = map . get ( str [ 1 ] ) ; strB = Integer . toString ( 7 - Integer . parseInt ( strT ) ) ; String strBST = strB + strS + strT ; for ( int i = 0 ; i < 6 ; i ++ ) { if ( - 1 < strRing [ i ] . indexOf ( strBST ) ) { nE = i ; nW = 5 - i ; } } if ( strValue [ nE ] . equals ( str [ 2 ] ) && strValue [ nW ] . equals ( str [ 3 ] ) ) { int nB = Integer . parseInt ( strB ) ; System . out . println ( strValue [ nB - 1 ] . equals ( str [ 5 ] ) ? \" Yes \" : \" No \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "import java . util . Arrays ; import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int a [ ] , b [ ] ; a = new int [ 7 ] ; b = new int [ 7 ] ; int h ; boolean flag = false ; for ( int i = 1 ; i < 7 ; i ++ ) { a [ i ] = scan . nextInt ( ) ; } for ( int i = 1 ; i < 7 ; i ++ ) { b [ i ] = scan . nextInt ( ) ; } for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { if ( flag == true ) break ; h = a [ 2 ] ; a [ 2 ] = a [ 3 ] ; a [ 3 ] = a [ 5 ] ; a [ 5 ] = a [ 4 ] ; a [ 4 ] = h ; flag = Arrays . equals ( a , b ) ; } if ( i == 0 || i == 4 ) { h = a [ 1 ] ; a [ 1 ] = a [ 3 ] ; a [ 3 ] = a [ 6 ] ; a [ 6 ] = a [ 4 ] ; a [ 4 ] = h ; } else { h = a [ 1 ] ; a [ 1 ] = a [ 2 ] ; a [ 2 ] = a [ 6 ] ; a [ 6 ] = a [ 5 ] ; a [ 5 ] = h ; } } if ( flag == true ) { System . out . println ( \" Yes \" ) ; } else { System . out . println ( \" No \" ) ; } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { static String [ ] a ; static String [ ] b ; static String temp ; public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; a = scanner . nextLine ( ) . split ( \" \u2581 \" ) ; b = scanner . nextLine ( ) . split ( \" \u2581 \" ) ; char [ ] c = { ' E ' , ' E ' , ' E ' , ' N ' , ' W ' , ' W ' , ' W ' , ' S ' } ; boolean flag = false ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( char d : c ) { roll ( d ) ; if ( Arrays . equals ( a , b ) ) { flag = true ; break ; } } } if ( flag ) System . out . println ( \" Yes \" ) ; else System . out . println ( \" No \" ) ; } public static void roll ( char c ) { switch ( c ) { case ' E ' : temp = a [ 0 ] ; a [ 0 ] = a [ 3 ] ; a [ 3 ] = a [ 5 ] ; a [ 5 ] = a [ 2 ] ; a [ 2 ] = temp ; break ; case ' N ' : temp = a [ 0 ] ; a [ 0 ] = a [ 1 ] ; a [ 1 ] = a [ 5 ] ; a [ 5 ] = a [ 4 ] ; a [ 4 ] = temp ; break ; case ' W ' : temp = a [ 0 ] ; a [ 0 ] = a [ 2 ] ; a [ 2 ] = a [ 5 ] ; a [ 5 ] = a [ 3 ] ; a [ 3 ] = temp ; break ; default : temp = a [ 0 ] ; a [ 0 ] = a [ 4 ] ; a [ 4 ] = a [ 5 ] ; a [ 5 ] = a [ 1 ] ; a [ 1 ] = temp ; break ; } } }"], "python": ["def swap ( dice , i , j , k , l ) : NEW_LINE INDENT x = dice [ l ] NEW_LINE dice [ l ] = dice [ k ] NEW_LINE dice [ k ] = dice [ j ] NEW_LINE dice [ j ] = dice [ i ] NEW_LINE dice [ i ] = x NEW_LINE return dice NEW_LINE DEDENT def Sroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 1 , 5 , 4 ) NEW_LINE return dice NEW_LINE DEDENT def Eroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 2 , 5 , 3 ) NEW_LINE return dice NEW_LINE DEDENT def Wroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 3 , 5 , 2 ) NEW_LINE return dice NEW_LINE DEDENT def Nroll ( dice ) : NEW_LINE INDENT dice = swap ( dice , 0 , 4 , 5 , 1 ) NEW_LINE return dice NEW_LINE DEDENT dice1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dice2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE top = dice1 [ 0 ] NEW_LINE fro = dice1 [ 1 ] NEW_LINE for j in range ( 0 , 8 ) : NEW_LINE INDENT if ( fro == dice2 [ 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( j == 3 ) : NEW_LINE INDENT dice2 = Eroll ( dice2 ) NEW_LINE DEDENT dice2 = Sroll ( dice2 ) NEW_LINE DEDENT while ( top != dice2 [ 0 ] ) : NEW_LINE INDENT dice2 = Eroll ( dice2 ) NEW_LINE DEDENT if ( dice1 [ 2 ] == dice2 [ 2 ] ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT", "import sys NEW_LINE side = ( ( 2 - 1 , 3 - 1 , 5 - 1 , 4 - 1 ) , ( 6 - 1 , 3 - 1 , 1 - 1 , 4 - 1 ) , ( 1 - 1 , 2 - 1 , 6 - 1 , 5 - 1 ) , ( 1 - 1 , 5 - 1 , 6 - 1 , 2 - 1 ) , ( 1 - 1 , 3 - 1 , 6 - 1 , 4 - 1 ) , ( 5 - 1 , 3 - 1 , 2 - 1 , 4 - 1 ) ) NEW_LINE def check_rotate ( face1 , face2 , f2_index ) : NEW_LINE INDENT f1_bot = face1 [ 5 ] NEW_LINE if face2 [ 5 - f2_index ] != f1_bot : NEW_LINE INDENT return False NEW_LINE DEDENT f2_side_index = side [ f2_index ] * 2 NEW_LINE f2_side = [ face2 [ f2_side_index [ i ] ] for i in range ( len ( f2_side_index ) ) ] NEW_LINE f1_side = [ face1 [ i ] for i in ( 2 - 1 , 3 - 1 , 5 - 1 , 4 - 1 ) ] NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT if f1_side == f2_side [ i : i + 4 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def check_ident ( face1 , face2 ) : NEW_LINE INDENT f1_top = face1 [ 0 ] NEW_LINE for index in range ( len ( face2 ) ) : NEW_LINE INDENT if face2 [ index ] == f1_top : NEW_LINE INDENT if check_rotate ( face1 , face2 , index ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT face1 = sys . stdin . readline ( ) . split ( ) NEW_LINE face2 = sys . stdin . readline ( ) . split ( ) NEW_LINE if check_ident ( face1 , face2 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT", "d , e = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] ; e [ 3 ] , e [ 4 ] = e [ 4 ] , e [ 3 ] NEW_LINE t = 0 NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT m = { 0 : '012345' , 1 : '152304' , 2 : '215043' , 3 : '310542' , 4 : '402351' , 5 : '513240' } [ i ] NEW_LINE f = [ d [ int ( j ) ] for j in m ] ; f [ 3 ] , f [ 4 ] = f [ 4 ] , f [ 3 ] NEW_LINE if f [ 0 ] == e [ 0 ] : NEW_LINE INDENT f = f [ 1 : 5 ] * 2 NEW_LINE for j in range ( 4 ) : NEW_LINE INDENT if f [ j : j + 4 ] == e [ 1 : 5 ] : t = 1 NEW_LINE DEDENT DEDENT DEDENT print ( ( ' No ' , ' Yes ' ) [ t == 1 ] ) NEW_LINE", "ptn = [ \"23542\" , \"14631\" , \"12651\" , \"15621\" , \"13641\" , \"32453\" ] NEW_LINE def rNO ( d ) : NEW_LINE INDENT global ptn NEW_LINE for i , e in enumerate ( ptn ) : NEW_LINE INDENT if d in e : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT dice1 = list ( input ( ) . split ( \" \u2581 \" ) ) NEW_LINE dice2 = list ( input ( ) . split ( \" \u2581 \" ) ) NEW_LINE e = dice1 [ 2 ] NEW_LINE d2 = [ \" \" , \" \" ] NEW_LINE for i , v in enumerate ( dice2 ) : NEW_LINE INDENT if dice1 [ 0 ] == v : NEW_LINE INDENT d2 [ 0 ] = str ( i + 1 ) NEW_LINE DEDENT if dice1 [ 1 ] == v : NEW_LINE INDENT d2 [ 1 ] = str ( i + 1 ) NEW_LINE DEDENT DEDENT d2Idx = rNO ( \" \" . join ( d2 ) ) NEW_LINE if dice1 [ 2 ] == dice2 [ d2Idx ] : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT", "class Dice : NEW_LINE INDENT def __init__ ( self , a , b , c , d , e , f ) : NEW_LINE INDENT self . face1 = a NEW_LINE self . face2 = b NEW_LINE self . face3 = c NEW_LINE self . face4 = d NEW_LINE self . face5 = e NEW_LINE self . face6 = f NEW_LINE DEDENT def above_face ( self ) : NEW_LINE INDENT return self . face1 NEW_LINE DEDENT def roll ( self , order ) : NEW_LINE INDENT if order == ' N ' : NEW_LINE INDENT tmp = self . face1 NEW_LINE self . face1 = self . face2 NEW_LINE self . face2 = self . face6 NEW_LINE self . face6 = self . face5 NEW_LINE self . face5 = tmp NEW_LINE DEDENT elif order == ' S ' : NEW_LINE INDENT tmp = self . face1 NEW_LINE self . face1 = self . face5 NEW_LINE self . face5 = self . face6 NEW_LINE self . face6 = self . face2 NEW_LINE self . face2 = tmp NEW_LINE DEDENT elif order == ' W ' : NEW_LINE INDENT tmp = self . face1 NEW_LINE self . face1 = self . face3 NEW_LINE self . face3 = self . face6 NEW_LINE self . face6 = self . face4 NEW_LINE self . face4 = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp = self . face1 NEW_LINE self . face1 = self . face4 NEW_LINE self . face4 = self . face6 NEW_LINE self . face6 = self . face3 NEW_LINE self . face3 = tmp NEW_LINE DEDENT DEDENT DEDENT a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE dice1 = Dice ( a , b , c , d , e , f ) NEW_LINE a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) NEW_LINE dice2 = Dice ( a , b , c , d , e , f ) NEW_LINE import random NEW_LINE flag = False NEW_LINE for i in ' NNNNWNNNWNNNENNNENNNWNNN ' : NEW_LINE INDENT dice1 . roll ( i ) NEW_LINE if dice1 . face1 == dice2 . face1 and dice1 . face2 == dice2 . face2 and dice1 . face3 == dice2 . face3 and dice1 . face4 == dice2 . face4 and dice1 . face5 == dice2 . face5 and dice1 . face6 == dice2 . face6 : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT"]}
{"id": "codeforces_1616_A", "java": ["import java . util . * ; public class MainClass { public static int count ( String s , char value ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == value ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; HashSet < Integer > ss = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = sc . nextInt ( ) ; if ( ss . contains ( k ) ) { ss . add ( - k ) ; } else ss . add ( k ) ; } System . out . println ( ss . size ( ) ) ; } } }", "import java . util . LinkedHashSet ; import java . util . Scanner ; import java . util . Set ; public class A1616 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; while ( t -- > 0 ) { int n = scanner . nextInt ( ) ; Set < Integer > set = new LinkedHashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = scanner . nextInt ( ) ; if ( set . contains ( a ) ) { set . add ( - a ) ; } else { set . add ( a ) ; } } System . out . println ( set . size ( ) ) ; } scanner . close ( ) ; } }", "import java . util . HashSet ; import java . util . Scanner ; public class A1616 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int test = sc . nextInt ( ) ; while ( test -- > 0 ) { int n = sc . nextInt ( ) ; HashSet < Integer > hs = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = sc . nextInt ( ) ; if ( hs . contains ( k ) ) hs . add ( - k ) ; hs . add ( k ) ; } System . out . println ( hs . size ( ) ) ; } } }", "import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; long arr [ ] = new long [ n ] ; Set < Long > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( set . contains ( arr [ i ] ) ) { arr [ i ] *= - 1 ; set . add ( arr [ i ] ) ; } else { set . add ( arr [ i ] ) ; } } System . out . println ( set . size ( ) ) ; } } catch ( Exception e ) { } } }"], "python": ["for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT t = set ( ) NEW_LINE for x in map ( int , s . split ( ) ) : t |= { ( x , - x ) [ x in t ] } NEW_LINE print ( len ( t ) ) NEW_LINE DEDENT", "import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = [ 0 ] * 105 NEW_LINE for i in a : NEW_LINE INDENT cnt [ abs ( i ) ] += 1 NEW_LINE DEDENT ans0 = min ( cnt [ 0 ] , 1 ) NEW_LINE for i in cnt [ 1 : ] : NEW_LINE INDENT ans0 += min ( i , 2 ) NEW_LINE DEDENT ans . append ( ans0 ) NEW_LINE DEDENT sys . stdout . write ( \" \\n \" . join ( map ( str , ans ) ) ) NEW_LINE", "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT t = set ( ) NEW_LINE for x in map ( int , s . split ( ) ) : t |= { ( x , - x ) [ x in t ] } NEW_LINE print ( len ( t ) ) NEW_LINE DEDENT", "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE w = { } NEW_LINE for i in a : NEW_LINE INDENT if i in w : NEW_LINE INDENT w [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT w [ i ] = 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in w : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if w [ i ] >= 2 : NEW_LINE INDENT if - i not in w : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( \" \\n \" . join ( ans ) ) NEW_LINE", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = { } NEW_LINE n , ans = int ( input ( ) ) , 0 NEW_LINE a = list ( map ( int , input ( ) . split ( ' \u2581 ' ) ) ) NEW_LINE ans = 0 NEW_LINE if n == len ( a ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] not in b : NEW_LINE INDENT b . append ( a [ i ] ) NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if a [ i ] * ( - 1 ) not in b : NEW_LINE INDENT b . append ( a [ i ] * ( - 1 ) ) NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1204_A", "java": ["import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void primesieve ( boolean [ ] prime ) { prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 650 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 650 ; i += p ) prime [ i ] = false ; } } } static pair sum_sqsum ( int n ) { int sum = 0 ; int sqsum = 0 ; int x ; while ( n > 0 ) { x = n % 10 ; sum += x ; sqsum += x * x ; n /= 10 ; } return ( new pair ( sum , sqsum ) ) ; } static int countnumber ( int L , int R ) { boolean [ ] prime = new boolean [ 651 ] ; Arrays . fill ( prime , true ) ; primesieve ( prime ) ; int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { pair digit = sum_sqsum ( i ) ; if ( prime [ digit . first ] && prime [ digit . second ] ) { cnt += 1 ; } } return cnt ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 20 ; System . out . println ( countnumber ( L , R ) ) ; } }"], "python": ["from math import sqrt NEW_LINE def primesieve ( prime ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( 650 ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , 651 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def sum_sqsum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE sqsum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT x = n % 10 ; NEW_LINE sum += x ; NEW_LINE sqsum += x * x ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return ( sum , sqsum ) ; NEW_LINE DEDENT def countnumber ( L , R ) : NEW_LINE INDENT prime = [ True ] * 651 ; NEW_LINE primesieve ( prime ) ; NEW_LINE cnt = 0 ; NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT digit = sum_sqsum ( i ) ; NEW_LINE if ( prime [ digit [ 0 ] ] and prime [ digit [ 1 ] ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 10 ; NEW_LINE R = 20 ; NEW_LINE print ( countnumber ( L , R ) ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3328_A", "java": ["import java . io . * ; import java . util . * ; public class GFG { static void printRepeating ( Integer [ ] arr , int size ) { SortedSet < Integer > s = new TreeSet < > ( ) ; Collections . addAll ( s , arr ) ; System . out . print ( s ) ; } public static void main ( String args [ ] ) { Integer [ ] arr = { 1 , 3 , 2 , 2 , 1 } ; int n = arr . length ; printRepeating ( arr , n ) ; } }"], "python": ["def printRepeating ( arr , size ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p225_A", "java": ["import java . util . Arrays ; public final class p225 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p225 ( ) . run ( ) ) ; } private static final int INDEX = 124 ; public String run ( ) { int count = 0 ; for ( int i = 1 ; ; i += 2 ) { if ( ! hasTribonacciMultiple ( i ) ) { count ++ ; if ( count == INDEX ) return Integer . toString ( i ) ; } } } private static boolean hasTribonacciMultiple ( int modulus ) { int [ ] slow = { 1 , 1 , 1 } ; int [ ] fast = slow . clone ( ) ; for ( boolean head = true ; ; head = false ) { if ( slow [ 0 ] % modulus == 0 ) return true ; if ( ! head && Arrays . equals ( slow , fast ) ) return false ; tribonacci ( slow , modulus ) ; tribonacci ( fast , modulus ) ; tribonacci ( fast , modulus ) ; } } private static void tribonacci ( int [ ] state , int mod ) { int a = state [ 0 ] ; int b = state [ 1 ] ; int c = state [ 2 ] ; state [ 0 ] = b ; state [ 1 ] = c ; state [ 2 ] = ( a + b + c ) % mod ; } }"], "python": ["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE stream = ( i for i in itertools . count ( 1 , 2 ) if not has_tribonacci_multiple ( i ) ) NEW_LINE ans = next ( itertools . islice ( stream , INDEX - 1 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_tribonacci_multiple ( i ) : NEW_LINE INDENT seen = set ( ) NEW_LINE a , b , c = 1 , 1 , 1 NEW_LINE while True : NEW_LINE INDENT key = ( a , b , c ) NEW_LINE if key in seen : NEW_LINE INDENT return False NEW_LINE DEDENT seen . add ( key ) NEW_LINE if a % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT a , b , c = b , c , ( a + b + c ) % i NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_384_A", "java": ["import java . io . * ; class GfG { static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { System . out . println ( \" x \u2581 = \u2581 \" + i + \" , \u2581 y \u2581 = \u2581 \" + ( n - ( i * a ) ) / b ) ; return ; } } System . out . println ( \" No \u2581 solution \" ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; } }"], "python": ["def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( \" x \u2581 = \u2581 \" , i , \" , \u2581 y \u2581 = \u2581 \" , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( \" No \u2581 solution \" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE"]}
{"id": "codeforces_987_B", "java": ["import java . util . Scanner ; public class HighSchool987B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long x = in . nextInt ( ) ; long y = in . nextInt ( ) ; long x_y = ( long ) Math . pow ( x , y ) ; long y_x = ( long ) Math . pow ( y , x ) ; if ( x_y > y_x ) { System . out . println ( ' > ' ) ; return ; } else if ( x_y < y_x ) { System . out . println ( ' < ' ) ; return ; } else if ( x == y || x_y == y_x && x_y < 999999999 ) { System . out . println ( ' = ' ) ; return ; } if ( x > y ) System . out . println ( ' < ' ) ; else System . out . println ( ' > ' ) ; } }", "import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; double xy = Math . log ( x ) * y ; double yx = Math . log ( y ) * x ; if ( xy > yx ) { System . out . println ( \" > \" ) ; } else if ( xy < yx ) { System . out . println ( \" < \" ) ; } else { System . out . println ( \" = \" ) ; } } catch ( Exception e ) { } } }", "import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; double xy = Math . log ( x ) / x ; double yx = Math . log ( y ) / y ; if ( xy > yx ) { System . out . println ( \" > \" ) ; } else if ( xy < yx ) { System . out . println ( \" < \" ) ; } else { System . out . println ( \" = \" ) ; } } catch ( Exception e ) { } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ; import static java . lang . System . out ; public class pre124 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { FastReader obj = new FastReader ( ) ; double x = obj . nextInt ( ) , y = obj . nextInt ( ) ; if ( Double . compare ( x , 1d ) == 0 && Double . compare ( y , 1d ) == 0 ) { out . println ( \" = \" ) ; return ; } int com = Double . compare ( y / x , Math . log ( y ) / Math . log ( x ) ) ; String ans = com == 0 ? \" = \" : ( com > 0 ) ? \" > \" : \" < \" ; out . println ( ans ) ; } }", "import java . io . * ; import java . util . * ; public class Main { static long n , d ; public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; long a = in . nextLong ( ) , b = in . nextLong ( ) ; double apow = b * Math . log ( a ) ; double bpow = a * Math . log ( b ) ; if ( a == b ) { pw . println ( \" = \" ) ; } else { if ( apow == bpow ) { pw . println ( \" = \" ) ; } else if ( apow < bpow ) { pw . println ( \" < \" ) ; } else { pw . println ( \" > \" ) ; } } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }"], "python": ["import sys , os , io NEW_LINE input = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if max ( x , y ) <= 8 : NEW_LINE INDENT if pow ( x , y ) < pow ( y , x ) : NEW_LINE INDENT ans = \" < \" NEW_LINE DEDENT elif pow ( x , y ) > pow ( y , x ) : NEW_LINE INDENT ans = \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" = \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if x < y : NEW_LINE INDENT ans = \" > \" if x ^ 1 else \" < \" NEW_LINE DEDENT elif x > y : NEW_LINE INDENT ans = \" < \" if y ^ 1 else \" > \" NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" = \" NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "import math NEW_LINE x , y = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if x * math . log ( y ) > y * math . log ( x ) : NEW_LINE INDENT print ( \" < \" ) NEW_LINE DEDENT elif x * math . log ( y ) == y * math . log ( x ) : NEW_LINE INDENT print ( \" = \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" > \" ) NEW_LINE DEDENT", "import math NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = y * math . log ( x , 10 ) NEW_LINE b = x * math . log ( y , 10 ) NEW_LINE if a > b : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT", "import math NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = y * math . log ( x ) NEW_LINE b = x * math . log ( y ) NEW_LINE if abs ( a - b ) < 1e-8 : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT", "import math NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE a = y * math . log ( x ) NEW_LINE b = x * math . log ( y ) NEW_LINE if abs ( a - b ) < 1e-8 : NEW_LINE INDENT print ( ' = ' ) NEW_LINE DEDENT elif a < b : NEW_LINE INDENT print ( ' < ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' > ' ) NEW_LINE DEDENT"]}
{"id": "aizu_p01931_A", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; int N = parseInt ( br . readLine ( ) ) ; String S = br . readLine ( ) ; int ans = S . indexOf ( \" xx \" ) + 1 ; System . out . println ( ans > 0 ? ans : N ) ; } }", "import java . util . Scanner ; class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int i ; String str = sc . next ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( ( str . charAt ( i ) == ' x ' ) && ( str . charAt ( i + 1 ) == ' x ' ) ) break ; } System . out . println ( i + 1 ) ; } }", "import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . nextLine ( ) ) ; String line = sc . nextLine ( ) ; int count = 0 ; int answer = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( line . charAt ( i ) == ' x ' ) { count += 1 ; } else { count = 0 ; } if ( count == 2 ) { answer = i ; break ; } } System . out . println ( answer ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; boolean lastWrong = false ; int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' o ' ) { lastWrong = false ; } else { if ( lastWrong ) { ans = i ; break ; } lastWrong = true ; } } System . out . println ( ans ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] arr = sc . next ( ) . toCharArray ( ) ; char prev = ' o ' ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == ' x ' && arr [ i - 1 ] == ' x ' ) { System . out . println ( i ) ; return ; } } System . out . println ( n ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE if n == 0 : print ( 0 ) NEW_LINE else : NEW_LINE INDENT s = input ( ) NEW_LINE ans = 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if s [ i - 1 ] == ' x ' and s [ i ] == ' x ' : break NEW_LINE ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT", "def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE S = input ( ) NEW_LINE try : NEW_LINE INDENT ans = S . index ( ' xx ' ) + 1 NEW_LINE print ( ans ) NEW_LINE DEDENT except : NEW_LINE INDENT print ( N ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE", "from sys import stdin NEW_LINE n = int ( stdin . readline ( ) . rstrip ( ) ) NEW_LINE s = stdin . readline ( ) . rstrip ( ) NEW_LINE faint = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if s [ i - 1 ] == \" x \" and s [ i ] == \" x \" : NEW_LINE INDENT print ( i ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE", "n = input ( ) NEW_LINE print ( input ( ) . find ( ' xx ' ) + 1 or n ) NEW_LINE", "N = input ( ) NEW_LINE S = input ( ) NEW_LINE N = int ( N ) NEW_LINE S_list = list ( S ) NEW_LINE flg = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if flg == 0 : NEW_LINE INDENT if S_list [ i ] == ( ' x ' ) : NEW_LINE INDENT flg = 1 NEW_LINE DEDENT DEDENT elif S_list [ i ] == ( ' o ' ) : NEW_LINE INDENT flg = 0 NEW_LINE DEDENT elif S_list [ i ] == ( ' x ' ) : NEW_LINE INDENT flg = 2 NEW_LINE break NEW_LINE DEDENT DEDENT if i == N - 1 : NEW_LINE INDENT if flg < 2 : NEW_LINE INDENT i = N NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE"]}
{"id": "atcoder_AGC004_C", "java": ["import java . io . PrintWriter ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; boolean [ ] [ ] a = new boolean [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) { String str = sc . next ( ) ; for ( int j = 0 ; j < W ; j ++ ) a [ i ] [ j ] = str . charAt ( j ) == ' # ' ; } for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { pw . print ( ( i == 0 || ( i < H - 1 && ( j % 2 == 0 || a [ i ] [ j ] ) ) ) ? ' # ' : ' . ' ) ; } pw . println ( ) ; } pw . println ( ) ; for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { pw . print ( ( i == H - 1 || ( i > 0 && ( j % 2 == 1 || a [ i ] [ j ] ) ) ) ? ' # ' : ' . ' ) ; } pw . println ( ) ; } sc . close ( ) ; pw . close ( ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; char [ ] [ ] reds = new char [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { if ( j == 0 || ( j != w - 1 && i % 2 == 0 ) ) { reds [ i ] [ j ] = ' # ' ; } else { reds [ i ] [ j ] = ' . ' ; } } } StringBuilder red = new StringBuilder ( ) ; StringBuilder blue = new StringBuilder ( ) ; char [ ] [ ] blues = new char [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { char [ ] line = sc . next ( ) . toCharArray ( ) ; for ( int j = 0 ; j < w ; j ++ ) { if ( reds [ i ] [ j ] == ' # ' ) { blues [ i ] [ j ] = ' . ' ; } else { blues [ i ] [ j ] = ' # ' ; } if ( line [ j ] == ' # ' ) { reds [ i ] [ j ] = ' # ' ; blues [ i ] [ j ] = ' # ' ; } } red . append ( new String ( reds [ i ] ) ) . append ( \" \\n \" ) ; blue . append ( new String ( blues [ i ] ) ) . append ( \" \\n \" ) ; } System . out . println ( red ) ; System . out . print ( blue ) ; } }", "import java . util . * ; public class Main { static final int MOD = 1000000007 ; public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; boolean [ ] [ ] redField = new boolean [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { if ( i % 2 == 0 ) { redField [ i ] [ 0 ] = true ; } else { for ( int j = 0 ; j < w - 1 ; j ++ ) { redField [ i ] [ j ] = true ; } } } boolean [ ] [ ] blueField = new boolean [ h ] [ w ] ; for ( int i = 0 ; i < h ; i ++ ) { if ( i % 2 == 1 ) { blueField [ i ] [ w - 1 ] = true ; } else { for ( int j = 1 ; j < w ; j ++ ) { blueField [ i ] [ j ] = true ; } } } StringBuilder blueOut = new StringBuilder ( ) ; StringBuilder redOut = new StringBuilder ( ) ; for ( int i = 0 ; i < h ; i ++ ) { char [ ] arr = sc . next ( ) . toCharArray ( ) ; for ( int j = 0 ; j < w ; j ++ ) { if ( arr [ j ] == ' # ' ) { redField [ i ] [ j ] = true ; blueField [ i ] [ j ] = true ; } if ( redField [ i ] [ j ] ) { redOut . append ( \" # \" ) ; } else { redOut . append ( \" . \" ) ; } if ( blueField [ i ] [ j ] ) { blueOut . append ( \" # \" ) ; } else { blueOut . append ( \" . \" ) ; } } redOut . append ( \" \\n \" ) ; blueOut . append ( \" \\n \" ) ; } System . out . println ( redOut ) ; System . out . print ( blueOut ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ) { new Main ( ) . solve ( in ) ; } } private void solve ( Scanner in ) { int H = in . nextInt ( ) , W = in . nextInt ( ) ; char [ ] [ ] a = new char [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) { a [ i ] = in . next ( ) . toCharArray ( ) ; } char [ ] [ ] r = new char [ H ] [ W ] ; char [ ] [ ] b = new char [ H ] [ W ] ; for ( int i = 0 ; i < H ; i ++ ) { Arrays . fill ( r [ i ] , DOT ) ; Arrays . fill ( b [ i ] , DOT ) ; r [ i ] [ 0 ] = SHA ; b [ i ] [ W - 1 ] = SHA ; for ( int j = 1 ; j < W - 1 ; j ++ ) { r [ i ] [ j ] = ( i % 2 == 0 ) ? SHA : DOT ; b [ i ] [ j ] = ( i % 2 == 1 ) ? SHA : DOT ; } } for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { if ( a [ i ] [ j ] == SHA ) { r [ i ] [ j ] = SHA ; b [ i ] [ j ] = SHA ; } } } show ( r ) ; System . out . println ( ) ; show ( b ) ; } private static final char DOT = ' . ' , SHA = ' # ' ; private void show ( char [ ] [ ] cs ) { for ( int i = 0 ; i < cs . length ; i ++ ) { System . out . println ( new String ( cs [ i ] ) ) ; } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; char [ ] [ ] a = new char [ H ] [ W ] ; for ( int i = 0 ; i < H ; ++ i ) { a [ i ] = sc . next ( ) . toCharArray ( ) ; } for ( int i = 0 ; i < H ; ++ i ) { for ( int j = 0 ; j < W ; ++ j ) { if ( j != W - 1 && ( j == 0 || a [ i ] [ j ] == ' # ' || i % 2 == 0 ) ) { System . out . print ( ' # ' ) ; } else { System . out . print ( ' . ' ) ; } } System . out . println ( ) ; } System . out . println ( ) ; for ( int i = 0 ; i < H ; ++ i ) { for ( int j = 0 ; j < W ; ++ j ) { if ( j != 0 && ( j == W - 1 || a [ i ] [ j ] == ' # ' || i % 2 == 1 ) ) { System . out . print ( ' # ' ) ; } else { System . out . print ( ' . ' ) ; } } System . out . println ( ) ; } } void tr ( Object ... objects ) { System . out . println ( Arrays . deepToString ( objects ) ) ; } }"], "python": ["H , W = map ( int , input ( ) . split ( ) ) NEW_LINE G = [ list ( map ( lambda x : x == ' # ' , input ( ) . strip ( ) ) ) for _ in range ( H ) ] NEW_LINE Takahashi = [ [ False ] * W for _ in range ( H ) ] NEW_LINE Aoki = [ [ False ] * W for _ in range ( H ) ] NEW_LINE for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT if w == 0 : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE DEDENT elif not h & 1 : NEW_LINE INDENT Aoki [ h ] [ w ] = True NEW_LINE DEDENT if w == W - 1 : NEW_LINE INDENT Aoki [ h ] [ w ] = True NEW_LINE DEDENT elif h & 1 : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE DEDENT if G [ h ] [ w ] : NEW_LINE INDENT Takahashi [ h ] [ w ] = True NEW_LINE Aoki [ h ] [ w ] = True NEW_LINE DEDENT DEDENT DEDENT print ( ' \\n ' . join ( [ ' ' . join ( [ ' # ' if s else ' . ' for s in Takahashi [ i ] ] ) for i in range ( H ) ] ) ) NEW_LINE print ( ' ' ) NEW_LINE print ( ' \\n ' . join ( [ ' ' . join ( [ ' # ' if s else ' . ' for s in Aoki [ i ] ] ) for i in range ( H ) ] ) ) NEW_LINE", "def main ( ) : NEW_LINE INDENT import sys NEW_LINE input = sys . stdin . readline NEW_LINE H , W = map ( int , input ( ) . split ( ) ) NEW_LINE grid_p = [ ] NEW_LINE for _ in range ( H ) : NEW_LINE INDENT grid_p . append ( input ( ) . rstrip ( ' \\n ' ) ) NEW_LINE DEDENT grid_r = [ [ ' . ' ] * W for _ in range ( H ) ] NEW_LINE grid_b = [ [ ' . ' ] * W for _ in range ( H ) ] NEW_LINE for w in range ( W ) : NEW_LINE INDENT grid_r [ 0 ] [ w ] = ' # ' NEW_LINE grid_b [ - 1 ] [ w ] = ' # ' NEW_LINE DEDENT for h in range ( 1 , H - 1 ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT if w % 2 : NEW_LINE INDENT grid_r [ h ] [ w ] = ' # ' NEW_LINE DEDENT else : NEW_LINE INDENT grid_b [ h ] [ w ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT for h in range ( H ) : NEW_LINE INDENT for w in range ( W ) : NEW_LINE INDENT if grid_p [ h ] [ w ] == ' # ' : NEW_LINE INDENT grid_r [ h ] [ w ] = ' # ' NEW_LINE grid_b [ h ] [ w ] = ' # ' NEW_LINE DEDENT DEDENT DEDENT [ print ( ' ' . join ( line ) ) for line in grid_r ] NEW_LINE print ( ' ' ) NEW_LINE [ print ( ' ' . join ( line ) ) for line in grid_b ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from collections import defaultdict , Counter NEW_LINE from itertools import product , groupby , count , permutations , combinations NEW_LINE from math import pi , sqrt NEW_LINE from collections import deque NEW_LINE from bisect import bisect , bisect_left , bisect_right NEW_LINE INF = 10 ** 10 NEW_LINE def check ( ans1 , ans2 , field ) : NEW_LINE INDENT h , w = len ( ans1 ) , len ( ans1 [ 0 ] ) NEW_LINE ans = [ [ 0 ] * w for _ in range ( h ) ] NEW_LINE for y in range ( h ) : NEW_LINE INDENT for x in range ( w ) : NEW_LINE INDENT c = \" # \" if ans1 [ y ] [ x ] == ans2 [ y ] [ x ] == \" # \" else \" . \" NEW_LINE if field [ y ] [ x ] != c : NEW_LINE INDENT print ( y , x ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE field = [ ] NEW_LINE for _ in range ( H ) : NEW_LINE INDENT field . append ( input ( ) ) NEW_LINE DEDENT ans1 , ans2 = [ [ \" . \" ] * W for _ in range ( H ) ] , [ [ \" . \" ] * W for _ in range ( H ) ] NEW_LINE for i in range ( H ) : NEW_LINE INDENT ans1 [ i ] [ 0 ] = \" # \" NEW_LINE ans2 [ i ] [ - 1 ] = \" # \" NEW_LINE if i % 2 == 0 : NEW_LINE INDENT ans1 [ i ] = [ \" # \" ] * ( W - 1 ) + [ \" . \" ] NEW_LINE DEDENT else : NEW_LINE INDENT ans2 [ i ] = [ \" . \" ] + [ \" # \" ] * ( W - 1 ) NEW_LINE DEDENT DEDENT for y in range ( H ) : NEW_LINE INDENT for x in range ( W ) : NEW_LINE INDENT if field [ y ] [ x ] == \" # \" : NEW_LINE INDENT if y % 2 == 0 : NEW_LINE INDENT ans2 [ y ] [ x ] = \" # \" NEW_LINE DEDENT else : NEW_LINE INDENT ans1 [ y ] [ x ] = \" # \" NEW_LINE DEDENT DEDENT DEDENT DEDENT for line in ans1 : NEW_LINE INDENT print ( \" \" . join ( line ) ) NEW_LINE DEDENT print ( ) NEW_LINE for line in ans2 : NEW_LINE INDENT print ( \" \" . join ( line ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE import numpy as np NEW_LINE H , W = map ( int , sys . stdin . buffer . readline ( ) . split ( ) ) NEW_LINE purple = np . frombuffer ( sys . stdin . buffer . read ( ) , dtype = ' S1' ) . reshape ( H , - 1 ) [ : , : W ] . astype ( str ) NEW_LINE red = np . full ( ( H , W ) , ' . ' , dtype = ' U1' ) NEW_LINE blue = np . full ( ( H , W ) , ' . ' , dtype = ' U1' ) NEW_LINE red [ : , : : 2 ] = ' # ' NEW_LINE red [ - 1 ] = ' . ' NEW_LINE red [ 0 ] = ' # ' NEW_LINE blue [ : , 1 : : 2 ] = ' # ' NEW_LINE blue [ - 1 ] = ' # ' NEW_LINE blue [ 0 ] = ' . ' NEW_LINE is_purple = purple == ' # ' NEW_LINE red [ is_purple ] = ' # ' NEW_LINE blue [ is_purple ] = ' # ' NEW_LINE print ( ' \\n ' . join ( ' ' . join ( row ) for row in red ) ) NEW_LINE print ( ) NEW_LINE print ( ' \\n ' . join ( ' ' . join ( row ) for row in blue ) ) NEW_LINE", "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT h , w = LI ( ) NEW_LINE a = [ [ c == ' # ' for c in S ( ) ] for _ in range ( h ) ] NEW_LINE r = [ ' # ' * w ] NEW_LINE for c in a [ 1 : - 1 ] : NEW_LINE INDENT t = ' ' NEW_LINE for i in range ( w ) : NEW_LINE INDENT ci = c [ i ] NEW_LINE if ci or i % 2 == 0 : NEW_LINE INDENT t += ' # ' NEW_LINE DEDENT else : NEW_LINE INDENT t += ' . ' NEW_LINE DEDENT DEDENT r . append ( t ) NEW_LINE DEDENT r . append ( ' . ' * w ) NEW_LINE r . append ( ' ' ) NEW_LINE r . append ( ' . ' * w ) NEW_LINE for c in a [ 1 : - 1 ] : NEW_LINE INDENT t = ' ' NEW_LINE for i in range ( w ) : NEW_LINE INDENT ci = c [ i ] NEW_LINE if ci or i % 2 == 1 : NEW_LINE INDENT t += ' # ' NEW_LINE DEDENT else : NEW_LINE INDENT t += ' . ' NEW_LINE DEDENT DEDENT r . append ( t ) NEW_LINE DEDENT r . append ( ' # ' * w ) NEW_LINE return ' \\n ' . join ( r ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2024_A", "java": ["import java . io . * ; class GFG { static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } public static void main ( String args [ ] ) throws IOException { System . out . println ( unitDigitXRaisedY ( 4 , 2 ) ) ; } }"], "python": ["def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE"]}
{"id": "codeforces_935_A", "java": ["import java . util . Scanner ; public class FafaAndHisCompany { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int X = 0 ; for ( int l = 1 ; l <= N / 2 ; l ++ ) { if ( N % l == 0 ) { X ++ ; } } System . out . println ( X ) ; sc . close ( ) ; } }", "import java . util . * ; public class cp { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x ; int counter = 0 ; x = sc . nextInt ( ) ; for ( int i = 1 ; i <= x / 2 ; i ++ ) { if ( x % i == 0 ) { counter ++ ; } } System . out . println ( counter ) ; } }", "import java . util . * ; public class Main { public static int solve ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n / 2 ; i ++ ) { if ( ( n - i ) % i == 0 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n ; n = sc . nextInt ( ) ; System . out . println ( solve ( n ) ) ; } }", "import java . util . Scanner ; public class Fafa_and_his_Company { public static void main ( String [ ] args ) { int n , count = 0 ; Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; for ( int i = 1 ; i <= n / 2 ; i ++ ) { if ( n % i == 0 ) count ++ ; } System . out . print ( count ) ; sc . close ( ) ; } }", "import java . util . Scanner ; public class A_Fafa_and_his_Company { public static void main ( String [ ] args ) { Scanner sn = new Scanner ( System . in ) ; int n = sn . nextInt ( ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int rem = n - i ; if ( rem % i == 0 ) count ++ ; } System . out . println ( count ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for x in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT if ( n - x ) % x == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "a = int ( input ( ) ) NEW_LINE k = 0 NEW_LINE for i in range ( 1 , a ) : NEW_LINE INDENT if a % i == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT print ( k ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE c = 0 NEW_LINE for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT if ( ( n - i ) // i ) * i == n - i : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE print ( len ( [ x for x in range ( 1 , n ) if not n % x ] ) ) NEW_LINE", "x = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT if x % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"]}
{"id": "codeforces_1023_B", "java": ["import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; public class Pairs_of_toys { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; { System . out . print ( Math . max ( 0 , Math . min ( n , k - 1 ) - k / 2 ) ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; long s1 = scanner . nextLong ( ) ; long s2 = scanner . nextLong ( ) ; if ( s2 == 1 || s2 == 2 ) { System . out . println ( 0 ) ; System . exit ( 0 ) ; } if ( s1 * 2 >= s2 + 1 ) { if ( s2 > s1 + 1 ) { double t1 = s2 - s1 ; double t2 = s1 ; double mx = Math . ceil ( ( t2 - t1 ) / 2 ) ; System . out . printf ( \" % .0f \" , mx ) ; } else { double t1 = 1 ; double t2 = s2 - 1 ; double mx = Math . ceil ( ( t2 - t1 ) / 2 ) ; System . out . printf ( \" % .0f \" , mx ) ; } } else System . out . println ( 0 ) ; } }", "import java . util . Scanner ; public class B { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long k = sc . nextLong ( ) ; long half = k / 2 ; if ( n < half ) { System . out . println ( \"0\" ) ; } else System . out . println ( ( Math . min ( n , k - 1 ) ) - half ) ; } }"], "python": ["n , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if k >= 2 * n : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif k > n : NEW_LINE INDENT print ( ( 2 * n - k + 1 ) // 2 ) NEW_LINE DEDENT elif k == n : NEW_LINE INDENT print ( ( n - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( k - 1 ) // 2 ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= k : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT print ( k // 2 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT ans = 2 * n - k NEW_LINE if ans <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ans + 1 ) // 2 ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= k : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT print ( k // 2 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT ans = 2 * n - k NEW_LINE if ans <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ans + 1 ) // 2 ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n >= k : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT print ( k // 2 ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT ans = 2 * n - k NEW_LINE if ans <= 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ans + 1 ) // 2 ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( max ( 0 , min ( n , k - 1 ) - ( k >> 1 ) ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3616_A", "java": ["import java . io . * ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( \" Touch \" ) ; else if ( radius > dist ) System . out . println ( \" Intersect \" ) ; else System . out . println ( \" Outside \" ) ; } public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }"], "python": ["import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE INDENT dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE if ( radius == dist ) : NEW_LINE INDENT print ( \" Touch \" ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( \" Intersect \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE"]}
{"id": "codeforces_287_B", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Long n = sc . nextLong ( ) ; Long k = sc . nextLong ( ) ; if ( n == 1 ) { System . out . println ( 0 ) ; return ; } Long max = ( k * ( k - 1 ) ) / 2 ; if ( n > 1 + max ) { System . out . println ( - 1 ) ; return ; } else if ( n == 1 + max ) { System . out . println ( k - 1 ) ; return ; } Long l = 2L ; Long h = k ; Long ans = k + 1 ; boolean exact = false ; while ( l <= h ) { Long mid = l + ( h - l ) / 2 ; Long all = ( ( k - mid + 1 ) * ( mid + k ) ) / 2 ; all -= ( k - mid + 1 ) ; Long rem = n - ( all + 1 ) ; if ( rem < 0 ) { l = mid + 1 ; } else if ( rem < mid - 1 ) { ans = mid ; if ( rem == 0 ) { exact = true ; break ; } l = mid + 1 ; } else { h = mid - 1 ; } } int add = exact ? 0 : 1 ; System . out . println ( ( k - ans + 1 ) + add ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } String nextLine ( ) throws IOException { return br . readLine ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } } static FastScanner in = new FastScanner ( ) ; static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) throws IOException { long n = in . nextLong ( ) , k = in . nextLong ( ) ; out . println ( bs ( n , k ) ) ; out . close ( ) ; } public static long bs ( long n , long k ) { long sum = ( ( k * ( k + 1 ) ) / 2 ) - ( k - 1 ) ; if ( n == 1 ) return 0 ; if ( sum < n ) return - 1 ; long l = 1 , r = k - 1 , mid , temp ; while ( l <= r ) { mid = ( l + r ) / 2 ; long temp2 = k - mid ; long temp3 = ( ( ( temp2 * ( temp2 + 1 ) ) / 2 ) - ( temp2 ) ) ; temp = sum - temp3 ; if ( temp > n ) r = mid - 1 ; else if ( temp == n ) return mid ; else l = mid + 1 ; } return l ; } }"], "python": ["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE def f ( m ) : NEW_LINE INDENT global n NEW_LINE global k NEW_LINE total = m * k - ( m * ( m - 1 ) ) // 2 NEW_LINE total -= ( m - 1 ) NEW_LINE return total >= n NEW_LINE DEDENT if ( ( k * ( k + 1 ) ) // 2 - ( k - 1 ) < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT r = k NEW_LINE l = 0 NEW_LINE while ( r > ( l + 1 ) ) : NEW_LINE INDENT m = ( r + l ) // 2 NEW_LINE if ( f ( m ) == 0 ) : NEW_LINE INDENT l = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE def sum1 ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT s = sum1 ( k - 1 ) NEW_LINE n = n - 1 NEW_LINE if s < n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT low = 0 NEW_LINE high = k - 1 NEW_LINE while low <= high : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if s - sum1 ( mid ) >= n : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT print ( k - 1 - ans ) NEW_LINE DEDENT", "import collections NEW_LINE import heapq NEW_LINE import sys NEW_LINE import math NEW_LINE import itertools NEW_LINE import bisect NEW_LINE from io import BytesIO , IOBase NEW_LINE import os NEW_LINE def valid ( i , j , n , m ) : NEW_LINE INDENT if i < n and i >= 0 and j >= 0 and j < m : return True NEW_LINE return False NEW_LINE DEDENT def sumn ( i , n ) : NEW_LINE INDENT return ( n - i + 1 ) * ( i + n ) // 2 NEW_LINE DEDENT def sqfun ( a , b , c ) : NEW_LINE INDENT return ( - b + math . sqrt ( b * b - 4 * a * c ) ) / ( 2 * a ) NEW_LINE DEDENT def value ( ) : return tuple ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def values ( ) : return tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def inlst ( ) : return [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE def inlsts ( ) : return [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def inp ( ) : return int ( input ( ) ) NEW_LINE def inps ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def instr ( ) : return input ( ) NEW_LINE def stlst ( ) : return [ i for i in input ( ) . split ( ) ] NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = values ( ) NEW_LINE if n == 1 : return 0 NEW_LINE k -= 1 ; n -= 1 NEW_LINE if ( ( 1 + k ) * k ) // 2 < n : return - 1 NEW_LINE h = int ( sqfun ( 1 , - 1 , 2 * n - k * k - k ) ) NEW_LINE if sumn ( h , k ) >= n : return k - h + 1 NEW_LINE else : return k - h + 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( solve ( ) ) NEW_LINE DEDENT", "def sum ( l ) : NEW_LINE INDENT return int ( ( l * ( l + 1 ) ) / 2 ) NEW_LINE DEDENT def sume ( s , e ) : NEW_LINE INDENT if s <= 1 : NEW_LINE INDENT return sum ( e ) NEW_LINE DEDENT else : NEW_LINE INDENT return sum ( e ) - sum ( s - 1 ) NEW_LINE DEDENT DEDENT def minsplitters ( k , n ) : NEW_LINE INDENT st = int ( 1 ) NEW_LINE en = int ( k ) NEW_LINE while ( st < en ) : NEW_LINE INDENT md = int ( ( st + en ) / 2 ) NEW_LINE s = sume ( md , k ) NEW_LINE if s == n : NEW_LINE INDENT return k - md + 1 NEW_LINE DEDENT if s > n : NEW_LINE INDENT st = md + 1 NEW_LINE DEDENT else : NEW_LINE INDENT en = md NEW_LINE DEDENT DEDENT return k - st + 2 NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( n <= k ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT n -= 1 NEW_LINE k -= 1 NEW_LINE if sum ( k ) < n : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( minsplitters ( k , n ) ) NEW_LINE DEDENT DEDENT", "l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n = l [ 0 ] NEW_LINE k = l [ 1 ] NEW_LINE def solve ( n , k ) : NEW_LINE INDENT mx = ( ( k * ( k + 1 ) ) // 2 ) - ( k - 1 ) NEW_LINE if mx < n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif mx == n : NEW_LINE INDENT return k - 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = 1 NEW_LINE e = k - 1 NEW_LINE o = 1 NEW_LINE while True : NEW_LINE INDENT md = ( s + e ) // 2 NEW_LINE op1 = ( ( md + 1 ) * ( md + 2 ) ) // 2 NEW_LINE if mx - op1 < n : NEW_LINE INDENT op2 = ( ( md ) * ( md + 1 ) ) // 2 NEW_LINE if mx - op2 >= n : NEW_LINE INDENT return k - 1 - md NEW_LINE DEDENT else : NEW_LINE INDENT e = md NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s = md NEW_LINE DEDENT DEDENT DEDENT print ( solve ( n , k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2321_A", "java": ["import java . io . * ; class GFG { static boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }"], "python": ["def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC118_D", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Main main = new Main ( ) ; main . run ( ) ; } int f [ ] = { - 1 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; public void run ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int dp [ ] = new int [ n + 1 ] ; Arrays . fill ( dp , - 1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( i - f [ a [ j ] ] >= 0 && dp [ i - f [ a [ j ] ] ] >= 0 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - f [ a [ j ] ] ] + 1 ) ; } } } int keta = dp [ n ] ; int rem = n ; StringBuilder sb = new StringBuilder ( ) ; while ( rem > 0 ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( rem - f [ a [ i ] ] >= 0 && keta == dp [ rem - f [ a [ i ] ] ] + 1 ) { sb . append ( a [ i ] ) ; keta -- ; rem -= f [ a [ i ] ] ; break ; } } } System . out . println ( sb ) ; sc . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { static long t [ ] ; static long l [ ] ; static long h [ ] ; public static void main ( String [ ] args ) throws IOException { BufferedReader r = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; String s ; String sl [ ] ; int d [ ] = new int [ 10 ] ; int c [ ] = { 999999 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; for ( int i = 0 ; i <= 9 ; i ++ ) { d [ i ] = 999999 ; } s = r . readLine ( ) ; sl = s . split ( \" \u2581 \" ) ; int n = Integer . parseInt ( sl [ 0 ] ) ; int m = Integer . parseInt ( sl [ 1 ] ) ; s = r . readLine ( ) ; sl = s . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < m ; i ++ ) { int v = Integer . parseInt ( sl [ i ] ) ; d [ v ] = c [ v ] ; } int dp [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] = - 999999 ; for ( int j = 1 ; j <= 9 ; j ++ ) { if ( i - d [ j ] >= 0 && dp [ i - d [ j ] ] >= 0 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - d [ j ] ] + 1 ) ; } } } int z = dp [ n ] ; int q = n ; while ( q > 0 ) { for ( int i = 9 ; 1 <= i ; i -- ) { if ( q - d [ i ] >= 0 && dp [ q - d [ i ] ] == dp [ q ] - 1 ) { System . out . print ( i ) ; q -= d [ i ] ; break ; } } } } }", "import java . math . BigInteger ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; List < BigInteger > dp = new ArrayList < BigInteger > ( ) ; Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; for ( int i = 1 ; i <= m ; i ++ ) { int a = sc . nextInt ( ) ; switch ( a ) { case 1 : mp . put ( a , 2 ) ; break ; case 2 : case 3 : case 5 : mp . put ( a , 5 ) ; break ; case 4 : mp . put ( a , 4 ) ; break ; case 6 : case 9 : mp . put ( a , 6 ) ; break ; case 7 : mp . put ( a , 3 ) ; break ; case 8 : mp . put ( a , 7 ) ; break ; } } for ( int i = 0 ; i <= n + 10 ; i ++ ) { dp . add ( BigInteger . valueOf ( 0L ) ) ; } BigInteger ten = BigInteger . valueOf ( 10 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && dp . get ( i ) . equals ( BigInteger . valueOf ( 0L ) ) ) continue ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pos = i + entry . getValue ( ) ; BigInteger tmp = dp . get ( pos ) ; BigInteger now = dp . get ( i ) . multiply ( ten ) . add ( BigInteger . valueOf ( entry . getKey ( ) ) ) ; if ( now . compareTo ( tmp ) > 0 ) { dp . set ( pos , now ) ; } } } System . out . println ( dp . get ( n ) ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { int INF = 100000000 ; Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] dp = new int [ n + 1 ] ; int [ ] a = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int [ ] cost = { 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; Arrays . sort ( a ) ; Arrays . fill ( dp , - INF ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m - 1 ; j >= 0 ; j -- ) { if ( i - cost [ a [ j ] ] < 0 ) continue ; else dp [ i ] = Math . max ( dp [ i ] , dp [ i - cost [ a [ j ] ] ] + 1 ) ; } } StringBuilder ans = new StringBuilder ( ) ; while ( n != 0 ) { for ( int j = m - 1 ; j >= 0 ; j -- ) { if ( cost [ a [ j ] ] > n ) continue ; if ( dp [ n - cost [ a [ j ] ] ] == dp [ n ] - 1 ) { ans . append ( a [ j ] ) ; n -= cost [ a [ j ] ] ; break ; } } } System . out . println ( ans ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Integer [ ] cost_array = { 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; List < Integer > cost = Arrays . asList ( cost_array ) ; Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . next ( ) ) ; int m = Integer . parseInt ( sc . next ( ) ) ; List < Integer > aArray = new ArrayList < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { aArray . add ( Integer . parseInt ( sc . next ( ) ) ) ; } String [ ] dp = new String [ n + 1 ] ; dp [ 0 ] = \" \" ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int a : aArray ) { if ( cost . get ( a - 1 ) <= i && dp [ i - cost . get ( a - 1 ) ] != null ) { dp [ i ] = func2 ( dp [ i - cost . get ( a - 1 ) ] + a , dp [ i ] ) ; } } } System . out . println ( dp [ n ] ) ; } public static String func2 ( String x , String y ) { if ( y == null ) { return x ; } else if ( x . length ( ) > y . length ( ) ) { return x ; } else if ( x . length ( ) < y . length ( ) ) { return y ; } else { for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( x . charAt ( i ) > y . charAt ( i ) ) { return x ; } else if ( x . charAt ( i ) < y . charAt ( i ) ) { return y ; } } return x ; } } }"], "python": ["if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = [ 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE n , m = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE res = ' ' NEW_LINE INF = 10 ** 4 NEW_LINE dp = [ [ 0 , 0 ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if dp [ i ] [ 1 ] + l [ a [ j ] ] != i + l [ a [ j ] ] or i + l [ a [ j ] ] > n : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + l [ a [ j ] ] ] [ 0 ] = max ( dp [ i ] [ 0 ] + 1 , dp [ i + l [ a [ j ] ] ] [ 0 ] ) NEW_LINE dp [ i + l [ a [ j ] ] ] [ 1 ] = dp [ i ] [ 1 ] + l [ a [ j ] ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : dp [ i ] [ 0 ] = - INF if dp [ i ] [ 0 ] == 0 else dp [ i ] [ 0 ] NEW_LINE a . sort ( reverse = True ) NEW_LINE i = n NEW_LINE while i > 0 : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if i >= l [ a [ j ] ] and dp [ i - l [ a [ j ] ] ] [ 0 ] + 1 == dp [ i ] [ 0 ] : NEW_LINE INDENT res += str ( a [ j ] ) NEW_LINE i -= l [ a [ j ] ] NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT DEDENT print ( res ) NEW_LINE DEDENT", "def max_for_str ( a , b ) : NEW_LINE INDENT if len ( a ) > len ( b ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif len ( a ) < len ( b ) : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT for c1 , c2 in zip ( a , b ) : NEW_LINE INDENT if c1 > c2 : NEW_LINE INDENT return a NEW_LINE DEDENT elif c1 < c2 : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT DEDENT match = [ 0 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE N , M = map ( int , input ( ) . split ( ) ) NEW_LINE As = list ( input ( ) . split ( ) ) NEW_LINE dp = [ None ] * ( N + 1 ) NEW_LINE dp [ 0 ] = \" \" NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for A in As : NEW_LINE INDENT if i - match [ int ( A ) ] >= 0 and not dp [ i - match [ int ( A ) ] ] is None : NEW_LINE INDENT if dp [ i ] is None : NEW_LINE INDENT dp [ i ] = A + dp [ i - match [ int ( A ) ] ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max_for_str ( dp [ i ] , A + dp [ i - match [ int ( A ) ] ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( dp [ N ] ) NEW_LINE", "def is_big ( x = [ 0 ] * 10 , y = [ 0 ] * 10 ) : NEW_LINE INDENT if sum ( x ) > sum ( y ) : NEW_LINE INDENT return True NEW_LINE DEDENT if sum ( x ) < sum ( y ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , 10 ) [ : : - 1 ] : NEW_LINE INDENT if x [ i ] > y [ i ] : NEW_LINE INDENT return True NEW_LINE DEDENT if y [ i ] > x [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE d = [ 0 ] * 8 NEW_LINE b = [ ] NEW_LINE L1 = [ 1 , 7 , 4 , 2 , 3 , 5 , 6 , 9 , 8 ] NEW_LINE L2 = [ 2 , 3 , 4 , 5 , 5 , 5 , 6 , 6 , 7 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if L1 [ i ] in a : NEW_LINE INDENT d [ L2 [ i ] ] = L1 [ i ] NEW_LINE if L2 [ i ] not in b : NEW_LINE INDENT b . append ( L2 [ i ] ) NEW_LINE DEDENT DEDENT DEDENT p = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT p . append ( [ - 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ) NEW_LINE DEDENT p [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for t in b : NEW_LINE INDENT if i - t < 0 or p [ i - t ] [ 0 ] == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT q = p [ i - t ] [ : ] NEW_LINE q [ d [ t ] ] += 1 NEW_LINE if is_big ( q , p [ i ] ) : NEW_LINE INDENT p [ i ] = q NEW_LINE DEDENT DEDENT DEDENT a = \" \" NEW_LINE for i in range ( 10 ) [ : : - 1 ] : NEW_LINE INDENT a += str ( i ) * p [ n ] [ i ] NEW_LINE DEDENT print ( a ) NEW_LINE", "import collections NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE ri = lambda : int ( input ( ) ) NEW_LINE rs = lambda : input ( ) . rstrip ( ) NEW_LINE ril = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE rsl = lambda : input ( ) . rstrip ( ) . split ( ) NEW_LINE ris = lambda n : [ ri ( ) for _ in range ( n ) ] NEW_LINE rss = lambda n : [ rs ( ) for _ in range ( n ) ] NEW_LINE rils = lambda n : [ ril ( ) for _ in range ( n ) ] NEW_LINE rsls = lambda n : [ rsl ( ) for _ in range ( n ) ] NEW_LINE d0 = { 1 : 2 , 2 : 5 , 3 : 5 , 4 : 4 , 5 : 5 , 6 : 6 , 7 : 3 , 8 : 7 , 9 : 6 , } NEW_LINE n , m = ril ( ) NEW_LINE ls = ril ( ) NEW_LINE d = collections . defaultdict ( int ) NEW_LINE for x in ls : NEW_LINE INDENT d [ d0 [ x ] ] = max ( x , d [ d0 [ x ] ] ) NEW_LINE DEDENT dp = [ ( 0 , 0 ) ] * ( n + 1 ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for count , num in d . items ( ) : NEW_LINE INDENT if count > i : NEW_LINE INDENT continue NEW_LINE DEDENT k , l = dp [ i - count ] NEW_LINE if count != i and l == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = ( max ( dp [ i ] [ 0 ] , 10 * k + num ) , max ( dp [ i ] [ 1 ] , l + 1 ) ) NEW_LINE if k != 0 : NEW_LINE INDENT dp [ i ] = ( max ( dp [ i ] [ 0 ] , num * 10 ** l + k ) , max ( dp [ i ] [ 1 ] , l + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT print ( dp [ n ] [ 0 ] ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE INF = 10 ** 6 NEW_LINE match_dict = { 1 : 2 , 2 : 5 , 3 : 5 , 4 : 4 , 5 : 5 , 6 : 6 , 7 : 3 , 8 : 7 , 9 : 6 } NEW_LINE a_list = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a_sorted = sorted ( a_list , reverse = True ) NEW_LINE dp = [ 0 , - INF ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp_dp = [ ] NEW_LINE for a in a_sorted : NEW_LINE INDENT if i - match_dict [ a ] < 0 : NEW_LINE INDENT tmp_dp . append ( - INF ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp_dp . append ( dp [ i - match_dict [ a ] ] + 1 ) NEW_LINE DEDENT DEDENT dp . append ( max ( tmp_dp ) ) NEW_LINE DEDENT sum_str = ' ' NEW_LINE tmp_i = n NEW_LINE while tmp_i > 0 : NEW_LINE INDENT for a in a_sorted : NEW_LINE INDENT if tmp_i >= match_dict [ a ] and dp [ tmp_i - match_dict [ a ] ] == dp [ tmp_i ] - 1 : NEW_LINE INDENT sum_str = sum_str + str ( a ) NEW_LINE tmp_i = tmp_i - match_dict [ a ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( int ( sum_str ) ) NEW_LINE"]}
{"id": "aizu_p00682_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int Case = 1 ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; double a [ ] [ ] = new double [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] [ 0 ] = sc . nextDouble ( ) ; a [ i ] [ 1 ] = sc . nextDouble ( ) ; } double area = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) area += ( a [ i ] [ 0 ] * a [ i + 1 ] [ 1 ] - a [ i ] [ 1 ] * a [ i + 1 ] [ 0 ] ) / 2 ; area += ( a [ n - 1 ] [ 0 ] * a [ 0 ] [ 1 ] - a [ n - 1 ] [ 1 ] * a [ 0 ] [ 0 ] ) / 2 ; System . out . printf ( \" % d \u2581 % .1f \\n \" , Case ++ , - area ) ; } } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int n ; double [ ] x , y ; int i , j ; double sum , ax , ay , bx , by ; for ( j = 1 ; ; ) { n = sc . nextInt ( ) ; if ( n == 0 ) break ; x = new double [ n ] ; y = new double [ n ] ; for ( i = 0 ; i < n ; i ++ ) { x [ i ] = sc . nextDouble ( ) ; y [ i ] = sc . nextDouble ( ) ; } sum = 0.0 ; for ( i = 0 ; i < n - 2 ; i ++ ) { ax = x [ i + 1 ] - x [ 0 ] ; ay = y [ i + 1 ] - y [ 0 ] ; bx = x [ i + 2 ] - x [ 0 ] ; by = y [ i + 2 ] - y [ 0 ] ; sum += ( ax * by - ay * bx ) / 2.0 ; } System . out . printf ( \" % d \u2581 % .1f % n \" , j ++ , - sum ) ; } sc . close ( ) ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { int j = 1 ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 ) ; while ( true ) { ArrayList < Integer > x = new ArrayList < > ( ) ; ArrayList < Integer > y = new ArrayList < > ( ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; if ( n == 0 ) { break ; } for ( int i = 0 ; i < n ; i ++ ) { String st = br . readLine ( ) ; String [ ] num = st . split ( \" \u2581 \" , 0 ) ; x . add ( Integer . parseInt ( num [ 0 ] ) ) ; y . add ( Integer . parseInt ( num [ 1 ] ) ) ; } int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != n - 1 ) { s += ( x . get ( i ) * y . get ( i + 1 ) - x . get ( i + 1 ) * y . get ( i ) ) ; } else { s += ( x . get ( i ) * y . get ( 0 ) - x . get ( 0 ) * y . get ( i ) ) ; } } double S = Math . abs ( s ) / 2.0 ; System . out . print ( j + \" \u2581 \" ) ; System . out . printf ( \" % .1f \" , S ) ; System . out . println ( \" \" ) ; String musi = br . readLine ( ) ; j ++ ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int testnum = 0 ; while ( true ) { testnum ++ ; int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } Vector2 [ ] r = new Vector2 [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = new Vector2 ( sc . nextInt ( ) , sc . nextInt ( ) ) ; } double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Vector2 r1 = r [ i ] ; Vector2 r2 = r [ ( i + 1 ) % n ] ; sum += r1 . cross ( r2 ) / 2 ; } System . out . println ( testnum + \" \u2581 \" + Math . abs ( sum ) ) ; } } } class Vector2 { public double x ; public double y ; public Vector2 ( double x , double y ) { this . x = x ; this . y = y ; } public double dot ( Vector2 v ) { return this . x * v . x + this . y * v . y ; } public double cross ( Vector2 v ) { return this . x * v . y - this . y * v . x ; } public double norm ( ) { return Math . sqrt ( this . x * this . x + this . y * this . y ) ; } public Vector2 normalize ( ) { return divide ( norm ( ) ) ; } public Vector2 add ( Vector2 v ) { return new Vector2 ( x + v . x , y + v . y ) ; } public Vector2 subtract ( Vector2 v ) { return new Vector2 ( x - v . x , y - v . y ) ; } public Vector2 multiply ( double k ) { return new Vector2 ( x * k , y * k ) ; } public Vector2 divide ( double k ) { return new Vector2 ( x / k , y / k ) ; } public String toString ( ) { return \" ( \" + this . x + \" , \" + this . y + \" ) \" ; } }", "import java . awt . * ; import java . util . Scanner ; public class Main { private static double solve ( int n , Point [ ] points ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) { sum += points [ i ] . getX ( ) * points [ 0 ] . getY ( ) - points [ 0 ] . getX ( ) * points [ i ] . getY ( ) ; } else { sum += points [ i ] . getX ( ) * points [ i + 1 ] . getY ( ) - points [ i + 1 ] . getX ( ) * points [ i ] . getY ( ) ; } } return Math . abs ( sum ) / 2 ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = 1 ; while ( true ) { int n = Integer . parseInt ( sc . nextLine ( ) ) ; if ( n == 0 ) break ; Point [ ] points = new Point [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { points [ i ] = new Point ( ) ; String [ ] xy = sc . nextLine ( ) . split ( \" \u2581 \" ) ; points [ i ] . setLocation ( Integer . parseInt ( xy [ 0 ] ) , Integer . parseInt ( xy [ 1 ] ) ) ; } double sum = solve ( n , points ) ; System . out . println ( ( t ++ ) + \" \u2581 \" + String . format ( \" % .1f \" , sum ) ) ; sc . nextLine ( ) ; } sc . close ( ) ; } }"], "python": ["num = 1 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : NEW_LINE INDENT break NEW_LINE DEDENT x0 , y0 = map ( float , input ( ) . split ( ) ) NEW_LINE prx , pry = x0 , y0 NEW_LINE area = 0 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT x , y = map ( float , input ( ) . split ( ) ) NEW_LINE area += ( prx * y - x * pry ) NEW_LINE prx , pry = x , y NEW_LINE DEDENT area += ( prx * y0 - x0 * pry ) NEW_LINE area /= 2 NEW_LINE print ( num , abs ( area ) ) NEW_LINE num += 1 NEW_LINE input ( ) NEW_LINE DEDENT", "def area ( p , q , r ) : NEW_LINE INDENT a = [ x - y for x , y in zip ( r , p ) ] NEW_LINE b = [ x - y for x , y in zip ( q , p ) ] NEW_LINE return ( a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] ) / 2 NEW_LINE DEDENT S = [ ] NEW_LINE while True : NEW_LINE INDENT string = input ( ) NEW_LINE if string == ' ' : NEW_LINE INDENT continue NEW_LINE DEDENT elif int ( string ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( string ) NEW_LINE v = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT v . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT s += area ( v [ 0 ] , v [ i ] , v [ i + 1 ] ) NEW_LINE DEDENT S . append ( round ( s , 1 ) ) NEW_LINE DEDENT DEDENT for i , x in enumerate ( S ) : NEW_LINE INDENT print ( i + 1 , x ) NEW_LINE DEDENT", "def area ( px , py , x , y ) : NEW_LINE INDENT if py > y : NEW_LINE INDENT py , y = y , py NEW_LINE DEDENT return py * ( x - px ) + ( x - px ) * abs ( y - py ) / 2 NEW_LINE DEDENT count = 1 NEW_LINE while True : NEW_LINE INDENT res = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT px , py = map ( int , input ( ) . split ( ) ) NEW_LINE sx , sy = px , py NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE res += area ( px , py , x , y ) NEW_LINE px , py = x , y NEW_LINE DEDENT res += area ( px , py , sx , sy ) NEW_LINE print ( count , res ) NEW_LINE count += 1 NEW_LINE input ( ) NEW_LINE DEDENT", "import sys NEW_LINE if sys . version_info [ 0 ] >= 3 : raw_input = input NEW_LINE cross = lambda a1 , b1 , a2 , b2 : a1 * b2 - a2 * b1 NEW_LINE try : NEW_LINE INDENT T = 0 NEW_LINE while True : NEW_LINE INDENT T += 1 NEW_LINE n = int ( raw_input ( ) ) NEW_LINE if n == 0 : break NEW_LINE a = [ [ float ( e ) for e in raw_input ( ) . split ( ) ] for i in range ( n ) ] NEW_LINE s = 0 NEW_LINE t = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x = cross ( a [ i ] [ 0 ] , a [ i ] [ 1 ] , a [ i + 1 ] [ 0 ] , a [ i + 1 ] [ 1 ] ) NEW_LINE if x > 0 : s += abs ( x ) / 2 NEW_LINE else : t += abs ( x ) / 2 NEW_LINE DEDENT x = cross ( a [ n - 1 ] [ 0 ] , a [ n - 1 ] [ 1 ] , a [ 0 ] [ 0 ] , a [ 0 ] [ 1 ] ) NEW_LINE if x > 0 : s += abs ( x ) / 2 NEW_LINE else : t += abs ( x ) / 2 NEW_LINE print ( ' % d \u2581 % .1f ' % ( T , abs ( s - t ) ) ) NEW_LINE raw_input ( ) NEW_LINE DEDENT DEDENT except EOFError : NEW_LINE INDENT pass NEW_LINE DEDENT", "from decimal import Decimal , ROUND_HALF_UP NEW_LINE def calc_area ( pp ) : NEW_LINE INDENT n , s = len ( pp ) , 0 NEW_LINE for i in range ( n ) : s += ( pp [ i ] . real - pp [ ( i + 1 ) % n ] . real ) * ( pp [ i ] . imag + pp [ ( i + 1 ) % n ] . imag ) NEW_LINE return abs ( s ) / 2 NEW_LINE DEDENT cno = 0 NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE pp = [ complex ( * map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE input ( ) NEW_LINE cno += 1 NEW_LINE print ( cno , Decimal ( str ( calc_area ( pp ) ) ) . quantize ( Decimal ( '0.1' ) , rounding = ROUND_HALF_UP ) ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC130_B", "java": ["import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int [ ] l = new int [ n ] ; int [ ] d = new int [ n + 1 ] ; d [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { l [ i ] = sc . nextInt ( ) ; } int count = 1 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { d [ i ] = d [ i - 1 ] + l [ i - 1 ] ; if ( d [ i ] <= x ) count ++ ; } System . out . println ( count ) ; sc . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; import java . util . StringTokenizer ; public class Main { private static final int MOD = ( int ) Math . pow ( 10 , 9 ) ; public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int res = 0 ; int [ ] d = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int ls = sc . nextInt ( ) ; d [ i + 1 ] = ls + d [ i ] ; if ( d [ i + 1 ] <= x ) { res ++ ; } } System . out . println ( res + 1 ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; BBounding solver = new BBounding ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class BBounding { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int x = in . nextInt ( ) ; int d = 0 ; int count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = in . nextInt ( ) ; d += temp ; if ( d <= x ) count ++ ; else break ; } out . println ( count ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { MyReader r = new MyReader ( ) ; int N , X ; { int [ ] a = r . ii ( ) ; N = a [ 0 ] ; X = a [ 1 ] ; } int [ ] L = r . ii ( ) ; int y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { y += L [ i ] ; if ( X < y ) { println ( i + 1 ) ; return ; } } println ( N + 1 ) ; } static void print ( Object o ) { System . out . print ( o . toString ( ) ) ; } static void println ( Object o ) { System . out . println ( o . toString ( ) ) ; } static int Int ( String s ) { return Integer . parseInt ( s ) ; } static long Long ( String s ) { return Long . parseLong ( s ) ; } static class MyReader extends BufferedReader { MyReader ( ) { super ( new InputStreamReader ( System . in ) ) ; } String s ( ) throws IOException { return readLine ( ) ; } String [ ] ss ( ) throws IOException { return s ( ) . split ( \" \u2581 \" ) ; } int i ( ) throws IOException { return Int ( s ( ) ) ; } int [ ] ii ( ) throws IOException { String [ ] ss = ss ( ) ; int size = ss . length ; int [ ] ii = new int [ size ] ; for ( int j = 0 ; j < size ; j ++ ) ii [ j ] = Int ( ss [ j ] ) ; return ii ; } long l ( ) throws IOException { return Long ( s ( ) ) ; } long [ ] ll ( ) throws IOException { String [ ] ss = ss ( ) ; int size = ss . length ; long [ ] ll = new long [ size ] ; for ( int j = 0 ; j < size ; j ++ ) ll [ j ] = Long ( ss [ j ] ) ; return ll ; } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] arg ) { try ( Scanner scanner = new Scanner ( System . in ) ) { int [ ] input = Arrays . stream ( scanner . nextLine ( ) . split ( \" \u2581 \" ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; int n = input [ 0 ] ; int x = input [ 1 ] ; int sum = 0 ; int count = 1 ; for ( int i : Arrays . stream ( scanner . nextLine ( ) . split ( \" \u2581 \" ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ) { sum += i ; if ( sum > x ) break ; count ++ ; } System . out . println ( count ) ; } } }"], "python": ["N , X = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE l_list = input ( ) . split ( ) NEW_LINE count = 1 NEW_LINE d = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT da = d + int ( l_list [ i ] ) NEW_LINE d = da NEW_LINE if da <= X : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) NEW_LINE break NEW_LINE DEDENT if count == int ( N ) + 1 : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT DEDENT", "import sys ; NEW_LINE import string ; NEW_LINE sys . setrecursionlimit ( 20000 ) NEW_LINE import copy NEW_LINE import itertools NEW_LINE from functools import lru_cache NEW_LINE PPP = 1000000007 NEW_LINE n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE import re NEW_LINE def doit ( ) : NEW_LINE INDENT p = 0 NEW_LINE res = 1 NEW_LINE for lx in l : NEW_LINE INDENT p += lx NEW_LINE if x < p : NEW_LINE INDENT break NEW_LINE DEDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT try : NEW_LINE INDENT print ( doit ( ) ) NEW_LINE DEDENT except Exception as e : NEW_LINE INDENT print ( \" e \" , e , file = sys . stderr ) NEW_LINE DEDENT", "n , x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE lList = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE coordinate = 0 NEW_LINE count = 1 NEW_LINE for l in lList : NEW_LINE INDENT coordinate += l NEW_LINE if coordinate <= x : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "def main ( ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE max = 0 NEW_LINE for i in range ( len ( l ) ) : NEW_LINE INDENT max += l [ i ] NEW_LINE if max <= x : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE", "n , x = map ( int , input ( ) . split ( ) ) NEW_LINE L = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE cnt = 0 NEW_LINE Sum = [ 0 for i in range ( len ( L ) + 1 ) ] NEW_LINE for i in range ( len ( L ) ) : NEW_LINE INDENT Sum [ i + 1 ] = Sum [ i ] + L [ i ] NEW_LINE DEDENT for i in range ( len ( Sum ) ) : NEW_LINE INDENT if Sum [ i ] > x : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"]}
{"id": "codeforces_758_A", "java": ["import java . util . * ; import java . io . * ; public class A758 { static Scanner sc = new Scanner ( ) ; public static void main ( String [ ] args ) { solve ( ) ; } public static void solve ( ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int result = 0 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; if ( max <= arr [ i ] ) max = arr [ i ] ; } for ( int j = 0 ; j < n ; j ++ ) { result += max - arr [ j ] ; } System . out . print ( result ) ; } static class Scanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } int [ ] readArray ( int n ) { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } } }", "import java . util . * ; public class Today { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += max - arr [ i ] ; } System . out . println ( ans ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; import java . util . Scanner ; import java . util . TreeSet ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; TreeSet < Integer > s = new TreeSet < > ( ) ; if ( n == 1 ) { System . out . println ( 0 ) ; return ; } int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; int max = arr [ n - 1 ] ; long sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += max - arr [ i ] ; } System . out . println ( sum ) ; } }", "import java . util . Scanner ; import java . util . ArrayList ; public class problems { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int citizens = input . nextInt ( ) , theMax = 0 , sum = 0 ; int ar [ ] = new int [ citizens ] ; for ( int i = 0 ; i < citizens ; i ++ ) { ar [ i ] = input . nextInt ( ) ; if ( theMax < ar [ i ] ) { theMax = ar [ i ] ; } } for ( int i = 0 ; i < citizens ; i ++ ) { if ( ar [ i ] <= theMax ) { sum = sum + theMax - ar [ i ] ; } } System . out . println ( sum ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; max = Math . max ( arr [ i ] , max ) ; } long min = 0 ; for ( int j = 0 ; j < n ; j ++ ) { min += Math . abs ( arr [ j ] - max ) ; } System . out . println ( min ) ; } }"], "python": ["a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = b [ 0 ] NEW_LINE for j in b : NEW_LINE INDENT if j > c : NEW_LINE INDENT c = j NEW_LINE DEDENT DEDENT m = 0 NEW_LINE for k in b : NEW_LINE INDENT m += ( c - k ) NEW_LINE DEDENT print ( m ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_burles = max ( a ) NEW_LINE total = 0 NEW_LINE for i in a : NEW_LINE INDENT total += abs ( max_burles - i ) NEW_LINE DEDENT print ( total ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE max_burles = max ( a ) NEW_LINE total = 0 NEW_LINE for i in a : NEW_LINE INDENT total += abs ( max_burles - i ) NEW_LINE DEDENT print ( total ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxb = max ( a ) NEW_LINE print ( sum ( map ( lambda e : abs ( maxb - e ) , a ) ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE maxb = max ( a ) NEW_LINE print ( sum ( map ( lambda e : abs ( maxb - e ) , a ) ) ) NEW_LINE"]}
{"id": "codeforces_1283_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int testcases = sc . nextInt ( ) ; int hour ; int minute ; for ( int i = 0 ; i < testcases ; i ++ ) { hour = sc . nextInt ( ) ; int hoursto = 24 - hour ; int minutes1 = hoursto * 60 ; minute = sc . nextInt ( ) ; int totaltimeto = minutes1 - minute ; System . out . println ( totaltimeto ) ; } } }", "import java . util . Scanner ; public class cf1283A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; int h , m , min ; for ( int i = 1 ; i <= t ; i ++ ) { h = input . nextInt ( ) ; m = input . nextInt ( ) ; min = 60 - m ; if ( ++ h < 24 ) min += ( 24 - h ) * 60 ; System . out . println ( min ) ; } } }", "import java . util . Scanner ; public class cf1283A { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; int h , m , min ; for ( int i = 1 ; i <= t ; i ++ ) { h = input . nextInt ( ) ; m = input . nextInt ( ) ; min = 60 - m ; if ( ++ h < 24 ) min += ( 24 - h ) * 60 ; System . out . println ( min ) ; } } }", "import java . util . Scanner ; public class newYear { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int a = in . nextInt ( ) ; while ( a -- > 0 ) { int hour = in . nextInt ( ) ; int minutes = in . nextInt ( ) ; int h = 0 ; int m = 0 ; while ( hour < 23 ) { h ++ ; hour ++ ; } while ( minutes < 60 ) { m ++ ; minutes ++ ; } System . out . println ( ( h * 60 ) + m ) ; } } }", "import java . util . Scanner ; public class NEWYEAR { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int T = sc . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int h = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int x = ( 24 - h ) * 60 - m ; System . out . println ( x ) ; } } }"], "python": ["for j in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE k = 0 NEW_LINE k = ( 23 - a ) * 60 + ( 60 - b ) NEW_LINE print ( k ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE out = 1440 - h * 60 - m NEW_LINE print ( out ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE t , d = 0 , 0 NEW_LINE d = 24 * 60 NEW_LINE t = h * 60 + m NEW_LINE print ( d - t ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT h , m = map ( int , input ( ) . split ( ) ) NEW_LINE print ( 1440 - h * 60 - m ) NEW_LINE DEDENT", "a = int ( input ( ) ) NEW_LINE k = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT b , c = map ( int , input ( ) . split ( ) ) NEW_LINE k = ( 23 - b ) * 60 + ( 60 - c ) NEW_LINE print ( k ) NEW_LINE DEDENT"]}
{"id": "aizu_p00218_A", "java": ["import java . util . Arrays ; import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { final int n = sc . nextInt ( ) ; if ( n == 0 ) { break ; } for ( int i = 0 ; i < n ; i ++ ) { int pm = sc . nextInt ( ) , pe = sc . nextInt ( ) , pj = sc . nextInt ( ) ; if ( Math . max ( Math . max ( pm , pe ) , pj ) == 100 ) { System . out . println ( \" A \" ) ; } else if ( ( pm + pe ) / 2 >= 90 ) { System . out . println ( \" A \" ) ; } else if ( ( pm + pe + pj ) / 3 >= 80 ) { System . out . println ( \" A \" ) ; } else if ( ( pm + pe + pj ) / 3 >= 70 ) { System . out . println ( \" B \" ) ; } else if ( ( pm + pe + pj ) / 3 >= 50 && Math . max ( pm , pe ) >= 80 ) { System . out . println ( \" B \" ) ; } else { System . out . println ( \" C \" ) ; } } } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line = \" \" ; StringBuilder sb = new StringBuilder ( ) ; while ( ! ( line = br . readLine ( ) ) . equals ( \"0\" ) ) { int n = Integer . parseInt ( line ) ; for ( int i = 0 ; i < n ; ++ i ) { StringTokenizer st = new StringTokenizer ( br . readLine ( ) ) ; int pm = Integer . parseInt ( st . nextToken ( ) ) ; int pe = Integer . parseInt ( st . nextToken ( ) ) ; int pj = Integer . parseInt ( st . nextToken ( ) ) ; int sum = pm + pe + pj ; char rank = ' C ' ; if ( pm > 99 || pe > 99 || pj > 99 ) { rank = ' A ' ; } else if ( sum > 239 || sum - pj > 179 ) { rank = ' A ' ; } else if ( sum > 209 ) { rank = ' B ' ; } else if ( sum > 149 && ( pm > 79 || pe > 79 ) ) { rank = ' B ' ; } sb . append ( rank ) . append ( ' \\n ' ) ; } } System . out . print ( sb . toString ( ) ) ; } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int n , pm , pe , pj ; for ( ; ; ) { n = sc . nextInt ( ) ; if ( n == 0 ) break ; for ( ; n -- > 0 ; out . println ( solve ( pm , pe , pj ) ) ) { pm = sc . nextInt ( ) ; pe = sc . nextInt ( ) ; pj = sc . nextInt ( ) ; } } sc . close ( ) ; } private static String solve ( int m , int e , int j ) { if ( m == 100 ) return \" A \" ; if ( e == 100 ) return \" A \" ; if ( j == 100 ) return \" A \" ; if ( m + e >= 180 ) return \" A \" ; if ( m + e + j >= 240 ) return \" A \" ; if ( m + e + j >= 210 ) return \" B \" ; if ( m + e + j >= 150 && m >= 80 ) return \" B \" ; if ( m + e + j >= 150 && e >= 80 ) return \" B \" ; return \" C \" ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import static java . util . Arrays . deepToString ; import java . util . Arrays ; import java . util . Scanner ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void tr ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } Scanner sc = new Scanner ( System . in ) ; void run ( ) { for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; char ans = 0 ; if ( ans == 0 ) { if ( a >= 100 || b >= 100 || c >= 100 ) ans = ' A ' ; } if ( ans == 0 ) { if ( a + b >= 180 ) ans = ' A ' ; } if ( ans == 0 ) { if ( a + b + c >= 240 ) ans = ' A ' ; } if ( ans == 0 ) { if ( a + b + c >= 210 ) ans = ' B ' ; } if ( ans == 0 ) { if ( a + b + c >= 150 && ( a >= 80 || b >= 80 ) ) ans = ' B ' ; } if ( ans == 0 ) { ans = ' C ' ; } System . out . println ( ans ) ; } } } }", "import java . util . * ; import static java . lang . Math . * ; import static java . util . Arrays . * ; public class Main { int INF = 1 << 28 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] score = new int [ 3 ] ; for ( int j = 0 ; j < 3 ; j ++ ) score [ j ] = sc . nextInt ( ) ; if ( score [ 0 ] == 100 || score [ 1 ] == 100 || score [ 2 ] == 100 || score [ 0 ] + score [ 1 ] >= 180 || score [ 0 ] + score [ 1 ] + score [ 2 ] >= 240 ) { System . out . println ( \" A \" ) ; } else if ( score [ 0 ] + score [ 1 ] + score [ 2 ] >= 210 || ( score [ 0 ] + score [ 1 ] + score [ 2 ] >= 150 && ( score [ 0 ] >= 80 || score [ 1 ] >= 80 ) ) ) { System . out . println ( \" B \" ) ; } else System . out . println ( \" C \" ) ; } } } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } }"], "python": ["def bar ( a , b , c ) : NEW_LINE INDENT x = ( a + b + c ) / 3 NEW_LINE return x NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT m , e , j = map ( int , input ( ) . split ( ) ) NEW_LINE y = ( m + e ) / 2 NEW_LINE x = bar ( m , e , j ) NEW_LINE if ( m == 100 or e == 100 or j == 100 ) or y >= 90 or x >= 80 : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT elif x >= 70 : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT elif x >= 50 : NEW_LINE INDENT if m >= 80 or e >= 80 : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" C \" ) NEW_LINE DEDENT DEDENT DEDENT", "import sys , math , os , fractions NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == \" True \" : NEW_LINE INDENT sys . stdin = open ( \" sample - input . txt \" , \" rt \" ) NEW_LINE DEDENT def grade ( m , e , j ) : NEW_LINE INDENT if m + e >= 180 or m + e + j >= 240 or max ( e , j , m ) == 100 : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT elif m + e + j >= 210 : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT elif m + e + j >= 150 and max ( m , e ) >= 80 : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT return ' C ' NEW_LINE DEDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT m , e , j = [ int ( __ ) for __ in input ( ) . split ( ) ] NEW_LINE print ( grade ( m , e , j ) ) NEW_LINE DEDENT DEDENT", "def a1 ( li ) : NEW_LINE INDENT if 100 in li : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT def a2 ( li ) : NEW_LINE INDENT if ( li [ 0 ] + li [ 1 ] ) / 2 >= 90 : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT def a3 ( li ) : NEW_LINE INDENT if sum ( li ) / 3 >= 80 : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT def isA ( li ) : NEW_LINE INDENT if a1 ( li ) or a2 ( li ) or a3 ( li ) : return 1 NEW_LINE else : 0 NEW_LINE DEDENT def b1 ( li ) : NEW_LINE INDENT if sum ( li ) / 3 >= 70 : return 1 NEW_LINE else : return 0 NEW_LINE DEDENT def b2 ( li ) : NEW_LINE INDENT if sum ( li ) / 3 >= 50 and ( li [ 0 ] >= 80 or li [ 1 ] >= 80 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : return 0 NEW_LINE DEDENT def isB ( li ) : NEW_LINE INDENT if b1 ( li ) or b2 ( li ) : return 1 NEW_LINE else : 0 NEW_LINE DEDENT def isX ( li ) : NEW_LINE INDENT if isA ( li ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT elif isB ( li ) : NEW_LINE INDENT return ' B ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' C ' NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE for _ in range ( N ) : NEW_LINE INDENT l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( isX ( l ) ) NEW_LINE DEDENT DEDENT", "while True : NEW_LINE INDENT num = int ( input ( ) ) NEW_LINE if num == 0 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT for _ in range ( num ) : NEW_LINE INDENT a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 100 or b == 100 or c == 100 or ( a + b ) / 2 >= 90 or ( a + b + c ) / 3 >= 80 : print ( \" A \" ) NEW_LINE elif ( a + b + c ) / 3 >= 70 or ( a + b + c ) / 3 >= 50 and a >= 80 or ( a + b + c ) / 3 >= 50 and b >= 80 : print ( \" B \" ) NEW_LINE else : print ( \" C \" ) NEW_LINE DEDENT DEDENT DEDENT", "while ( True ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if not n : break NEW_LINE for _ in range ( n ) : NEW_LINE INDENT m , e , j = map ( int , input ( ) . split ( ) ) NEW_LINE if 100 in [ m , e , j ] : print ( \" A \" ) ; continue NEW_LINE elif ( m + e ) / 2 >= 90 : print ( \" A \" ) ; continue NEW_LINE elif ( m + e + j ) / 3 >= 80 : print ( \" A \" ) ; continue NEW_LINE elif ( m + e + j ) / 3 >= 70 : print ( \" B \" ) ; continue NEW_LINE elif ( m + e + j ) / 3 >= 50 and ( m >= 80 or e >= 80 ) : print ( \" B \" ) ; continue NEW_LINE else : print ( \" C \" ) ; continue NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_412_B", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { try { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ n - k ] ) ; } catch ( Exception e ) { } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } Arrays . sort ( arr ) ; System . out . println ( arr [ n - k ] ) ; } }", "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int k = scanner . nextInt ( ) ; Integer [ ] a = new Integer [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( a , new P6974Cmp ( ) ) ; System . out . println ( a [ k - 1 ] ) ; } } class P6974Cmp implements Comparator < Integer > { @ Override public int compare ( Integer o1 , Integer o2 ) { return o2 - o1 ; } }"], "python": ["n_computers , k_participants = map ( int , input ( ) . split ( ) ) NEW_LINE kps = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( min ( sorted ( kps , reverse = True ) [ : k_participants ] ) ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ n - k ] ) NEW_LINE", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE print ( sorted ( map ( int , input ( ) . split ( ) ) ) [ n - k ] ) NEW_LINE", "n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE print ( arr [ n - k ] ) NEW_LINE", "a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE d . sort ( ) NEW_LINE print ( d [ - b ] ) NEW_LINE"]}
{"id": "codeforces_1295_B", "java": ["import java . util . Scanner ; public class Ex1 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- > 0 ) { int length = in . nextInt ( ) ; int balance = in . nextInt ( ) ; String s = in . next ( ) ; int val = 0 ; int min = 0 ; int max = 0 ; int counter = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) ) { val ++ ; } else { val -- ; } min = Math . min ( val , min ) ; max = Math . max ( val , max ) ; } if ( val == 0 && balance >= min && balance <= max ) { System . out . println ( \" - 1\" ) ; continue ; } else if ( val == 0 ) { System . out . println ( \"0\" ) ; continue ; } int totalVal = val ; val = 0 ; if ( balance == 0 ) { counter ++ ; } for ( int i = 0 ; i < length ; i ++ ) { if ( ( s . charAt ( i ) == '0' ) ) { val ++ ; } else { val -- ; } if ( ( balance - val ) % totalVal == 0 && ( balance - val ) / totalVal >= 0 ) { counter ++ ; } } System . out . println ( counter ) ; } } }"], "python": ["from collections import defaultdict NEW_LINE def balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT if imbalance >= 0 : NEW_LINE INDENT return ( x - balance ) >= 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( x - balance ) <= 0 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , x = tuple ( int ( o ) for o in input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE balances_to_occurrences = defaultdict ( int ) NEW_LINE imbalance = 0 NEW_LINE s = 0 NEW_LINE for char in string : NEW_LINE INDENT if char == '0' : NEW_LINE INDENT imbalance += 1 NEW_LINE DEDENT else : NEW_LINE INDENT imbalance -= 1 NEW_LINE DEDENT balances_to_occurrences [ imbalance ] += 1 NEW_LINE DEDENT if imbalance == 0 : NEW_LINE INDENT if ( x in balances_to_occurrences or x == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for balance , occurrences in balances_to_occurrences . items ( ) : NEW_LINE INDENT if ( x - balance ) % imbalance == 0 and balance_is_realizable ( imbalance , x , balance ) : NEW_LINE INDENT s += occurrences NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT s += 1 NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from math import * NEW_LINE zzz = int ( input ( ) ) NEW_LINE for zz in range ( zzz ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE s = [ int ( i ) for i in input ( ) ] NEW_LINE a = [ ] NEW_LINE bal = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] > 0 : NEW_LINE INDENT bal -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT a . append ( bal ) NEW_LINE DEDENT if x > 0 and a [ - 1 ] < 0 and max ( a ) < x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif x < 0 and a [ - 1 ] > 0 and min ( a ) > x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif a [ - 1 ] != 0 : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x - a [ i ] ) % a [ - 1 ] == 0 and ( x - a [ i ] ) // a [ - 1 ] >= 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if x == 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT if x in a : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT x , y = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE s = input ( ) NEW_LINE b , z , ans , flag = s . count ( '0' ) - s . count ( '1' ) , 0 , 0 , False NEW_LINE if y == 0 : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT for elem in s : NEW_LINE INDENT z += ( elem == '0' ) - ( elem == '1' ) NEW_LINE if b == 0 and z == y : NEW_LINE INDENT flag = True NEW_LINE print ( - 1 ) NEW_LINE break NEW_LINE DEDENT if z == y or ( ( y - z ) * b > 0 and abs ( ( y - z ) ) % abs ( b ) == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , x = map ( int , input ( ) . split ( ) ) NEW_LINE string = input ( ) NEW_LINE num = [ 0 ] NEW_LINE for i in string : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT num . append ( num [ - 1 ] - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT num . append ( num [ - 1 ] + 1 ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE isInfi = False NEW_LINE for i in num [ : - 1 ] : NEW_LINE INDENT if num [ n ] == 0 : NEW_LINE INDENT if i == x : NEW_LINE INDENT isInfi = True NEW_LINE DEDENT DEDENT elif abs ( x - i ) % abs ( num [ n ] ) == 0 : NEW_LINE INDENT if ( x - i ) / ( num [ n ] ) >= 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT if isInfi : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT", "def str_balance ( s ) : NEW_LINE INDENT return s . count ( \"0\" ) - s . count ( \"1\" ) NEW_LINE DEDENT def val ( c ) : NEW_LINE INDENT if c == \"1\" : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def arr_balance ( s ) : NEW_LINE INDENT l = [ 0 ] NEW_LINE for c in s : NEW_LINE INDENT l . append ( l [ - 1 ] + val ( c ) ) NEW_LINE DEDENT return l [ 1 : ] NEW_LINE DEDENT INFINITE = - 1 NEW_LINE def calc_prefix_number ( s , n , x ) : NEW_LINE INDENT l = arr_balance ( s ) NEW_LINE steps = l [ - 1 ] NEW_LINE if steps == 0 : NEW_LINE INDENT if x in l : NEW_LINE INDENT return INFINITE NEW_LINE DEDENT return 0 NEW_LINE DEDENT cnt = 0 NEW_LINE if x == 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for cell in l : NEW_LINE INDENT if ( x - cell ) % steps == 0 and ( x - cell ) * steps >= 0 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT testcases = int ( input ( ) ) NEW_LINE for _ in range ( testcases ) : NEW_LINE INDENT n , x = [ int ( p ) for p in input ( ) . split ( ) ] NEW_LINE s = input ( ) NEW_LINE print ( calc_prefix_number ( s , n , x ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1530_A", "java": ["class Main { static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( \" Index : \u2581 \" + i ) ; else System . out . println ( \" Key \u2581 not \u2581 found \" ) ; } }"], "python": ["def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ l ] <= arr [ mid ] : NEW_LINE INDENT if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT return search ( arr , mid + 1 , h , key ) NEW_LINE DEDENT if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( \" Index : \u2581 % d \" % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Key \u2581 not \u2581 found \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5236_A", "java": ["import java . util . Arrays ; class GFG { static void fillWithFreq ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; Arrays . fill ( temp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fillWithFreq ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + \" \u2581 \" ) ; } }"], "python": ["def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2239_A", "java": ["import java . io . * ; class GFG { static void convert_To_Len_th_base ( int n , int arr [ ] , int len , int L ) { for ( int i = 0 ; i < L ; i ++ ) { System . out . print ( arr [ n % len ] ) ; n /= len ; } System . out . println ( ) ; } static void print ( int arr [ ] , int len , int L ) { for ( int i = 0 ; i < ( int ) Math . pow ( len , L ) ; i ++ ) { convert_To_Len_th_base ( i , arr , len , L ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int len = arr . length ; int L = 2 ; print ( arr , len , L ) ; } }"], "python": ["def convert_To_Len_th_base ( n , arr , Len , L ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT print ( arr [ n % Len ] , end = \" \" ) NEW_LINE n //= Len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printf ( arr , Len , L ) : NEW_LINE INDENT for i in range ( pow ( Len , L ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , Len , L ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE Len = len ( arr ) NEW_LINE L = 2 NEW_LINE printf ( arr , Len , L ) NEW_LINE"]}
{"id": "codeforces_292_B", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int nodes = input . nextInt ( ) ; int edges = input . nextInt ( ) ; int [ ] arr = new int [ nodes ] ; for ( int i = 0 ; i < edges ; i ++ ) { int n1 = input . nextInt ( ) ; int n2 = input . nextInt ( ) ; arr [ n1 - 1 ] ++ ; arr [ n2 - 1 ] ++ ; } int deg1 = 0 ; int deg2 = 0 ; int deg3 = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == 1 ) { deg1 ++ ; } else if ( arr [ i ] == 2 ) { deg2 ++ ; } else if ( arr [ i ] == nodes - 1 ) { deg3 ++ ; } else { System . out . println ( \" unknown \u2581 topology \" ) ; return ; } } if ( deg2 == nodes ) { System . out . println ( \" ring \u2581 topology \" ) ; } else if ( deg2 == nodes - 2 && deg1 == 2 ) { System . out . println ( \" bus \u2581 topology \" ) ; } else if ( deg3 == 1 && deg1 == nodes - 1 ) { System . out . println ( \" star \u2581 topology \" ) ; } else { System . out . println ( \" unknown \u2581 topology \" ) ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; int [ ] x = new int [ n + 1 ] ; int [ ] y = new int [ n + 1 ] ; int two = 0 , one = 0 ; for ( int j = 0 ; j < m ; j ++ ) { int a = sc . nextInt ( ) , b = sc . nextInt ( ) ; x [ a ] ++ ; x [ b ] ++ ; y [ a ] = b ; y [ b ] = a ; } int max = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x [ i ] == 1 ) one ++ ; else if ( x [ i ] == 2 ) two ++ ; max = Math . max ( max , x [ i ] ) ; } if ( max == m ) System . out . println ( \" star \u2581 topology \" ) ; else if ( two == n ) System . out . println ( \" ring \u2581 topology \" ) ; else if ( two == n - 2 && one == 2 ) System . out . println ( \" bus \u2581 topology \" ) ; else System . out . println ( \" unknown \u2581 topology \" ) ; } }", "import java . util . * ; public class B2 { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] data = new int [ n ] ; int max = 0 ; int twoTimes = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int k = sc . nextInt ( ) ; int v = sc . nextInt ( ) ; data [ k - 1 ] ++ ; data [ v - 1 ] ++ ; if ( data [ k - 1 ] == 2 ) twoTimes ++ ; if ( data [ v - 1 ] == 2 ) twoTimes ++ ; max = Math . max ( max , data [ k - 1 ] ) ; max = Math . max ( max , data [ v - 1 ] ) ; } if ( max == 2 && twoTimes == n ) { System . out . println ( \" ring \u2581 topology \" ) ; } else if ( max == 2 && twoTimes == n - 2 ) { System . out . println ( \" bus \u2581 topology \" ) ; } else if ( max == m ) { System . out . println ( \" star \u2581 topology \" ) ; } else { System . out . println ( \" unknown \u2581 topology \" ) ; } } }", "import java . util . * ; import java . io . * ; import java . lang . * ; public class Codeforces { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { if ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public static void main ( String [ ] args ) { new Codeforces ( ) . solve ( ) ; } Node node [ ] ; void solve ( ) { int n = nextInt ( ) , m = nextInt ( ) ; node = new Node [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) node [ i ] = new Node ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int a = nextInt ( ) , b = nextInt ( ) ; node [ a ] . adj . add ( b ) ; node [ b ] . adj . add ( a ) ; } int res [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { res [ i ] = node [ i ] . adj . size ( ) ; } int notOne = 0 , two = 0 , one = 0 , zero = 0 ; for ( int i : res ) { if ( i == 0 ) zero ++ ; if ( i != 1 ) { notOne ++ ; } if ( i == 2 ) two ++ ; if ( i == 1 ) one ++ ; } notOne -- ; if ( two == n ) { out . println ( \" ring \u2581 topology \" ) ; } else if ( one == 2 && two == n - 2 ) { out . println ( \" bus \u2581 topology \" ) ; } else if ( notOne == 1 && one == n - 1 ) { out . println ( \" star \u2581 topology \" ) ; } else { out . println ( \" unknown \u2581 topology \" ) ; } out . close ( ) ; } } class Node { List < Integer > adj = new ArrayList < > ( ) ; }"], "python": ["n , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = dict ( ) NEW_LINE maxi = 0 NEW_LINE maxv = 0 NEW_LINE for _ in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a - 1 in d : NEW_LINE INDENT d [ a - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ a - 1 ] = 1 NEW_LINE DEDENT if b - 1 in d : NEW_LINE INDENT d [ b - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ b - 1 ] = 1 NEW_LINE DEDENT if d [ a - 1 ] > maxv : NEW_LINE INDENT maxv = d [ a - 1 ] NEW_LINE maxi = a - 1 NEW_LINE DEDENT if d [ b - 1 ] > maxv : NEW_LINE INDENT maxv = d [ b - 1 ] NEW_LINE maxi = b - 1 NEW_LINE DEDENT DEDENT if m + 1 == n : NEW_LINE INDENT if maxv == m : NEW_LINE INDENT print ( ' star \u2581 topology ' ) NEW_LINE DEDENT elif maxv == 2 : NEW_LINE INDENT print ( ' bus \u2581 topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT DEDENT elif m == n : NEW_LINE INDENT if maxv == 2 : NEW_LINE INDENT print ( ' ring \u2581 topology ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ' unknown \u2581 topology ' ) NEW_LINE DEDENT", "import sys NEW_LINE import math NEW_LINE import string NEW_LINE def getRes ( connections , n , m ) : NEW_LINE INDENT bus = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if connections [ i ] == 1 : NEW_LINE INDENT bus += 1 NEW_LINE DEDENT elif connections [ i ] == n - 1 and m == n - 1 : NEW_LINE INDENT print ( \" star \u2581 topology \" ) NEW_LINE return NEW_LINE DEDENT elif connections [ i ] != 2 : NEW_LINE INDENT print ( \" unknown \u2581 topology \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if bus == 2 : NEW_LINE INDENT print ( \" bus \u2581 topology \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ring \u2581 topology \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT [ n , m ] = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE connections = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT [ x , y ] = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE connections [ x ] += 1 NEW_LINE connections [ y ] += 1 NEW_LINE DEDENT getRes ( connections , n , m ) NEW_LINE DEDENT", "import sys NEW_LINE import math NEW_LINE import string NEW_LINE def getRes ( connections , n , m ) : NEW_LINE INDENT bus = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if connections [ i ] == 1 : NEW_LINE INDENT bus += 1 NEW_LINE DEDENT elif connections [ i ] == n - 1 and m == n - 1 : NEW_LINE INDENT print ( \" star \u2581 topology \" ) NEW_LINE return NEW_LINE DEDENT elif connections [ i ] != 2 : NEW_LINE INDENT print ( \" unknown \u2581 topology \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if bus == 2 : NEW_LINE INDENT print ( \" bus \u2581 topology \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ring \u2581 topology \" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT [ n , m ] = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE connections = [ 0 for x in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT [ x , y ] = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] NEW_LINE connections [ x ] += 1 NEW_LINE connections [ y ] += 1 NEW_LINE DEDENT getRes ( connections , n , m ) NEW_LINE DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE g = [ [ ] for _ in range ( n ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE g [ x - 1 ] . append ( y - 1 ) NEW_LINE g [ y - 1 ] . append ( x - 1 ) NEW_LINE DEDENT def ring ( n , m , g ) : NEW_LINE INDENT if all ( len ( l ) == 2 for l in g ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def star ( n , m , g ) : NEW_LINE INDENT return any ( len ( l ) == m for l in g ) NEW_LINE DEDENT def bus ( n , m , g ) : NEW_LINE INDENT for node in range ( 3 ) : NEW_LINE INDENT if len ( g [ node ] ) == 2 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT exit = 0 NEW_LINE visited = [ 0 ] * n NEW_LINE visited [ node ] = 1 NEW_LINE nodes = [ node ] NEW_LINE while nodes : NEW_LINE INDENT cur = nodes . pop ( ) NEW_LINE count = 0 NEW_LINE for new_node in g [ cur ] : NEW_LINE INDENT if not visited [ new_node ] : NEW_LINE INDENT visited [ new_node ] = 1 NEW_LINE nodes . append ( new_node ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT if count == 0 : NEW_LINE INDENT exit += 1 NEW_LINE DEDENT DEDENT return exit == 2 NEW_LINE DEDENT if m == n - 1 and bus ( n , m , g ) : NEW_LINE INDENT print ( \" bus \u2581 topology \" ) NEW_LINE DEDENT elif m == n and ring ( n , m , g ) : NEW_LINE INDENT print ( \" ring \u2581 topology \" ) NEW_LINE DEDENT elif m == n - 1 and star ( n , m , g ) : NEW_LINE INDENT print ( \" star \u2581 topology \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" unknown \u2581 topology \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3735_A", "java": ["class GFG { static long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . pow ( p , 1 / n ) ; return gcd ; } public static void main ( String [ ] args ) { long n = 3 ; long p = 80 ; System . out . println ( max_gcd ( n , p ) ) ; } }"], "python": ["import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 ; NEW_LINE gcd = 1 ; NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( 2 , count // n ) ; NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( p ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE p = p // i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( i , count // n ) ; NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd = gcd * pow ( p , 1 // n ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT n = 3 ; NEW_LINE p = 80 ; NEW_LINE print ( max_gcd ( n , p ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_1238_A", "java": ["import java . io . * ; class GFG { static int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; } public static void main ( String [ ] args ) { float n = 38 ; System . out . println ( \" Maximum \u2581 Area \u2581 = \u2581 \" + maxArea ( n ) ) ; } }"], "python": ["from math import ceil , floor NEW_LINE def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 38 NEW_LINE print ( \" Maximum \u2581 Area \u2581 = \" , maxArea ( n ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_899_A", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = s . nextInt ( ) ; Arrays . sort ( a ) ; int c = 0 ; int st = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( a [ j ] == 2 && a [ i ] + a [ j ] == 3 ) { c ++ ; } else { st = i ; break ; } } int one = 0 ; for ( int i = st ; i < n ; i ++ ) { if ( a [ i ] == 1 ) one ++ ; else break ; } System . out . println ( c + one / 3 ) ; } }", "import java . io . * ; import java . util . StringTokenizer ; public class A { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( sc . nextInt ( ) == 1 ) ++ ones ; else ++ twos ; int ans = Math . min ( ones , twos ) ; ones -= ans ; ans += ones / 3 ; out . println ( ans ) ; out . close ( ) ; } static class Scanner { StringTokenizer st ; BufferedReader br ; public Scanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public String nextLine ( ) throws IOException { return br . readLine ( ) ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ 2 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextInt ( ) ; b [ a [ i ] - 1 ] ++ ; } if ( b [ 1 ] >= b [ 0 ] ) { System . out . println ( b [ 0 ] ) ; } else { System . out . println ( ( b [ 0 ] - b [ 1 ] ) / 3 + b [ 1 ] ) ; } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Solution { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = s . nextInt ( ) ; int one = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) one ++ ; else two ++ ; } int c = 0 ; if ( one >= two ) { c = two ; c += ( one - two ) / 3 ; } else { c = one ; } System . out . println ( c ) ; } }"], "python": ["def solution ( n , arr ) : NEW_LINE INDENT ans = 0 NEW_LINE num_of_ones = 0 NEW_LINE num_of_twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 1 : NEW_LINE INDENT num_of_ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_of_twos += 1 NEW_LINE DEDENT DEDENT min_val = min ( num_of_ones , num_of_twos ) NEW_LINE diff = num_of_ones - min_val NEW_LINE if diff >= 3 : NEW_LINE INDENT ans = diff // 3 NEW_LINE DEDENT return min_val + ans NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE arr = [ int ( x ) for x in input ( ) . strip ( ) . split ( \" \u2581 \" ) ] NEW_LINE print ( solution ( n , arr ) ) NEW_LINE", "a = int ( input ( ) ) NEW_LINE b = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if 2 not in b : NEW_LINE INDENT print ( sum ( b ) // 3 ) NEW_LINE DEDENT elif 1 not in b : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT if b . count ( 1 ) >= b . count ( 2 ) : NEW_LINE INDENT print ( b . count ( 2 ) + ( b . count ( 1 ) - b . count ( 2 ) ) // 3 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b . count ( 1 ) ) NEW_LINE DEDENT DEDENT", "n = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE n1 = 0 NEW_LINE n2 = 0 NEW_LINE ans = 0 NEW_LINE for i in l : NEW_LINE INDENT if i == 1 : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT elif i == 2 : NEW_LINE INDENT n2 += 1 NEW_LINE DEDENT DEDENT mi = min ( n1 , n2 ) NEW_LINE if n1 > mi : NEW_LINE INDENT mi += ( n1 - mi ) // 3 NEW_LINE DEDENT print ( mi ) NEW_LINE", "input ( ) NEW_LINE a = [ 0 , 0 ] NEW_LINE for x in input ( ) . split ( ) : a [ int ( x ) - 1 ] += 1 NEW_LINE c = min ( a ) NEW_LINE print ( c + ( a [ 0 ] - c ) // 3 ) NEW_LINE", "from cmath import * NEW_LINE from decimal import * NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = sorted ( _list ( ) ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( lst [ i ] == 1 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT if ( a <= b ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( b + ( a - b ) // 3 ) NEW_LINE DEDENT DEDENT t = 1 NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC145_F", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int K = sc . nextInt ( ) ; long [ ] H = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { H [ i ] = sc . nextLong ( ) ; } if ( N == K ) { System . out . println ( \"0\" ) ; return ; } long [ ] [ ] dp = new long [ N ] [ N - K + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = H [ i ] ; } for ( int l = 2 ; l <= N - K ; l ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( k + 1 >= l ) { long min = - 1 ; for ( int i = 0 ; i < k ; i ++ ) { if ( dp [ i ] [ l - 1 ] != - 1 ) { long tmp = dp [ i ] [ l - 1 ] + Math . max ( 0 , H [ k ] - H [ i ] ) ; if ( min == - 1 || tmp < min ) { min = tmp ; } } } dp [ k ] [ l ] = min ; } else { dp [ k ] [ l ] = - 1 ; } } } long result = - 1 ; for ( int i = ( N - K ) - 1 ; i < N ; i ++ ) { if ( result == - 1 || dp [ i ] [ N - K ] < result ) { result = dp [ i ] [ N - K ] ; } } System . out . println ( result ) ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int K = scanner . nextInt ( ) ; int [ ] h = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) h [ i ] = scanner . nextInt ( ) ; long [ ] [ ] dp = new long [ N + 1 ] [ N + 1 ] ; final long INF = 1_000_000_000_000L ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = INF ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { for ( int k = 0 ; k < i ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ k ] [ j - 1 ] + Math . max ( h [ i ] - h [ k ] , 0 ) ) ; } } long min = INF ; for ( int i = 0 ; i <= N ; i ++ ) min = Math . min ( min , dp [ i ] [ N - K ] ) ; System . out . println ( min ) ; } }", "import java . util . * ; class Main { Scanner sc ; int N , K ; int [ ] H ; long [ ] [ ] dp ; long [ ] s ; private void calc ( ) { sc = new Scanner ( System . in ) ; N = sc . nextInt ( ) ; K = sc . nextInt ( ) ; H = new int [ N + 2 ] ; s = new long [ N + 2 ] ; for ( int i = 1 ; i < N + 1 ; i ++ ) { H [ i ] = sc . nextInt ( ) ; s [ i ] = s [ i - 1 ] + Math . abs ( H [ i - 1 ] - H [ i ] ) ; } s [ N + 1 ] = s [ N ] + Math . abs ( H [ N ] - H [ N + 1 ] ) ; dp = new long [ N + 2 ] [ K + 1 ] ; for ( int i = 0 ; i < N + 2 ; i ++ ) { for ( int k = 0 ; k < K + 1 ; k ++ ) { int lp = Math . min ( K , Math . min ( N - i , K - k ) ) ; for ( int c = 0 ; c <= lp ; c ++ ) { long d = s [ i + c + 1 ] - s [ i ] - Math . abs ( H [ i ] - H [ i + c + 1 ] ) ; dp [ i + c + 1 ] [ k + c ] = Math . max ( dp [ i + c + 1 ] [ k + c ] , dp [ i ] [ k ] + d ) ; } } } System . out . println ( s [ N + 1 ] / 2 - dp [ N + 1 ] [ K ] / 2 ) ; } public static void main ( String [ ] args ) { new Main ( ) . calc ( ) ; } }", "import java . util . * ; public class Main { static long [ ] [ ] dp ; static int [ ] arr ; public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; dp = new long [ k + 1 ] [ n + 2 ] ; arr = new int [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } System . out . println ( dfw ( k , n + 1 ) ) ; } static long dfw ( int count , int idx ) { if ( idx < 1 ) { return 0 ; } if ( dp [ count ] [ idx ] != 0 ) { return dp [ count ] [ idx ] ; } long ans = Long . MAX_VALUE ; for ( int i = 0 ; i <= count && i <= idx - 1 ; i ++ ) { ans = Math . min ( ans , dfw ( count - i , idx - 1 - i ) + Math . max ( 0 , arr [ idx ] - arr [ idx - 1 - i ] ) ) ; } dp [ count ] [ idx ] = ans ; return ans ; } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int N = scanner . nextInt ( ) ; int K = scanner . nextInt ( ) ; int [ ] h = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) h [ i ] = scanner . nextInt ( ) ; long [ ] [ ] dp = new long [ N + 1 ] [ N + 1 ] ; final long INF = 1_000_000_000_000L ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = INF ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { for ( int k = 0 ; k < i ; k ++ ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ k ] [ j - 1 ] + Math . max ( h [ i ] - h [ k ] , 0 ) ) ; } } long min = INF ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = N - K ; j <= N ; j ++ ) min = Math . min ( min , dp [ i ] [ j ] ) ; System . out . println ( min ) ; } }"], "python": ["import sys NEW_LINE input = sys . stdin . readline NEW_LINE def max2 ( x , y ) : NEW_LINE INDENT return x if x > y else y NEW_LINE DEDENT def min2 ( x , y ) : NEW_LINE INDENT return x if x < y else y NEW_LINE DEDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE H = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp = [ [ 10 ** 9 * N for _ in range ( N - K + 1 ) ] for _ in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i , h in enumerate ( H [ 1 : ] , start = 1 ) : NEW_LINE INDENT for k in range ( 1 , min2 ( i + 1 , N - K + 1 ) ) : NEW_LINE INDENT dp [ i ] [ k ] = min ( dp [ j ] [ k - 1 ] + max2 ( 0 , h - H [ j ] ) for j in range ( i ) ) NEW_LINE DEDENT DEDENT print ( min ( d [ - 1 ] for d in dp ) ) NEW_LINE", "from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : NEW_LINE INDENT res = list ( sys . stdin . readline ( ) ) NEW_LINE if res [ - 1 ] == \" \\n \" : NEW_LINE INDENT return res [ : - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( ) : NEW_LINE INDENT n , k = LI ( ) NEW_LINE h = LI ( ) NEW_LINE h . insert ( 0 , 0 ) NEW_LINE dp = [ [ float ( \" inf \" ) ] * ( n + 1 ) for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ni = i + 1 NEW_LINE hi = h [ ni ] NEW_LINE for s in range ( n ) : NEW_LINE INDENT ns = s + 1 NEW_LINE for j in range ( ni ) : NEW_LINE INDENT hj = h [ j ] NEW_LINE nd = dp [ j ] [ s ] + max ( 0 , hi - hj ) NEW_LINE if nd < dp [ ni ] [ ns ] : NEW_LINE INDENT dp [ ni ] [ ns ] = nd NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = min ( [ dp [ i ] [ n - k ] for i in range ( n + 1 ) ] ) NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT", "import sys NEW_LINE stdin = sys . stdin NEW_LINE ni = lambda : int ( ns ( ) ) NEW_LINE na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) NEW_LINE ns = lambda : stdin . readline ( ) . rstrip ( ) NEW_LINE n , k = na ( ) NEW_LINE h = na ( ) NEW_LINE ys = h [ : ] + [ 0 ] NEW_LINE ys . sort ( ) NEW_LINE ys2 = [ ] NEW_LINE for v in ys : NEW_LINE INDENT if len ( ys2 ) > 0 and ys2 [ - 1 ] == v : NEW_LINE INDENT continue NEW_LINE DEDENT ys2 . append ( v ) NEW_LINE DEDENT ys = ys2 NEW_LINE m = len ( ys ) NEW_LINE dp = [ [ 999999999999999999 ] * m for _ in range ( k + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 NEW_LINE for v in h : NEW_LINE INDENT ndp = [ [ 999999999999999999 ] * m for _ in range ( k + 1 ) ] NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT plus = 99999999999999999 NEW_LINE for j in range ( m ) : NEW_LINE INDENT plus = min ( plus + ( ys [ j ] - ys [ j - 1 ] if j > 0 else 0 ) , dp [ i ] [ j ] ) NEW_LINE if ys [ j ] == v : NEW_LINE INDENT ndp [ i ] [ j ] = min ( ndp [ i ] [ j ] , plus ) NEW_LINE DEDENT elif i + 1 <= k : NEW_LINE INDENT ndp [ i + 1 ] [ j ] = min ( ndp [ i + 1 ] [ j ] , plus ) NEW_LINE DEDENT DEDENT plus = 99999999999999999 NEW_LINE for j in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT plus = min ( plus , dp [ i ] [ j ] ) NEW_LINE if ys [ j ] == v : NEW_LINE INDENT ndp [ i ] [ j ] = min ( ndp [ i ] [ j ] , plus ) NEW_LINE DEDENT elif i + 1 <= k : NEW_LINE INDENT ndp [ i + 1 ] [ j ] = min ( ndp [ i + 1 ] [ j ] , plus ) NEW_LINE DEDENT DEDENT DEDENT dp = ndp NEW_LINE DEDENT ans = min ( min ( row ) for row in dp ) NEW_LINE print ( ans ) NEW_LINE", "import sys NEW_LINE import math NEW_LINE from collections import defaultdict NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def input ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) [ : - 1 ] NEW_LINE DEDENT mod = 10 ** 9 + 7 NEW_LINE def I ( ) : return int ( input ( ) ) NEW_LINE def II ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def III ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def Line ( N , num ) : NEW_LINE INDENT if N <= 0 : NEW_LINE INDENT return [ [ ] ] * num NEW_LINE DEDENT elif num == 1 : NEW_LINE INDENT return [ I ( ) for _ in range ( N ) ] NEW_LINE DEDENT else : NEW_LINE INDENT read_all = [ tuple ( II ( ) ) for _ in range ( N ) ] NEW_LINE return map ( list , zip ( * read_all ) ) NEW_LINE DEDENT DEDENT N , K = II ( ) NEW_LINE H = III ( ) NEW_LINE if N == K : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT dp = [ [ float ( ' inf ' ) ] * ( N - K + 1 ) for _ in range ( N ) ] NEW_LINE for x in range ( N ) : NEW_LINE INDENT for y in range ( N - K + 1 ) : NEW_LINE INDENT if x + 1 < y : NEW_LINE INDENT continue NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT dp [ x ] [ y ] = float ( ' inf ' ) NEW_LINE DEDENT elif y == 1 : NEW_LINE INDENT dp [ x ] [ y ] = H [ x ] NEW_LINE DEDENT else : NEW_LINE INDENT val = float ( ' inf ' ) NEW_LINE for i in range ( x ) : NEW_LINE INDENT now = dp [ i ] [ y - 1 ] + max ( 0 , H [ x ] - H [ i ] ) NEW_LINE if now < val : NEW_LINE INDENT val = now NEW_LINE DEDENT DEDENT dp [ x ] [ y ] = val NEW_LINE DEDENT DEDENT DEDENT ans = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if dp [ i ] [ N - K ] < ans : NEW_LINE INDENT ans = dp [ i ] [ N - K ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "def solve ( ) : NEW_LINE INDENT INF = float ( ' inf ' ) NEW_LINE def max2 ( x , y ) : return x if x >= y else y NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE Hs = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if N == K : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ INF ] * ( N + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE for j in range ( 1 , N - K + 1 ) : NEW_LINE INDENT dp2 = [ INF ] * ( N + 1 ) NEW_LINE for i , H in enumerate ( Hs [ j : ] , j ) : NEW_LINE INDENT for k in range ( j - 1 , i ) : NEW_LINE INDENT dp2 [ i ] = min ( dp2 [ i ] , dp [ k ] + max2 ( 0 , H - Hs [ k ] ) ) NEW_LINE DEDENT DEDENT dp = dp2 NEW_LINE DEDENT return min ( dp ) NEW_LINE DEDENT ans = solve ( ) NEW_LINE print ( ans ) NEW_LINE"]}
{"id": "atcoder_ABC077_C", "java": ["import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; double [ ] a = new double [ n ] ; int [ ] b = new int [ n ] ; double [ ] c = new double [ n ] ; Arrays . setAll ( a , i -> sc . nextInt ( ) ) ; Arrays . setAll ( b , i -> sc . nextInt ( ) ) ; Arrays . setAll ( c , i -> sc . nextInt ( ) ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int idxA = ~ Arrays . binarySearch ( a , b [ i ] - 0.1 ) ; if ( idxA < 0 ) continue ; long numA = idxA ; int idxC = ~ Arrays . binarySearch ( c , b [ i ] + 0.1 ) ; if ( idxC < 0 ) continue ; long numC = n - idxC ; ans += numA * numC ; } System . out . println ( ans ) ; sc . close ( ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; CSnukeFestival solver = new CSnukeFestival ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class CSnukeFestival { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) c [ i ] = in . nextInt ( ) ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int ng = - 1 ; int ok = a . length ; while ( Math . abs ( ok - ng ) > 1 ) { int mid = ( ok + ng ) / 2 ; if ( a [ mid ] >= b [ i ] ) { ok = mid ; } else { ng = mid ; } } long cnta = ok ; ng = - 1 ; ok = c . length ; while ( Math . abs ( ok - ng ) > 1 ) { int mid = ( ok + ng ) / 2 ; if ( c [ mid ] > b [ i ] ) { ok = mid ; } else { ng = mid ; } } long cntc = n - 1 - ng ; sum += cnta * cntc ; } out . println ( sum ) ; } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { private static long lowerBound ( long [ ] x , long bj ) { int leftIdx = - 1 ; int rightIdx = x . length ; while ( rightIdx - leftIdx > 1 ) { int middleIdx = ( leftIdx + rightIdx ) / 2 ; if ( bj <= x [ middleIdx ] ) { rightIdx = middleIdx ; continue ; } leftIdx = middleIdx ; } return rightIdx ; } private static long upperBound ( long [ ] x , long bj ) { int leftIdx = - 1 ; int rightIdx = x . length ; while ( rightIdx - leftIdx > 1 ) { int middleIdx = ( leftIdx + rightIdx ) / 2 ; if ( bj < x [ middleIdx ] ) { rightIdx = middleIdx ; continue ; } leftIdx = middleIdx ; } return rightIdx ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] b = new long [ n ] ; long [ ] c = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextLong ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = sc . nextLong ( ) ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; long count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { long bj = b [ j ] ; long aiCount = lowerBound ( a , bj ) ; long ckCount = n - upperBound ( c , bj ) ; count += aiCount * ckCount ; } System . out . println ( count ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; import java . util . stream . IntStream ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ) { int n = scanner . nextInt ( ) ; Integer [ ] a = new Integer [ n ] , b = new Integer [ n ] , c = new Integer [ n ] ; IntStream . range ( 0 , n ) . forEach ( i -> a [ i ] = scanner . nextInt ( ) ) ; IntStream . range ( 0 , n ) . forEach ( i -> b [ i ] = scanner . nextInt ( ) ) ; IntStream . range ( 0 , n ) . forEach ( i -> c [ i ] = scanner . nextInt ( ) ) ; Arrays . sort ( a ) ; Arrays . sort ( c ) ; System . out . println ( IntStream . range ( 0 , n ) . mapToLong ( i -> getLessCount ( b [ i ] , a ) * getGreaterCount ( b [ i ] , c ) ) . sum ( ) ) ; } } private static long getLessCount ( int i , Integer [ ] a ) { int result = Arrays . binarySearch ( a , i , ( x , y ) -> ( x . compareTo ( y ) >= 0 ) ? 1 : - 1 ) ; if ( result < 0 ) { result = ~ result ; } return result ; } private static long getGreaterCount ( int i , Integer [ ] a ) { int result = Arrays . binarySearch ( a , i , ( x , y ) -> ( x . compareTo ( y ) > 0 ) ? 1 : - 1 ) ; if ( result < 0 ) { result = ~ result ; } return a . length - result ; } }", "import java . util . Arrays ; import java . util . HashMap ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . execute ( ) ; } public void execute ( ) { Scanner sc = new Scanner ( System . in ) ; final int N = sc . nextInt ( ) ; sc . nextLine ( ) ; int A [ ] = new int [ N ] ; int B [ ] = new int [ N ] ; int C [ ] = new int [ N ] ; String [ ] a1An = sc . nextLine ( ) . split ( \" \u2581 \" ) ; String [ ] b1Bn = sc . nextLine ( ) . split ( \" \u2581 \" ) ; String [ ] c1Cn = sc . nextLine ( ) . split ( \" \u2581 \" ) ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = Integer . parseInt ( a1An [ i ] ) ; B [ i ] = Integer . parseInt ( b1Bn [ i ] ) ; C [ i ] = Integer . parseInt ( c1Cn [ i ] ) ; } Arrays . sort ( A ) ; Arrays . sort ( B ) ; Arrays . sort ( C ) ; long [ ] cntB = new long [ N ] ; int aIx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int b = B [ i ] ; while ( aIx < A . length && A [ aIx ] < b ) { aIx ++ ; } cntB [ i ] = aIx ; } long [ ] cntC = new long [ N ] ; int bIx = 0 ; long total = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int c = C [ i ] ; long subTotal = ( i == 0 ) ? 0 : cntC [ i - 1 ] ; while ( bIx < B . length && B [ bIx ] < c ) { subTotal += cntB [ bIx ] ; bIx ++ ; } cntC [ i ] = subTotal ; total += subTotal ; } System . out . println ( total ) ; sc . close ( ) ; } }"], "python": ["import bisect NEW_LINE ans = 0 NEW_LINE N = int ( input ( ) ) NEW_LINE A = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE B = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE C = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE C . sort ( ) NEW_LINE for b in B : NEW_LINE INDENT a = bisect . bisect_left ( A , b ) NEW_LINE c = N - bisect . bisect_right ( C , b ) NEW_LINE ans += a * c NEW_LINE DEDENT print ( ans ) NEW_LINE", "def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE parts = [ [ int ( a ) , 0 ] for a in input ( ) . split ( ) ] NEW_LINE parts += [ [ int ( b ) , 1 ] for b in input ( ) . split ( ) ] NEW_LINE parts += [ [ int ( c ) , 2 ] for c in input ( ) . split ( ) ] NEW_LINE parts = sorted ( parts , key = lambda x : x [ 0 ] , reverse = True ) NEW_LINE countC = 0 NEW_LINE countBC = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( len ( parts ) ) : NEW_LINE INDENT if parts [ i ] [ 1 ] == 0 : NEW_LINE INDENT ans += countBC NEW_LINE DEDENT elif parts [ i ] [ 1 ] == 1 : NEW_LINE INDENT countBC += countC NEW_LINE DEDENT else : NEW_LINE INDENT countC += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT", "from bisect import bisect_right NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE C = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = sorted ( B ) NEW_LINE C = sorted ( C ) NEW_LINE b_list = { N : 0 } NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT j = bisect_right ( C , B [ i ] ) NEW_LINE b_list [ i ] = N - j + b_list [ i + 1 ] NEW_LINE DEDENT m = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT j = bisect_right ( B , A [ i ] ) NEW_LINE m += b_list [ j ] NEW_LINE DEDENT print ( m ) NEW_LINE", "from bisect import * ; N , A , B , C = [ sorted ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * 4 ] ; print ( sum ( bisect_left ( A , x ) * ( N [ 0 ] - bisect_right ( C , x ) ) for x in B ) ) NEW_LINE", "import bisect NEW_LINE cnt = 0 NEW_LINE n = int ( input ( ) ) NEW_LINE a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE b = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE ab = [ 0 ] * n NEW_LINE bc = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT bc [ i ] = bisect . bisect_left ( b , c [ i ] - 0.5 ) NEW_LINE ab [ i ] = bisect . bisect_left ( a , b [ i ] - 0.5 ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT ab [ i ] += ab [ i - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if bc [ i ] != 0 : NEW_LINE INDENT cnt += ab [ bc [ i ] - 1 ] NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE"]}
{"id": "geeksforgeeks_831_A", "java": ["class GFG { static double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; System . out . println ( ( int ) calculate_angle ( n , a1 , a2 , a3 ) ) ; } }"], "python": ["def calculate_angle ( n , i , j , k ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1789_A", "java": ["class GFG { static int solve ( int [ ] arr , int n ) { int k = arr . length ; int mp [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i <= n ; i ++ ) { mp [ i ] = 0 ; } for ( int i = 0 ; i < k ; i ++ ) { mp [ arr [ i ] ] = 1 ; } int leftSegment = arr [ 0 ] - 1 ; for ( int i = 1 ; i < k ; i ++ ) { leftSegment = Math . max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) ; } int rightSegment = n - arr [ k - 1 ] ; int maxSegment = Math . max ( leftSegment , rightSegment ) ; int tim ; if ( ( maxSegment & 1 ) == 1 ) tim = ( maxSegment / 2 ) + 1 ; else tim = maxSegment / 2 ; return tim ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 1 , 4 } ; System . out . println ( solve ( arr , N ) ) ; } }"], "python": ["def solve ( arr , n ) : NEW_LINE INDENT k = len ( arr ) NEW_LINE mp = [ False for i in range ( n + 2 ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT mp [ arr [ i ] ] = True NEW_LINE DEDENT leftSegment = arr [ 0 ] - 1 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT leftSegment = max ( leftSegment , arr [ i ] - arr [ i - 1 ] - 1 ) NEW_LINE DEDENT rightSegment = n - arr [ k - 1 ] NEW_LINE maxSegment = max ( leftSegment , rightSegment ) ; NEW_LINE tim = 0 NEW_LINE if ( maxSegment & 1 ) : NEW_LINE INDENT tim = ( maxSegment // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT tim = maxSegment // 2 NEW_LINE DEDENT return tim NEW_LINE DEDENT N = 5 NEW_LINE arr = [ 1 , 4 ] NEW_LINE print ( solve ( arr , N ) ) NEW_LINE"]}
{"id": "geeksforgeeks_5101_A", "java": ["import java . util . * ; class GFG { static void findCombinationsUtil ( int arr [ ] , int index , int n , int red_num ) { HashSet < Integer > s = new HashSet < > ( ) ; int sum = 0 ; if ( red_num < 0 ) { return ; } if ( red_num == 0 ) { for ( int i = 0 ; i < index ; i ++ ) { s . add ( arr [ i ] ) ; } for ( Integer itr : s ) { sum = sum + itr ; } if ( sum == n ) { for ( Integer i : s ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . println ( ) ; return ; } } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= n ; k ++ ) { if ( index < n ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , n , red_num - k ) ; } } } static void findCombinations ( int n ) { int [ ] a = new int [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; } public static void main ( String arr [ ] ) { int n = 7 ; findCombinations ( n ) ; } }"], "python": ["def findCombinationsUtil ( arr , index , n , red_num ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE if ( red_num < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( red_num == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT for itr in s : NEW_LINE INDENT sum = sum + ( itr ) NEW_LINE DEDENT if ( sum == n ) : NEW_LINE INDENT for i in s : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \\n \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT if ( index == 0 ) : NEW_LINE INDENT prev = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prev = arr [ index - 1 ] NEW_LINE DEDENT for k in range ( prev , n + 1 , 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , n , red_num - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT a = [ 0 for i in range ( n + 1 ) ] NEW_LINE findCombinationsUtil ( a , 0 , n , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE findCombinations ( n ) NEW_LINE DEDENT"]}
{"id": "codeforces_1536_A", "java": ["import java . util . * ; import java . math . BigInteger ; import java . io . * ; public class codeHundredSixty { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = input . nextInt ( ) ; int [ ] arrayOne = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrayOne [ i ] = input . nextInt ( ) ; } Arrays . sort ( arrayOne ) ; if ( arrayOne [ 0 ] < 0 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; System . out . println ( 101 ) ; for ( int i = 0 ; i <= 100 ; i ++ ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . println ( ) ; } } } }", "import java . util . * ; import java . math . BigInteger ; import java . io . * ; public class codeHundredSixty { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = input . nextInt ( ) ; for ( int o = 0 ; o < t ; o ++ ) { int n = input . nextInt ( ) ; int [ ] arrayOne = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrayOne [ i ] = input . nextInt ( ) ; } Arrays . sort ( arrayOne ) ; if ( arrayOne [ 0 ] < 0 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; System . out . println ( 101 ) ; for ( int i = 0 ; i <= 100 ; i ++ ) { System . out . print ( i + \" \u2581 \" ) ; } System . out . println ( ) ; } } } }", "import java . util . * ; import java . util . stream . Collectors ; public class A1536 { public static void solve ( List < Integer > input ) { for ( int num : input ) { if ( num < 0 ) { System . out . println ( \" NO \" ) ; return ; } } Set < Integer > set = new HashSet < > ( input ) ; for ( int i = 0 ; i < input . size ( ) ; i ++ ) { for ( int j = 0 ; j < input . size ( ) ; j ++ ) { if ( input . size ( ) > 300 ) { System . out . println ( \" NO \" ) ; return ; } if ( i == j ) { continue ; } int dist = Math . abs ( input . get ( i ) - input . get ( j ) ) ; if ( ! set . contains ( dist ) ) { set . add ( dist ) ; input . add ( dist ) ; } } } System . out . println ( \" YES \" ) ; System . out . println ( input . size ( ) ) ; System . out . println ( input . stream ( ) . map ( Object :: toString ) . collect ( Collectors . joining ( \" \u2581 \" ) ) ) ; } public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; List < Integer > input = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { input . add ( scanner . nextInt ( ) ) ; } solve ( input ) ; } } }", "import java . util . * ; import java . util . stream . Collectors ; public class A1536 { public static void solve ( List < Integer > input ) { Set < Integer > set = new HashSet < > ( input ) ; for ( int i = 0 ; i < input . size ( ) ; i ++ ) { for ( int j = 0 ; j < input . size ( ) ; j ++ ) { if ( input . size ( ) > 300 ) { System . out . println ( \" NO \" ) ; return ; } if ( i == j ) { continue ; } int dist = Math . abs ( input . get ( i ) - input . get ( j ) ) ; if ( ! set . contains ( dist ) ) { set . add ( dist ) ; input . add ( dist ) ; } } } System . out . println ( \" YES \" ) ; System . out . println ( input . size ( ) ) ; System . out . println ( input . stream ( ) . map ( Object :: toString ) . collect ( Collectors . joining ( \" \u2581 \" ) ) ) ; } public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) ; List < Integer > input = new ArrayList < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { input . add ( scanner . nextInt ( ) ) ; } solve ( input ) ; } } }"], "python": ["def diff ( List ) : NEW_LINE INDENT List . sort ( ) NEW_LINE if List [ 0 ] < 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE L = { 0 } NEW_LINE Set = set ( List ) NEW_LINE Q = Set NEW_LINE while not Q == set ( ) : NEW_LINE INDENT for x in Set : NEW_LINE INDENT for y in Set : NEW_LINE INDENT l = { abs ( x - y ) } NEW_LINE L . update ( l ) NEW_LINE DEDENT DEDENT L . remove ( 0 ) NEW_LINE Q = L . difference ( Set ) NEW_LINE Set . update ( L ) NEW_LINE DEDENT print ( len ( Set ) ) NEW_LINE for x in Set : NEW_LINE INDENT print ( x , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT N = int ( input ( ) ) NEW_LINE for x in range ( N ) : NEW_LINE INDENT n = input ( ) NEW_LINE S = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE diff ( S ) NEW_LINE DEDENT", "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : print ( * ( [ ' nO ' ] if min ( map ( int , s . split ( ) ) ) < 0 else [ ' yES \\n 101 \\n ' , * range ( 101 ) ] ) ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( j ) for j in input ( ) . split ( ) ] NEW_LINE l1 = [ ] NEW_LINE if min ( l ) < 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE print ( max ( l ) + 1 ) NEW_LINE for j in range ( max ( l ) + 1 ) : NEW_LINE INDENT l1 . append ( j ) NEW_LINE DEDENT print ( * l1 , sep = ' \u2581 ' ) NEW_LINE DEDENT DEDENT", "from cmath import * NEW_LINE from math import * NEW_LINE from decimal import * NEW_LINE from collections import * NEW_LINE import numbers NEW_LINE from operator import index NEW_LINE import sys NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE def _list ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def _int ( ) : return int ( input ( ) ) NEW_LINE def solves ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE lst = _list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if lst [ i ] < 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" YES \" ) NEW_LINE ans = [ i for i in range ( max ( lst ) + 1 ) ] NEW_LINE print ( len ( ans ) ) NEW_LINE print ( * ans ) NEW_LINE DEDENT t = 1 NEW_LINE t = int ( input ( ) ) NEW_LINE for _ in range ( 0 , t ) : NEW_LINE INDENT solves ( ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if min ( a ) < 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE continue NEW_LINE DEDENT print ( \" YES \" ) NEW_LINE mx = max ( a ) + 1 NEW_LINE print ( mx ) NEW_LINE print ( \" \u2581 \" . join ( map ( str , range ( 0 , mx ) ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2121_A", "java": ["import java . util . ArrayList ; import java . util . Collections ; class GFG { static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { ArrayList V = new ArrayList ( ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { V . add ( A [ j ] ) ; } } Collections . sort ( V ) ; return ( ( int ) V . get ( K - 1 ) ) ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = A . length ; System . out . println ( KthMinValAfterMconcatenate ( A , N , M , K ) ) ; } }"], "python": ["def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M , K = 3 , 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_520_B", "java": ["import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . ArrayDeque ; import java . util . Queue ; import java . util . Scanner ; public class Main { private static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int start = sc . nextInt ( ) ; int target = sc . nextInt ( ) ; boolean [ ] vis = new boolean [ 20005 ] ; Queue < Integer > queue = new ArrayDeque < > ( ) ; queue . offer ( start ) ; vis [ start ] = true ; int step = 0 ; a : while ( ! queue . isEmpty ( ) ) { int n = queue . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int poll = queue . poll ( ) ; if ( poll == target ) { break a ; } if ( poll * 2 < 20005 && ! vis [ poll * 2 ] ) { vis [ poll * 2 ] = true ; queue . offer ( poll * 2 ) ; } if ( poll - 1 > 0 && ! vis [ poll - 1 ] ) { vis [ poll - 1 ] = true ; queue . offer ( poll - 1 ) ; } } step ++ ; } System . out . println ( step ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextInt ( ) , m = sc . nextInt ( ) ; if ( n >= m ) System . out . println ( n - m ) ; else { int res = 0 ; while ( n < m ) { if ( m % 2 != 0 ) m ++ ; else m /= 2 ; res ++ ; } System . out . println ( res + n - m ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static int minClicks ( int n , int m ) { int clicks = 0 ; while ( m > n ) { if ( m % 2 == 0 ) { m /= 2 ; clicks ++ ; } else { m ++ ; m /= 2 ; clicks += 2 ; } } while ( m != n ) { m ++ ; clicks ++ ; } return clicks ; } public static void main ( String [ ] args ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] input = bufferedReader . readLine ( ) . split ( \" \u2581 \" ) ; System . out . println ( minClicks ( Integer . parseInt ( input [ 0 ] ) , Integer . parseInt ( input [ 1 ] ) ) ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int sum = 0 ; while ( b > a ) { if ( b % 2 == 0 ) { b /= 2 ; sum ++ ; } else { b += 1 ; sum ++ ; } } System . out . println ( sum + ( a - b ) ) ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; public class Main { private static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; private static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int target = sc . nextInt ( ) ; int start = sc . nextInt ( ) ; int step = 0 ; while ( true ) { if ( target >= start ) { step += target - start ; break ; } else { if ( start % 2 == 0 ) { start /= 2 ; step ++ ; } else { start ++ ; step ++ ; } if ( start == target ) break ; } } System . out . println ( step ) ; } }"], "python": ["from math import log2 NEW_LINE n , m = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE queue = [ [ n , 0 ] ] NEW_LINE maxn = 10e4 NEW_LINE red = lambda x : x * 2 NEW_LINE blue = lambda x : x - 1 NEW_LINE memoized_values = set ( ) NEW_LINE while queue : NEW_LINE INDENT current_n , buttons_pressed = queue . pop ( 0 ) NEW_LINE if current_n == m : NEW_LINE INDENT print ( buttons_pressed ) NEW_LINE break NEW_LINE DEDENT if blue ( current_n ) not in memoized_values and blue ( current_n ) > 0 : NEW_LINE INDENT memoized_values . add ( blue ( current_n ) ) NEW_LINE queue . append ( [ blue ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT if red ( current_n ) not in memoized_values and red ( current_n ) <= maxn : NEW_LINE INDENT memoized_values . add ( red ( current_n ) ) NEW_LINE queue . append ( [ red ( current_n ) , buttons_pressed + 1 ] ) NEW_LINE DEDENT DEDENT", "from collections import deque NEW_LINE n , m = map ( int , input ( ) . split ( ) ) NEW_LINE def bfs ( n , m ) : NEW_LINE INDENT visited = set ( ) NEW_LINE q = deque ( ) NEW_LINE q . append ( n ) NEW_LINE visited . add ( n ) NEW_LINE if n > m : NEW_LINE INDENT return n - m NEW_LINE DEDENT cnt = 0 NEW_LINE while q : NEW_LINE INDENT for _ in range ( len ( q ) ) : NEW_LINE INDENT n = q . popleft ( ) NEW_LINE visited . add ( n ) NEW_LINE if n == m : NEW_LINE INDENT return cnt NEW_LINE DEDENT else : NEW_LINE INDENT if n - 1 not in visited and n > 0 : NEW_LINE INDENT q . append ( n - 1 ) NEW_LINE DEDENT if n * 2 not in visited and n * 2 < 3 * m : NEW_LINE INDENT q . append ( n * 2 ) NEW_LINE DEDENT DEDENT DEDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( bfs ( n , m ) ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n > m : NEW_LINE INDENT print ( n - m ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE while m > n : NEW_LINE INDENT if m % 2 : NEW_LINE INDENT m += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m = m // 2 NEW_LINE DEDENT cnt += 1 NEW_LINE DEDENT print ( cnt + n - m ) NEW_LINE DEDENT", "import timeit NEW_LINE from collections import deque NEW_LINE numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count = 0 NEW_LINE info = { } NEW_LINE arr = deque ( [ numbers [ 0 ] , ' count ' ] ) NEW_LINE while True : NEW_LINE INDENT value = arr . popleft ( ) NEW_LINE if value == \" count \" : NEW_LINE INDENT count += 1 NEW_LINE arr . append ( ' count ' ) NEW_LINE continue NEW_LINE DEDENT elif value == numbers [ 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT if value > 0 and numbers [ 1 ] / value > 1 : NEW_LINE INDENT arr . append ( value * 2 ) NEW_LINE DEDENT if value > 0 and not value in info : NEW_LINE INDENT arr . append ( value - 1 ) NEW_LINE info [ value ] = 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "n , m = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE count = 0 NEW_LINE while n != m : NEW_LINE INDENT if m > n : NEW_LINE INDENT if m % 2 == 0 : NEW_LINE INDENT m = m // 2 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE"]}
{"id": "geeksforgeeks_4082_A", "java": ["import java . io . * ; class GFG { static int numberOfSolutions ( int n ) { int c = 0 ; while ( n > 0 ) { c += n % 2 ; n /= 2 ; } return ( int ) Math . pow ( 2 , c ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( numberOfSolutions ( n ) ) ; } }"], "python": ["from math import * NEW_LINE def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n ) : NEW_LINE INDENT c += n % 2 NEW_LINE n //= 2 NEW_LINE DEDENT return int ( pow ( 2 , c ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_884_B", "java": ["import java . io . BufferedOutputStream ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . TreeMap ; public class Practice1 { public static void main ( String [ ] args ) { PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; FastReader sc = new FastReader ( ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; long [ ] arr = new long [ n ] ; long sum = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextLong ( ) ; sum += arr [ i ] ; } if ( x == sum ) { out . println ( \" YES \" ) ; } else { out . println ( \" NO \" ) ; } out . close ( ) ; } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . util . Scanner ; public class JapaneseCrosswordSrikesBack { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long n = in . nextLong ( ) ; long x = in . nextLong ( ) ; long [ ] a = new long [ ( int ) n ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextLong ( ) ; sum += a [ i ] ; } if ( x - sum - n + 1 == 0 ) System . out . println ( \" YES \" ) ; else System . out . println ( \" NO \" ) ; } }", "import java . util . * ; import java . io . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; long n = in . nextLong ( ) , x = in . nextLong ( ) ; long [ ] a = new long [ ( int ) n ] ; Arrays . setAll ( a , i -> in . nextLong ( ) ) ; long totoal = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { totoal += ( a [ i ] + 1 ) ; } totoal += a [ ( int ) n - 1 ] ; if ( totoal == x ) pw . println ( \" YES \" ) ; else pw . println ( \" NO \" ) ; pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }"], "python": ["n , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE somatorioA = sum ( a ) NEW_LINE if x == ( somatorioA + n - 1 ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT", "n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) + n - 1 == x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if sum ( a ) + n - 1 == x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "n , x = map ( int , input ( ) . split ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE total_of_ones = sum ( a ) NEW_LINE if total_of_ones + n - 1 == x : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT", "firstLine = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE secondLine = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstLine [ 0 ] ) : NEW_LINE INDENT sum += secondLine [ i ] NEW_LINE DEDENT sum = sum + firstLine [ 0 ] - 1 NEW_LINE if ( sum == firstLine [ 1 ] ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p005_A", "java": ["import java . math . BigInteger ; public final class p005 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p005 ( ) . run ( ) ) ; } public String run ( ) { BigInteger allLcm = BigInteger . ONE ; for ( int i = 1 ; i <= 20 ; i ++ ) allLcm = lcm ( BigInteger . valueOf ( i ) , allLcm ) ; return allLcm . toString ( ) ; } private static BigInteger lcm ( BigInteger x , BigInteger y ) { return x . divide ( x . gcd ( y ) ) . multiply ( y ) ; } }"], "python": ["import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2554_A", "java": ["class GFG { static int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } static int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } public static void main ( String [ ] args ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) System . out . println ( \" No \u2581 profit \u2581 nor \u2581 Loss \" ) ; else if ( sellingPrice > costPrice ) System . out . println ( Profit ( costPrice , sellingPrice ) + \" \u2581 Profit \u2581 \" ) ; else System . out . println ( Loss ( costPrice , sellingPrice ) + \" \u2581 Loss \u2581 \" ) ; } }"], "python": ["def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT costPrice , sellingPrice = 1500 , 2000 NEW_LINE if sellingPrice == costPrice : NEW_LINE INDENT print ( \" No \u2581 profit \u2581 nor \u2581 Loss \" ) NEW_LINE DEDENT elif sellingPrice > costPrice : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , \" Profit \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , \" Loss \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_659_A", "java": ["import java . util . Scanner ; public class JavaApplication40 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numOfEntrance = sc . nextInt ( ) ; int herEnterance = sc . nextInt ( ) ; int count = sc . nextInt ( ) ; int num = herEnterance + ( numOfEntrance + count ) ; while ( num > numOfEntrance ) { num -= numOfEntrance ; } while ( num <= 0 ) { num += numOfEntrance ; } System . out . println ( num ) ; } }", "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int n = in . nextInt ( ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int res = ( a + b ) % n ; if ( b <= 0 ) { if ( res <= 0 ) res += n ; pw . println ( res ) ; } else { if ( res == 0 ) pw . println ( n ) ; else pw . println ( res ) ; } pw . close ( ) ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }", "import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; long n = in . nextLong ( ) , a = in . nextLong ( ) , b = in . nextLong ( ) ; System . out . println ( ( ( a - 1 + b ) % n + n ) % n + 1 ) ; } }"], "python": ["n , a , b = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE if ( b > 0 ) : NEW_LINE INDENT if ( b % n == 0 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a + b % n > n ) : NEW_LINE INDENT print ( a + b % n - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b % n ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT if ( b % n == 0 ) : NEW_LINE INDENT print ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( a + b % n > n ) : NEW_LINE INDENT print ( a + b % n - n ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a + b % n ) NEW_LINE DEDENT DEDENT DEDENT", "inp = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE n = inp [ 0 ] NEW_LINE a = inp [ 1 ] NEW_LINE b = inp [ 2 ] NEW_LINE result = ( a + b ) % n NEW_LINE if result == 0 : result = n NEW_LINE print ( result ) NEW_LINE", "n , a , b = input ( ) . split ( ) NEW_LINE n = int ( n ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE result = ( a + b ) % n NEW_LINE if result == 0 : result = n NEW_LINE print ( result ) NEW_LINE", "k = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l = 0 NEW_LINE if ( k [ 2 ] + k [ 1 ] ) % k [ 0 ] == 0 : NEW_LINE INDENT l = k [ 0 ] NEW_LINE DEDENT print ( ( k [ 2 ] + k [ 1 ] ) % k [ 0 ] + l ) NEW_LINE", "n , a , b = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if ( b < 0 ) : NEW_LINE INDENT for i in range ( 0 , - b ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT a = n NEW_LINE DEDENT else : NEW_LINE INDENT a = a - 1 NEW_LINE DEDENT DEDENT DEDENT elif ( b > 0 ) : NEW_LINE INDENT for i in range ( 0 , b ) : NEW_LINE INDENT if ( a == n ) : NEW_LINE INDENT a = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a = a + 1 NEW_LINE DEDENT DEDENT DEDENT print ( a ) NEW_LINE"]}
{"id": "atcoder_ABC116_B", "java": ["import java . util . HashSet ; import java . util . Scanner ; import java . util . Set ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; Set < Integer > set = new HashSet < Integer > ( ) ; int s = sc . nextInt ( ) ; set . add ( s ) ; int before = s ; for ( int i = 2 ; ; i ++ ) { if ( set . contains ( f ( before ) ) ) { System . out . println ( i ) ; break ; } else { before = f ( before ) ; set . add ( before ) ; } } } static int f ( int x ) { if ( x % 2 == 0 ) { return x / 2 ; } else { return ( x * 3 + 1 ) ; } } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashSet ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Solver solver = new Solver ( ) ; solver . init ( ) ; solver . readHead ( in . readLine ( ) ) ; } } class Solver { int N ; int cnt ; public void init ( ) { N = 0 ; cnt = 0 ; } public void readHead ( String str ) { String [ ] strArr = str . split ( \" \u2581 \" ) ; int s = Integer . parseInt ( strArr [ 0 ] ) ; HashSet < Integer > f = new HashSet < Integer > ( ) ; f . add ( s ) ; int ans = 2 ; for ( int a = s ; ; ans ++ ) { if ( a % 2 == 0 ) a = a / 2 ; else a = 3 * a + 1 ; if ( f . contains ( a ) ) break ; f . add ( a ) ; } System . out . println ( ans ) ; } public boolean hasNext ( ) { return cnt < N ; } public void readBody ( String str ) { cnt ++ ; } public void solve ( ) { } }", "import java . util . Scanner ; import java . util . ArrayList ; class Main { public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int s = scn . nextInt ( ) ; ArrayList < Integer > element = new ArrayList < Integer > ( ) ; for ( int i = 1 ; ; ) { if ( i == 1 ) { element . add ( s ) ; } else { if ( s % 2 == 1 ) { s = odd ( s ) ; } else { s = even ( s ) ; } if ( element . indexOf ( s ) == - 1 ) { element . add ( s ) ; } else { System . out . println ( i ) ; break ; } } i ++ ; } } public static int even ( int n ) { return n / 2 ; } public static int odd ( int n ) { return 3 * n + 1 ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { boolean sw = false ; int answer = 0 ; List < Integer > a = new ArrayList < Integer > ( ) ; int s ; int n = 1 ; int ai = 0 ; int count = 0 ; Scanner sc = new Scanner ( System . in ) ; s = sc . nextInt ( ) ; while ( sw == false ) { if ( count == 0 ) { a . add ( s ) ; count ++ ; } else { n = a . get ( count - 1 ) ; if ( n % 2 == 0 ) { ai = n / 2 ; a . add ( ai ) ; } else { ai = 3 * n + 1 ; a . add ( ai ) ; } count ++ ; } for ( int i = 0 ; i < count - 1 ; i ++ ) { if ( a . get ( i ) == ai ) { answer = a . size ( ) ; sw = true ; } } } System . out . println ( answer ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int count = 1 ; int i = 0 ; int ans = 0 ; int [ ] hairetu = new int [ 1000000 ] ; hairetu [ count - 1 ] = n ; while ( count < 1000000 ) { if ( hairetu [ count - 1 ] % 2 == 0 ) { hairetu [ count ] = hairetu [ count - 1 ] / 2 ; } else { hairetu [ count ] = 3 * hairetu [ count - 1 ] + 1 ; } count ++ ; } for ( i = 0 ; i < 1000000 ; i ++ ) { if ( hairetu [ i ] == 4 ) { ans = i ; break ; } else if ( hairetu [ i ] == 2 ) { ans = i ; break ; } else if ( hairetu [ i ] == 1 ) { ans = i ; break ; } else { continue ; } } System . out . println ( ans + 4 ) ; } }"], "python": ["s = int ( input ( ) ) NEW_LINE i = 1 NEW_LINE while ( s != 1 and s != 2 and s != 4 ) : NEW_LINE INDENT if s % 2 == 0 : NEW_LINE INDENT s = s / 2 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( i + 3 ) NEW_LINE", "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE def f ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return int ( n / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 3 * n + 1 NEW_LINE DEDENT DEDENT def main ( s ) : NEW_LINE INDENT a = [ 0 ] * 10000000 NEW_LINE a [ s ] = 1 NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT s = f ( s ) NEW_LINE i += 1 NEW_LINE if a [ s ] == 1 : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT a [ s ] = 1 NEW_LINE DEDENT return NEW_LINE DEDENT main ( int ( input ( ) ) ) NEW_LINE", "def func ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n / 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 * n + 1 NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT from builtins import int , map , list , print , len NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE input = ( lambda : ( sys . stdin . readline ( ) ) . rstrip ( ) ) NEW_LINE input_list = ( lambda : input ( ) . split ( ) ) NEW_LINE input_number = ( lambda : int ( input ( ) ) ) NEW_LINE input_number_list = ( lambda : list ( map ( int , input_list ( ) ) ) ) NEW_LINE s = input_number ( ) NEW_LINE ls = [ s ] NEW_LINE for i in range ( 1000000 ) : NEW_LINE INDENT a = func ( ls [ - 1 ] ) NEW_LINE ls . append ( a ) NEW_LINE if a in ls [ : - 1 ] : NEW_LINE INDENT print ( len ( ls ) ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE tmp = 0 NEW_LINE if ( n == 1 or n == 2 ) : print ( 4 ) NEW_LINE else : NEW_LINE INDENT while n != 4 : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT else : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT tmp += 1 NEW_LINE DEDENT print ( tmp + 4 ) NEW_LINE DEDENT", "import sys NEW_LINE s = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE a . append ( s ) NEW_LINE i = 1 NEW_LINE def f ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 * n + 1 NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT val = f ( a [ i - 1 ] ) NEW_LINE if val in a : NEW_LINE INDENT print ( i + 1 ) NEW_LINE sys . exit ( ) NEW_LINE DEDENT a . append ( val ) NEW_LINE i += 1 NEW_LINE DEDENT"]}
{"id": "aizu_p02044_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; if ( N == 0 ) break ; int ans = 0 ; int price = M / N ; for ( int i = 0 ; i < N ; i ++ ) { int a = sc . nextInt ( ) ; if ( a < price ) ans += a ; else ans += price ; } System . out . println ( ans ) ; } } }"], "python": ["while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE for i in a : NEW_LINE INDENT if i < m // n : NEW_LINE INDENT ans += i NEW_LINE DEDENT else : NEW_LINE INDENT ans += m // n NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT", "while True : NEW_LINE INDENT N , M = map ( int , input ( ) . split ( ) ) NEW_LINE if ( N | M ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE ans = 0 NEW_LINE M //= N NEW_LINE for a in A : NEW_LINE INDENT if a < M : NEW_LINE INDENT ans += a NEW_LINE DEDENT else : NEW_LINE INDENT ans += M NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT", "while True : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT h = b // a NEW_LINE for c in list ( map ( int , input ( ) . split ( ) ) ) : NEW_LINE INDENT if c < h : NEW_LINE INDENT b -= h - c NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE DEDENT", "while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT c += min ( m // n , a [ i ] ) NEW_LINE DEDENT print ( c ) NEW_LINE DEDENT", "while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n , m ) == ( 0 , 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT t = m // n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 0 NEW_LINE for i in a : NEW_LINE INDENT if t <= i : NEW_LINE INDENT cnt += t NEW_LINE DEDENT else : NEW_LINE INDENT cnt += i NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE DEDENT"]}
{"id": "aizu_p01315_A", "java": ["import java . util . Arrays ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws java . io . IOException { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; final Map < String , Double > map = new HashMap < String , Double > ( ) ; String [ ] seed = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String L = sc . next ( ) ; seed [ i ] = L ; int P = sc . nextInt ( ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int D = sc . nextInt ( ) ; int E = sc . nextInt ( ) ; int F = sc . nextInt ( ) ; int S = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int t = A + B + C + M * ( D + E ) ; int inc = ( M * F * S - P ) ; double ef = 1.0 * inc / t ; map . put ( L , ef ) ; } Arrays . sort ( seed ) ; Arrays . sort ( seed , new Comparator < String > ( ) { public int compare ( String a , String b ) { return map . get ( b ) - map . get ( a ) > 0 ? 1 : - 1 ; } } ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . println ( seed [ i ] ) ; } System . out . println ( ( \" # \" ) ) ; } } }", "import java . util . * ; public class Main { private static final String END_OF_DATASET = \" # \" ; public static void main ( String [ ] args ) { try ( Scanner scn = new Scanner ( System . in ) ) { int n ; while ( ( n = scn . nextInt ( ) ) > 0 ) { ArrayList < Plant > plants = new ArrayList < > ( ) ; while ( n -- > 0 ) { String name = scn . next ( ) ; int cost = scn . nextInt ( ) ; int firstTime = scn . nextInt ( ) + scn . nextInt ( ) + scn . nextInt ( ) ; int latterTime = scn . nextInt ( ) + scn . nextInt ( ) ; int amount = scn . nextInt ( ) ; int price = scn . nextInt ( ) ; int count = scn . nextInt ( ) ; double profit = amount * price * count - cost ; double efficiency = profit / ( firstTime + latterTime * count ) ; plants . add ( new Plant ( name , efficiency ) ) ; } Collections . sort ( plants ) ; for ( Plant plant : plants ) { System . out . println ( plant ) ; } System . out . println ( END_OF_DATASET ) ; } } } } class Plant implements Comparable < Plant > { private String name ; private double efficiency ; public Plant ( String name , double efficiency ) { this . name = name ; this . efficiency = efficiency ; } public int compareTo ( Plant another ) { int rslt ; if ( this . efficiency < another . efficiency ) { rslt = 1 ; } else if ( this . efficiency > another . efficiency ) { rslt = - 1 ; } else { rslt = this . name . compareTo ( another . name ) ; } return rslt ; } @ Override public String toString ( ) { return name ; } }", "import java . util . Arrays ; import java . util . Scanner ; import java . util . Comparator ; public class Main { static class Plant { String name ; int P , A , B , C , D , E , F , S , M ; int rieki , time ; Plant ( String str , int p , int a , int b , int c , int d , int e , int f , int s , int m ) { name = str ; P = p ; A = a ; B = b ; C = c ; D = d ; E = e ; F = f ; S = s ; M = m ; time = a + b + c ; for ( int i = 0 ; i < m ; i ++ ) { time += ( d + e ) ; } rieki = m * f * s - p ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int data = sc . nextInt ( ) ; if ( data == 0 ) break ; Plant [ ] plants = new Plant [ data ] ; for ( int i = 0 ; i < data ; i ++ ) { plants [ i ] = new Plant ( sc . next ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) , sc . nextInt ( ) ) ; } Arrays . sort ( plants , new Comparator < Plant > ( ) { public int compare ( Plant a , Plant b ) { if ( a . rieki * b . time - b . rieki * a . time > 0 ) { return - 1 ; } else if ( a . rieki * b . time - b . rieki * a . time < 0 ) { return 1 ; } else { return a . name . compareTo ( b . name ) ; } } } ) ; for ( int i = 0 ; i < data ; i ++ ) { System . out . println ( plants [ i ] . name ) ; } System . out . println ( \" # \" ) ; } } }", "import java . util . PriorityQueue ; import java . util . Scanner ; public class Main { static class State implements Comparable < State > { String name ; double cost ; State ( String name , double cost ) { this . name = name ; this . cost = cost ; } public int compareTo ( State s ) { if ( s . cost == this . cost ) { return this . name . compareTo ( s . name ) ; } else if ( this . cost > s . cost ) { return - 1 ; } else { return 1 ; } } } public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { while ( sc . hasNext ( ) ) { int N = sc . nextInt ( ) ; if ( N == 0 ) break ; PriorityQueue < State > pq = new PriorityQueue < State > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { String name = sc . next ( ) ; int p = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int e = sc . nextInt ( ) ; int f = sc . nextInt ( ) ; int s = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int turn1 = a + b + c + d + e ; int turn2 = d + e ; int benefit = f * s * m - p ; double cost = 1.0 * benefit / ( double ) ( turn1 + ( m - 1 ) * turn2 ) ; pq . add ( new State ( name , cost ) ) ; } for ( int i = 0 ; i < N ; i ++ ) { State st = pq . remove ( ) ; System . out . println ( st . name ) ; } System . out . println ( \" # \" ) ; } } } }", "import java . util . * ; class Main { public static void main ( String [ ] z ) { Scanner s = new Scanner ( System . in ) ; String L ; for ( int t , i ; ( t = s . nextInt ( ) ) > 0 ; System . out . println ( L + \" # \" ) ) { List < String [ ] > l = new ArrayList < String [ ] > ( ) ; for ( ; t -- > 0 ; ) { L = s . next ( ) ; int [ ] x = new int [ 9 ] ; for ( i = 0 ; i < 9 ; ++ i ) x [ i ] = s . nextInt ( ) ; l . add ( new String [ ] { L , \" \" + ( double ) ( x [ 6 ] * x [ 8 ] * x [ 7 ] - x [ 0 ] ) / ( x [ 1 ] + x [ 2 ] + x [ 3 ] + ( x [ 4 ] + x [ 5 ] ) * x [ 8 ] ) } ) ; } Collections . sort ( l , new Comparator < String [ ] > ( ) { public int compare ( String [ ] a , String [ ] b ) { int i = new Double ( b [ 1 ] ) . compareTo ( new Double ( a [ 1 ] ) ) ; return i == 0 ? a [ 0 ] . compareTo ( b [ 0 ] ) : i ; } } ) ; L = \" \" ; for ( String [ ] y : l ) L += y [ 0 ] + \" \\n \" ; } } }"], "python": ["while True : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE if N == 0 : break NEW_LINE mem = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l , p , a , b , c , d , e , f , s , m = map ( lambda x : int ( x ) if x [ 0 ] . isdigit ( ) else x , input ( ) . split ( ) ) NEW_LINE time = a + b + c + ( d + e ) * m NEW_LINE income = f * m * s - p NEW_LINE mem . append ( ( - income / time , l ) ) NEW_LINE DEDENT for e , name in sorted ( mem ) : NEW_LINE INDENT print ( name ) NEW_LINE DEDENT print ( ' # ' ) NEW_LINE DEDENT", "from collections import defaultdict , deque NEW_LINE from heapq import heappush , heappop NEW_LINE import sys NEW_LINE import math NEW_LINE import bisect NEW_LINE import random NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def LS ( ) : return [ list ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def S ( ) : return list ( sys . stdin . readline ( ) ) [ : - 1 ] NEW_LINE def IR ( n ) : NEW_LINE INDENT return [ I ( ) for i in range ( n ) ] NEW_LINE DEDENT def LIR ( n ) : NEW_LINE INDENT return [ LI ( ) for i in range ( n ) ] NEW_LINE DEDENT def SR ( n ) : NEW_LINE INDENT return [ S ( ) for i in range ( n ) ] NEW_LINE DEDENT def LSR ( n ) : NEW_LINE INDENT return [ LS ( ) for i in range ( n ) ] NEW_LINE DEDENT sys . setrecursionlimit ( 1000000 ) NEW_LINE mod = 1000000007 NEW_LINE def solve ( n ) : NEW_LINE INDENT lis = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l = input ( ) . split ( ) NEW_LINE p , a , b , c , d , e , f , s , m = [ int ( i ) for i in l [ 1 : ] ] NEW_LINE l = l [ 0 ] NEW_LINE lis . append ( ( ( f * s * m - p ) / ( a + b + c + ( d + e ) * m ) , l ) ) NEW_LINE DEDENT lis . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) NEW_LINE for i , j in lis : NEW_LINE INDENT print ( j ) NEW_LINE DEDENT print ( \" # \" ) NEW_LINE return NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = I ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT solve ( n ) NEW_LINE DEDENT DEDENT", "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE def f ( k ) : NEW_LINE INDENT p , a , b , c , d , e , f , s , m = map ( int , k [ 1 : ] ) NEW_LINE t = a + b + c + ( d + e ) * m NEW_LINE u = f * s * m - p NEW_LINE return ( - u / t , k [ 0 ] ) NEW_LINE DEDENT while True : NEW_LINE INDENT n = I ( ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT a = [ LS ( ) for _ in range ( n ) ] NEW_LINE b = [ f ( c ) for c in a ] NEW_LINE b . sort ( ) NEW_LINE for u , l in b : NEW_LINE INDENT rr . append ( l ) NEW_LINE DEDENT rr . append ( ' # ' ) NEW_LINE DEDENT return ' \\n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE", "while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT else : NEW_LINE INDENT aa = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , p , a , b , c , d , e , f , s , m = input ( ) . split ( ) NEW_LINE p = int ( p ) NEW_LINE a = int ( a ) NEW_LINE b = int ( b ) NEW_LINE c = int ( c ) NEW_LINE d = int ( d ) NEW_LINE e = int ( e ) NEW_LINE f = int ( f ) NEW_LINE s = int ( s ) NEW_LINE m = int ( m ) NEW_LINE time = a + b + c + ( d + e ) * m NEW_LINE pro = s * m * f - p NEW_LINE aa . append ( [ pro / time , l ] ) NEW_LINE DEDENT aa . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( aa [ i ] [ 1 ] ) NEW_LINE DEDENT print ( \" # \" ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = \" \\n \" ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE def main ( ) : NEW_LINE INDENT while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : break NEW_LINE ans = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l , * num = input ( ) . split ( ) NEW_LINE p , a , b , c , d , e , f , s , m = map ( int , num ) NEW_LINE ans . append ( [ ( f * s * m - p ) / ( a + b + c + ( d + e ) * m ) , l ] ) NEW_LINE DEDENT ans . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) NEW_LINE for _ , l in ans : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT print ( \" # \" ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE"]}
{"id": "codejam_12_11", "java": ["import java . util . * ; import java . io . * ; import java . math . * ; import java . awt . * ; import static java . lang . Math . * ; import static java . lang . Integer . parseInt ; import static java . lang . Double . parseDouble ; import static java . lang . Long . parseLong ; import static java . lang . System . * ; import static java . util . Arrays . * ; import static java . util . Collection . * ; public class A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; int T = parseInt ( br . readLine ( ) ) ; for ( int t = 0 ; t ++ < T ; ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; int A = parseInt ( line [ 0 ] ) , B = parseInt ( line [ 1 ] ) ; line = br . readLine ( ) . split ( \" \u2581 \" ) ; double [ ] P = new double [ A + 1 ] ; P [ 0 ] = 1 ; for ( int a = 0 ; a < A ; a ++ ) P [ a + 1 ] = parseDouble ( line [ a ] ) * P [ a ] ; double best = 2 + B ; for ( int a = 0 ; a <= A ; a ++ ) best = min ( best , 2 * a + ( B - A ) + 1 + ( 1 - P [ A - a ] ) * ( B + 1 ) ) ; out . println ( \" Case \u2581 # \" + t + \" : \u2581 \" + best ) ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int inputs = in . nextInt ( ) ; Q : for ( int _ = 1 ; _ <= inputs ; _ ++ ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; double exp = 2 + b ; double [ ] prob = new double [ a + 1 ] ; prob [ 0 ] = 1 ; for ( int i = 0 ; i < a ; i ++ ) { prob [ i + 1 ] = prob [ i ] * ( in . nextDouble ( ) ) ; } double exp2 = prob [ a ] * ( b - a + 1 ) + ( 1 - prob [ a ] ) * ( 2 * b - a + 2 ) ; if ( exp2 < exp ) exp = exp2 ; exp2 = 0 ; for ( int i = 0 ; i < a ; i ++ ) { exp2 = prob [ i ] * ( 2 * ( a - i ) + ( b - a ) + 1 ) + ( 1 - prob [ i ] ) * ( ( 2 * ( a - i ) + ( b - a ) + 1 ) + b + 1 ) ; if ( exp2 < exp ) exp = exp2 ; } System . out . printf ( \" Case \u2581 # \" + _ + \" : \u2581 % .6f \\n \" , exp ) ; } } }", "import java . io . * ; import java . util . * ; public class PasswordProblem { void solve ( ) throws Exception { int a = nextInt ( ) ; int b = nextInt ( ) ; double [ ] p = new double [ a ] ; for ( int i = 0 ; i < a ; i ++ ) { p [ i ] = nextDouble ( ) ; } double [ ] prob = p . clone ( ) ; for ( int i = 1 ; i < a ; i ++ ) { prob [ i ] = prob [ i - 1 ] * prob [ i ] ; } double ans = b + 2 ; for ( int i = a - 1 ; i >= 0 ; i -- ) { double curAns = ( a - i - 1 ) + ( b - i - 1 ) + 1 + ( 1 - prob [ i ] ) * ( b + 1 ) ; ans = Math . min ( ans , curAns ) ; } out . println ( ans ) ; } void run ( ) { try { in = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int tests = nextInt ( ) ; for ( int i = 0 ; i < tests ; i ++ ) { out . print ( \" Case \u2581 # \" + ( i + 1 ) + \" : \u2581 \" ) ; solve ( ) ; } out . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } BufferedReader in ; StringTokenizer st ; PrintWriter out ; final String filename = new String ( \" PasswordProblem \" ) . toLowerCase ( ) ; String nextToken ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( in . readLine ( ) ) ; return st . nextToken ( ) ; } int nextInt ( ) throws Exception { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) throws Exception { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) throws Exception { return Double . parseDouble ( nextToken ( ) ) ; } public static void main ( String [ ] args ) { new PasswordProblem ( ) . run ( ) ; } }", "import java . math . BigDecimal ; import java . math . MathContext ; import java . math . RoundingMode ; import java . util . Arrays ; import java . util . Scanner ; public class A { private static Scanner sc ; private static long start ; public static void main ( String [ ] args ) { sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 0 ; i < t ; i ++ ) { start = System . currentTimeMillis ( ) ; System . out . printf ( \" Case \u2581 # % d : \u2581 % s \\n \" , i + 1 , exec ( ) ) ; long end = System . currentTimeMillis ( ) ; } } private static final MathContext ROUND_CONTEXT = new MathContext ( 8 , RoundingMode . HALF_EVEN ) ; public static String exec ( ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; BigDecimal [ ] bd = new BigDecimal [ a ] ; for ( int i = 0 ; i < a ; i ++ ) bd [ i ] = new BigDecimal ( sc . next ( ) ) ; BigDecimal [ ] rs = new BigDecimal [ a + 2 ] ; rs [ 0 ] = new BigDecimal ( b + 2 ) ; int backspacesNeeded = a ; double runningChance = 1.0 ; for ( int i = 0 ; i < a ; i ++ ) { int charsNeededOnSuccess = backspacesNeeded + b - i + 1 ; int charsNeededOnFail = charsNeededOnSuccess + b + 1 ; double onSuccess = runningChance * charsNeededOnSuccess ; double onFail = ( 1.0 - runningChance ) * charsNeededOnFail ; rs [ i + 1 ] = new BigDecimal ( onSuccess + onFail ) ; runningChance *= bd [ i ] . doubleValue ( ) ; backspacesNeeded -- ; } rs [ a + 1 ] = new BigDecimal ( ( runningChance * ( b - a + 1 ) ) + ( ( 1.0 - runningChance ) * ( b - a + 1 + b + 1 ) ) ) ; Arrays . sort ( rs ) ; BigDecimal result = rs [ 0 ] ; return String . format ( \" % .06f \" , result ) ; } }", "import java . io . File ; import java . io . PrintWriter ; import java . util . Scanner ; public class A { static double [ ] logP = new double [ 1 << 17 ] ; public static void main ( String [ ] args ) throws Exception { Scanner s = new Scanner ( new File ( \" A . in \" ) ) ; PrintWriter out = new PrintWriter ( new File ( \" A . out \" ) ) ; int T = s . nextInt ( ) ; for ( int tc = 1 ; tc <= T ; tc ++ ) { out . print ( \" Case \u2581 # \" + tc + \" : \u2581 \" ) ; int A = s . nextInt ( ) , B = s . nextInt ( ) ; double best = A + B + 1 ; logP [ 0 ] = Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ 0 ] ) ) ; for ( int i = 1 ; i < A ; i ++ ) { logP [ i ] = logP [ i - 1 ] + Math . log ( s . nextDouble ( ) ) ; best = Math . min ( best , ( 2 * ( A - 1 - i ) + ( B - A ) + 1 ) + ( B + 1 ) - ( B + 1 ) * Math . exp ( logP [ i ] ) ) ; } best = Math . min ( best , B + 2 ) ; out . println ( best ) ; } out . close ( ) ; } }"], "python": ["testCount = int ( raw_input ( ) ) NEW_LINE for testIndex in range ( testCount ) : NEW_LINE INDENT ans = \" Case \u2581 # \" + str ( testIndex + 1 ) + \" : \u2581 \" NEW_LINE n , m = [ int ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE p = [ float ( x ) for x in raw_input ( ) . split ( \" \u2581 \" ) ] NEW_LINE minType = m + 1.0 NEW_LINE p1 = reduce ( lambda x , y : x * y , p , 1.0 ) NEW_LINE type = ( m - n ) * p1 + ( m - n + 1 + m ) * ( 1 - p1 ) NEW_LINE minType = min ( type , minType ) NEW_LINE p1 = 1.0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT p1 *= p [ i - 1 ] NEW_LINE type = ( n - i + m - i ) * p1 + ( n - i + m - i + 1 + m ) * ( 1 - p1 ) NEW_LINE minType = min ( type , minType ) NEW_LINE DEDENT print ( ans + str ( minType + 1.0 ) ) NEW_LINE DEDENT", "with open ( ' A - large . in ' , ' r ' ) as fin : NEW_LINE INDENT with open ( ' output . txt ' , ' w ' ) as fout : NEW_LINE INDENT numcases = int ( fin . readline ( ) ) NEW_LINE for i in range ( 1 , numcases + 1 ) : NEW_LINE INDENT line = [ int ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE charstyped = line [ 0 ] NEW_LINE numchars = line [ 1 ] NEW_LINE line = [ float ( j ) for j in fin . readline ( ) . split ( ) ] NEW_LINE bestcost = numchars + 2 NEW_LINE correctprob = 1 NEW_LINE for idx in range ( charstyped ) : NEW_LINE INDENT correctprob = correctprob * line [ idx ] NEW_LINE currcost = ( numchars + 1 ) * ( 1 - correctprob ) + ( charstyped - idx - 1 ) + ( numchars - idx - 1 ) + 1 NEW_LINE if currcost < bestcost : NEW_LINE INDENT bestcost = currcost NEW_LINE DEDENT DEDENT fout . write ( \" Case \u2581 # \" ) NEW_LINE fout . write ( str ( i ) ) NEW_LINE fout . write ( \" : \u2581 \" ) NEW_LINE fout . write ( str ( bestcost ) ) NEW_LINE fout . write ( ' \\n ' ) NEW_LINE print ( i ) NEW_LINE DEDENT DEDENT DEDENT", "import sys NEW_LINE t_n = int ( sys . stdin . readline ( ) ) NEW_LINE for t_t in range ( 1 , t_n + 1 ) : NEW_LINE INDENT a , b = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE p = list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE ans = 1.0 * b + 1 NEW_LINE r = 1.0 NEW_LINE for x in range ( 0 , a + 1 ) : NEW_LINE INDENT ans = min ( ans , ( a + b - 2 * x ) + ( 1.0 - r ) * ( b + 1 ) ) NEW_LINE if x < a : NEW_LINE INDENT r *= p [ x ] NEW_LINE DEDENT DEDENT print ( \" Case \u2581 # % d : \u2581 % .10f \" % ( t_t , ans + 1.0 ) ) NEW_LINE DEDENT", "def work ( K , N , P ) : NEW_LINE INDENT return min ( work_backspace ( K , N , P ) , work_giveup ( K , N , P ) ) NEW_LINE DEDENT def work_backspace ( K , N , P ) : NEW_LINE INDENT Pc = 1 NEW_LINE res = N * N NEW_LINE for k in range ( K + 1 ) : NEW_LINE INDENT r = ( K - k ) NEW_LINE r += ( N + 1 - k ) NEW_LINE r += ( 1 - Pc ) * ( N + 1 ) NEW_LINE if k < K : NEW_LINE INDENT Pc *= P [ k ] NEW_LINE DEDENT res = min ( res , r ) NEW_LINE DEDENT return res NEW_LINE DEDENT def work_giveup ( K , N , P ) : NEW_LINE INDENT return 1 + N + 1 NEW_LINE DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( 1 , T + 1 ) : NEW_LINE INDENT K , N = map ( int , raw_input ( ) . split ( ) ) NEW_LINE P = map ( float , raw_input ( ) . split ( ) ) NEW_LINE print ( ' Case \u2581 # { } : \u2581 { : f } ' . format ( i , work ( K , N , P ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1318_A", "java": ["import java . util . * ; class GFG { static Vector < Long > pr = new Vector < > ( ) ; static boolean prime [ ] = new boolean [ 10000000 + 1 ] ; static void sieve ( long n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = true ; } for ( int p = 2 ; ( int ) p * ( int ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = ( int ) p * ( int ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . add ( ( long ) p ) ; } static long SemiPrimeSum ( long N ) { long ans = 0 ; for ( int i = 0 ; i < pr . size ( ) ; i += 1 ) { for ( int j = i ; j < pr . size ( ) ; j += 1 ) { if ( ( long ) pr . get ( i ) * ( long ) pr . get ( j ) > N ) break ; ans += ( long ) pr . get ( i ) * ( long ) pr . get ( j ) ; } } return ans ; } public static void main ( String [ ] args ) { long N = 6 ; sieve ( N ) ; System . out . println ( SemiPrimeSum ( N ) ) ; } }"], "python": ["pr = [ ] NEW_LINE prime = [ 1 for i in range ( 10000000 + 1 ) ] NEW_LINE def sieve ( n ) : NEW_LINE INDENT for p in range ( 2 , n ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT pr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def SemiPrimeSum ( N ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( pr ) ) : NEW_LINE INDENT for j in range ( i , len ( pr ) ) : NEW_LINE INDENT if ( pr [ i ] * pr [ j ] > N ) : NEW_LINE INDENT break NEW_LINE DEDENT ans += pr [ i ] * pr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 6 NEW_LINE sieve ( N ) NEW_LINE print ( SemiPrimeSum ( N ) ) NEW_LINE"]}
{"id": "codeforces_1350_A", "java": ["import java . util . Scanner ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . nio . charset . MalformedInputException ; import java . util . StringTokenizer ; import java . util . Arrays ; public class Cv { public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; Scanner sc = new Scanner ( System . in ) ; PrintWriter o = new PrintWriter ( System . out ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) , k = sc . nextInt ( ) , m = 2 ; if ( n % 2 == 0 ) { o . println ( n + k * 2 ) ; } else { while ( n % m != 0 ) { m ++ ; } o . println ( n + m + k * 2 - 2 ) ; } } o . close ( ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; public String next ( ) { while ( ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } public String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } byte nextByte ( ) { return Byte . parseByte ( next ( ) ) ; } short nextShort ( ) { return Short . parseShort ( next ( ) ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return java . lang . Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }", "import java . util . * ; public class App { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = s . nextInt ( ) ; int k = s . nextInt ( ) ; if ( n % 2 == 0 ) System . out . println ( n + 2 * k ) ; else { int val = n ; for ( int j = 3 ; j * j <= n ; j += 2 ) { if ( n % j == 0 ) { val = j ; break ; } } System . out . println ( n + val + ( 2 * ( k - 1 ) ) ) ; } } } }", "import java . util . * ; import java . io . * ; import java . util . stream . * ; public class App { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws Exception { if ( System . getProperty ( \" ONLINE _ JUDGE \" ) == null ) { File inputFile = new File ( \" / Users / vipinjain / self / cp / input . txt \" ) ; File outputFile = new File ( \" / Users / vipinjain / self / cp / output . txt \" ) ; br = new BufferedReader ( new FileReader ( inputFile ) ) ; bw = new BufferedWriter ( new FileWriter ( outputFile ) ) ; } int tests ; tests = Integer . parseInt ( br . readLine ( ) ) ; while ( tests -- > 0 ) { solve ( ) ; } bw . flush ( ) ; bw . close ( ) ; br . close ( ) ; } static void solve ( ) throws Exception { String [ ] tmp = br . readLine ( ) . split ( \" \u2581 \" ) ; long n = Long . parseLong ( tmp [ 0 ] ) ; long k = Long . parseLong ( tmp [ 1 ] ) ; long minDivisor = minDivisor ( n ) ; n += minDivisor ; k -- ; if ( k > 0 ) { n = n + 2 * k ; } bw . write ( n + \" \" ) ; bw . write ( \" \\n \" ) ; } static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static boolean isPrime ( long n ) { for ( long i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } static long minDivisor ( long n ) { for ( long i = 2 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { return i ; } } return n ; } }", "import java . util . * ; public class Practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long i = 2 ; while ( i * i <= a ) { if ( a % i == 0 ) { break ; } i ++ ; } if ( a % 2 == 0 ) { System . out . println ( a + ( 2 * b ) ) ; } else { if ( a % i != 0 ) a += a ; else a += i ; a += ( 2 * ( b - 1 ) ) ; System . out . println ( a ) ; } } } }"], "python": ["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = i NEW_LINE break ; NEW_LINE DEDENT DEDENT print ( n + ans + ( k - 1 ) * 2 ) NEW_LINE DEDENT", "ls = [ ] NEW_LINE set = int ( input ( ) ) NEW_LINE for i in range ( set ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT d = 2 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT n += 2 * ( k - i ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT while n % d != 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT if n % ( d + 1 ) == 0 : NEW_LINE INDENT d += 1 NEW_LINE DEDENT n += d NEW_LINE DEDENT DEDENT ls . append ( n ) NEW_LINE DEDENT for x in range ( set ) : NEW_LINE INDENT print ( ls [ x ] ) NEW_LINE DEDENT", "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT temp = input ( ) . split ( ) ; n , k = [ int ( x ) for x in temp ] NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n + 2 * k ) NEW_LINE DEDENT else : NEW_LINE INDENT i = 2 NEW_LINE while i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( n + i + 2 * ( k - 1 ) ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT print ( n + k * 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT prime = - 1 NEW_LINE for i in range ( 3 , n , 2 ) : NEW_LINE INDENT if i ** 2 > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT prime = i NEW_LINE break NEW_LINE DEDENT DEDENT if prime == - 1 : NEW_LINE INDENT prime = n NEW_LINE DEDENT print ( n + prime + ( k - 1 ) * 2 ) NEW_LINE DEDENT DEDENT", "def smallest_div ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT def calculate ( n , k ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n += 2 * k NEW_LINE DEDENT else : NEW_LINE INDENT n += 2 * ( k - 1 ) + smallest_div ( n ) NEW_LINE DEDENT print ( n ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE l1 = [ ] NEW_LINE l2 = [ ] NEW_LINE for i in range ( t ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l1 . append ( n ) NEW_LINE l2 . append ( k ) NEW_LINE DEDENT for i in range ( t ) : NEW_LINE INDENT calculate ( l1 [ i ] , l2 [ i ] ) NEW_LINE DEDENT"]}
{"id": "codejam_16_32", "java": ["import java . util . * ; public class B { static Scanner in ; public static void main ( String [ ] args ) { in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int C = 1 ; C <= T ; C ++ ) { System . out . println ( \" Case \u2581 # \" + C + \" : \u2581 \" + solve ( ) ) ; } } public static String solve ( ) { String out = \" \" ; int B = in . nextInt ( ) ; long M = in . nextLong ( ) - 1 ; String binary = \" \" ; while ( M > 0 ) { binary += M % 2 ; M = M / 2 ; } System . err . println ( binary ) ; if ( binary . length ( ) > B - 2 ) { out = \" IMPOSSIBLE \" ; } else { out = \" POSSIBLE \" ; for ( int i = 0 ; i < B ; i ++ ) { String line = \" \" ; for ( int j = 0 ; j <= i ; j ++ ) { line += \"0\" ; } for ( int j = 0 ; j < B - 2 - i ; j ++ ) { line += \"1\" ; } if ( i < B - 1 ) { if ( i == 0 ) { line += \"1\" ; } else if ( i - 1 < binary . length ( ) ) { line += binary . charAt ( i - 1 ) ; } else { line += \"0\" ; } } out += \" \\n \" + line ; } } return out ; } }", "import java . io . File ; import java . io . FileInputStream ; import java . io . FileOutputStream ; import java . io . IOException ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int x = 1 ; x <= t ; ++ x ) { int b = scanner . nextInt ( ) ; long m = scanner . nextLong ( ) ; System . out . print ( \" Case \u2581 # \" + x + \" : \u2581 \" ) ; if ( m > Math . pow ( 2 , b - 2 ) ) { System . out . print ( \" IMPOSSIBLE \\n \" ) ; continue ; } else System . out . print ( \" POSSIBLE \\n \" ) ; int [ ] [ ] slides = new int [ b ] [ b ] ; for ( int i = 0 ; i < b ; ++ i ) { for ( int j = i + 1 ; j < b ; ++ j ) { slides [ i ] [ j ] = 1 ; } } String str = Long . toBinaryString ( m - 1 ) + \" \" ; if ( str . equals ( \"0\" ) ) str = \" \" ; while ( str . length ( ) < b - 1 ) { str = \"0\" + str ; } str += \"1\" ; System . out . println ( str ) ; for ( int i = 1 ; i < b ; ++ i ) { for ( int j = 0 ; j < b ; ++ j ) { System . out . print ( slides [ i ] [ j ] ) ; } System . out . print ( \" \\n \" ) ; } } } }", "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class B { public static void main ( String [ ] args ) { new B ( ) . run ( ) ; } BufferedReader br ; StringTokenizer in ; PrintWriter out ; public String nextToken ( ) throws IOException { while ( in == null || ! in . hasMoreTokens ( ) ) { in = new StringTokenizer ( br . readLine ( ) ) ; } return in . nextToken ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( nextToken ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( nextToken ( ) ) ; } public void solve ( ) throws IOException { int n = nextInt ( ) ; long b = nextLong ( ) ; if ( b > 1L << ( n - 2 ) ) { out . println ( \" IMPOSSIBLE \" ) ; return ; } int [ ] [ ] a = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { a [ i ] [ j ] = 1 ; } } b -- ; a [ 0 ] [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( b % 2 == 1 ) { a [ 0 ] [ i ] = 1 ; } b /= 2 ; } out . println ( \" POSSIBLE \" ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . print ( a [ i ] [ j ] ) ; } out . println ( ) ; } } public void run ( ) { try { br = new BufferedReader ( new FileReader ( \" input . txt \" ) ) ; out = new PrintWriter ( \" output . txt \" ) ; int t = nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { out . print ( String . format ( \" Case \u2581 # % d : \u2581 \" , i + 1 ) ) ; solve ( ) ; } out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } }", "import java . util . * ; import java . io . * ; public class B { static int N ; static int ans ; public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int B = input . nextInt ( ) ; long M = input . nextLong ( ) ; if ( M > ( 1L << ( B - 2 ) ) ) { System . out . printf ( \" Case \u2581 # % d : \u2581 IMPOSSIBLE \\n \" , n + 1 ) ; continue ; } boolean [ ] [ ] slides = new boolean [ B ] [ B ] ; if ( M == ( 1L << ( B - 2 ) ) ) { for ( int i = 0 ; i < B ; i ++ ) for ( int j = i + 1 ; j < B ; j ++ ) slides [ i ] [ j ] = true ; } for ( int i = 0 ; i + 1 < B ; i ++ ) for ( int j = i + 1 ; j + 1 < B ; j ++ ) slides [ i ] [ j ] = true ; for ( int i = 0 ; i + 2 < B ; i ++ ) if ( ( M & ( 1L << i ) ) > 0 ) slides [ i + 1 ] [ B - 1 ] = true ; System . out . printf ( \" Case \u2581 # % d : \u2581 POSSIBLE \\n \" , n + 1 ) ; for ( int i = 0 ; i < B ; i ++ ) { for ( int j = 0 ; j < B ; j ++ ) System . out . print ( slides [ i ] [ j ] ? '1' : '0' ) ; System . out . println ( ) ; } } } }", "package Round1 ; import java . io . * ; public class B { public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( \" / Users / chao / Downloads / B - large . in \" ) ) ; FileWriter out = new FileWriter ( \" / Users / chao / Desktop / B - large . txt \" ) ; String s = in . readLine ( ) ; int m = Integer . parseInt ( s ) ; for ( int cases = 1 ; cases <= m ; cases ++ ) { String [ ] ss = in . readLine ( ) . split ( \" \u2581 \" ) ; int B = Integer . parseInt ( ss [ 0 ] ) ; long M = Long . parseLong ( ss [ 1 ] ) ; out . write ( \" Case \u2581 # \" + cases + \" : \u2581 \" ) ; int n = B ; long max = pow ( B - 2 ) ; if ( max >= M ) { out . write ( \" POSSIBLE \\n \" ) ; int [ ] [ ] map = new int [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { map [ i ] [ j ] = 1 ; } } for ( int k = 1 ; k < n ; k ++ ) { if ( k != n - 1 ) max = max / 2 ; if ( max <= M ) { M -= max ; map [ 0 ] [ k ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { out . write ( \" \" + map [ i ] [ j ] ) ; } out . write ( \" \\n \" ) ; } } else { out . write ( \" IMPOSSIBLE \\n \" ) ; } } in . close ( ) ; out . flush ( ) ; out . close ( ) ; } private static long pow ( int n ) { long x = 1 ; for ( int i = 0 ; i < n ; i ++ ) { x *= 2 ; } return x ; } }"], "python": ["def solve ( b , m ) : NEW_LINE INDENT if m > 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE return NEW_LINE DEDENT print ( \" POSSIBLE \" ) NEW_LINE if m == 2 ** ( b - 2 ) : NEW_LINE INDENT print ( \"0\" + \"1\" * ( b - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT l = [ ( m >> i ) & 1 for i in range ( b - 2 ) ] NEW_LINE print ( \"0\" + \" \" . join ( map ( str , reversed ( l ) ) ) + \"0\" ) NEW_LINE DEDENT for i in range ( 1 , b ) : NEW_LINE INDENT print ( \"0\" * ( i + 1 ) + \"1\" * ( b - i - 1 ) ) NEW_LINE DEDENT DEDENT t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT print ( \" Case \u2581 # \" + str ( i + 1 ) + \" : \" , end = \" \u2581 \" ) NEW_LINE b , m = map ( int , input ( ) . split ( ) ) NEW_LINE solve ( b , m ) NEW_LINE DEDENT", "T = int ( input ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT t = input ( ) . split ( ) NEW_LINE B = int ( t [ 0 ] ) NEW_LINE M = int ( t [ 1 ] ) NEW_LINE if M > 2 ** ( B - 2 ) : NEW_LINE INDENT print ( ' Case \u2581 # { 0 } : \u2581 IMPOSSIBLE ' . format ( case ) ) NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Case \u2581 # { 0 } : \u2581 POSSIBLE ' . format ( case ) ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i in range ( B ) : NEW_LINE INDENT ans . append ( [ ] ) NEW_LINE for j in range ( B ) : NEW_LINE INDENT ans [ i ] . append ( '0' ) NEW_LINE DEDENT for j in range ( i + 1 , B - 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = '1' NEW_LINE DEDENT DEDENT for i in range ( B - 2 , 0 , - 1 ) : NEW_LINE INDENT now = 2 ** ( i - 1 ) NEW_LINE if M >= now : NEW_LINE INDENT M -= now NEW_LINE ans [ i ] [ B - 1 ] = '1' NEW_LINE DEDENT DEDENT assert ( M <= 1 ) NEW_LINE if M >= 1 : NEW_LINE INDENT ans [ 0 ] [ B - 1 ] = '1' NEW_LINE DEDENT for line in ans : NEW_LINE INDENT print ( ' ' . join ( line ) ) NEW_LINE DEDENT DEDENT", "T = int ( input ( ) ) NEW_LINE for test in range ( 1 , T + 1 ) : NEW_LINE INDENT B , M = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % test , end = \" \" ) NEW_LINE if M > ( 2 ** ( B - 2 ) ) : NEW_LINE INDENT print ( \" IMPOSSIBLE \" ) NEW_LINE continue NEW_LINE DEDENT A = [ [ 0 ] * B for _ in range ( B ) ] NEW_LINE for i in range ( 0 , B ) : NEW_LINE INDENT for j in range ( i + 1 , B ) : NEW_LINE INDENT A [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT if M < 2 ** ( B - 2 ) : NEW_LINE INDENT A [ 0 ] [ B - 1 ] = 0 NEW_LINE for i in range ( B - 2 ) : NEW_LINE INDENT if ( 1 << i ) & M : NEW_LINE INDENT A [ 0 ] [ B - i - 2 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT A [ 0 ] [ B - i - 2 ] = 0 NEW_LINE DEDENT DEDENT DEDENT print ( \" POSSIBLE \" ) NEW_LINE for i in range ( B ) : NEW_LINE INDENT print ( \" \" . join ( [ str ( x ) for x in A [ i ] ] ) ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE def solve_test ( inp ) : NEW_LINE INDENT B , M = map ( int , inp . readline ( ) . split ( ) ) NEW_LINE if M > 2 ** ( B - 2 ) : NEW_LINE INDENT return ' IMPOSSIBLE ' NEW_LINE DEDENT if M == 2 ** ( B - 2 ) : NEW_LINE INDENT first = '0' + '1' * ( B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT first = '0' + bin ( M ) [ 2 : ] . zfill ( B - 2 ) + '0' NEW_LINE DEDENT print ( bin ( M ) , bin ( M ) [ 2 : ] . zfill ( B - 2 ) ) NEW_LINE lines = [ '0' * i + '1' * ( B - i ) for i in range ( 2 , B + 1 ) ] NEW_LINE return ' POSSIBLE \\n ' + ' \\n ' . join ( [ first ] + lines ) NEW_LINE DEDENT def solve_dumb ( inp ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT inp = open ( sys . argv [ 1 ] ) NEW_LINE inp_dumb = open ( sys . argv [ 1 ] ) NEW_LINE out = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . out ' , ' w ' ) NEW_LINE out_dumb = open ( sys . argv [ 1 ] . rsplit ( ' . ' , 1 ) [ 0 ] + ' . dumb . out ' , ' w ' ) NEW_LINE n_tests = int ( inp . readline ( ) ) NEW_LINE for i in range ( n_tests ) : NEW_LINE INDENT ans = solve_test ( inp ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans , file = out ) NEW_LINE ans_dumb = solve_dumb ( inp_dumb ) NEW_LINE print ( \" Case \u2581 # % d : \u2581 \" % ( i + 1 ) + ans_dumb , file = out_dumb ) NEW_LINE if ans != ans_dumb : NEW_LINE INDENT print ( ' Wrong ' , i + 1 , file = sys . stderr ) NEW_LINE DEDENT DEDENT out . close ( ) NEW_LINE"]}
{"id": "geeksforgeeks_34_A", "java": ["import java . util . * ; class GFG { static boolean isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = ( int ) Math . sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; } static boolean check ( int s , int p , int prefix_sum [ ] , int n ) { boolean satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; } static int minimumWindowSize ( int x , int y , int p ) { int [ ] prefix_sum = new int [ y - x + 1 ] ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; } public static void main ( String [ ] args ) { int x = 12 ; int y = 42 ; int p = 3 ; System . out . print ( minimumWindowSize ( x , y , p ) ) ; } }"], "python": ["from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N < 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( N & 1 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr = 5 NEW_LINE s = sqrt ( N ) NEW_LINE while ( curr <= s ) : NEW_LINE INDENT if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 2 NEW_LINE if ( N % curr == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT curr += 4 NEW_LINE DEDENT return True NEW_LINE DEDENT def check ( s , p , prefix_sum , n ) : NEW_LINE INDENT satisfies = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i + s - 1 >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( i - 1 >= 0 ) : NEW_LINE INDENT x = prefix_sum [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT x = 0 NEW_LINE DEDENT if ( prefix_sum [ i + s - 1 ] - x < p ) : NEW_LINE INDENT satisfies = False NEW_LINE DEDENT DEDENT return satisfies NEW_LINE DEDENT def minimumWindowSize ( x , y , p ) : NEW_LINE INDENT prefix_sum = [ 0 ] * ( y - x + 1 ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prefix_sum [ i - x ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , y - x + 1 ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT low = 1 NEW_LINE high = y - x + 1 NEW_LINE while ( high - low > 1 ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( check ( mid , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT DEDENT if ( check ( low , p , prefix_sum , y - x + 1 ) ) : NEW_LINE INDENT return low NEW_LINE DEDENT return high NEW_LINE DEDENT x = 12 NEW_LINE y = 42 NEW_LINE p = 3 NEW_LINE print ( minimumWindowSize ( x , y , p ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2341_A", "java": ["import java . lang . Math ; import java . io . * ; class GFG { static boolean checkPerfectSquare ( double n ) { double d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = a . length ; System . out . println ( largestPerfectSquareNumber ( a , n ) ) ; } }"], "python": ["from math import sqrt NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = sqrt ( n ) NEW_LINE if d * d == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT"]}
{"id": "leetcode_443_A", "java": ["class Solution { public int compress ( char [ ] chars ) { int anchor = 0 , write = 0 ; for ( int read = 0 ; read < chars . length ; read ++ ) { if ( read + 1 == chars . length || chars [ read + 1 ] != chars [ read ] ) { chars [ write ++ ] = chars [ anchor ] ; if ( read > anchor ) { for ( char c : ( \" \" + ( read - anchor + 1 ) ) . toCharArray ( ) ) { chars [ write ++ ] = c ; } } anchor = read + 1 ; } } return write ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1919_A", "java": ["import java . util . * ; class GFG { static void checkPalindrome ( int num ) { String str = Integer . toString ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str . charAt ( l ) != str . charAt ( r ) ) { System . out . print ( \" No \" ) ; return ; } l ++ ; r -- ; } System . out . print ( \" Yes \" ) ; return ; } public static void main ( String args [ ] ) { int n = 19 , k = 3 ; checkPalindrome ( n + k ) ; } }"], "python": ["def checkPalindrome ( num ) : NEW_LINE INDENT string = str ( num ) NEW_LINE l = 0 NEW_LINE r = len ( string ) - 1 ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( string [ l ] != string [ r ] ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return ; NEW_LINE DEDENT l = l + 1 ; NEW_LINE r = r - 1 ; NEW_LINE DEDENT print ( \" Yes \" ) NEW_LINE return ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE k = 3 NEW_LINE checkPalindrome ( n + k ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4103_A", "java": ["import java . util . * ; class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static int countSubstringsUtil ( char [ ] s ) { int count = 0 ; Map < Character , Integer > mp = new HashMap < > ( ) ; int n = s . length ; int start = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( s [ i ] ) ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) + 1 ) ; } else { mp . put ( s [ i ] , 1 ) ; } while ( mp . containsKey ( ' a ' ) && mp . containsKey ( ' e ' ) && mp . containsKey ( ' i ' ) && mp . containsKey ( ' o ' ) && mp . containsKey ( ' u ' ) && mp . get ( ' a ' ) > 0 && mp . get ( ' e ' ) > 0 && mp . get ( ' i ' ) > 0 && mp . get ( ' o ' ) > 0 && mp . get ( ' u ' ) > 0 ) { count += n - i ; mp . put ( s [ start ] , mp . get ( s [ start ] ) - 1 ) ; start ++ ; } } return count ; } static int countSubstrings ( String s ) { int count = 0 ; String temp = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) { temp += s . charAt ( i ) ; } else { if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; temp = \" \" ; } } if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; return count ; } public static void main ( String [ ] args ) { String s = \" aeouisddaaeeiouua \" ; System . out . println ( countSubstrings ( s ) ) ; } }"], "python": ["def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE mp = dict . fromkeys ( s , 0 ) ; NEW_LINE n = len ( s ) ; NEW_LINE start = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 ; NEW_LINE while ( mp [ ' a ' ] > 0 and mp [ ' e ' ] > 0 and mp [ ' i ' ] > 0 and mp [ ' o ' ] > 0 and mp [ ' u ' ] > 0 ) : NEW_LINE INDENT count += n - i ; NEW_LINE mp [ s [ start ] ] -= 1 ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countSubstrings ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE temp = \" \" ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT temp += s [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT temp = \" \" ; NEW_LINE DEDENT DEDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" aeouisddaaeeiouua \" ; NEW_LINE print ( countSubstrings ( s ) ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_239_B", "java": ["import java . util . ArrayList ; import java . util . Arrays ; import java . util . Scanner ; public class CF239B { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int q = s . nextInt ( ) ; String str = s . next ( ) ; while ( q -- > 0 ) { int [ ] count = new int [ 10 ] ; StringBuilder sb = new StringBuilder ( \" \" ) ; int l = s . nextInt ( ) - 1 ; int r = s . nextInt ( ) - 1 ; int pointer = 0 ; sb = sb . append ( str . substring ( l , r + 1 ) ) ; boolean flag1 = false , flag2 = false ; while ( pointer >= 0 && pointer < sb . length ( ) ) { if ( sb . charAt ( pointer ) == '0' ) { count [ 0 ] ++ ; sb . deleteCharAt ( pointer ) ; if ( flag2 ) pointer -= 1 ; } else if ( sb . charAt ( pointer ) >= '1' && sb . charAt ( pointer ) <= '9' ) { count [ sb . charAt ( pointer ) - '0' ] ++ ; sb . replace ( pointer , pointer + 1 , Character . toString ( ( char ) ( ( int ) sb . charAt ( pointer ) - 1 ) ) ) ; if ( flag2 ) pointer -= 1 ; else pointer += 1 ; } else { int intial = pointer ; if ( sb . charAt ( pointer ) == ' > ' ) { flag1 = true ; flag2 = false ; } else { flag1 = false ; flag2 = true ; } pointer += ( flag1 ? 1 : - 1 ) ; if ( pointer >= 0 && pointer < sb . length ( ) && ( sb . charAt ( pointer ) == ' > ' || sb . charAt ( pointer ) == ' < ' ) ) { sb . deleteCharAt ( intial ) ; if ( flag1 ) pointer -= 1 ; } } } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( count [ i ] + \" \u2581 \" ) ; } System . out . println ( ) ; } } }"], "python": ["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ - 1 ] + [ ord ( c ) - ord ( '0' ) for c in input ( ) ] + [ - 1 ] NEW_LINE for _ in range ( k ) : NEW_LINE INDENT L , R = map ( int , input ( ) . split ( ) ) NEW_LINE b = [ - 1 ] + a [ L : R + 1 ] + [ - 1 ] NEW_LINE ans , dp , p = [ 0 ] * 10 , 1 , 1 NEW_LINE c = b [ p ] NEW_LINE while c != - 1 : NEW_LINE INDENT if c == 12 : NEW_LINE INDENT p -= 1 NEW_LINE dp = - 1 NEW_LINE if b [ p ] == 12 or b [ p ] == 14 : b . pop ( p + 1 ) NEW_LINE DEDENT elif c == 14 : NEW_LINE INDENT dp = 1 NEW_LINE if b [ p + 1 ] == 12 or b [ p + 1 ] == 14 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if c == 0 : NEW_LINE INDENT b . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT b [ p ] -= 1 NEW_LINE DEDENT p += dp NEW_LINE if c == 0 and dp == 1 : p -= 1 NEW_LINE ans [ c ] += 1 NEW_LINE DEDENT c = b [ p ] NEW_LINE DEDENT print ( * ans ) NEW_LINE DEDENT", "n , q = map ( int , input ( ) . split ( ) ) NEW_LINE S = list ( ' x ' + input ( ) + ' x ' ) NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s = S [ l - 1 : r + 2 ] NEW_LINE s [ 0 ] = s [ - 1 ] = ' x ' NEW_LINE c = [ 0 ] * 10 NEW_LINE dp , p = 1 , 1 NEW_LINE while s [ p ] != ' x ' : NEW_LINE INDENT if s [ p ] == ' > ' : NEW_LINE INDENT dp = 1 NEW_LINE if s [ p + 1 ] in \" > < \" : NEW_LINE INDENT s . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT elif s [ p ] == ' < ' : NEW_LINE INDENT dp = - 1 NEW_LINE p -= 1 NEW_LINE if s [ p ] in \" > < \" : s . pop ( p + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT d = ord ( s [ p ] ) - ord ( '0' ) NEW_LINE c [ d ] += 1 NEW_LINE if d == 0 : s . pop ( p ) NEW_LINE else : s [ p ] = chr ( d - 1 + ord ( '0' ) ) NEW_LINE p += dp NEW_LINE if d == 0 and dp == 1 : p -= 1 NEW_LINE DEDENT DEDENT print ( ' \u2581 ' . join ( map ( str , c ) ) ) NEW_LINE DEDENT", "n , q = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ - 1 ] + list ( map ( lambda x : ord ( x ) - ord ( '0' ) , input ( ) ) ) + [ - 1 ] NEW_LINE D = [ 12 , 14 ] NEW_LINE for _ in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE s = S [ l - 1 : r + 2 ] NEW_LINE s [ 0 ] = s [ - 1 ] = - 1 NEW_LINE c = [ 0 ] * 10 NEW_LINE dp , p = 1 , 1 NEW_LINE i = s [ p ] NEW_LINE while i != - 1 : NEW_LINE INDENT if i == 14 : NEW_LINE INDENT dp = 1 NEW_LINE if s [ p + 1 ] in D : NEW_LINE INDENT s . pop ( p ) NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE DEDENT DEDENT elif i == 12 : NEW_LINE INDENT dp = - 1 NEW_LINE p -= 1 NEW_LINE if s [ p ] in D : s . pop ( p + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] += 1 NEW_LINE if i == 0 : s . pop ( p ) NEW_LINE else : s [ p ] -= 1 NEW_LINE p += dp NEW_LINE if i == 0 and dp == 1 : p -= 1 NEW_LINE DEDENT i = s [ p ] NEW_LINE DEDENT print ( ' \u2581 ' . join ( map ( str , c ) ) ) NEW_LINE DEDENT", "def solve_task6 ( ) : NEW_LINE INDENT n , q = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE program = input ( ) NEW_LINE result = [ ] NEW_LINE for k in range ( q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE temp_program = list ( program [ l - 1 : r ] ) NEW_LINE cp = 0 NEW_LINE dp = 1 NEW_LINE temp_result = [ 0 for i in range ( 10 ) ] NEW_LINE flag = False NEW_LINE while 0 <= cp < len ( temp_program ) : NEW_LINE INDENT current_symbol = temp_program [ cp ] NEW_LINE if current_symbol . isdigit ( ) : NEW_LINE INDENT flag = False NEW_LINE if current_symbol == \"0\" : NEW_LINE INDENT temp_result [ 0 ] += 1 NEW_LINE temp_program . pop ( cp ) NEW_LINE if dp == 1 : NEW_LINE INDENT cp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp_result [ int ( temp_program [ cp ] ) ] += 1 NEW_LINE temp_program [ cp ] = str ( int ( current_symbol ) - 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if flag : NEW_LINE INDENT temp_program . pop ( cp - dp ) NEW_LINE if dp == 1 : NEW_LINE INDENT cp -= dp NEW_LINE DEDENT DEDENT if current_symbol == \" > \" : NEW_LINE INDENT dp = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp = - 1 NEW_LINE DEDENT flag = True NEW_LINE DEDENT cp += dp NEW_LINE DEDENT result . append ( temp_result ) NEW_LINE DEDENT return result NEW_LINE DEDENT result = solve_task6 ( ) NEW_LINE for line in result : NEW_LINE INDENT print ( \" \u2581 \" . join ( [ str ( el ) for el in line ] ) + \" \u2581 \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4514_A", "java": ["class GFG { static int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . print ( n ) ; } }"], "python": ["def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE"]}
{"id": "geeksforgeeks_3443_A", "java": ["class GFG { static class Data { double x , y ; public Data ( double x , double y ) { super ( ) ; this . x = x ; this . y = y ; } } ; static double inv_interpolate ( Data [ ] d , int n , double y ) { double x = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { double xi = d [ i ] . x ; for ( j = 0 ; j < n ; j ++ ) { if ( j != i ) { xi = xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ; } } x += xi ; } return x ; } public static void main ( String [ ] args ) { Data [ ] d = { new Data ( 1.27 , 2.3 ) , new Data ( 2.25 , 2.95 ) , new Data ( 2.5 , 3.5 ) , new Data ( 3.6 , 5.1 ) } ; int n = 4 ; double y = 4.5 ; System . out . printf ( \" Value \u2581 of \u2581 x \u2581 at \u2581 y \u2581 = \u2581 4.5 \u2581 : \u2581 % .5f \" , inv_interpolate ( d , n , y ) ) ; } }"], "python": ["class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT def inv_interpolate ( d : list , n : int , y : float ) -> float : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xi = d [ i ] . x NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT xi = ( xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ) NEW_LINE DEDENT DEDENT x += xi NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT d = [ Data ( 1.27 , 2.3 ) , Data ( 2.25 , 2.95 ) , Data ( 2.5 , 3.5 ) , Data ( 3.6 , 5.1 ) ] NEW_LINE n = 4 NEW_LINE y = 4.5 NEW_LINE print ( \" Value \u2581 of \u2581 x \u2581 at \u2581 y \u2581 = \u2581 4.5 \u2581 : \" , round ( inv_interpolate ( d , n , y ) , 5 ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_236_A", "java": ["class GFG { static int findElement ( int arr [ ] , int n ) { int prefixMul [ ] = new int [ n ] ; prefixMul [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixMul [ i ] = prefixMul [ i - 1 ] * arr [ i ] ; int suffixMul [ ] = new int [ n ] ; suffixMul [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( prefixMul [ i ] == suffixMul [ i ] ) return arr [ i ] ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 1 , 4 , 6 } ; int n = arr . length ; System . out . println ( findElement ( arr , n ) ) ; } }"], "python": ["def findElement ( arr , n ) : NEW_LINE INDENT prefixMul = [ ] NEW_LINE prefixMul . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefixMul . append ( prefixMul [ i - 1 ] * arr [ i ] ) NEW_LINE DEDENT suffixMul = [ None for i in range ( 0 , n ) ] NEW_LINE suffixMul [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixMul [ i ] = suffixMul [ i + 1 ] * arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if prefixMul [ i ] == suffixMul [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findElement ( arr , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_927_A", "java": ["import java . io . * ; class GFG { static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }"], "python": ["def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE"]}
{"id": "codeforces_1616_B", "java": ["import java . util . Scanner ; public class hw13 { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; { } { int t = scan . nextInt ( ) ; while ( t -- > 0 ) { int n = scan . nextInt ( ) ; String in = scan . next ( ) ; int letter = in . charAt ( 0 ) ; StringBuilder toPrint = new StringBuilder ( ) ; toPrint . append ( in . charAt ( 0 ) ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( letter > in . charAt ( i ) && i == 1 ) { letter = in . charAt ( i ) ; toPrint . append ( in . charAt ( i ) ) ; } else if ( letter >= in . charAt ( i ) && i > 1 ) { letter = in . charAt ( i ) ; toPrint . append ( in . charAt ( i ) ) ; } else { break ; } } StringBuilder rev = new StringBuilder ( toPrint . reverse ( ) ) ; toPrint . reverse ( ) ; toPrint . append ( rev ) ; System . out . println ( toPrint ) ; } } } }", "import java . util . Scanner ; public class cf1616B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int t = scan . nextInt ( ) ; while ( t -- > 0 ) { int n = scan . nextInt ( ) ; char [ ] charArr = scan . next ( ) . toCharArray ( ) ; if ( n > 1 && charArr [ 0 ] == charArr [ 1 ] ) { String ans = \" \" + charArr [ 0 ] + charArr [ 0 ] ; System . out . println ( ans ) ; } else { int dummy = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( charArr [ i ] <= charArr [ i - 1 ] ) { dummy = i ; } else { break ; } } StringBuilder out = new StringBuilder ( ) ; for ( int i = 0 ; i <= dummy ; i ++ ) { out . append ( charArr [ i ] ) ; } StringBuilder str1 = new StringBuilder ( out . reverse ( ) ) ; out . reverse ( ) . append ( str1 ) ; System . out . println ( out ) ; } } } }", "import java . util . Scanner ; public class cf1616B { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = scan . nextInt ( ) ; String str = scan . next ( ) ; StringBuilder str2 = new StringBuilder ( ) ; char min = ' z ' + 1 ; char prevMin = min ; for ( int y = 0 ; y < x ; y ++ ) { char c = str . charAt ( y ) ; if ( c < min ) { prevMin = min ; min = c ; str2 . append ( c ) ; } else if ( c == min ) { boolean found = false ; if ( prevMin > c && prevMin != ' z ' + 1 ) { str2 . append ( c ) ; found = true ; } if ( ! found ) { break ; } } else { break ; } } System . out . print ( str2 ) ; System . out . print ( str2 . reverse ( ) ) ; System . out . println ( \" \" ) ; } } }", "import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; int test = in . nextInt ( ) ; for ( int t = 1 ; t <= test ; t ++ ) { int n = in . nextInt ( ) ; String s = in . next ( ) ; char ch = s . charAt ( 0 ) ; int count = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) || s . charAt ( i ) == s . charAt ( i - 1 ) && i > 1 ) { count = i ; ch = s . charAt ( i ) ; } else { break ; } } for ( int i = 0 ; i <= count ; i ++ ) { pw . print ( s . charAt ( i ) ) ; } for ( int i = count ; i >= 0 ; i -- ) { pw . print ( s . charAt ( i ) ) ; } pw . println ( ) ; } pw . close ( ) ; } public static String rev ( String s ) { StringBuilder sb = new StringBuilder ( s ) ; sb = sb . reverse ( ) ; String r = sb . toString ( ) ; return r ; } static void debug ( Object ... obj ) { System . err . println ( Arrays . deepToString ( obj ) ) ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE p = input ( ) NEW_LINE i = 1 NEW_LINE while ( i < m and ( p [ i - 1 ] > p [ i ] or ( i > 1 and p [ i ] == p [ i - 1 ] ) ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT print ( p [ : i ] + p [ i - 1 : : - 1 ] ) NEW_LINE DEDENT", "testcases = int ( input ( ) ) NEW_LINE for i in range ( testcases ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE input_2 = input ( ) NEW_LINE word = [ * input_2 ] NEW_LINE mirror_list = list ( [ word [ 0 ] ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if word [ i ] < mirror_list [ - 1 ] : NEW_LINE INDENT mirror_list . append ( word [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( mirror_list ) == 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if word [ i ] == mirror_list [ - 1 ] and word [ i ] <= mirror_list [ - 2 ] : NEW_LINE INDENT mirror_list . append ( word [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT result = mirror_list + mirror_list [ : : - 1 ] NEW_LINE result_mirror = ' ' . join ( result ) NEW_LINE print ( result_mirror ) NEW_LINE DEDENT", "testcases = int ( input ( ) ) NEW_LINE for i in range ( testcases ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE input_2 = input ( ) NEW_LINE word = [ * input_2 ] NEW_LINE mirror_list = list ( [ word [ 0 ] ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if word [ i ] < mirror_list [ - 1 ] : NEW_LINE INDENT mirror_list . append ( word [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( mirror_list ) == 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT if word [ i ] == mirror_list [ - 1 ] : NEW_LINE INDENT mirror_list . append ( word [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT result = mirror_list + mirror_list [ : : - 1 ] NEW_LINE result_mirror = ' ' . join ( result ) NEW_LINE print ( result_mirror ) NEW_LINE DEDENT", "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE marker = - 1 NEW_LINE marker2 = False NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ord ( s [ i ] ) > ord ( s [ i - 1 ] ) : NEW_LINE INDENT marker = i NEW_LINE break NEW_LINE DEDENT elif ord ( s [ i ] ) < ord ( s [ i - 1 ] ) : NEW_LINE INDENT marker2 = True NEW_LINE DEDENT elif ord ( s [ i ] ) == ord ( s [ i - 1 ] ) and not marker2 : NEW_LINE INDENT marker = i NEW_LINE break NEW_LINE DEDENT DEDENT if marker == - 1 : NEW_LINE INDENT ans = s + s [ : : - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = s [ : marker ] NEW_LINE ans = ans + ans [ : : - 1 ] NEW_LINE print ( ans ) NEW_LINE DEDENT DEDENT", "for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = * map ( ord , s [ : - 1 ] ) , 123 ; i = 1 NEW_LINE while ( i > 1 ) + a [ i - 1 ] > a [ i ] : i += 1 NEW_LINE s = s [ : i ] ; print ( s + s [ : : - 1 ] ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_59_A", "java": ["import java . util . * ; class GFG { static final int MAX = 100005 ; static HashSet < Integer > fibonacci = new HashSet < Integer > ( ) ; static void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . add ( prev ) ; fibonacci . add ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . add ( temp ) ; prev = curr ; curr = temp ; } } static boolean checkArray ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . contains ( arr [ i ] ) ) sum += arr [ i ] ; if ( fibonacci . contains ( sum ) ) return true ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 2 } ; int n = arr . length ; createHash ( ) ; if ( checkArray ( arr , n ) ) System . out . print ( \" Yes \" ) ; else System . out . print ( \" No \" ) ; } }"], "python": ["MAX = 100005 NEW_LINE fibonacci = set ( ) NEW_LINE def createHash ( ) : NEW_LINE INDENT global fibonacci NEW_LINE prev , curr = 0 , 1 NEW_LINE fibonacci . add ( prev ) NEW_LINE fibonacci . add ( curr ) NEW_LINE while ( curr <= MAX ) : NEW_LINE INDENT temp = curr + prev NEW_LINE if temp <= MAX : NEW_LINE INDENT fibonacci . add ( temp ) NEW_LINE DEDENT prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in fibonacci ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT if ( sum in fibonacci ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE createHash ( ) NEW_LINE if ( checkArray ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_4887_A", "java": ["import java . util . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int solve ( int health [ ] , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } public static void main ( String args [ ] ) { int health [ ] = { 4 , 6 , 8 , 12 } ; int n = health . length ; System . out . println ( solve ( health , n ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT health = [ 4 , 6 , 8 , 12 ] NEW_LINE n = len ( health ) NEW_LINE print ( solve ( health , n ) ) NEW_LINE"]}
{"id": "geeksforgeeks_3529_A", "java": ["import java . io . * ; class GFG { static float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . pow ( r , 2 ) / 5 ) ; return a ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( squarearea ( r ) ) ; } }"], "python": ["def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r = 5 NEW_LINE print ( int ( squarearea ( r ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3093_A", "java": ["import java . util . * ; public class GFG { static class Graph { int V ; LinkedList < Integer > [ ] adj ; Graph ( int V ) { this . V = V ; adj = new LinkedList [ V ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new LinkedList < Integer > ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void DFSUtil ( int s , Vector < Boolean > visited ) { Stack < Integer > stack = new Stack < > ( ) ; stack . push ( s ) ; while ( stack . empty ( ) == false ) { s = stack . peek ( ) ; stack . pop ( ) ; if ( visited . get ( s ) == false ) { System . out . print ( s + \" \u2581 \" ) ; visited . set ( s , true ) ; } Iterator < Integer > itr = adj [ s ] . iterator ( ) ; while ( itr . hasNext ( ) ) { int v = itr . next ( ) ; if ( ! visited . get ( v ) ) stack . push ( v ) ; } } } void DFS ( ) { Vector < Boolean > visited = new Vector < Boolean > ( V ) ; for ( int i = 0 ; i < V ; i ++ ) visited . add ( false ) ; for ( int i = 0 ; i < V ; i ++ ) if ( ! visited . get ( i ) ) DFSUtil ( i , visited ) ; } } public static void main ( String [ ] args ) { Graph g = new Graph ( 5 ) ; g . addEdge ( 1 , 0 ) ; g . addEdge ( 2 , 1 ) ; g . addEdge ( 3 , 4 ) ; g . addEdge ( 4 , 0 ) ; System . out . println ( \" Following \u2581 is \u2581 Depth \u2581 First \u2581 Traversal \" ) ; g . DFS ( ) ; } }"], "python": ["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFSUtil ( self , s , visited ) : NEW_LINE INDENT stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) != 0 ) : NEW_LINE INDENT s = stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = \" \u2581 \" ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( self . adj [ s ] ) : NEW_LINE INDENT if ( not visited [ self . adj [ s ] [ i ] ] ) : NEW_LINE INDENT stack . append ( self . adj [ s ] [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT def DFS ( self ) : NEW_LINE INDENT visited = [ False ] * self . V NEW_LINE for i in range ( self . V ) : NEW_LINE INDENT if ( not visited [ i ] ) : NEW_LINE INDENT self . DFSUtil ( i , visited ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = Graph ( 5 ) NEW_LINE g . addEdge ( 1 , 0 ) NEW_LINE g . addEdge ( 2 , 1 ) NEW_LINE g . addEdge ( 3 , 4 ) NEW_LINE g . addEdge ( 4 , 0 ) NEW_LINE print ( \" Following \u2581 is \u2581 Depth \u2581 First \u2581 Traversal \" ) NEW_LINE g . DFS ( ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3092_A", "java": ["import java . util . * ; public class GFG { static class Graph { int V ; LinkedList < Integer > [ ] adj ; Graph ( int V ) { this . V = V ; adj = new LinkedList [ V ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new LinkedList < Integer > ( ) ; } void addEdge ( int v , int w ) { adj [ v ] . add ( w ) ; } void DFS ( int s ) { Vector < Boolean > visited = new Vector < Boolean > ( V ) ; for ( int i = 0 ; i < V ; i ++ ) visited . add ( false ) ; Stack < Integer > stack = new Stack < > ( ) ; stack . push ( s ) ; while ( stack . empty ( ) == false ) { s = stack . peek ( ) ; stack . pop ( ) ; if ( visited . get ( s ) == false ) { System . out . print ( s + \" \u2581 \" ) ; visited . set ( s , true ) ; } Iterator < Integer > itr = adj [ s ] . iterator ( ) ; while ( itr . hasNext ( ) ) { int v = itr . next ( ) ; if ( ! visited . get ( v ) ) stack . push ( v ) ; } } } } public static void main ( String [ ] args ) { Graph g = new Graph ( 5 ) ; g . addEdge ( 1 , 0 ) ; g . addEdge ( 0 , 2 ) ; g . addEdge ( 2 , 1 ) ; g . addEdge ( 0 , 3 ) ; g . addEdge ( 1 , 4 ) ; System . out . println ( \" Following \u2581 is \u2581 the \u2581 Depth \u2581 First \u2581 Traversal \" ) ; g . DFS ( 0 ) ; } }"], "python": ["class Graph : NEW_LINE INDENT def __init__ ( self , V ) : NEW_LINE INDENT self . V = V NEW_LINE self . adj = [ [ ] for i in range ( V ) ] NEW_LINE DEDENT def addEdge ( self , v , w ) : NEW_LINE INDENT self . adj [ v ] . append ( w ) NEW_LINE DEDENT def DFS ( self , s ) : NEW_LINE INDENT visited = [ False for i in range ( self . V ) ] NEW_LINE stack = [ ] NEW_LINE stack . append ( s ) NEW_LINE while ( len ( stack ) ) : NEW_LINE INDENT s = stack [ - 1 ] NEW_LINE stack . pop ( ) NEW_LINE if ( not visited [ s ] ) : NEW_LINE INDENT print ( s , end = ' \u2581 ' ) NEW_LINE visited [ s ] = True NEW_LINE DEDENT for node in self . adj [ s ] : NEW_LINE INDENT if ( not visited [ node ] ) : NEW_LINE INDENT stack . append ( node ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT g = Graph ( 5 ) ; NEW_LINE g . addEdge ( 1 , 0 ) ; NEW_LINE g . addEdge ( 0 , 2 ) ; NEW_LINE g . addEdge ( 2 , 1 ) ; NEW_LINE g . addEdge ( 0 , 3 ) ; NEW_LINE g . addEdge ( 1 , 4 ) ; NEW_LINE print ( \" Following \u2581 is \u2581 Depth \u2581 First \u2581 Traversal \" ) NEW_LINE g . DFS ( 0 ) NEW_LINE"]}
{"id": "atcoder_ARC059_B", "java": ["import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { new Main ( ) ; } FS in = new FS ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int len ; char [ ] str ; boolean found = false ; Main ( ) { len = ( str = in . next ( ) . toCharArray ( ) ) . length ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { out . printf ( \" % d \u2581 % d % n \" , i + 1 , i + 2 ) ; found = true ; break ; } if ( i < len - 2 && str [ i ] == str [ i + 2 ] ) { out . printf ( \" % d \u2581 % d % n \" , i + 1 , i + 3 ) ; found = true ; break ; } } if ( ! found ) out . printf ( \" % d \u2581 % d % n \" , - 1 , - 1 ) ; out . close ( ) ; } class FS { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }", "import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . awt . geom . Point2D . Double ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . PriorityQueue ; import java . util . Scanner ; import java . util . TreeSet ; import java . lang . Object ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { new D ( ) . doIt ( ) ; } class D { ArrayList < ArrayList < Integer > > array = new ArrayList < ArrayList < Integer > > ( ) ; void doIt ( ) { String str = sc . next ( ) ; int length = str . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { array . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < length ; i ++ ) { array . get ( str . charAt ( i ) - ' a ' ) . add ( i ) ; } int s = - 1 ; int g = - 1 ; for ( int c = 0 ; c < 26 ; c ++ ) { ArrayList < Integer > array2 = new ArrayList < Integer > ( ) ; array2 = array . get ( c ) ; int length2 = array2 . size ( ) ; if ( length2 > 1 ) { for ( int i = 1 ; i < length2 ; i ++ ) { if ( array2 . get ( i ) - array2 . get ( i - 1 ) <= 2 ) { s = array2 . get ( i - 1 ) + 1 ; g = array2 . get ( i ) + 1 ; } } } } System . out . println ( s + \" \u2581 \" + g ) ; } } }", "import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int ngs = s . length ( ) ; int [ ] [ ] unko = new int [ 26 ] [ ngs + 1 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j <= ngs ; j ++ ) { unko [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < ngs ; i ++ ) { unko [ s . charAt ( i ) - 97 ] [ i + 1 ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= ngs ; j ++ ) { unko [ i ] [ j ] = unko [ i ] [ j ] + unko [ i ] [ j - 1 ] ; } } int l = 0 ; int r = 0 ; int tmp = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j <= ngs - 2 ; j ++ ) { if ( unko [ i ] [ j + 2 ] - unko [ i ] [ j ] == 2 ) { System . out . println ( j + 1 + \" \u2581 \" + ( j + 2 ) ) ; System . exit ( 0 ) ; } } for ( int j = 0 ; j <= ngs - 3 ; j ++ ) { if ( unko [ i ] [ j + 3 ] - unko [ i ] [ j ] >= 2 ) { System . out . println ( j + 1 + \" \u2581 \" + ( j + 3 ) ) ; System . exit ( 0 ) ; } } } System . out . println ( - 1 + \" \u2581 \" + - 1 ) ; } }", "import java . util . * ; public class Main { public void main ( Scanner sc ) { char s [ ] = sc . next ( ) . toCharArray ( ) ; int len = s . length ; int a = - 1 ; int b = - 1 ; for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { a = i + 1 ; b = i + 2 ; break ; } if ( i + 2 < len && s [ i ] == s [ i + 2 ] ) { a = i + 1 ; b = i + 3 ; break ; } } System . out . println ( a + \" \u2581 \" + b ) ; } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; new Main ( ) . main ( sc ) ; sc . close ( ) ; } }", "import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { final Scanner scanner = new Scanner ( System . in ) ; solve ( scanner ) ; } static void solve ( Scanner scanner ) { String s = scanner . nextLine ( ) ; if ( s . charAt ( 0 ) == s . charAt ( 1 ) ) { System . out . printf ( \" % d \u2581 % d \\n \" , 1 , 2 ) ; return ; } for ( int i = 0 ; i < s . length ( ) - 2 ; i ++ ) { char c1 = s . charAt ( i ) ; char c2 = s . charAt ( i + 1 ) ; char c3 = s . charAt ( i + 2 ) ; if ( c1 == c2 || c1 == c3 || c2 == c3 ) { System . out . printf ( \" % d \u2581 % d \\n \" , i + 1 , i + 3 ) ; return ; } } System . out . printf ( \" % d \u2581 % d \\n \" , - 1 , - 1 ) ; } }"], "python": ["def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE if len ( s ) == 2 and s [ 0 ] == s [ 1 ] : NEW_LINE INDENT print ( 1 , 2 ) NEW_LINE return NEW_LINE DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] or s [ i + 1 ] == s [ i + 2 ] or s [ i ] == s [ i + 2 ] : NEW_LINE INDENT print ( i + 1 , i + 3 ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 , - 1 ) NEW_LINE return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from fractions import gcd NEW_LINE import math NEW_LINE from math import factorial as f NEW_LINE from math import ceil , floor , sqrt NEW_LINE from sys import exit NEW_LINE from copy import deepcopy NEW_LINE import numpy as np NEW_LINE import bisect NEW_LINE import re NEW_LINE import heapq NEW_LINE ii = lambda : int ( input ( ) ) NEW_LINE mi = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE li = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def main ( ) : NEW_LINE INDENT s = input ( ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT ans = str ( i + 1 ) + ' \u2581 ' + str ( i + 2 ) NEW_LINE print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT if s [ i ] == s [ i + 2 ] : NEW_LINE INDENT ans = str ( i + 1 ) + ' \u2581 ' + str ( i + 3 ) NEW_LINE print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if s [ n - 2 ] == s [ n - 1 ] : NEW_LINE INDENT ans = str ( n - 1 ) + ' \u2581 ' + str ( n ) NEW_LINE print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT print ( ' - 1 \u2581 - 1' ) NEW_LINE DEDENT main ( ) NEW_LINE", "from functools import reduce NEW_LINE import math NEW_LINE def main ( ) : NEW_LINE INDENT INF = float ( \" inf \" ) NEW_LINE s = list ( _ for _ in input ( ) ) NEW_LINE left = - 1 NEW_LINE right = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i + 1 ] == s [ i ] ) : NEW_LINE INDENT left = i + 1 NEW_LINE right = i + 2 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT left = i + 1 NEW_LINE right = i + 3 NEW_LINE break NEW_LINE DEDENT DEDENT print ( left , right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE readline = sys . stdin . readline NEW_LINE s = [ - 1 , - 2 ] + list ( map ( ord , readline ( ) . strip ( ) ) ) NEW_LINE N = len ( s ) NEW_LINE ans = ( - 1 , - 1 ) NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if s [ i ] == s [ i - 1 ] : NEW_LINE INDENT ans = ( i - 2 , i - 1 ) NEW_LINE break NEW_LINE DEDENT if s [ i ] == s [ i - 2 ] : NEW_LINE INDENT ans = ( i - 3 , i - 1 ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( * ans ) NEW_LINE", "s = input ( ) NEW_LINE t = s [ 1 : ] + \" \u2581 \" NEW_LINE r = s [ 2 : ] + \" \u2581 \u2581 \" NEW_LINE for n , ( i , j , k ) in enumerate ( zip ( s , t , r ) ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT print ( n + 1 , n + 2 ) NEW_LINE exit ( ) NEW_LINE DEDENT elif i == k : NEW_LINE INDENT print ( n + 1 , n + 3 ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( - 1 , - 1 ) NEW_LINE"]}
{"id": "geeksforgeeks_499_A", "java": ["class GFG { public static void sequence ( int n ) { int f [ ] = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; System . out . print ( f [ 1 ] + \" \u2581 \" + f [ 2 ] + \" \u2581 \" ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; System . out . print ( f [ i ] + \" \u2581 \" ) ; } } public static void main ( String [ ] args ) { int n = 13 ; sequence ( n ) ; } }"], "python": ["def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = \" \u2581 \" ) , NEW_LINE print ( f [ 2 ] , end = \" \u2581 \" ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = \" \u2581 \" ) , NEW_LINE DEDENT DEDENT n = 13 NEW_LINE sequence ( n ) NEW_LINE"]}
{"id": "codeforces_855_B", "java": ["import java . util . Scanner ; public class B855 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; long P = in . nextLong ( ) ; long Q = in . nextLong ( ) ; long R = in . nextLong ( ) ; long [ ] A = new long [ N ] ; for ( int n = 0 ; n < N ; n ++ ) { A [ n ] = in . nextInt ( ) ; } long [ ] maxP = new long [ N ] ; maxP [ 0 ] = P * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { maxP [ n ] = Math . max ( maxP [ n - 1 ] , P * A [ n ] ) ; } long [ ] maxQ = new long [ N ] ; maxQ [ 0 ] = maxP [ 0 ] + Q * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { maxQ [ n ] = Math . max ( maxQ [ n - 1 ] , Q * A [ n ] + maxP [ n ] ) ; } long answer = maxQ [ 0 ] + R * A [ 0 ] ; for ( int n = 1 ; n < N ; n ++ ) { answer = Math . max ( answer , R * A [ n ] + maxQ [ n ] ) ; } System . out . println ( answer ) ; } }"], "python": ["n , p , q , r = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE l = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE prefixMax = list ( ) NEW_LINE pM = l [ 0 ] * p NEW_LINE for i in l : NEW_LINE INDENT if ( i * p > pM ) : NEW_LINE INDENT pM = i * p NEW_LINE DEDENT prefixMax . append ( pM ) NEW_LINE DEDENT suffixMax = list ( ) NEW_LINE sM = l [ n - 1 ] * r NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l [ j ] * r > sM ) : NEW_LINE INDENT sM = l [ j ] * r NEW_LINE DEDENT suffixMax . append ( sM ) NEW_LINE DEDENT suffixMax = suffixMax [ : : - 1 ] NEW_LINE mM = l [ 0 ] * q NEW_LINE maxValue = - 2 ** 64 + 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = prefixMax [ i ] + l [ i ] * q + suffixMax [ i ] NEW_LINE if ( sum > maxValue ) : NEW_LINE INDENT maxValue = sum NEW_LINE DEDENT DEDENT print ( maxValue ) NEW_LINE", "import sys NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( \" \\n \" ) NEW_LINE n , p , q , r = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE first = second = ans = int ( - 5e18 ) NEW_LINE for i in a : NEW_LINE INDENT if first < p * i : NEW_LINE INDENT first = p * i NEW_LINE DEDENT if second < first + q * i : NEW_LINE INDENT second = first + q * i NEW_LINE DEDENT if ans < second + r * i : NEW_LINE INDENT ans = second + r * i NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "n , p , q , r = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ar = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE preMax = [ 0 ] * n NEW_LINE sufMax = [ 0 ] * n NEW_LINE preMax [ 0 ] = p * ar [ 0 ] NEW_LINE sufMax [ n - 1 ] = r * ar [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if preMax [ i - 1 ] > ( ar [ i ] * p ) : NEW_LINE INDENT preMax [ i ] = preMax [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT preMax [ i ] = ar [ i ] * p NEW_LINE DEDENT if ar [ n - i - 1 ] * r > sufMax [ n - i ] : NEW_LINE INDENT sufMax [ n - i - 1 ] = ar [ n - i - 1 ] * r NEW_LINE DEDENT else : NEW_LINE INDENT sufMax [ n - i - 1 ] = sufMax [ n - i ] NEW_LINE DEDENT DEDENT ans = ar [ 0 ] * q + preMax [ 0 ] + sufMax [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ar [ i ] * q + preMax [ i ] + sufMax [ i ] > ans : NEW_LINE INDENT ans = ar [ i ] * q + preMax [ i ] + sufMax [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "def P_Max ( arr , p ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr = [ x * p for x in arr ] NEW_LINE PMax = n * [ 0 ] NEW_LINE PMax [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > PMax [ i - 1 ] : NEW_LINE INDENT PMax [ i ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT PMax [ i ] = PMax [ i - 1 ] NEW_LINE DEDENT DEDENT return PMax NEW_LINE DEDENT def S_Max ( arr , r ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr = [ x * r for x in arr ] NEW_LINE SMax = n * [ 0 ] NEW_LINE SMax [ n - 1 ] = arr [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if arr [ i ] > SMax [ i + 1 ] : NEW_LINE INDENT SMax [ i ] = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SMax [ i ] = SMax [ i + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return SMax NEW_LINE DEDENT def potion ( arr , n , p , q , r ) : NEW_LINE INDENT max_val = float ( ' - inf ' ) NEW_LINE PMax = P_Max ( arr , p ) NEW_LINE SMax = S_Max ( arr , r ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , ( PMax [ i ] + q * arr [ i ] + SMax [ i ] ) ) NEW_LINE DEDENT return max_val NEW_LINE DEDENT [ n , p , q , r ] = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE arr = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE val = potion ( arr , n , p , q , r ) NEW_LINE print ( val ) NEW_LINE", "n , p , q , r = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dp0 = [ - 1e15 for i in range ( n ) ] NEW_LINE dp1 = [ - 1e15 for i in range ( n ) ] NEW_LINE dp2 = [ - 1e15 for i in range ( n ) ] NEW_LINE dp0 [ 0 ] = a [ 0 ] * p NEW_LINE dp1 [ 0 ] = a [ 0 ] * p + a [ 0 ] * q NEW_LINE dp2 [ 0 ] = a [ 0 ] * p + a [ 0 ] * q + a [ 0 ] * r NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp0 [ i ] = max ( dp0 [ i - 1 ] , a [ i ] * p ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT dp1 [ i ] = max ( dp1 [ i - 1 ] , dp0 [ i ] + a [ i ] * q ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT dp2 [ i ] = max ( dp2 [ i - 1 ] , dp1 [ i ] + a [ i ] * r ) NEW_LINE DEDENT print ( dp2 [ n - 1 ] ) NEW_LINE"]}
{"id": "projecteuler_p063_A", "java": ["import java . math . BigInteger ; public final class p063 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p063 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int n = 1 ; n <= 9 ; n ++ ) { for ( int k = 1 ; k <= 21 ; k ++ ) { if ( BigInteger . valueOf ( n ) . pow ( k ) . toString ( ) . length ( ) == k ) count ++ ; } } return Integer . toString ( count ) ; } }"], "python": ["def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3420_A", "java": ["import java . io . * ; class GFG { public static void main ( String [ ] args ) { double n = 12 ; System . out . println ( Math . sqrt ( n ) ) ; } }"], "python": ["import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4410_A", "java": ["import java . io . * ; class GFG { static double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( findSum ( n ) ) ; } }"], "python": ["import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2583_A", "java": ["import java . lang . Math ; class GFG { public static int findNth ( int n ) { int nthElement = 19 + ( n - 1 ) * 9 ; int outliersCount = ( int ) Math . log10 ( nthElement ) - 1 ; nthElement += 9 * outliersCount ; return nthElement ; } public static void main ( String [ ] args ) { System . out . println ( findNth ( 5 ) ) ; } }"], "python": ["import math NEW_LINE def findNth ( n ) : NEW_LINE INDENT nthElement = 19 + ( n - 1 ) * 9 NEW_LINE outliersCount = int ( math . log10 ( nthElement ) ) - 1 NEW_LINE nthElement += 9 * outliersCount NEW_LINE return nthElement NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( findNth ( 5 ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4482_A", "java": ["import java . lang . * ; class GFG { public static double per ( double a , double b ) { return ( a + b ) ; } public static double area ( double s ) { return ( s / 2 ) ; } public static void main ( String [ ] args ) { double a = 7 , b = 8 , s = 10 ; System . out . println ( per ( a , b ) ) ; System . out . println ( area ( s ) ) ; } }"], "python": ["def per ( a , b ) : NEW_LINE INDENT return ( a + b ) NEW_LINE DEDENT def area ( s ) : NEW_LINE INDENT return ( s / 2 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 8 NEW_LINE s = 10 NEW_LINE print ( per ( a , b ) ) NEW_LINE print ( area ( s ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2730_A", "java": ["import java . util . * ; class Solution { static boolean isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } static void formBinaryStr ( int n , int a [ ] ) { boolean flag = true ; String s = \" \" ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += \" \" + a [ i ] ; else { flag = false ; break ; } } if ( flag ) System . out . print ( s + \" \\n \" ) ; else System . out . print ( \" - 1 \\n \" ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = a . length ; formBinaryStr ( N , a ) ; } }"], "python": ["def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = \" \" NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout << \" - 1 \\n \" NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1788_A", "java": ["import java . util . Arrays ; import java . util . Collections ; import java . util . List ; class GFG { static int getMax ( int [ ] A ) { int max = Integer . MIN_VALUE ; for ( int i : A ) { max = Math . max ( max , i ) ; } return max ; } static int calculateAND ( int arr [ ] , int n ) { int max_val = getMax ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; int i ; for ( i = 0 ; i < max_val + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return ( S1 & S2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 6 , 7 } ; int n = arr . length ; System . out . println ( calculateAND ( arr , n ) ) ; } }"], "python": ["def calculateAND ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , max_val + 1 ) : NEW_LINE INDENT if p * p >= max_val : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] != 1 ) : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return ( S1 & S2 ) NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateAND ( arr , n ) ) NEW_LINE"]}
{"id": "aizu_p01622_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; int suma = 0 ; int sumb = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; b [ i ] = sc . nextInt ( ) ; suma += a [ i ] ; sumb += b [ i ] ; } Arrays . sort ( a ) ; Arrays . sort ( b ) ; int W = 0 ; if ( suma - a [ n - 1 ] < a [ n - 1 ] ) W = a [ n - 1 ] - ( suma - a [ n - 1 ] ) ; if ( W == 0 ) { System . out . println ( suma + sumb ) ; } else { int [ ] [ ] dp = new int [ n ] [ W + 1 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j <= W ; j ++ ) { if ( j < b [ i ] ) dp [ i + 1 ] [ j ] = dp [ i ] [ j ] ; else dp [ i + 1 ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ j - b [ i ] ] + b [ i ] ) ; } } System . out . println ( 2 * a [ n - 1 ] + ( sumb - dp [ n - 1 ] [ W ] ) ) ; } } } }", "import java . util . * ; import java . io . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import static java . lang . Math . * ; public class Main { int INF = 1 << 28 ; double EPS = 1e-10 ; void run ( ) { Scanner sc = new Scanner ( System . in ) ; for ( ; ; ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int [ ] r = new int [ n ] , w = new int [ n ] ; int max = 0 , p = 0 , sumr = 0 , sumw = 0 ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = sc . nextInt ( ) ; w [ i ] = sc . nextInt ( ) ; if ( r [ i ] > max ) { max = r [ i ] ; p = i ; } sumr += r [ i ] ; sumw += w [ i ] ; } if ( sumr - max >= max ) { System . out . println ( ( sumr + sumw ) ) ; } else { boolean [ ] dp = new boolean [ 2 * max - sumr + 1 ] ; dp [ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) if ( i != p ) for ( int j = 2 * max - sumr ; j >= w [ i ] ; j -- ) dp [ j ] |= dp [ j - w [ i ] ] ; for ( p = 2 * max - sumr ; ! dp [ p ] ; p -- ) ; System . out . println ( ( 2 * max + sumw - p ) ) ; } } } void debug ( Object ... os ) { System . err . println ( Arrays . deepToString ( os ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { int n = sc . nextInt ( ) ; if ( n == 0 ) break ; int r [ ] = new int [ n ] ; int w [ ] = new int [ n ] ; int sumr = 0 , sumw = 0 , rmax = 0 , maxindex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = sc . nextInt ( ) ; w [ i ] = sc . nextInt ( ) ; sumr += r [ i ] ; sumw += w [ i ] ; if ( rmax < r [ i ] ) { rmax = r [ i ] ; maxindex = i ; } } if ( rmax <= ( sumr - rmax ) ) { System . out . println ( sumr + sumw ) ; } else { boolean dp [ ] [ ] = new boolean [ n + 1 ] [ sumw + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { Arrays . fill ( dp [ i ] , false ) ; } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= sumw ; j ++ ) { if ( dp [ i ] [ j ] ) { dp [ i + 1 ] [ j ] = true ; if ( i != maxindex ) dp [ i + 1 ] [ j + w [ i ] ] = true ; } } } int max = 0 ; int wait = rmax - ( sumr - rmax ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sumw ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j <= wait && max < j ) { max = j ; } } } } System . out . println ( 2 * rmax + ( sumw - max ) ) ; } } } }", "import java . util . Arrays ; import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { while ( true ) { int N = sc . nextInt ( ) ; if ( N == 0 ) break ; Book [ ] books = new Book [ N ] ; for ( int i = 0 ; i < N ; ++ i ) { int r = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; books [ i ] = new Book ( r , w ) ; } Arrays . sort ( books ) ; int sumR = 0 ; int sumW = 0 ; for ( int i = 0 ; i < N ; ++ i ) { sumR += books [ i ] . r ; sumW += books [ i ] . w ; } int maxR = books [ N - 1 ] . r ; if ( sumR - maxR < maxR ) { int early = early ( books , maxR - ( sumR - maxR ) ) ; System . out . println ( Math . max ( sumR + sumW , maxR * 2 + sumW - early ) ) ; } else { System . out . println ( sumR + sumW ) ; } } } static int early ( Book [ ] books , int time ) { boolean [ ] ok = new boolean [ time + 1 ] ; ok [ 0 ] = true ; for ( int i = 0 ; i < books . length - 1 ; ++ i ) { int w = books [ i ] . w ; for ( int j = time ; j - w >= 0 ; -- j ) { if ( ok [ j - w ] ) ok [ j ] = true ; } } for ( int i = time ; i >= 0 ; -- i ) { if ( ok [ i ] ) return i ; } return 0 ; } static class Book implements Comparable < Book > { int r , w ; public Book ( int r , int w ) { this . r = r ; this . w = w ; } public int compareTo ( Book o ) { return this . r - o . r ; } } }"], "python": ["while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT books = [ ] NEW_LINE read_t = 0 NEW_LINE write_t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r , w = map ( int , input ( ) . split ( ) ) NEW_LINE read_t += r NEW_LINE write_t += w NEW_LINE books . append ( ( r , w ) ) NEW_LINE DEDENT books = sorted ( books ) NEW_LINE if books [ - 1 ] [ 0 ] <= read_t // 2 : NEW_LINE INDENT print ( read_t + write_t ) NEW_LINE continue NEW_LINE DEDENT sukima = books [ - 1 ] [ 0 ] - ( read_t - books [ - 1 ] [ 0 ] ) NEW_LINE dp = [ [ 0 for i in range ( sukima + 1 ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , sukima + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - books [ i - 1 ] [ 1 ] ] + books [ i - 1 ] [ 1 ] if j - books [ i - 1 ] [ 1 ] >= 0 else 0 ) NEW_LINE DEDENT DEDENT print ( read_t + write_t + sukima - dp [ - 1 ] [ - 1 ] ) NEW_LINE DEDENT", "import sys NEW_LINE sys . setrecursionlimit ( 10000000 ) NEW_LINE input = lambda : sys . stdin . readline ( ) . rstrip ( ) NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT books = [ ] NEW_LINE read_t = 0 NEW_LINE write_t = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT r , w = map ( int , input ( ) . split ( ) ) NEW_LINE read_t += r NEW_LINE write_t += w NEW_LINE books . append ( ( r , w ) ) NEW_LINE DEDENT books = sorted ( books ) NEW_LINE if books [ - 1 ] [ 0 ] <= read_t // 2 : NEW_LINE INDENT print ( read_t + write_t ) NEW_LINE continue NEW_LINE DEDENT sukima = books [ - 1 ] [ 0 ] - ( read_t - books [ - 1 ] [ 0 ] ) NEW_LINE dp = [ [ 0 for i in range ( sukima + 1 ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , sukima + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - books [ i - 1 ] [ 1 ] ] + books [ i - 1 ] [ 1 ] if j - books [ i - 1 ] [ 1 ] >= 0 else 0 ) NEW_LINE DEDENT DEDENT print ( read_t + write_t + sukima - dp [ - 1 ] [ - 1 ] ) NEW_LINE DEDENT", "from __future__ import division , print_function NEW_LINE try : NEW_LINE INDENT input = raw_input NEW_LINE DEDENT except NameError : NEW_LINE INDENT pass NEW_LINE DEDENT from datetime import datetime NEW_LINE import math NEW_LINE MAXW = 1001 NEW_LINE def solve ( n , read , write ) : NEW_LINE INDENT sumR = sum ( read ) NEW_LINE sumW = sum ( write ) NEW_LINE next = [ ] NEW_LINE base = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if read [ i ] < sumR // 2 : NEW_LINE INDENT next . append ( ( read [ i ] , write [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT base = read [ i ] NEW_LINE DEDENT DEDENT if ( len ( next ) == n ) : NEW_LINE INDENT print ( sumR + sumW ) NEW_LINE return NEW_LINE DEDENT dp = [ False ] * MAXW NEW_LINE dp [ 0 ] = True NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT tmp = dp [ : ] NEW_LINE for j in range ( base + 1 ) : NEW_LINE INDENT if dp [ j ] : NEW_LINE INDENT na = j + next [ i ] [ 0 ] NEW_LINE nb = j + next [ i ] [ 0 ] + next [ i ] [ 1 ] NEW_LINE if na <= base : NEW_LINE INDENT tmp [ na ] = True NEW_LINE DEDENT if nb <= base : NEW_LINE INDENT tmp [ nb ] = True NEW_LINE DEDENT DEDENT DEDENT dp = tmp NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( base + 1 ) : NEW_LINE INDENT if dp [ i ] : NEW_LINE INDENT res = base - i NEW_LINE DEDENT DEDENT print ( sumR + sumW + res ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : return NEW_LINE read = [ ] NEW_LINE write = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT r , w = map ( int , input ( ) . split ( ) ) NEW_LINE read . append ( r ) NEW_LINE write . append ( w ) NEW_LINE DEDENT solve ( n , read , write ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE", "import operator NEW_LINE import sys NEW_LINE def solve ( ) : NEW_LINE INDENT readline = sys . stdin . readline NEW_LINE write = sys . stdout . write NEW_LINE N = int ( readline ( ) ) NEW_LINE if N == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT P = [ list ( map ( int , readline ( ) . split ( ) ) ) for i in range ( N ) ] NEW_LINE P . sort ( key = operator . itemgetter ( 0 ) ) NEW_LINE RS = sum ( r for r , w in P ) NEW_LINE WS = sum ( w for r , w in P ) NEW_LINE if all ( 2 * r <= RS for r , w in P ) : NEW_LINE INDENT write ( \" % d \\n \" % ( RS + WS ) ) NEW_LINE return True NEW_LINE DEDENT rl , sl = P [ - 1 ] NEW_LINE W = 2 * rl - RS NEW_LINE dp = [ 0 ] * ( W + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE for r , w in P [ : - 1 ] : NEW_LINE INDENT for j in range ( W , w - 1 , - 1 ) : NEW_LINE INDENT dp [ j ] |= dp [ j - w ] NEW_LINE DEDENT DEDENT ma = max ( j for j in range ( W + 1 ) if dp [ j ] ) NEW_LINE write ( \" % d \\n \" % ( RS + WS + ( W - ma ) ) ) NEW_LINE return True NEW_LINE DEDENT while solve ( ) : NEW_LINE INDENT ... NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4095_A", "java": ["public class GFG { static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } public static void main ( String [ ] args ) { String str = \" ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) \" ; System . out . println ( findIndex ( str ) ) ; } }"], "python": ["def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = \" ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) \" NEW_LINE print ( findIndex ( str ) ) NEW_LINE"]}
{"id": "geeksforgeeks_2102_A", "java": ["class Test { static int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; } static int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } public static void main ( String args [ ] ) { int N = 13 ; int diff = 2 ; System . out . println ( totalNumbersWithSpecificDifference ( N , diff ) ) ; } }"], "python": ["def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K ) : NEW_LINE INDENT sod = sod + K % 10 NEW_LINE K = K // 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT N = 13 NEW_LINE diff = 2 NEW_LINE print ( totalNumbersWithSpecificDifference ( N , diff ) ) NEW_LINE"]}
{"id": "geeksforgeeks_241_A", "java": ["class GFG { static int numOfsubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int product = arr [ i ] ; int sum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( product == sum ) count ++ ; product *= arr [ j ] ; sum += arr [ j ] ; } if ( product == sum ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 } ; int n = arr . length ; System . out . println ( numOfsubarrays ( arr , n ) ) ; } }"], "python": ["def numOfsubarrays ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = arr [ i ] NEW_LINE sum = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT product *= arr [ j ] NEW_LINE sum += arr [ j ] NEW_LINE DEDENT if ( product == sum ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( numOfsubarrays ( arr , n ) ) NEW_LINE"]}
{"id": "atcoder_ABC148_D", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s . nextInt ( ) ; } int count = 0 ; int num = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == num ) { count ++ ; num ++ ; } } if ( count == 0 ) { count = - 1 ; } else { count = n - count ; } System . out . println ( count ) ; s . close ( ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Solver solver = new Solver ( ) ; solver . init ( ) ; solver . readHead ( in . readLine ( ) ) ; solver . readA ( in . readLine ( ) ) ; } } class Solver { int N ; int cnt ; public void init ( ) { N = 0 ; cnt = 0 ; } public void readHead ( String str ) { String [ ] strArr = str . split ( \" \\\\ s + \" ) ; N = Integer . parseInt ( strArr [ 0 ] ) ; } public void readA ( String str ) { String [ ] strArr = str . split ( \" \\\\ s + \" ) ; boolean ok = false ; int n = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int a = Integer . parseInt ( strArr [ i ] ) ; if ( a == n ) { ok = true ; n ++ ; } } if ( ok ) System . out . println ( N - n + 1 ) ; else System . out . println ( - 1 ) ; } public boolean hasNext ( ) { return cnt < N ; } public void readBody ( String str ) { cnt ++ ; } public void solve ( ) { } }", "import java . util . ArrayList ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . next ( ) ) ; List < Integer > a = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a . add ( Integer . parseInt ( sc . next ( ) ) ) ; } Iterator < Integer > it = a . iterator ( ) ; int total = 0 ; int index = 1 ; while ( it . hasNext ( ) ) { int i = it . next ( ) ; if ( i == index ) { index ++ ; } else { total ++ ; } } if ( total == n ) { System . out . println ( - 1 ) ; } else { System . out . println ( total ) ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] bricknumber = new int [ N ] ; int [ ] index = new int [ N + 2 ] ; int [ ] check = new int [ N + 2 ] ; int last = N ; for ( int h = 0 ; h < N ; h ++ ) { bricknumber [ h ] = sc . nextInt ( ) ; } check [ 1 ] = 0 ; for ( int k = 0 ; k <= N ; k ++ ) { index [ k ] = - 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = check [ i ] ; j < N ; j ++ ) { if ( bricknumber [ j ] == i ) { index [ i ] = j ; check [ i + 1 ] = j ; break ; } } if ( index [ i ] == - 1 ) { last = i - 1 ; break ; } } if ( last == 0 ) { last = N + 1 ; } System . out . println ( N - last ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String [ ] tmpArray = br . readLine ( ) . split ( \" \u2581 \" ) ; int input [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { input [ i ] = Integer . parseInt ( tmpArray [ i ] ) ; } int target = 1 ; int length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == target ) { target ++ ; length ++ ; } } System . out . println ( length > 0 ? n - length : - 1 ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE i = 0 NEW_LINE while i + 1 <= len ( a ) : NEW_LINE INDENT if a [ i ] != i + 1 : NEW_LINE INDENT if i + 1 in a : NEW_LINE INDENT del a [ i : a . index ( i + 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT del a [ i : ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT if len ( a ) == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - len ( a ) ) NEW_LINE DEDENT", "N = int ( input ( ) ) NEW_LINE a = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( a ) NEW_LINE count = 1 NEW_LINE ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT if a [ i ] == count : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( \" - 1\" if ans == N else ans ) NEW_LINE", "l = [ 0 ] * 200005 NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if l [ a [ i ] - 1 ] == 1 : NEW_LINE INDENT l [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT res = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res -= l [ i ] NEW_LINE DEDENT if res == n : NEW_LINE INDENT res = - 1 NEW_LINE DEDENT print ( res ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE c = 1 NEW_LINE i = 0 NEW_LINE while i != n : NEW_LINE INDENT if a [ i ] == c : NEW_LINE INDENT c += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if c == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n - c + 1 ) NEW_LINE DEDENT", "N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) NEW_LINE cnt = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if cnt + 1 == A [ i ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if ans == N : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT"]}
{"id": "aizu_p02032_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; TreeSet < Long > nums = new TreeSet < > ( ) ; for ( long i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nums . add ( - i ) ; nums . add ( - n / i ) ; } } int max = nums . size ( ) + 1 ; int min = 0 ; HashSet < Long > used = new HashSet < > ( ) ; for ( long x : nums ) { if ( used . contains ( - x ) ) { continue ; } min ++ ; for ( long i = 2 ; i <= Math . sqrt ( - x ) ; i ++ ) { if ( - x % i == 0 ) { used . add ( i ) ; used . add ( - x / i ) ; } } } if ( min == 0 ) { min ++ ; } System . out . println ( min + \" \u2581 \" + max ) ; } }"], "python": ["import sys NEW_LINE sys . setrecursionlimit ( 10 ** 5 + 10 ) NEW_LINE def input ( ) : return sys . stdin . readline ( ) . strip ( ) NEW_LINE def resolve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE import math NEW_LINE def make_prime_list_2 ( num ) : NEW_LINE INDENT if num < 2 : NEW_LINE INDENT return [ ] NEW_LINE DEDENT prime_list = [ i for i in range ( num + 1 ) ] NEW_LINE prime_list [ 1 ] = 0 NEW_LINE num_sqrt = math . sqrt ( num ) NEW_LINE for prime in prime_list : NEW_LINE INDENT if prime == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if prime > num_sqrt : NEW_LINE INDENT break NEW_LINE DEDENT for non_prime in range ( 2 * prime , num , prime ) : NEW_LINE INDENT prime_list [ non_prime ] = 0 NEW_LINE DEDENT DEDENT return [ prime for prime in prime_list if prime != 0 ] NEW_LINE DEDENT def prime_factorization_2 ( num ) : NEW_LINE INDENT if num <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT num_sqrt = math . floor ( math . sqrt ( num ) ) NEW_LINE prime_list = make_prime_list_2 ( num_sqrt ) NEW_LINE dict_counter = { } NEW_LINE for prime in prime_list : NEW_LINE INDENT while num % prime == 0 : NEW_LINE INDENT if prime in dict_counter : NEW_LINE INDENT dict_counter [ prime ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict_counter [ prime ] = 1 NEW_LINE DEDENT num //= prime NEW_LINE DEDENT DEDENT if num != 1 : NEW_LINE INDENT if num in dict_counter : NEW_LINE INDENT dict_counter [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dict_counter [ num ] = 1 NEW_LINE DEDENT DEDENT return dict_counter NEW_LINE DEDENT DEDENT d = prime_factorization_2 ( n ) NEW_LINE val = 1 NEW_LINE for v in d . values ( ) : NEW_LINE INDENT val *= ( v + 1 ) NEW_LINE DEDENT print ( len ( d ) , val - 1 ) NEW_LINE DEDENT resolve ( ) NEW_LINE", "import math NEW_LINE n = int ( input ( ) ) NEW_LINE p = list ( ) NEW_LINE m = int ( math . sqrt ( n ) + 1 ) NEW_LINE for i in range ( 2 , m ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT c = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT c += 1 NEW_LINE n //= i NEW_LINE DEDENT p . append ( c ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT p . append ( 1 ) NEW_LINE DEDENT maxi = 1 NEW_LINE for x in p : NEW_LINE INDENT maxi *= ( x + 1 ) NEW_LINE DEDENT print ( len ( p ) , maxi - 1 ) NEW_LINE", "import copy NEW_LINE def make_divisors ( n ) : NEW_LINE INDENT divisors = [ ] NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT divisors . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT divisors . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT divisors . sort ( ) NEW_LINE return divisors NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE yakusu = make_divisors ( N ) NEW_LINE max_times = len ( yakusu ) - 1 NEW_LINE min_times = 0 NEW_LINE result = [ ] NEW_LINE for i in reversed ( yakusu [ : - 1 ] ) : NEW_LINE INDENT if i in result : NEW_LINE INDENT continue NEW_LINE DEDENT result . extend ( make_divisors ( i ) ) NEW_LINE min_times += 1 NEW_LINE DEDENT print ( min_times , max_times ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import sys NEW_LINE sys . setrecursionlimit ( int ( 1e7 ) ) NEW_LINE from collections import deque NEW_LINE def inpl ( ) : return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE def primes ( N ) : NEW_LINE INDENT sieve = [ 1 ] * ( N + 1 ) NEW_LINE sieve [ 0 ] , sieve [ 1 ] = 0 , 0 NEW_LINE P = [ ] NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if sieve [ i ] : NEW_LINE INDENT P . append ( i ) NEW_LINE for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return P NEW_LINE DEDENT N = int ( input ( ) ) NEW_LINE P = primes ( 10 ** 6 + 10 ) NEW_LINE factors = [ 0 ] * len ( P ) NEW_LINE for i in range ( len ( P ) ) : NEW_LINE INDENT p = P [ i ] NEW_LINE while N % p == 0 : NEW_LINE INDENT factors [ i ] += 1 NEW_LINE N = N // p NEW_LINE DEDENT DEDENT factors += [ N != 1 ] NEW_LINE a = sum ( [ f > 0 for f in factors ] ) NEW_LINE b = 1 NEW_LINE for i in range ( len ( P ) + 1 ) : NEW_LINE INDENT b *= factors [ i ] + 1 NEW_LINE DEDENT b -= 1 NEW_LINE print ( a , b ) NEW_LINE"]}
{"id": "codeforces_1065_B", "java": ["import java . io . * ; import java . util . * ; import java . lang . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long m = sc . nextLong ( ) ; long min = Math . max ( 0 , n - 2 * m ) ; long vertex = 1 ; long rem = m ; while ( rem > 0 ) { long d = Math . min ( vertex , rem ) ; vertex ++ ; rem -= d ; } long max = n - ( vertex == 1 ? 0 : vertex ) ; System . out . println ( min + \" \u2581 \" + max ) ; sc . close ( ) ; writer . flush ( ) ; writer . close ( ) ; reader . close ( ) ; } }", "import java . util . * ; public class practice { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { long a = sc . nextLong ( ) , b = sc . nextLong ( ) ; long min = Math . max ( a - 2 * b , 0 ) ; long check = 0 ; while ( check * ( check - 1 ) / 2 < b ) { check ++ ; } long max = a - check ; System . out . println ( min + \" \u2581 \" + max ) ; } } }", "import java . util . * ; import java . io . * ; public class Solution { private static final FastReader fr = new FastReader ( ) ; public static void main ( String [ ] args ) throws IOException { BufferedWriter output = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = fr . nextInt ( ) ; long m = fr . nextLong ( ) ; long lo = 1 , hi = 100001 ; long min = Math . max ( 0 , n - 2 * m ) ; while ( lo <= hi ) { long mid = ( lo + hi ) / 2 ; if ( mid * ( mid - 1 ) / 2 == m ) { lo = mid ; break ; } if ( mid * ( mid - 1 ) / 2 > m ) hi = mid - 1 ; else lo = mid + 1 ; } long max = n - lo ; if ( m == 0 ) { min = n ; max = n ; } sb . append ( min ) . append ( \" \u2581 \" ) . append ( max ) ; output . write ( sb . toString ( ) ) ; output . flush ( ) ; } } class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( \" \\n \" ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } }"], "python": ["def line2int ( linea ) : NEW_LINE INDENT temp = \" \" NEW_LINE for i in linea : NEW_LINE INDENT if i == \" \u2581 \" : NEW_LINE INDENT if temp != \" \" : NEW_LINE INDENT val1 = int ( temp ) NEW_LINE temp = \" \" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT temp = temp + i NEW_LINE DEDENT DEDENT val2 = int ( temp ) NEW_LINE return ( val1 , val2 ) NEW_LINE DEDENT ( n , m ) = line2int ( input ( ) ) NEW_LINE if m == 0 : NEW_LINE INDENT minN = maxN = n NEW_LINE DEDENT else : NEW_LINE INDENT minN = n - m * 2 NEW_LINE if minN < 0 : minN = 0 NEW_LINE i = 1 NEW_LINE while m > 0 : NEW_LINE INDENT m = m - i NEW_LINE i = i + 1 NEW_LINE DEDENT maxN = n - i NEW_LINE DEDENT print ( minN , maxN ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n > m * 2 : NEW_LINE INDENT mi = n - m * 2 NEW_LINE DEDENT else : mi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT comEdge = i * ( i - 1 ) / 2 NEW_LINE ma = 0 NEW_LINE if comEdge >= m : NEW_LINE INDENT ma = abs ( n - ( i ) ) NEW_LINE break NEW_LINE DEDENT DEDENT print ( mi , ma ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = 0 NEW_LINE r = n NEW_LINE while l < r : NEW_LINE INDENT med = ( l + r ) // 2 NEW_LINE if med * ( med - 1 ) // 2 < m : NEW_LINE INDENT l = med + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = med NEW_LINE DEDENT DEDENT print ( max ( 0 , n - 2 * m ) , n - l ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE t = int ( ( ( 8 * m + 1 ) ** .5 + 1 ) / 2 ) NEW_LINE if m == 0 : print ( n , n ) NEW_LINE else : print ( max ( 0 , n - 2 * m ) , max ( 0 , n - t - ( max ( 0 , t * ( t - 1 ) ) < 2 * m ) ) ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE ans1 = max ( 0 , n - 2 * m ) NEW_LINE l = - 1 NEW_LINE r = n NEW_LINE while r - l > 1 : NEW_LINE INDENT M = ( l + r ) // 2 NEW_LINE if M * ( M - 1 ) // 2 >= m : NEW_LINE INDENT r = M NEW_LINE DEDENT else : NEW_LINE INDENT l = M NEW_LINE DEDENT DEDENT print ( ans1 , n - r ) NEW_LINE"]}
{"id": "geeksforgeeks_1986_A", "java": ["import java . io . * ; class GFG { static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 10 , c = 3 ; System . out . println ( getMaxNum ( a , b , c ) ) ; } }"], "python": ["def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a , b , c = 2 , 10 , 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE"]}
{"id": "codeforces_125_A", "java": ["import java . util . Scanner ; public class Problem3 { static int Cmtoinch ( int cm ) { int inch = ( int ) ( cm / 3 ) ; double modl = cm % 3 ; if ( modl >= 2 ) { inch ++ ; } return inch ; } public static void main ( String [ ] arr ) { Scanner sc = new Scanner ( System . in ) ; int cm = sc . nextInt ( ) ; int inches = Cmtoinch ( cm ) ; int feet = inches / 12 ; int op = 12 * feet ; int returned = inches - op ; System . out . println ( feet + \" \u2581 \" + returned ) ; } }", "import java . util . Scanner ; public class A125 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; int feet = N / 36 ; N %= 36 ; int inches = N / 3 ; N %= 3 ; if ( N == 2 ) { inches ++ ; } if ( inches == 12 ) { inches = 0 ; feet ++ ; } System . out . println ( feet + \" \u2581 \" + inches ) ; } }", "import java . awt . List ; import java . io . BufferedReader ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . Map . Entry ; import java . util . Queue ; import java . util . Scanner ; import java . util . Set ; import java . util . Stack ; import java . util . StringTokenizer ; import java . util . TreeMap ; import java . util . Vector ; public class Main { public static void main ( String [ ] args ) throws IOException { FastScanner sc = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; int inch = ( int ) ( Math . round ( n * 1.0 / 3 ) ) ; System . out . println ( inch / 12 + \" \u2581 \" + ( inch % 12 ) ) ; } public static long gcd ( long x , long y ) { if ( x == 0 ) return y ; if ( y == 0 ) return x ; return gcd ( y , x % y ) ; } } class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } public FastScanner ( String s ) { try { br = new BufferedReader ( new FileReader ( s ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } String nextToken ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( nextToken ( ) ) ; } long nextLong ( ) { return Long . parseLong ( nextToken ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( nextToken ( ) ) ; } }", "import java . util . Scanner ; public class Problem3 { public static void main ( String [ ] args ) { Scanner n = new Scanner ( System . in ) ; float s = n . nextLong ( ) ; int inches = Math . round ( s / 3 ) ; int foot = inches / 12 ; System . out . println ( foot + \" \u2581 \" + ( inches - foot * 12 ) ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE inches = round ( n / 3 ) NEW_LINE feet = inches // 12 NEW_LINE inches = inches % 12 NEW_LINE print ( feet , inches ) NEW_LINE", "def fi ( n ) : NEW_LINE INDENT ft = n // 36 NEW_LINE rem = n % 36 NEW_LINE ic = round ( rem / 3 ) NEW_LINE if ic == 12 : NEW_LINE INDENT ft += 1 NEW_LINE ic = 0 NEW_LINE DEDENT return ft , ic NEW_LINE return NEW_LINE DEDENT n = int ( input ( ) ) NEW_LINE a , b = fi ( n ) NEW_LINE print ( a , b ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT inc = n // 3 NEW_LINE DEDENT elif n % 3 == 1 : NEW_LINE INDENT inc = n // 3 NEW_LINE DEDENT else : NEW_LINE INDENT inc = n // 3 + 1 NEW_LINE DEDENT feet = inc // 12 NEW_LINE inc = inc % 12 NEW_LINE print ( feet , inc ) NEW_LINE", "from itertools import permutations NEW_LINE Test_case = 1 NEW_LINE for test in range ( Test_case ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT inc = n // 3 NEW_LINE print ( inc // 12 , inc % 12 ) NEW_LINE DEDENT elif n % 3 == 1 : NEW_LINE INDENT inc = n // 3 NEW_LINE print ( inc // 12 , inc % 12 ) NEW_LINE DEDENT else : NEW_LINE INDENT inc = n // 3 + 1 NEW_LINE print ( inc // 12 , inc % 12 ) NEW_LINE DEDENT DEDENT", "n = ( int ( input ( ) ) + 1 ) // 3 ; print ( n // 12 , n % 12 ) NEW_LINE"]}
{"id": "geeksforgeeks_4816_A", "java": ["import java . util . * ; class GFG { static int c ; static int HailstoneNumbers ( int N ) { System . out . print ( N + \" \u2581 \" ) ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } return c ; } public static void main ( String [ ] args ) { int N = 7 ; int x ; x = HailstoneNumbers ( N ) ; System . out . println ( ) ; System . out . println ( \" Number \u2581 of \u2581 Steps : \u2581 \" + x ) ; } }"], "python": ["def HailstoneNumbers ( N , c ) : NEW_LINE INDENT print ( N , end = \" \u2581 \" ) ; NEW_LINE if ( N == 1 and c == 0 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE c = HailstoneNumbers ( int ( N / 2 ) , c ) ; NEW_LINE DEDENT elif ( N % 2 != 0 ) : NEW_LINE INDENT c = c + 1 ; NEW_LINE c = HailstoneNumbers ( 3 * N + 1 , c ) ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT N = 7 ; NEW_LINE x = HailstoneNumbers ( N , 0 ) ; NEW_LINE print ( \" \\n Number \u2581 of \u2581 Steps : \u2581 \" , x ) ; NEW_LINE"]}
{"id": "aizu_p00508_A", "java": ["import java . io . IOException ; import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) throws IOException { new Main ( ) . run ( ) ; } private void run ( ) throws IOException { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; Pair [ ] p = new Pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) p [ i ] = new Pair ( scanner . nextInt ( ) , scanner . nextInt ( ) ) ; Arrays . sort ( p ) ; int ans = 1 << 25 ; for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = i ; j >= 0 ; j -- ) { int dx = p [ i + 1 ] . x - p [ j ] . x ; int dy = p [ i + 1 ] . y - p [ j ] . y ; if ( dx * dx >= ans ) break ; ans = Math . min ( ans , dx * dx + dy * dy ) ; } System . out . println ( ans ) ; } class Pair implements Comparable < Pair > { int x , y ; @ Override public String toString ( ) { return \" Pair \u2581 [ x = \" + x + \" , \u2581 y = \" + y + \" ] \" ; } public Pair ( int x , int y ) { super ( ) ; this . x = x ; this . y = y ; } @ Override public int compareTo ( Pair o ) { return x - o . x ; } } }", "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scanner = new Scanner ( System . in ) ) { while ( scanner . hasNextLine ( ) ) { int n = Integer . valueOf ( scanner . nextLine ( ) ) ; int [ ] [ ] data = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] tmp = scanner . nextLine ( ) . split ( \" \u2581 \" ) ; data [ i ] [ 0 ] = Integer . valueOf ( tmp [ 0 ] ) ; data [ i ] [ 1 ] = Integer . valueOf ( tmp [ 1 ] ) ; } solver ( data ) ; } } } private static void solver ( int [ ] [ ] data ) { int ans = Integer . MAX_VALUE ; int diffX = Integer . MAX_VALUE ; Arrays . parallelSort ( data , new Comparator < int [ ] > ( ) { @ Override public int compare ( int [ ] o1 , int [ ] o2 ) { return Integer . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ) ; for ( int i = 0 ; i < data . length ; i ++ ) { for ( int j = i + 1 ; j < data . length ; j ++ ) { if ( diffX < Math . abs ( data [ i ] [ 0 ] - data [ j ] [ 0 ] ) ) { break ; } int tmp = ( data [ i ] [ 0 ] - data [ j ] [ 0 ] ) * ( data [ i ] [ 0 ] - data [ j ] [ 0 ] ) + ( data [ i ] [ 1 ] - data [ j ] [ 1 ] ) * ( data [ i ] [ 1 ] - data [ j ] [ 1 ] ) ; if ( ans > tmp ) { ans = tmp ; diffX = ( int ) Math . sqrt ( ans ) ; } } } System . out . println ( ans ) ; } }", "import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int min = Integer . MAX_VALUE ; int [ ] [ ] p = new int [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] [ 0 ] = sc . nextInt ( ) ; p [ i ] [ 1 ] = sc . nextInt ( ) ; } Arrays . sort ( p , new Comparator < int [ ] > ( ) { public int compare ( int [ ] a , int [ ] b ) { return a [ 0 ] - b [ 0 ] ; } } ) ; for ( int i = 1 ; i < n ; i ++ ) { min = Math . min ( min , ( p [ i ] [ 0 ] - p [ i - 1 ] [ 0 ] ) * ( p [ i ] [ 0 ] - p [ i - 1 ] [ 0 ] ) + ( p [ i ] [ 1 ] - p [ i - 1 ] [ 1 ] ) * ( p [ i ] [ 1 ] - p [ i - 1 ] [ 1 ] ) ) ; } Arrays . sort ( p , new Comparator < int [ ] > ( ) { public int compare ( int [ ] a , int [ ] b ) { return a [ 1 ] - b [ 1 ] ; } } ) ; for ( int i = 1 ; i < n ; i ++ ) { min = Math . min ( min , ( p [ i ] [ 0 ] - p [ i - 1 ] [ 0 ] ) * ( p [ i ] [ 0 ] - p [ i - 1 ] [ 0 ] ) + ( p [ i ] [ 1 ] - p [ i - 1 ] [ 1 ] ) * ( p [ i ] [ 1 ] - p [ i - 1 ] [ 1 ] ) ) ; } System . out . println ( min ) ; } }", "import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Comparator ; import static java . lang . Integer . parseInt ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String line ; String [ ] words ; int n = parseInt ( br . readLine ( ) ) ; long [ ] [ ] a = new long [ n ] [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { line = br . readLine ( ) ; a [ i ] [ 0 ] = parseInt ( line . substring ( 0 , line . indexOf ( ' \u2581 ' ) ) ) ; a [ i ] [ 1 ] = parseInt ( line . substring ( line . indexOf ( ' \u2581 ' ) + 1 ) ) ; } Arrays . sort ( a , new Comparator < long [ ] > ( ) { @ Override public int compare ( long [ ] o1 , long [ ] o2 ) { return Long . compare ( o1 [ 0 ] , o2 [ 0 ] ) ; } } ) ; double L = Long . MAX_VALUE ; long SQ = Long . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ 0 ] - a [ j ] [ 0 ] >= L ) break ; long sq = ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) * ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) + ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) * ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) ; if ( sq < SQ ) { SQ = sq ; L = Math . sqrt ( SQ ) ; } } } System . out . println ( SQ ) ; } }", "import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . Comparator ; class Point { int x ; int y ; Point ( int x , int y ) { this . x = x ; this . y = y ; } int distance ( Point p ) { return ( p . x - this . x ) * ( p . x - this . x ) + ( p . y - this . y ) * ( p . y - this . y ) ; } } class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; Point [ ] p = new Point [ n ] ; String [ ] line = new String [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { line = br . readLine ( ) . split ( \" \u2581 \" ) ; p [ i ] = new Point ( Integer . parseInt ( line [ 0 ] ) , Integer . parseInt ( line [ 1 ] ) ) ; } Arrays . sort ( p , new Comparator < Point > ( ) { public int compare ( Point p1 , Point p2 ) { return p1 . x - p2 . x ; } } ) ; int result = Integer . MAX_VALUE ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( p [ i ] . x - p [ j ] . x >= Math . sqrt ( result ) ) break ; result = Math . min ( result , p [ i ] . distance ( p [ j ] ) ) ; } } System . out . println ( result ) ; } }"], "python": ["import sys NEW_LINE from sys import stdin NEW_LINE from math import sqrt NEW_LINE input = stdin . readline NEW_LINE def closest_part ( points , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT m = n // 2 NEW_LINE x = points [ m ] [ 0 ] NEW_LINE d = min ( closest_part ( points [ : m ] , m ) , closest_part ( points [ m : ] , n - m ) ) NEW_LINE points . sort ( key = lambda x : x [ 1 ] ) NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( points [ i ] [ 0 ] - x ) ** 2 >= d : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( len ( b ) ) : NEW_LINE INDENT dx = points [ i ] [ 0 ] - b [ - j - 1 ] [ 0 ] NEW_LINE dy = points [ i ] [ 1 ] - b [ - j - 1 ] [ 1 ] NEW_LINE if dy ** 2 >= d : NEW_LINE INDENT break NEW_LINE DEDENT d = min ( d , ( dx ** 2 + dy ** 2 ) ) NEW_LINE DEDENT b . append ( points [ i ] ) NEW_LINE DEDENT return d NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE points = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] NEW_LINE points . sort ( ) NEW_LINE result = closest_part ( points , n ) NEW_LINE print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT", "import sys NEW_LINE from operator import itemgetter NEW_LINE from itertools import combinations , takewhile NEW_LINE from math import sqrt NEW_LINE def solve ( a : list , sorted_axis : int = - 1 ) : NEW_LINE INDENT length = len ( a ) NEW_LINE if length <= 3 : NEW_LINE INDENT return min ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 for ( x1 , y1 ) , ( x2 , y2 ) in combinations ( a , 2 ) ) NEW_LINE DEDENT x_set_len = len ( set ( x for x , _ in a ) ) NEW_LINE axis1 = 0 if x_set_len > length / 2 else 1 NEW_LINE if sorted_axis != axis1 : NEW_LINE INDENT a . sort ( key = itemgetter ( axis1 ) ) NEW_LINE DEDENT mid_index = length // 2 NEW_LINE left , right = a [ : mid_index ] , a [ mid_index : ] NEW_LINE delta = min ( solve ( left , axis1 ) , solve ( right , axis1 ) ) NEW_LINE axis2 = not axis1 NEW_LINE median = a [ mid_index ] [ axis1 ] NEW_LINE mid_a = sorted ( [ p for _iter in ( ( takewhile ( lambda p : median - sqrt ( delta ) < p [ axis1 ] , left [ : : - 1 ] ) ) , ( takewhile ( lambda p : p [ axis1 ] < median + sqrt ( delta ) , right ) ) ) for p in _iter ] , key = itemgetter ( axis2 ) ) NEW_LINE for i , ( x1 , y1 ) in enumerate ( mid_a ) : NEW_LINE INDENT ub = ( x1 if axis1 else y1 ) + sqrt ( delta ) NEW_LINE for x2 , y2 in takewhile ( lambda p : p [ axis2 ] < ub , mid_a [ i + 1 : ] ) : NEW_LINE INDENT delta = min ( delta , ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) NEW_LINE DEDENT DEDENT return delta NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE a = [ tuple ( map ( int , l . split ( ) ) ) for l in sys . stdin . readlines ( ) ] NEW_LINE print ( solve ( a ) ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT b = sorted ( a , key = lambda x : ( x [ 0 ] , x [ 1 ] ) ) NEW_LINE c = sorted ( a , key = lambda x : ( x [ 1 ] , x [ 0 ] ) ) NEW_LINE ans = 10 ** 10 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT temp = ( b [ i + 1 ] [ 0 ] - b [ i ] [ 0 ] ) ** 2 + ( b [ i + 1 ] [ 1 ] - b [ i ] [ 1 ] ) ** 2 NEW_LINE if ans > temp : NEW_LINE INDENT ans = temp NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT temp = ( c [ i + 1 ] [ 0 ] - c [ i ] [ 0 ] ) ** 2 + ( c [ i + 1 ] [ 1 ] - c [ i ] [ 1 ] ) ** 2 NEW_LINE if ans > temp : NEW_LINE INDENT ans = temp NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE P , Q = [ ] , [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE P . append ( [ a , b ] ) NEW_LINE Q . append ( [ b , a ] ) NEW_LINE DEDENT P . sort ( ) NEW_LINE Q . sort ( ) NEW_LINE dist = 20000 ** 2 + 20000 ** 2 NEW_LINE for p in range ( 0 , n - 1 ) : NEW_LINE INDENT temp = ( P [ p ] [ 0 ] - P [ p + 1 ] [ 0 ] ) ** 2 + ( P [ p ] [ 1 ] - P [ p + 1 ] [ 1 ] ) ** 2 NEW_LINE if temp < dist : dist = temp NEW_LINE DEDENT for q in range ( 0 , n - 1 ) : NEW_LINE INDENT temp = ( Q [ q ] [ 0 ] - Q [ q + 1 ] [ 0 ] ) ** 2 + ( Q [ q ] [ 1 ] - Q [ q + 1 ] [ 1 ] ) ** 2 NEW_LINE if temp < dist : dist = temp NEW_LINE DEDENT print ( dist ) NEW_LINE", "from operator import itemgetter NEW_LINE N = int ( input ( ) ) NEW_LINE a = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * N ] NEW_LINE ans = float ( \" inf \" ) NEW_LINE a . sort ( ) NEW_LINE for ( x1 , y1 ) , ( x2 , y2 ) in zip ( a , a [ 1 : ] ) : NEW_LINE INDENT dist = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE if ans > dist : NEW_LINE INDENT ans = dist NEW_LINE DEDENT DEDENT a . sort ( key = itemgetter ( 1 ) ) NEW_LINE for ( x1 , y1 ) , ( x2 , y2 ) in zip ( a , a [ 1 : ] ) : NEW_LINE INDENT dist = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 NEW_LINE if ans > dist : NEW_LINE INDENT ans = dist NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "leetcode_868_A", "java": ["class Solution { public int binaryGap ( int N ) { int last = - 1 , ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( ( N >> i ) & 1 ) > 0 ) { if ( last >= 0 ) ans = Math . max ( ans , i - last ) ; last = i ; } return ans ; } }"], "python": ["class Solution : NEW_LINE INDENT def binaryGap ( self , n : int ) -> int : NEW_LINE INDENT current = 1 NEW_LINE last1 = - 1 NEW_LINE out = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT if last1 >= 1 : NEW_LINE INDENT out = max ( out , current - last1 ) NEW_LINE DEDENT last1 = current NEW_LINE DEDENT current += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT return out NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_916_A", "java": ["import java . util . Scanner ; public class ImportantExam { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int snoozeInterval = scanner . nextInt ( ) , hh = scanner . nextInt ( ) , mm = scanner . nextInt ( ) ; int noOfTimeSnooze = 0 ; boolean flag = true ; while ( flag ) { if ( hh == 7 || hh == 17 || mm == 7 || mm % 10 == 7 ) { flag = false ; System . out . println ( noOfTimeSnooze ) ; } mm -= snoozeInterval ; noOfTimeSnooze ++ ; if ( mm < 0 ) { mm += 60 ; hh -= 1 ; if ( hh < 0 ) hh = 23 ; } } } }", "import java . util . Scanner ; public class JamieAndAlarmSnooze { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int hh = sc . nextInt ( ) ; int mm = sc . nextInt ( ) ; int time = hh * 60 + mm ; for ( int i = 0 ; ; i ++ ) { int hours = time / 60 , minutes = time % 60 ; if ( hours / 10 == 7 || hours % 10 == 7 || minutes / 10 == 7 || minutes % 10 == 7 ) { System . out . println ( i ) ; return ; } time = ( time - x + 1440 ) % 1440 ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] arg ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; int hh = sc . nextInt ( ) ; int mm = sc . nextInt ( ) ; boolean check = true ; int cnt = 0 ; while ( check ) { int MMlnum = mm % 10 ; int HHlnum = hh % 10 ; if ( MMlnum == 7 || HHlnum == 7 ) { System . out . println ( cnt ) ; check = false ; break ; } int tmpMM = mm - x ; if ( tmpMM >= 0 ) { mm -= x ; cnt ++ ; } else { mm = 60 + tmpMM ; if ( hh != 00 ) hh -- ; else hh = 23 ; cnt ++ ; } } } }", "import java . util . * ; public class MyClass { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int x , h , m , totalminutes ; x = sc . nextInt ( ) ; h = sc . nextInt ( ) ; m = sc . nextInt ( ) ; totalminutes = h * 60 + m ; for ( int i = 0 ; ; i ++ ) { h = totalminutes / 60 ; m = totalminutes % 60 ; if ( h / 10 == 7 || h % 10 == 7 || m / 10 == 7 || m % 10 == 7 ) { System . out . print ( i ) ; break ; } totalminutes = ( totalminutes - x + 1440 ) % 1440 ; } } }", "import java . util . Scanner ; public class aaaauxiliary { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int gap , hh , mm , ans = 0 ; boolean flag = false ; gap = sc . nextInt ( ) ; hh = sc . nextInt ( ) ; mm = sc . nextInt ( ) ; sc . close ( ) ; while ( ! flag ) { if ( hh % 10 == 7 || hh / 10 == 7 || mm % 10 == 7 || mm / 10 == 7 ) { System . out . println ( ans ) ; flag = true ; } else if ( mm - gap >= 0 ) { mm -= gap ; ans ++ ; } else { mm -= gap ; mm += 60 ; hh -- ; if ( hh == - 1 ) { hh = 23 ; } ans ++ ; } } } }"], "python": ["x = int ( input ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE M , c = 60 * h + m , 0 NEW_LINE while '7' not in str ( M // 60 ) + str ( M % 60 ) : NEW_LINE INDENT c += 1 ; M -= x NEW_LINE if M < 0 : M += 1440 NEW_LINE DEDENT print ( c ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE c = 0 NEW_LINE if \"7\" in str ( h ) or \"7\" in str ( m ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( \"7\" not in str ( m ) ) and ( \"7\" not in str ( h ) ) : NEW_LINE INDENT m -= n NEW_LINE c += 1 NEW_LINE if m < 0 : NEW_LINE INDENT m = 60 + m NEW_LINE h -= 1 NEW_LINE if h < 0 : NEW_LINE INDENT h = 24 + h NEW_LINE DEDENT DEDENT DEDENT print ( c ) NEW_LINE DEDENT", "x = int ( input ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE M , c = 60 * h + m , 0 NEW_LINE while '7' not in str ( M // 60 ) + str ( M % 60 ) : NEW_LINE INDENT c += 1 ; M -= x NEW_LINE if M < 0 : M += 1440 NEW_LINE DEDENT print ( c ) NEW_LINE", "x = int ( input ( ) ) NEW_LINE h , m = map ( int , input ( ) . split ( ) ) NEW_LINE M , c = 60 * h + m , 0 NEW_LINE while '7' not in str ( M // 60 ) + str ( M % 60 ) : NEW_LINE INDENT c += 1 ; M -= x NEW_LINE if M < 0 : M += 1440 NEW_LINE DEDENT print ( c ) NEW_LINE", "x = int ( input ( ) ) NEW_LINE ( hh , mm ) = map ( str , input ( ) . split ( ' \u2581 ' ) ) NEW_LINE if ( '7' in hh ) or ( '7' in mm ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT press_the_button = 0 NEW_LINE while True : NEW_LINE INDENT if int ( mm ) >= x : NEW_LINE INDENT mm = str ( int ( mm ) - x ) NEW_LINE DEDENT else : NEW_LINE INDENT mm = str ( 60 + int ( mm ) - x ) NEW_LINE if int ( hh ) > 0 : NEW_LINE INDENT hh = str ( int ( hh ) - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT hh = str ( 23 ) NEW_LINE DEDENT DEDENT press_the_button += 1 NEW_LINE if ( '7' in hh ) or ( '7' in mm ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( press_the_button ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_846_A", "java": ["class GFG { static boolean canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } static int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } public static void main ( String args [ ] ) { int n = 4 , m = 5 ; System . out . println ( maxTeams ( n , m ) ) ; } }"], "python": ["def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3999_A", "java": ["class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( catalan ( i ) + \" \u2581 \" ) ; } } }"], "python": ["def binomialCoefficient ( n , k ) : NEW_LINE INDENT if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoefficient ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = \" \u2581 \" ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2070_A", "java": ["class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catalan ( n ) ) ; } }"], "python": ["def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( catalan ( n ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_2683_A", "java": ["import java . util . * ; class RemoveDuplicates { void removeDuplicates ( String str ) { LinkedHashSet < Character > lhs = new LinkedHashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) lhs . add ( str . charAt ( i ) ) ; for ( Character ch : lhs ) System . out . print ( ch ) ; } public static void main ( String args [ ] ) { String str = \" geeksforgeeks \" ; RemoveDuplicates r = new RemoveDuplicates ( ) ; r . removeDuplicates ( str ) ; } }"], "python": ["NO_OF_CHARS = 256 NEW_LINE def toMutable ( string ) : NEW_LINE INDENT List = [ ] NEW_LINE for i in string : NEW_LINE INDENT List . append ( i ) NEW_LINE DEDENT return List NEW_LINE DEDENT def toString ( List ) : NEW_LINE INDENT return ' ' . join ( List ) NEW_LINE DEDENT def removeDups ( string ) : NEW_LINE INDENT bin_hash = [ 0 ] * NO_OF_CHARS NEW_LINE ip_ind = 0 NEW_LINE res_ind = 0 NEW_LINE temp = ' ' NEW_LINE mutableString = toMutable ( string ) NEW_LINE while ip_ind != len ( mutableString ) : NEW_LINE INDENT temp = mutableString [ ip_ind ] NEW_LINE if bin_hash [ ord ( temp ) ] == 0 : NEW_LINE INDENT bin_hash [ ord ( temp ) ] = 1 NEW_LINE mutableString [ res_ind ] = mutableString [ ip_ind ] NEW_LINE res_ind += 1 NEW_LINE DEDENT ip_ind += 1 NEW_LINE DEDENT return toString ( mutableString [ 0 : res_ind ] ) NEW_LINE DEDENT string = \" geeksforgeeks \" NEW_LINE print NEW_LINE removeDups ( string ) NEW_LINE"]}
{"id": "atcoder_ABC137_C", "java": ["import java . io . * ; import java . util . * ; public class Main { public static final Scanner in = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; public static final PrintStream out = System . out ; public static void main ( String [ ] args ) { int N = in . nextInt ( ) ; Map < String , Integer > found = new HashMap < > ( ) ; long result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { String input = in . next ( ) ; String data = new String ( input . chars ( ) . sorted ( ) . toArray ( ) , 0 , input . length ( ) ) ; result += found . merge ( data , 1 , ( x , y ) -> x + y ) - 1 ; } out . println ( result ) ; } }", "import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; String [ ] words = new String [ N ] ; for ( int i = 0 ; i < words . length ; i ++ ) words [ i ] = in . next ( ) ; Map < String , Long > cnt = new HashMap < > ( ) ; for ( String word : words ) { char [ ] arr = word . toCharArray ( ) ; Arrays . sort ( arr ) ; String sorted = String . valueOf ( arr ) ; cnt . put ( sorted , cnt . getOrDefault ( sorted , ( long ) 0 ) + 1 ) ; } long res = 0 ; for ( Long i : cnt . values ( ) ) res += i * ( i - 1 ) / 2 ; System . out . println ( res ) ; } }", "import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; class Main { private static int min ( int a , int b ) { return ( a < b ) ? a : b ; } static long binomialCoeff ( int n , int k ) { long C [ ] [ ] = new long [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; String [ ] strings = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { char [ ] s = in . next ( ) . toCharArray ( ) ; Arrays . sort ( s ) ; strings [ i ] = new String ( s ) ; } Arrays . sort ( strings ) ; long count = 0 ; for ( int i = 1 ; i < n ; ) { long c = 0 ; boolean flag = false ; while ( i < n && strings [ i ] . equals ( strings [ i - 1 ] ) ) { flag = true ; c ++ ; i ++ ; } if ( c > 0 ) { count += ( c * ( c + 1 ) ) / 2 ; } if ( ! flag ) i ++ ; } System . out . println ( count ) ; } }", "import java . io . * ; import java . util . * ; import java . util . function . * ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer in = new StringTokenizer ( \" \" ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; Map < String , Long > mp = new HashMap < > ( ) ; Consumer < String > fun = ( s ) -> mp . put ( s , mp . getOrDefault ( s , 0L ) + 1L ) ; for ( int i = 0 ; i < n ; i ++ ) fun . accept ( Arrays . toString ( br . readLine ( ) . chars ( ) . mapToObj ( it -> ( char ) it ) . sorted ( ) . toArray ( ) ) ) ; System . out . println ( mp . values ( ) . stream ( ) . mapToLong ( it -> it * ( it - 1 ) / 2 ) . sum ( ) ) ; } }", "import java . util . * ; public class Main { Scanner sc ; Map < String , Integer > h ; int N ; public Main ( ) { sc = new Scanner ( System . in ) ; } private void calc ( ) { N = sc . nextInt ( ) ; h = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char [ ] cs = sc . next ( ) . toCharArray ( ) ; Arrays . sort ( cs ) ; String s = new String ( cs ) ; h . put ( s , h . getOrDefault ( s , 0 ) + 1 ) ; } long result = 0L ; for ( String s : h . keySet ( ) ) { int cnt = h . get ( s ) ; if ( cnt <= 1 ) continue ; result = result + ( ( long ) cnt ) * ( cnt - 1 ) / 2 ; } out ( result ) ; } private void out ( Object o ) { System . out . println ( o ) ; System . out . flush ( ) ; } public static void main ( String [ ] args ) { Main m = new Main ( ) ; m . calc ( ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE wordlist = [ input ( ) for i in range ( n ) ] NEW_LINE sortlist = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = list ( wordlist [ i ] ) NEW_LINE a . sort ( ) NEW_LINE sortlist . append ( a ) NEW_LINE DEDENT count = 0 NEW_LINE sortlist . sort ( ) NEW_LINE checkword = \" \" NEW_LINE check = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a = sortlist . pop ( ) NEW_LINE if checkword == a : NEW_LINE INDENT check += 1 NEW_LINE count += check NEW_LINE DEDENT else : NEW_LINE INDENT check = 0 NEW_LINE checkword = a NEW_LINE DEDENT DEDENT print ( int ( count ) ) NEW_LINE", "from collections import defaultdict NEW_LINE from collections import deque NEW_LINE from collections import Counter NEW_LINE import itertools NEW_LINE import math NEW_LINE def readInt ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def readInts ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT def readChar ( ) : NEW_LINE INDENT return input ( ) NEW_LINE DEDENT def readChars ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT def comb ( n , r ) : NEW_LINE INDENT return math . factorial ( n ) // math . factorial ( r ) // math . factorial ( max ( 1 , n - r ) ) NEW_LINE DEDENT def con ( t ) : NEW_LINE INDENT ans = \" \" NEW_LINE for i in t : NEW_LINE INDENT ans += i [ 0 ] + str ( i [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = readInt ( ) NEW_LINE d = defaultdict ( int ) NEW_LINE for i in [ input ( ) for i in range ( n ) ] : NEW_LINE INDENT t = defaultdict ( int ) NEW_LINE for j in i : NEW_LINE INDENT t [ j ] += 1 NEW_LINE DEDENT d [ con ( sorted ( t . items ( ) ) ) ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in d : NEW_LINE INDENT ans += comb ( d [ i ] , 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE", "import collections NEW_LINE import sys NEW_LINE input = sys . stdin . readline NEW_LINE N = int ( input ( ) ) NEW_LINE list = [ ' ' . join ( sorted ( list ( input ( ) . strip ( \" \\n \" ) ) ) ) for i in range ( N ) ] NEW_LINE list . sort ( ) NEW_LINE c = collections . Counter ( list ) NEW_LINE c = c . most_common ( ) NEW_LINE ans = 0 NEW_LINE for i , v in c : NEW_LINE INDENT ans += v * ( v - 1 ) // 2 NEW_LINE DEDENT print ( ans ) NEW_LINE", "import numpy as np NEW_LINE import collections NEW_LINE n = int ( input ( ) ) NEW_LINE s = np . array ( [ [ str ( i ) for i in input ( ) . split ( ) ] for i in range ( n ) ] ) NEW_LINE s = np . ravel ( s ) NEW_LINE ans = 0 NEW_LINE sorted_list = [ ' ' . join ( sorted ( e ) ) for e in s ] NEW_LINE c = collections . Counter ( sorted_list ) NEW_LINE for i in c . values ( ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT ans += j NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "d = { } NEW_LINE c = 0 NEW_LINE for i in open ( 0 ) : i = str ( sorted ( i ) ) ; t = d . get ( i , 0 ) ; c += t ; d [ i ] = t + 1 NEW_LINE print ( c ) NEW_LINE"]}
{"id": "geeksforgeeks_2500_A", "java": ["import java . util . * ; class solution { static int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } public static void main ( String args [ ] ) { int a [ ] = { 2 , 5 , 4 } ; int n = a . length ; int m = 2 ; System . out . println ( getPosition ( a , n , m ) ) ; } }"], "python": ["import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE"]}
{"id": "geeksforgeeks_4823_A", "java": ["class GFG { static int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; static int dayOfYear ( String date ) { int year = Integer . parseInt ( date . substring ( 0 , 4 ) ) ; int month = Integer . parseInt ( date . substring ( 5 , 7 ) ) ; int day = Integer . parseInt ( date . substring ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 || year % 400 == 0 ) ) { ++ day ; } while ( -- month > 0 ) { day = day + days [ month - 1 ] ; } return day ; } public static void main ( String [ ] args ) { String date = \"2019-01-09\" ; System . out . println ( dayOfYear ( date ) ) ; } }"], "python": ["days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE def dayOfYear ( date ) : NEW_LINE INDENT year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT"]}
{"id": "codeforces_1541_A", "java": ["import java . util . Scanner ; public class test215 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int j = 0 ; j < t ; j ++ ) { int n = in . nextInt ( ) ; if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { System . out . print ( ( i - 1 ) + \" \u2581 \" ) ; } else { System . out . print ( ( i + 1 ) + \" \u2581 \" ) ; } } } else { for ( int i = 1 ; i <= n - 3 ; i ++ ) { if ( i % 2 == 0 ) { System . out . print ( ( i - 1 ) + \" \u2581 \" ) ; } else { System . out . print ( ( i + 1 ) + \" \u2581 \" ) ; } } System . out . print ( n + \" \u2581 \" ) ; System . out . print ( ( n - 2 ) + \" \u2581 \" ) ; System . out . print ( ( n - 1 ) + \" \u2581 \" ) ; } System . out . println ( ) ; } in . close ( ) ; } }", "import java . util . * ; import static java . lang . Integer . parseInt ; public class _1541A_PrettyPermutations { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int test = parseInt ( input . nextLine ( ) ) ; while ( test -- > 0 ) { int num = parseInt ( input . nextLine ( ) ) ; if ( num == 2 ) { System . out . println ( \"2 \u2581 1\" ) ; } else { String result = \" \" ; if ( num % 2 == 0 ) { for ( int i = 1 ; i <= num ; i ++ ) { if ( i % 2 == 1 ) { result += i + 1 + \" \u2581 \" ; } else { result += i - 1 + \" \u2581 \" ; } } } else { result = \"3 \u2581 1 \u2581 2 \u2581 \" ; for ( int i = 4 ; i <= num ; i ++ ) { if ( i % 2 == 0 ) { result += i + 1 + \" \u2581 \" ; } else { result += i - 1 + \" \u2581 \" ; } } } System . out . println ( result . trim ( ) ) ; } } } }", "import java . util . Scanner ; public class Pretty_Permutations { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int testcase = sc . nextInt ( ) ; while ( testcase != 0 ) { testcase -- ; int num = sc . nextInt ( ) ; for ( int i = 2 ; i <= num ; i += 2 ) { if ( num % 2 == 1 && i > num - 3 ) { System . out . print ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i - 1 ) ) ; } else if ( i % 2 == 0 ) System . out . print ( i + \" \u2581 \" + ( i - 1 ) ) ; if ( i <= num - 1 ) System . out . print ( \" \u2581 \" ) ; } if ( testcase > 0 ) System . out . println ( ) ; } sc . close ( ) ; } }", "import java . util . Scanner ; public class Pretty_Permutations { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int testcase = sc . nextInt ( ) ; while ( testcase != 0 ) { testcase -- ; int num = sc . nextInt ( ) ; for ( int i = 2 ; i <= num ; i += 2 ) { if ( num % 2 == 1 && i > num - 3 ) { System . out . print ( i + \" \u2581 \" + ( i + 1 ) + \" \u2581 \" + ( i - 1 ) ) ; } else if ( i % 2 == 0 ) System . out . print ( i + \" \u2581 \" + ( i - 1 ) ) ; if ( i <= num - 1 ) System . out . print ( \" \u2581 \" ) ; } if ( testcase > 0 ) System . out . println ( ) ; } sc . close ( ) ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT a = [ i + ( 2 * ( i % 2 ) - 1 ) for i in range ( 1 , n - 2 ) ] + [ n , n - 2 , n - 1 ] NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE while t : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT for i in range ( 1 , n , 2 ) : NEW_LINE INDENT print ( i + 1 , i , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , n - 2 , 2 ) : NEW_LINE INDENT print ( i + 1 , i , end = ' \u2581 ' ) NEW_LINE DEDENT print ( n , n - 2 , n - 1 , end = ' \u2581 ' ) NEW_LINE print ( ) NEW_LINE DEDENT t -= 1 NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE res = list ( range ( 1 , n + 1 ) ) NEW_LINE res = [ i + 1 if i % 2 == 1 else i - 1 for i in res ] NEW_LINE if len ( res ) % 2 == 1 : NEW_LINE INDENT res [ - 2 ] += 2 NEW_LINE res [ - 1 ] -= 3 NEW_LINE DEDENT print ( * res ) NEW_LINE DEDENT", "def solve ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n % 2 == 0 : NEW_LINE INDENT a = list ( range ( 1 , n + 1 ) ) NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT a = [ 3 , 1 , 2 ] NEW_LINE b = list ( range ( 4 , n + 1 ) ) NEW_LINE for i in range ( 0 , n - 3 , 2 ) : NEW_LINE INDENT b [ i ] , b [ i + 1 ] = b [ i + 1 ] , b [ i ] NEW_LINE DEDENT a += b NEW_LINE DEDENT return \" \u2581 \" . join ( [ str ( i ) for i in a ] ) NEW_LINE DEDENT t = int ( input ( ) ) NEW_LINE ans = [ ] NEW_LINE while t : NEW_LINE INDENT ans . append ( str ( solve ( ) ) ) NEW_LINE t -= 1 NEW_LINE DEDENT print ( \" \\n \" . join ( ans ) ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE res , s = [ ] , 2 NEW_LINE if n & 1 == 1 : NEW_LINE INDENT res += [ 3 , 1 , 2 ] NEW_LINE s = 5 NEW_LINE DEDENT res += [ i for pair in zip ( range ( s , n + 1 , 2 ) , range ( s - 1 , n + 1 , 2 ) ) for i in pair ] NEW_LINE print ( * res ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2868_A", "java": ["import java . util . * ; class GFG { static int cnt = 0 ; static Vector < Vector < Integer > > graph = new Vector < Vector < Integer > > ( ) ; static Vector < String > weight = new Vector < String > ( ) ; static boolean isPalindrome ( String x ) { int n = x . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( x . charAt ( i ) != x . charAt ( n - 1 - i ) ) return false ; } return true ; } static void dfs ( int node , int parent ) { String x = weight . get ( node ) ; if ( isPalindrome ( x ) ) cnt += 1 ; for ( int i = 0 ; i < graph . get ( node ) . size ( ) ; i ++ ) { if ( graph . get ( node ) . get ( i ) == parent ) continue ; dfs ( graph . get ( node ) . get ( i ) , node ) ; } } public static void main ( String args [ ] ) { weight . add ( \" \" ) ; weight . add ( \" abc \" ) ; weight . add ( \" aba \" ) ; weight . add ( \" bcb \" ) ; weight . add ( \" moh \" ) ; weight . add ( \" aa \" ) ; for ( int i = 0 ; i < 100 ; i ++ ) graph . add ( new Vector < Integer > ( ) ) ; graph . get ( 1 ) . add ( 2 ) ; graph . get ( 2 ) . add ( 3 ) ; graph . get ( 2 ) . add ( 4 ) ; graph . get ( 1 ) . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . println ( cnt ) ; } }"], "python": ["cnt = 0 NEW_LINE graph = [ 0 ] * 100 NEW_LINE for i in range ( 100 ) : NEW_LINE INDENT graph [ i ] = [ ] NEW_LINE DEDENT weight = [ \"0\" ] * 100 NEW_LINE def isPalindrome ( x ) : NEW_LINE INDENT n = len ( x ) NEW_LINE for i in range ( 0 , n // 2 ) : NEW_LINE INDENT if x [ i ] != x [ n - 1 - i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT global cnt NEW_LINE x = weight [ node ] NEW_LINE if ( isPalindrome ( x ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT for to in graph [ node ] : NEW_LINE INDENT if to == parent : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT weight [ 0 ] = \" \" NEW_LINE weight [ 1 ] = \" abc \" NEW_LINE weight [ 2 ] = \" aba \" NEW_LINE weight [ 3 ] = \" bcb \" NEW_LINE weight [ 4 ] = \" moh \" NEW_LINE weight [ 5 ] = \" aa \" NEW_LINE graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 2 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 1 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 ) NEW_LINE print ( cnt ) NEW_LINE DEDENT"]}
{"id": "aizu_p00343_A", "java": ["import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { boolean [ ] used = new boolean [ 14 ] ; boolean ans = false ; for ( int i = 0 ; i < 6 ; i ++ ) { used [ sc . nextInt ( ) ] = true ; } if ( used [ 1 ] == used [ 13 ] ) ans = ! used [ 1 ] ; else { int l = 6 , r = 8 ; boolean t = false ; for ( ; ; ) { if ( t == used [ 1 ] ) { if ( used [ r ] ^ t ) r ++ ; else if ( used [ l ] ^ t ) l -- ; } else { if ( used [ l ] ^ t ) l -- ; else if ( used [ r ] ^ t ) r ++ ; } if ( r == 13 ) { ans = ! used [ 1 ] ; break ; } if ( l == 1 ) { ans = used [ 1 ] ; break ; } t = ! t ; } } System . out . println ( ans ? \" yes \" : \" no \" ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { boolean [ ] used = new boolean [ 14 ] ; boolean ans = false ; for ( int i = 0 ; i < 6 ; i ++ ) { used [ sc . nextInt ( ) ] = true ; } if ( used [ 1 ] == used [ 13 ] ) ans = ! used [ 1 ] ; else { int l = 6 , r = 8 ; boolean t = false ; for ( ; ; ) { if ( t == used [ 1 ] ) { if ( used [ r ] ^ t ) r ++ ; else if ( used [ l ] ^ t ) l -- ; } else { if ( used [ l ] ^ t ) l -- ; else if ( used [ r ] ^ t ) r ++ ; } if ( r == 13 || l == 1 ) { ans = used [ 1 ] ^ r == 13 ; break ; } t = ! t ; } } System . out . println ( ans ? \" yes \" : \" no \" ) ; } } }", "import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { boolean [ ] used = new boolean [ 14 ] ; boolean ans = false ; for ( int i = 0 ; i < 6 ; i ++ ) { used [ sc . nextInt ( ) ] = true ; } if ( used [ 1 ] == used [ 13 ] ) ans = ! used [ 1 ] ; else { int [ ] r = { 6 , 8 } ; boolean t = false ; for ( ; ; ) { int a = t == used [ 1 ] ? 1 : 0 ; int b = ( a + 1 ) % 2 ; if ( used [ r [ a ] ] ^ t ) r [ a ] += a == 1 ? 1 : - 1 ; else if ( used [ r [ b ] ] ^ t ) r [ b ] += b == 1 ? 1 : - 1 ; if ( r [ 1 ] == 13 || r [ 0 ] == 1 ) { ans = used [ 1 ] ^ r [ 1 ] == 13 ; break ; } t = ! t ; } } System . out . println ( ans ? \" yes \" : \" no \" ) ; } } }"], "python": ["n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT F = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE fl = min ( F ) ; fr = max ( F ) NEW_LINE G = { i for i in range ( 1 , 14 ) } - F - { 7 } NEW_LINE gl = min ( G ) ; gr = max ( G ) NEW_LINE memo = { } NEW_LINE def dfs ( s , t , u ) : NEW_LINE INDENT if ( s , t , u ) in memo : NEW_LINE INDENT return memo [ s , t , u ] NEW_LINE DEDENT T = [ G , F ] [ u ] NEW_LINE res = 0 NEW_LINE if s - 1 in T : NEW_LINE INDENT if s - 1 <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT res |= dfs ( s - 1 , t , u ^ 1 ) ^ 1 NEW_LINE DEDENT DEDENT if t + 1 in T : NEW_LINE INDENT if s <= [ gl , fl ] [ u ] and [ gr , fr ] [ u ] <= t + 1 : NEW_LINE INDENT res = 1 NEW_LINE DEDENT else : NEW_LINE INDENT res |= dfs ( s , t + 1 , u ^ 1 ) ^ 1 NEW_LINE DEDENT DEDENT if s - 1 not in T and t + 1 not in T : NEW_LINE INDENT res = dfs ( s , t , u ^ 1 ) ^ 1 NEW_LINE DEDENT memo [ s , t , u ] = res NEW_LINE return res NEW_LINE DEDENT print ( [ \" no \" , \" yes \" ] [ dfs ( 7 , 7 , 1 ) ] ) NEW_LINE DEDENT", "def search ( a_cards , b_cards , left , right , turn ) : NEW_LINE INDENT if a_cards == [ ] : NEW_LINE INDENT return True NEW_LINE DEDENT if b_cards == [ ] : NEW_LINE INDENT return False NEW_LINE DEDENT ret = False NEW_LINE if turn == 0 : NEW_LINE INDENT if left not in a_cards and right not in a_cards : NEW_LINE INDENT return search ( a_cards , b_cards , left , right , 1 ) NEW_LINE DEDENT if left in a_cards : NEW_LINE INDENT ret = ret or search ( [ i for i in a_cards if i != left ] , b_cards , left - 1 , right , 1 ) NEW_LINE DEDENT if right in a_cards : NEW_LINE INDENT ret = ret or search ( [ i for i in a_cards if i != right ] , b_cards , left , right + 1 , 1 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT ret = True NEW_LINE if turn == 1 : NEW_LINE INDENT if left not in b_cards and right not in b_cards : NEW_LINE INDENT return search ( a_cards , b_cards , left , right , 0 ) NEW_LINE DEDENT if left in b_cards : NEW_LINE INDENT ret = ret and search ( a_cards , [ i for i in b_cards if i != left ] , left - 1 , right , 0 ) NEW_LINE DEDENT if right in b_cards : NEW_LINE INDENT ret = ret and search ( a_cards , [ i for i in b_cards if i != right ] , left , right + 1 , 0 ) NEW_LINE DEDENT return ret NEW_LINE DEDENT DEDENT n = int ( input ( ) ) NEW_LINE all_cards = [ i + 1 for i in range ( 13 ) if i != 6 ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT a_cards = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b_cards = [ i for i in all_cards if i not in a_cards ] NEW_LINE if search ( a_cards , b_cards , 6 , 8 , 0 ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "aizu_p00979_A", "java": ["public class Main { public static long low = 1 , high = ( long ) Math . pow ( 3 , 32 ) , n ; public static void main ( String [ ] args ) { n = new java . util . Scanner ( System . in ) . nextLong ( ) ; long ans = ( n == 0 ) ? - 1 : dfs ( 1 , 1 ) ; System . out . println ( ans + 1 ) ; } public static long dfs ( long pos , long pace ) { if ( pos > n ) return 0 ; if ( pace < high ) { long npace = 3 * pace ; long npos = pos + npace ; if ( npos == n & ( npace == 1 | npace == 3 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } { long npace = pace ; long npos = npace + pos ; if ( npos == n & ( npace == 1 | npace == 3 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } if ( pace > low ) { long npace = pace / 3 ; long npos = pos + npace ; if ( npos == n & ( npace == 3 | npace == 1 ) ) return 1 ; else { long temp = dfs ( npos , npace ) ; if ( temp != 0 ) return 1 + temp ; } } return 0 ; } }", "import java . util . * ; import java . lang . Math ; public class Main { public static void main ( String [ ] args ) { long count = 0 ; double quo = 1 ; int quo_max_n = 0 ; Scanner scan = new Scanner ( System . in ) ; double t = 0 ; t = scan . nextLong ( ) ; for ( int n = 0 ; ; n ++ ) { if ( t < ( Math . pow ( 3 , n ) - Math . pow ( 3 , n - 1 ) - 2 ) ) { quo_max_n = n - 2 ; break ; } } count = quo_max_n + 1 ; quo = Math . pow ( 3 , quo_max_n ) ; for ( double tmp = t - ( Math . pow ( 3 , count ) - 1 ) / 2 ; tmp > 0 ; count ++ ) { if ( tmp >= ( quo - 1 ) * 3 / 2 ) { tmp = tmp - quo ; continue ; } if ( tmp < ( quo - 1 ) * 3 / 2 ) { quo = quo / 3 ; tmp = tmp - quo ; continue ; } } if ( t == 0 ) { count = 0 ; } System . out . println ( count ) ; scan . close ( ) ; } }"], "python": ["from sys import stdin , stdout NEW_LINE import math NEW_LINE n = int ( stdin . readline ( ) . strip ( ) ) NEW_LINE reserved = 1 NEW_LINE maxspeed = 1 NEW_LINE while True : NEW_LINE INDENT if reserved + maxspeed * 3 > n : NEW_LINE INDENT break NEW_LINE DEDENT maxspeed *= 3 NEW_LINE reserved += maxspeed * 2 NEW_LINE DEDENT ans = 1 NEW_LINE n -= 1 NEW_LINE i = 3 NEW_LINE while i < maxspeed : NEW_LINE INDENT ans += 2 NEW_LINE n -= i * 2 NEW_LINE i *= 3 NEW_LINE DEDENT n -= maxspeed NEW_LINE i = maxspeed NEW_LINE while i : NEW_LINE INDENT ans += n // i NEW_LINE n -= n // i * i NEW_LINE i //= 3 NEW_LINE DEDENT stdout . writelines ( str ( ans + 1 ) + ' \\n ' ) NEW_LINE", "t = int ( input ( ) ) NEW_LINE count = 0 NEW_LINE speed = 1 NEW_LINE margin = 0 NEW_LINE while t > 0 : NEW_LINE INDENT t -= speed NEW_LINE count += 1 NEW_LINE if margin + speed * 3 <= t : NEW_LINE INDENT speed *= 3 NEW_LINE margin += speed NEW_LINE DEDENT elif t < margin : NEW_LINE INDENT margin -= speed NEW_LINE speed /= 3 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE", "import os NEW_LINE import sys NEW_LINE def main ( ) : NEW_LINE INDENT T = read_int ( ) NEW_LINE print ( solve ( T ) ) NEW_LINE DEDENT def solve ( T ) : NEW_LINE INDENT if T <= 3 : NEW_LINE INDENT return T NEW_LINE DEDENT sec = 1 NEW_LINE T -= 1 NEW_LINE f = 3 NEW_LINE while T >= 2 * f : NEW_LINE INDENT T -= 2 * f NEW_LINE f *= 3 NEW_LINE sec += 2 NEW_LINE DEDENT if T >= f : NEW_LINE INDENT T -= f NEW_LINE sec += 1 NEW_LINE DEDENT else : NEW_LINE INDENT f //= 3 NEW_LINE DEDENT while T > 0 : NEW_LINE INDENT t = T // f NEW_LINE T -= t * f NEW_LINE sec += t NEW_LINE f //= 3 NEW_LINE DEDENT return sec NEW_LINE DEDENT DEBUG = ' DEBUG ' in os . environ NEW_LINE def inp ( ) : NEW_LINE INDENT return sys . stdin . readline ( ) . rstrip ( ) NEW_LINE DEDENT def read_int ( ) : NEW_LINE INDENT return int ( inp ( ) ) NEW_LINE DEDENT def read_ints ( ) : NEW_LINE INDENT return [ int ( e ) for e in inp ( ) . split ( ) ] NEW_LINE DEDENT def dprint ( * value , sep = ' \u2581 ' , end = ' \\n ' ) : NEW_LINE INDENT if DEBUG : NEW_LINE INDENT print ( * value , sep = sep , end = end ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT"]}
{"id": "codeforces_1287_B", "java": ["import java . util . Arrays ; import java . util . Scanner ; import java . util . Set ; import java . util . stream . Collectors ; public class Main { static final char [ ] VALUES = { ' S ' , ' E ' , ' T ' } ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; sc . nextInt ( ) ; String [ ] cards = new String [ n ] ; for ( int i = 0 ; i < cards . length ; ++ i ) { cards [ i ] = sc . next ( ) ; } System . out . println ( solve ( cards ) ) ; sc . close ( ) ; } static int solve ( String [ ] cards ) { Set < String > cardSet = Arrays . stream ( cards ) . collect ( Collectors . toSet ( ) ) ; int result = 0 ; for ( int i = 0 ; i < cards . length ; ++ i ) { for ( int j = i + 1 ; j < cards . length ; ++ j ) { if ( cardSet . contains ( computeTarget ( cards [ i ] , cards [ j ] ) ) ) { ++ result ; } } } result /= 3 ; return result ; } static String computeTarget ( String card1 , String card2 ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = 0 ; i < card1 . length ( ) ; ++ i ) { char ch1 = card1 . charAt ( i ) ; char ch2 = card2 . charAt ( i ) ; char ch ; if ( ch1 == ch2 ) { ch = ch1 ; } else { for ( int j = 0 ; ; ++ j ) { if ( VALUES [ j ] != ch1 && VALUES [ j ] != ch2 ) { ch = VALUES [ j ] ; break ; } } } result . append ( ch ) ; } return result . toString ( ) ; } }"], "python": ["def predictFeature ( a , b ) : NEW_LINE INDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT if ' S ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' S ' NEW_LINE DEDENT if ' T ' in ( a , b ) : NEW_LINE INDENT pass NEW_LINE DEDENT else : NEW_LINE INDENT return ' T ' NEW_LINE DEDENT return ' E ' NEW_LINE DEDENT DEDENT def hyperSet ( n , k , l ) : NEW_LINE INDENT d = { } NEW_LINE for x in l : NEW_LINE INDENT if x not in d : NEW_LINE INDENT d [ x ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ x ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT w = ' ' NEW_LINE for x in range ( k ) : NEW_LINE INDENT w += predictFeature ( l [ i ] [ x ] , l [ j ] [ x ] ) NEW_LINE DEDENT if w in d : NEW_LINE INDENT c = 0 NEW_LINE if w == l [ i ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if w == l [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT ans += d [ w ] - c NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans // 6 NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT l . append ( input ( ) ) NEW_LINE DEDENT print ( hyperSet ( n , k , l ) ) NEW_LINE", "import sys NEW_LINE import io , os NEW_LINE input = sys . stdin . readline NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE S = [ ] NEW_LINE T = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s = str ( input ( ) . rstrip ( ) ) NEW_LINE S . append ( s ) NEW_LINE T . add ( s ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT s = S [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT t = S [ j ] NEW_LINE temp = [ ] NEW_LINE for k in range ( K ) : NEW_LINE INDENT if s [ k ] == t [ k ] : NEW_LINE INDENT temp . append ( s [ k ] ) NEW_LINE DEDENT if ( s [ k ] == ' S ' and t [ k ] == ' E ' ) or ( s [ k ] == ' E ' and t [ k ] == ' S ' ) : NEW_LINE INDENT temp . append ( ' T ' ) NEW_LINE DEDENT if ( s [ k ] == ' S ' and t [ k ] == ' T ' ) or ( s [ k ] == ' T ' and t [ k ] == ' S ' ) : NEW_LINE INDENT temp . append ( ' E ' ) NEW_LINE DEDENT if ( s [ k ] == ' T ' and t [ k ] == ' E ' ) or ( s [ k ] == ' E ' and t [ k ] == ' T ' ) : NEW_LINE INDENT temp . append ( ' S ' ) NEW_LINE DEDENT DEDENT temp = ' ' . join ( temp ) NEW_LINE if temp in T : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans // 3 ) NEW_LINE"]}
{"id": "aizu_p00207_A", "java": ["import java . util . * ; class Main { static int mat [ ] [ ] = new int [ 105 ] [ 105 ] ; public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; for ( ; ; ) { int w = in . nextInt ( ) , h = in . nextInt ( ) ; if ( w == 0 && h == 0 ) return ; int sx = in . nextInt ( ) , sy = in . nextInt ( ) ; int gx = in . nextInt ( ) , gy = in . nextInt ( ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < 105 ; i ++ ) for ( int j = 0 ; j < 105 ; j ++ ) mat [ i ] [ j ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int c = in . nextInt ( ) , d = in . nextInt ( ) , x = in . nextInt ( ) , y = in . nextInt ( ) ; if ( d == 1 ) { for ( int j = 0 ; j < 2 ; j ++ ) for ( int k = 0 ; k < 4 ; k ++ ) mat [ x + j ] [ y + k ] = c ; } else { for ( int j = 0 ; j < 4 ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) mat [ x + j ] [ y + k ] = c ; } } if ( mat [ sx ] [ sy ] == - 1 ) { System . out . println ( \" NG \" ) ; continue ; } dfs ( sx , sy , mat [ sx ] [ sy ] ) ; System . out . println ( ( mat [ gx ] [ gy ] == - 2 ) ? \" OK \" : \" NG \" ) ; } } static void dfs ( int i , int j , int col ) { if ( mat [ i ] [ j ] != col ) return ; mat [ i ] [ j ] = - 2 ; dfs ( i + 1 , j , col ) ; dfs ( i , j + 1 , col ) ; dfs ( i - 1 , j , col ) ; dfs ( i , j - 1 , col ) ; return ; } }"], "python": ["lx , ly = [ 4 , 2 ] , [ 2 , 4 ] NEW_LINE dx = [ - 1 , 0 , 1 , 0 ] NEW_LINE dy = [ 0 , - 1 , 0 , 1 ] NEW_LINE while 1 : NEW_LINE INDENT w , h = map ( int , raw_input ( ) . split ( ) ) NEW_LINE if w == 0 and h == 0 : break NEW_LINE xs , ys = map ( int , raw_input ( ) . split ( ) ) NEW_LINE xg , yg = map ( int , raw_input ( ) . split ( ) ) NEW_LINE f = [ [ 0 for i in range ( 102 ) ] for j in range ( 102 ) ] NEW_LINE s = [ ] NEW_LINE n = input ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT c , d , x , y = map ( int , raw_input ( ) . split ( ) ) NEW_LINE for p in range ( lx [ d ] ) : NEW_LINE INDENT for q in range ( ly [ d ] ) : NEW_LINE INDENT f [ y + q ] [ x + p ] = c NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE if f [ ys ] [ xs ] > 0 and f [ ys ] [ xs ] == f [ yg ] [ xg ] : NEW_LINE INDENT c = f [ ys ] [ xs ] NEW_LINE s . append ( [ xs , ys ] ) NEW_LINE while len ( s ) > 0 : NEW_LINE INDENT x , y = s . pop ( ) NEW_LINE if x == xg and y == yg : NEW_LINE INDENT ans = 1 ; break ; NEW_LINE DEDENT for k in range ( 4 ) : NEW_LINE INDENT if f [ y + dy [ k ] ] [ x + dx [ k ] ] == c : NEW_LINE INDENT s . append ( [ x + dx [ k ] , y + dy [ k ] ] ) NEW_LINE f [ y + dy [ k ] ] [ x + dx [ k ] ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( \" OK \" if ans == 1 else \" NG \" ) NEW_LINE DEDENT", "import sys NEW_LINE from collections import deque NEW_LINE while True : NEW_LINE INDENT W , H = map ( int , input ( ) . split ( ) ) NEW_LINE if W == 0 : NEW_LINE INDENT break NEW_LINE DEDENT ( xs , ys ) , ( xg , yg ) = map ( int , input ( ) . split ( ) ) , map ( int , input ( ) . split ( ) ) NEW_LINE square = [ [ 0 ] * ( W + 2 ) for _ in [ 0 ] * ( H + 2 ) ] NEW_LINE visited = [ [ 0 ] * ( W + 2 ) for _ in [ 0 ] * ( H + 2 ) ] NEW_LINE visited [ ys ] [ xs ] = 1 NEW_LINE N = int ( input ( ) ) NEW_LINE for c , d , from_x , from_y in ( map ( int , sys . stdin . readline ( ) . split ( ) ) for _ in [ 0 ] * N ) : NEW_LINE INDENT to_x , to_y = ( from_x + 4 , from_y + 2 ) if d == 0 else ( from_x + 2 , from_y + 4 ) NEW_LINE for y in range ( from_y , to_y ) : NEW_LINE INDENT square [ y ] [ from_x : to_x ] = [ c ] * ( to_x - from_x ) NEW_LINE DEDENT DEDENT color = square [ ys ] [ xs ] or - 1 NEW_LINE dq = deque ( [ ( ys , xs ) ] ) NEW_LINE popleft , append = dq . popleft , dq . append NEW_LINE while dq : NEW_LINE INDENT y , x = popleft ( ) NEW_LINE if y == yg and x == xg : NEW_LINE INDENT print ( \" OK \" ) NEW_LINE break NEW_LINE DEDENT for ny , nx in ( ( y + 1 , x ) , ( y - 1 , x ) , ( y , x + 1 ) , ( y , x - 1 ) ) : NEW_LINE INDENT if not visited [ ny ] [ nx ] and square [ ny ] [ nx ] == color : NEW_LINE INDENT visited [ ny ] [ nx ] = 1 NEW_LINE append ( ( ny , nx ) ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( \" NG \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1415_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( \" GCD \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + gcd ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1579_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( \" GCD \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + gcd ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4091_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( \" LCM \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + lcm ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM \u2581 of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1572_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( \" LCM \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + lcm ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) / gcd ( a , b ) NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM \u2581 of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1578_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( \" GCD \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + gcd ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT False NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1416_A", "java": ["class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( \" GCD \u2581 of \u2581 \" + a + \" \u2581 and \u2581 \" + b + \" \u2581 is \u2581 \" + gcd ( a , b ) ) ; } }"], "python": ["def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD \u2581 of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not \u2581 found ' ) NEW_LINE DEDENT"]}
{"id": "projecteuler_p188_A", "java": ["public final class p188 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p188 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( tetrationMod ( 1777 , 1855 , Library . pow ( 10 , 8 ) ) ) ; } private static int tetrationMod ( int x , int y , int m ) { if ( y == 1 ) return x % m ; else return Library . powMod ( x , tetrationMod ( x , y - 1 , Library . totient ( m ) ) , m ) ; } }"], "python": ["import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n //= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n //= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_2090_A", "java": ["import java . io . * ; import java . util . * ; class GFG { static int min_sum ( int n , int k , int a [ ] ) { Arrays . sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = arr . length ; System . out . println ( min_sum ( N , K , arr ) ) ; } }"], "python": ["def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( min_sum ( N , K , arr ) ) NEW_LINE DEDENT"]}
{"id": "leetcode_019_A", "java": ["class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow , fast , curr ; slow = head ; fast = head ; for ( int i = 0 ; i < n ; i ++ ) fast = fast . next ; if ( fast == null ) { head = head . next ; return head ; } while ( fast . next != null ) { fast = fast . next ; slow = slow . next ; } curr = slow . next ; slow . next = curr . next ; return head ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1355_A", "java": ["class GFG { static String findMaxLenEven ( String str ) { int n = str . length ( ) ; int i = 0 ; int currlen = 0 ; int maxlen = 0 ; int st = - 1 ; while ( i < n ) { if ( str . charAt ( i ) == ' \u2581 ' ) { if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } currlen = 0 ; } else { currlen ++ ; } i ++ ; } if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } if ( st == - 1 ) return \" - 1\" ; return str . substring ( st , st + maxlen ) ; } public static void main ( String args [ ] ) { String str = \" this \u2581 is \u2581 a \u2581 test \u2581 string \" ; System . out . println ( findMaxLenEven ( str ) ) ; } }"], "python": ["def findMaxLenEven ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE currlen = 0 NEW_LINE maxlen = 0 NEW_LINE st = - 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( str [ i ] == ' \u2581 ' ) : NEW_LINE INDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT currlen = 0 NEW_LINE DEDENT else : NEW_LINE INDENT currlen += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( currlen % 2 == 0 ) : NEW_LINE INDENT if ( maxlen < currlen ) : NEW_LINE INDENT maxlen = currlen NEW_LINE st = i - currlen NEW_LINE DEDENT DEDENT if ( st == - 1 ) : NEW_LINE INDENT print ( \" trie \" ) NEW_LINE return \" - 1\" NEW_LINE DEDENT return str [ st : st + maxlen ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" this \u2581 is \u2581 a \u2581 test \u2581 string \" NEW_LINE print ( findMaxLenEven ( str ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1538_A", "java": ["import java . io . * ; class GFG { static int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; System . out . println ( pairsInSortedRotated ( arr , n , sum ) ) ; } }"], "python": ["def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 7 , 9 , 10 ] NEW_LINE s = 16 NEW_LINE print ( pairsInSortedRotated ( arr , 6 , s ) ) NEW_LINE"]}
{"id": "projecteuler_p129_A", "java": ["public final class p129 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p129 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { for ( int n = LIMIT ; ; n ++ ) { if ( findLeastDivisibleRepunit ( n ) > LIMIT ) return Integer . toString ( n ) ; } } private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( \" Arithmetic \u2581 overflow \" ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } }"], "python": ["import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4203_A", "java": ["class GFG { static int getPassingCars ( int A [ ] , int n ) { int countOne = 0 , result = 0 ; while ( n >= 1 ) { if ( A [ n - 1 ] == 1 ) countOne ++ ; else result += countOne ; n -- ; } return result ; } public static void main ( String [ ] args ) { int A [ ] = { 0 , 1 , 0 , 1 , 1 } ; int n = A . length ; System . out . println ( getPassingCars ( A , n ) ) ; } }"], "python": ["def getPassingCars ( A , n ) : NEW_LINE INDENT countOne = 0 ; result = 0 NEW_LINE while n >= 1 : NEW_LINE INDENT if A [ n - 1 ] == 1 : NEW_LINE INDENT countOne += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += countOne NEW_LINE DEDENT n -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE print ( getPassingCars ( A , n ) ) NEW_LINE"]}
{"id": "projecteuler_p046_A", "java": ["public final class p046 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p046 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 9 ; ; i += 2 ) { if ( ! satisfiesConjecture ( i ) ) return Integer . toString ( i ) ; } } private static boolean satisfiesConjecture ( int n ) { if ( n % 2 == 0 || Library . isPrime ( n ) ) return true ; for ( int i = 1 ; i * i * 2 <= n ; i ++ ) { if ( Library . isPrime ( n - i * i * 2 ) ) return true ; } return false ; } }"], "python": ["import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = next ( itertools . filterfalse ( test_goldbach , itertools . count ( 9 , 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def test_goldbach ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in itertools . count ( 1 ) : NEW_LINE INDENT k = n - 2 * i * i NEW_LINE if k <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif eulerlib . is_prime ( k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1200_B", "java": ["import java . util . Scanner ; public class BlockAdventure { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( int t = in . nextInt ( ) ; t > 0 ; t -- ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int k = in . nextInt ( ) ; int prev = in . nextInt ( ) ; boolean answer = true ; for ( int i = 1 ; i < n ; i ++ ) { int next = in . nextInt ( ) ; m += prev - Math . max ( 0 , ( next - k ) ) ; prev = next ; if ( m < 0 ) { answer = false ; } } System . out . println ( answer ? \" YES \" : \" NO \" ) ; } } }", "import java . util . * ; public class climb { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t , j , n , m , k , i , h [ ] , d ; t = sc . nextInt ( ) ; for ( j = 1 ; j <= t ; j ++ ) { n = sc . nextInt ( ) ; m = sc . nextInt ( ) ; k = sc . nextInt ( ) ; h = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) h [ i ] = sc . nextInt ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( h [ i + 1 ] >= h [ i ] ) { d = h [ i + 1 ] - h [ i ] ; if ( d > k ) { if ( d - k <= m ) m = m - d + k ; else break ; } else { d = k - d ; m = m + Math . min ( d , h [ i ] ) ; } } else { d = h [ i ] - h [ i + 1 ] ; m = m + d + Math . min ( k , h [ i + 1 ] ) ; } } if ( i != n - 1 ) System . out . println ( \" NO \" ) ; else System . out . println ( \" YES \" ) ; } } }", "import java . util . Scanner ; public class BlockAdventure { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( int t = in . nextInt ( ) ; t > 0 ; t -- ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int k = in . nextInt ( ) ; int prev = in . nextInt ( ) ; boolean answer = true ; for ( int i = 1 ; i < n ; i ++ ) { int next = in . nextInt ( ) ; m += prev - Math . max ( 0 , ( next - k ) ) ; prev = next ; if ( m < 0 ) { answer = false ; } } System . out . println ( answer ? \" YES \" : \" NO \" ) ; } } }", "import java . util . Scanner ; public class BlockAdventure { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; for ( int t = in . nextInt ( ) ; t > 0 ; t -- ) { int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int k = in . nextInt ( ) ; int prev = in . nextInt ( ) ; boolean answer = true ; for ( int i = 1 ; i < n ; i ++ ) { int next = in . nextInt ( ) ; m += prev - Math . max ( 0 , ( next - k ) ) ; prev = next ; if ( m < 0 ) { answer = false ; } } System . out . println ( answer ? \" YES \" : \" NO \" ) ; } } }", "import java . io . * ; import java . util . * ; public class Run { public static void main ( String [ ] Z ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringBuilder op = new StringBuilder ( ) ; StringTokenizer stz ; int T = Integer . parseInt ( br . readLine ( ) ) ; while ( T -- > 0 ) { stz = new StringTokenizer ( br . readLine ( ) ) ; int n = Integer . parseInt ( stz . nextToken ( ) ) ; int m = Integer . parseInt ( stz . nextToken ( ) ) ; int k = Integer . parseInt ( stz . nextToken ( ) ) ; int [ ] arr = new int [ n ] ; stz = new StringTokenizer ( br . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = Integer . parseInt ( stz . nextToken ( ) ) ; } boolean poss = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int now = arr [ i ] ; int next = arr [ i + 1 ] ; if ( now < next ) { if ( next - now > k ) { if ( m >= ( next - now - k ) ) m -= next - now - k ; else { poss = false ; break ; } } else { int add = now - next + k ; if ( add > now ) add = now ; m += add ; } } else { int add = now - next + k ; if ( add > now ) add = now ; m += add ; } } if ( poss ) op . append ( \" YES \\n \" ) ; else op . append ( \" NO \\n \" ) ; } System . out . println ( op ) ; } }"], "python": ["for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT x = min ( k - l [ i + 1 ] , 0 ) NEW_LINE m += ( l [ i ] + x ) NEW_LINE if m < 0 : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if i == n - 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( \" \u2581 \" ) ) NEW_LINE hv = list ( map ( int , input ( ) . split ( \" \u2581 \" ) ) ) NEW_LINE f = True NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m += hv [ i ] - max ( 0 , hv [ i + 1 ] - k ) NEW_LINE if m < 0 : NEW_LINE INDENT f = False NEW_LINE break NEW_LINE DEDENT DEDENT if f : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT", "import sys NEW_LINE input = sys . stdin . readline NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE w = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT c = max ( 0 , w [ i + 1 ] - k ) NEW_LINE m += w [ i ] - c NEW_LINE if m < 0 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE while ( t ) : NEW_LINE INDENT t -= 1 NEW_LINE n , m , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k is None or k == ' ' : NEW_LINE INDENT k = 0 NEW_LINE DEDENT arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m += arr [ i - 1 ] - max ( 0 , arr [ i ] - k ) NEW_LINE if m < 0 : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT", "import math NEW_LINE t = int ( input ( ) ) NEW_LINE for t in range ( t ) : NEW_LINE INDENT n , blocks , k = map ( int , input ( ) . split ( ) ) NEW_LINE towers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE yes = True NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT blocks += towers [ i ] - max ( ( towers [ i + 1 ] - k ) , 0 ) NEW_LINE if ( blocks < 0 ) : NEW_LINE INDENT yes = False NEW_LINE DEDENT DEDENT if ( yes ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_646_A", "java": ["class GFG { static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = arr . length ; System . out . print ( findMinRemoval ( arr , n ) + \" \\n \" ) ; } }"], "python": ["def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5094_A", "java": ["import java . io . * ; class GFG { static void find ( int n ) { String [ ] arr = new String [ n + 1 ] ; arr [ 0 ] = \" \" ; int size = 1 , m = 1 ; while ( size <= n ) { for ( int i = 0 ; i < m && ( size + i ) <= n ; i ++ ) arr [ size + i ] = \"3\" + arr [ size - m + i ] ; for ( int i = 0 ; i < m && ( size + m + i ) <= n ; i ++ ) arr [ size + m + i ] = \"4\" + arr [ size - m + i ] ; m = m << 1 ; size = size + m ; } System . out . println ( arr [ n ] ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 16 ; i ++ ) find ( i ) ; } }"], "python": ["def find ( n ) : NEW_LINE INDENT arr = [ ' ' ] * ( n + 1 ) ; NEW_LINE size = 1 ; NEW_LINE m = 1 ; NEW_LINE while ( size <= n ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( i < m and ( size + i ) <= n ) : NEW_LINE INDENT arr [ size + i ] = \"3\" + arr [ size - m + i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( i < m and ( size + m + i ) <= n ) : NEW_LINE INDENT arr [ size + m + i ] = \"4\" + arr [ size - m + i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT m = m << 1 ; NEW_LINE size = size + m ; NEW_LINE DEDENT print ( arr [ n ] ) ; NEW_LINE DEDENT for i in range ( 1 , 16 ) : NEW_LINE INDENT find ( i ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3059_A", "java": ["import java . util . * ; class GFG { static String maxValue ( char [ ] a , char [ ] b ) { Arrays . sort ( b ) ; int n = a . length ; int m = b . length ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String a = \"1234\" ; String b = \"4321\" ; System . out . print ( maxValue ( a . toCharArray ( ) , b . toCharArray ( ) ) ) ; } }"], "python": ["def maxValue ( a , b ) : NEW_LINE INDENT b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT x = \" \" . join ( ai ) NEW_LINE return x NEW_LINE DEDENT a = \"1234\" NEW_LINE b = \"4321\" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE"]}
{"id": "codeforces_558_A", "java": ["import javafx . util . Pair ; import java . util . ArrayList ; import java . util . Collections ; import java . util . Comparator ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < Pair < Integer , Integer > > N_arr = new ArrayList < Pair < Integer , Integer > > ( ) ; ArrayList < Pair < Integer , Integer > > P_arr = new ArrayList < Pair < Integer , Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) , a = sc . nextInt ( ) ; if ( x < 0 ) N_arr . add ( new Pair < > ( x , a ) ) ; else P_arr . add ( new Pair < > ( x , a ) ) ; } Collections . sort ( N_arr , Comparator . comparing ( p -> - p . getKey ( ) ) ) ; Collections . sort ( P_arr , Comparator . comparing ( p -> p . getKey ( ) ) ) ; int sum = 0 ; if ( N_arr . size ( ) == P_arr . size ( ) ) { for ( int i = 0 ; i < N_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; } else if ( N_arr . size ( ) < P_arr . size ( ) ) { for ( int i = 0 ; i < N_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; sum += P_arr . get ( N_arr . size ( ) ) . getValue ( ) ; } else { for ( int i = 0 ; i < P_arr . size ( ) ; i ++ ) sum += N_arr . get ( i ) . getValue ( ) + P_arr . get ( i ) . getValue ( ) ; sum += N_arr . get ( P_arr . size ( ) ) . getValue ( ) ; } System . out . println ( sum ) ; } }", "import java . util . * ; public class Car { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arr1 = new int [ n + 1 ] ; int [ ] arr2 = new int [ n + 1 ] ; int count = 0 ; int numNeg = 0 ; int numPos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr1 [ i ] = sc . nextInt ( ) ; arr2 [ i ] = sc . nextInt ( ) ; if ( arr1 [ i ] < 0 ) numNeg ++ ; else numPos ++ ; } arr1 [ n ] = 0 ; arr2 [ n ] = 0 ; int temp = 0 ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr1 [ i ] < arr1 [ j ] ) { temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ j ] ; arr1 [ j ] = temp ; temp = arr2 [ i ] ; arr2 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } } } int index = Arrays . binarySearch ( arr1 , 0 ) ; int i ; for ( i = 1 ; i <= Math . min ( numNeg , numPos ) ; i ++ ) { count += arr2 [ index + i ] + arr2 [ index - i ] ; } if ( numNeg > numPos ) count += arr2 [ index - i ] ; if ( numPos > numNeg ) count += arr2 [ index + i ] ; System . out . print ( count ) ; } }", "import java . util . PriorityQueue ; import java . util . Queue ; import java . util . Scanner ; public class Main { static class Node { Long index ; Long data ; public Node ( Long index , Long data ) { this . index = index ; this . data = data ; } } static Queue < Node > q1 ; static Queue < Node > q2 ; static Node temp ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; q1 = new PriorityQueue < > ( ( o1 , o2 ) -> ( int ) ( o2 . index - o1 . index ) ) ; q2 = new PriorityQueue < > ( ( o1 , o2 ) -> ( int ) ( o1 . index - o2 . index ) ) ; for ( int i = 0 ; i < N ; i ++ ) { Long index = sc . nextLong ( ) ; Long data = sc . nextLong ( ) ; temp = new Node ( index , data ) ; if ( index < 0 ) { q1 . add ( temp ) ; } else { q2 . add ( temp ) ; } } int len1 = q1 . size ( ) ; int len2 = q2 . size ( ) ; Long res = 0L ; if ( len1 < len2 ) { while ( ! q1 . isEmpty ( ) ) { res += q1 . poll ( ) . data ; res += q2 . poll ( ) . data ; } res += q2 . poll ( ) . data ; } else if ( len1 > len2 ) { while ( ! q2 . isEmpty ( ) ) { res += q1 . poll ( ) . data ; res += q2 . poll ( ) . data ; } res += q1 . poll ( ) . data ; } else { while ( ! q1 . isEmpty ( ) && ! q2 . isEmpty ( ) ) { res += q1 . poll ( ) . data ; res += q2 . poll ( ) . data ; } } System . out . println ( res ) ; } }"], "python": ["import math NEW_LINE def _input ( ) : return map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ ] ; b = [ ] NEW_LINE res = 0 NEW_LINE for _ in range ( n ) : NEW_LINE INDENT i , j = _input ( ) NEW_LINE if i < 0 : a . append ( ( - i , j ) ) NEW_LINE elif i > 0 : b . append ( ( i , j ) ) NEW_LINE else : res += j NEW_LINE DEDENT a . sort ( ) ; b . sort ( ) NEW_LINE la = len ( a ) ; lb = len ( b ) NEW_LINE if la > lb + 1 : la = lb + 1 NEW_LINE elif lb > la + 1 : lb = la + 1 NEW_LINE for i in range ( la ) : res += a [ i ] [ 1 ] NEW_LINE for i in range ( lb ) : res += b [ i ] [ 1 ] NEW_LINE print ( res ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE left = [ ] NEW_LINE right = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a < 0 : NEW_LINE INDENT left . append ( [ a , b ] ) NEW_LINE DEDENT else : NEW_LINE INDENT right . append ( [ a , b ] ) NEW_LINE DEDENT DEDENT right = sorted ( right ) ; left = sorted ( left , reverse = True ) NEW_LINE su = 0 NEW_LINE a = left ; b = right NEW_LINE if len ( right ) > len ( left ) : a , b = b , a NEW_LINE while b != [ ] : NEW_LINE INDENT su += a [ 0 ] [ 1 ] + b [ 0 ] [ 1 ] NEW_LINE a . pop ( 0 ) ; b . pop ( 0 ) NEW_LINE DEDENT if a != [ ] : su += a [ 0 ] [ 1 ] NEW_LINE print ( su ) NEW_LINE", "import bisect NEW_LINE n = int ( input ( ) ) NEW_LINE t = sorted ( tuple ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ) NEW_LINE b = bisect . bisect_left ( t , ( 0 , 0 ) ) NEW_LINE l = min ( b , n - b ) + 1 NEW_LINE res = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT if b + i < n : NEW_LINE INDENT res += t [ b + i ] [ 1 ] NEW_LINE DEDENT if b - i - 1 >= 0 : NEW_LINE INDENT res += t [ b - i - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT print ( res ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE x = n * [ 0 ] NEW_LINE a = n * [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x [ i ] , a [ i ] = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT bish = x [ 0 ] NEW_LINE k = 0 NEW_LINE for j in range ( 1 , n - i ) : NEW_LINE INDENT if x [ j ] > bish : NEW_LINE INDENT bish = x [ j ] NEW_LINE k = j NEW_LINE DEDENT DEDENT x [ n - 1 - i ] , x [ k ] = x [ k ] , x [ n - 1 - i ] NEW_LINE a [ n - 1 - i ] , a [ k ] = a [ k ] , a [ n - 1 - i ] NEW_LINE DEDENT manfi = 0 NEW_LINE mosbat = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x [ i ] > 0 : NEW_LINE INDENT mosbat += 1 NEW_LINE DEDENT else : NEW_LINE INDENT manfi += 1 NEW_LINE DEDENT DEDENT if manfi == mosbat : NEW_LINE INDENT print ( sum ( a ) ) NEW_LINE DEDENT elif mosbat > manfi : NEW_LINE INDENT print ( sum ( a [ : manfi * 2 + 1 ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( a [ manfi - ( mosbat + 1 ) : ] ) ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE pos = [ ] NEW_LINE neg = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , a = map ( int , input ( ) . split ( ) ) NEW_LINE if x > 0 : NEW_LINE INDENT pos . append ( ( x , a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT neg . append ( ( x , a ) ) NEW_LINE DEDENT DEDENT pos . sort ( ) NEW_LINE neg . sort ( reverse = True ) NEW_LINE pos = [ x for _ , x in pos ] NEW_LINE neg = [ x for _ , x in neg ] NEW_LINE if len ( pos ) == len ( neg ) : NEW_LINE INDENT print ( sum ( pos ) + sum ( neg ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ml = min ( len ( pos ) , len ( neg ) ) NEW_LINE total = sum ( pos [ : ml ] ) + sum ( neg [ : ml ] ) NEW_LINE if len ( pos ) > ml : NEW_LINE INDENT total += pos [ ml ] NEW_LINE DEDENT else : NEW_LINE INDENT total += neg [ ml ] NEW_LINE DEDENT print ( total ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4777_A", "java": ["import java . math . * ; class GFG { static float geometricMean ( int arr [ ] , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . pow ( product , ( float ) 1 / n ) ; return gm ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( geometricMean ( arr , n ) ) ; } }"], "python": ["import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( geometricMean ( arr , n ) ) ) NEW_LINE"]}
{"id": "atcoder_ABC173_E", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; int mod = ( int ) Math . pow ( 10 , 9 ) + 7 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) % mod ; } Arrays . sort ( a ) ; int left = 0 ; int right = n - 1 ; long ans = k % 2 == 0 ? 1 : a [ right -- ] ; int c = 1 ; if ( ans < 0 ) c = - 1 ; while ( k >= 2 ) { if ( c * a [ left ] * a [ left + 1 ] > c * a [ right ] * a [ right - 1 ] ) { ans = ans * a [ left ] % mod ; ans = ans * a [ left + 1 ] % mod ; left += 2 ; } else { ans = ans * a [ right ] % mod ; ans = ans * a [ right - 1 ] % mod ; right -= 2 ; } k -= 2 ; } if ( ans < 0 ) ans += mod ; System . out . println ( ans ) ; } }", "import java . util . * ; public class Main { static final int MOD = ( int ) 1e9 + 7 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = Integer . parseInt ( sc . next ( ) ) ; int k = Integer . parseInt ( sc . next ( ) ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Long . parseLong ( sc . next ( ) ) ; } Arrays . sort ( a ) ; int l = 0 ; int r = n - 1 ; long ans = k % 2 == 0 ? 1 : a [ r -- ] ; int b = ans <= 0 ? - 1 : 1 ; while ( k > 1 ) { long m = a [ l ] * a [ l + 1 ] ; long p = a [ r ] * a [ r - 1 ] ; if ( m * b >= p * b ) { ans = ans * ( m % MOD ) % MOD ; l += 2 ; } else { ans = ans * ( p % MOD ) % MOD ; r -= 2 ; } k -= 2 ; } System . out . println ( ( ans + MOD ) % MOD ) ; } }"], "python": ["n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a = sorted ( a ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE ans = 1 NEW_LINE if ( k % 2 == 0 or a [ - 1 ] >= 0 ) : NEW_LINE INDENT mlt1 = a [ 0 ] * a [ 1 ] NEW_LINE mlt2 = a [ - 2 ] * a [ - 1 ] NEW_LINE l = 0 NEW_LINE r = - 1 NEW_LINE for i in range ( k // 2 ) : NEW_LINE INDENT if ( mlt1 >= mlt2 ) : NEW_LINE INDENT ans *= mlt1 % mod NEW_LINE l += 2 NEW_LINE if ( l <= n - 2 ) : NEW_LINE INDENT mlt1 = a [ l + 1 ] * a [ l ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans *= mlt2 % mod NEW_LINE r -= 2 NEW_LINE if ( r >= - n + 1 ) : NEW_LINE INDENT mlt2 = a [ r - 1 ] * a [ r ] NEW_LINE DEDENT DEDENT ans %= mod NEW_LINE DEDENT if ( k % 2 == 1 ) : NEW_LINE INDENT ans *= a [ r ] NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT ans *= a [ n - 1 - i ] NEW_LINE ans %= mod NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "import operator NEW_LINE from functools import reduce NEW_LINE N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE positives = [ a for a in A if a > 0 ] NEW_LINE negatives = [ a for a in A if a < 0 ] NEW_LINE positive_cnt = len ( positives ) NEW_LINE negative_cnt = len ( negatives ) NEW_LINE zero_cnt = A . count ( 0 ) NEW_LINE if 2 * min ( K // 2 , negative_cnt // 2 ) + positive_cnt >= K : NEW_LINE INDENT ans = 1 NEW_LINE positives . sort ( key = lambda x : abs ( x ) , reverse = True ) NEW_LINE negatives . sort ( key = lambda x : abs ( x ) , reverse = True ) NEW_LINE if K % 2 == 1 : NEW_LINE INDENT ans *= positives . pop ( 0 ) NEW_LINE K -= 1 NEW_LINE DEDENT X = [ ] NEW_LINE for pair in zip ( * [ iter ( positives ) ] * 2 ) : NEW_LINE INDENT X . append ( reduce ( operator . mul , pair , 1 ) ) NEW_LINE DEDENT for pair in zip ( * [ iter ( negatives ) ] * 2 ) : NEW_LINE INDENT X . append ( reduce ( operator . mul , pair , 1 ) ) NEW_LINE DEDENT X . sort ( reverse = True ) NEW_LINE ans *= reduce ( lambda a , b : a * b % MOD , X [ : K // 2 ] , 1 ) NEW_LINE print ( ans % MOD ) NEW_LINE DEDENT elif zero_cnt : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT A . sort ( key = lambda x : abs ( x ) ) NEW_LINE print ( reduce ( lambda a , b : a * b % MOD , A [ : K ] , 1 ) % MOD ) NEW_LINE DEDENT", "mod = 10 ** 9 + 7 NEW_LINE def func ( A , n , k ) : NEW_LINE INDENT A . sort ( ) NEW_LINE product = 1 NEW_LINE if ( A [ n - 1 ] == 0 and ( k & 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( A [ n - 1 ] <= 0 and ( k & 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 , n - k - 1 , - 1 ) : NEW_LINE INDENT product = ( product * A [ i ] ) % mod NEW_LINE DEDENT return product % mod NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE if ( k & 1 ) : NEW_LINE INDENT product = ( product * A [ j ] ) % mod NEW_LINE j -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT k >>= 1 NEW_LINE for itr in range ( k ) : NEW_LINE INDENT left_product = ( A [ i ] * A [ i + 1 ] ) NEW_LINE right_product = ( A [ j ] * A [ j - 1 ] ) NEW_LINE if ( left_product > right_product ) : NEW_LINE INDENT product = ( product * ( left_product ) % mod ) % mod NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT product = ( ( right_product % mod ) * product ) % mod NEW_LINE j -= 2 NEW_LINE DEDENT DEDENT return product % mod NEW_LINE DEDENT n , k = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = func ( arr , n , k ) NEW_LINE print ( ans ) NEW_LINE NEW_LINE", "import sys NEW_LINE import heapq NEW_LINE input = sys . stdin . readline NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE def main ( ) : NEW_LINE INDENT N , K = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE pos = [ ] NEW_LINE neg = [ ] NEW_LINE for a in A : NEW_LINE INDENT if a >= 0 : NEW_LINE INDENT pos . append ( a ) NEW_LINE DEDENT else : NEW_LINE INDENT neg . append ( a ) NEW_LINE DEDENT DEDENT flag = False NEW_LINE if N == K : NEW_LINE INDENT ans = 1 NEW_LINE for a in A : NEW_LINE INDENT ans *= a NEW_LINE ans %= MOD NEW_LINE DEDENT print ( ans % MOD ) NEW_LINE exit ( ) NEW_LINE DEDENT if len ( pos ) > 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if K % 2 == 0 : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE if not flag : NEW_LINE INDENT h = [ abs ( x ) for x in A ] NEW_LINE heapq . heapify ( h ) NEW_LINE for i in range ( K ) : NEW_LINE INDENT ans *= heapq . heappop ( h ) NEW_LINE ans %= MOD NEW_LINE DEDENT ans *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT hpos = [ - x for x in pos ] NEW_LINE heapq . heapify ( hpos ) NEW_LINE hneg = neg [ : ] NEW_LINE heapq . heapify ( hneg ) NEW_LINE if K % 2 == 1 : NEW_LINE INDENT ans *= - heapq . heappop ( hpos ) NEW_LINE ans %= MOD NEW_LINE DEDENT pairs = [ ] NEW_LINE while len ( hpos ) >= 2 : NEW_LINE INDENT x = - heapq . heappop ( hpos ) NEW_LINE x *= - heapq . heappop ( hpos ) NEW_LINE heapq . heappush ( pairs , - x ) NEW_LINE DEDENT while len ( hneg ) >= 2 : NEW_LINE INDENT x = heapq . heappop ( hneg ) NEW_LINE x *= heapq . heappop ( hneg ) NEW_LINE heapq . heappush ( pairs , - x ) NEW_LINE DEDENT if len ( pairs ) : NEW_LINE INDENT for i in range ( K // 2 ) : NEW_LINE INDENT ans *= - heapq . heappop ( pairs ) NEW_LINE ans %= MOD NEW_LINE DEDENT DEDENT DEDENT print ( ans % MOD ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a_pos = sorted ( [ i for i in a if i >= 0 ] ) NEW_LINE a_neg = sorted ( [ i for i in a if i < 0 ] , reverse = True ) NEW_LINE mod = 10 ** 9 + 7 NEW_LINE ans = 1 NEW_LINE if len ( a_pos ) == 0 and k % 2 : NEW_LINE INDENT for i in a_neg [ : k ] : NEW_LINE INDENT ans = ans * i % mod NEW_LINE DEDENT print ( ans ) NEW_LINE exit ( ) NEW_LINE DEDENT while k > 0 : NEW_LINE INDENT if k == 1 or len ( a_neg ) <= 1 : NEW_LINE INDENT if len ( a_pos ) == 0 : NEW_LINE INDENT ans *= a_neg . pop ( ) NEW_LINE DEDENT elif len ( a_pos ) > 0 : NEW_LINE INDENT ans *= a_pos . pop ( ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT elif len ( a_pos ) <= 1 : NEW_LINE INDENT ans *= a_neg . pop ( ) * a_neg . pop ( ) NEW_LINE k -= 2 NEW_LINE DEDENT elif a_pos [ - 1 ] * a_pos [ - 2 ] > a_neg [ - 1 ] * a_neg [ - 2 ] : NEW_LINE INDENT ans *= a_pos . pop ( ) NEW_LINE k -= 1 NEW_LINE DEDENT elif a_pos [ 0 ] * a_pos [ 1 ] <= a_neg [ - 1 ] * a_neg [ - 2 ] : NEW_LINE INDENT ans *= a_neg . pop ( ) * a_neg . pop ( ) NEW_LINE k -= 2 NEW_LINE DEDENT ans %= mod NEW_LINE DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_4307_A", "java": ["import java . util . Scanner ; class Pattern { static void display ( int n ) { int i , j , k ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 , k = i ; j <= i ; j ++ , k -- ) { if ( k % 2 == 0 ) { System . out . print ( j ) ; } else { System . out . print ( \" * \" ) ; } } System . out . print ( \" \\n \" ) ; } } public static void main ( String [ ] args ) { int n = 5 ; display ( n ) ; } }"], "python": ["def display ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = i NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if k % 2 == 0 : NEW_LINE INDENT print ( j , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE display ( n ) NEW_LINE"]}
{"id": "geeksforgeeks_4181_A", "java": ["public class CountXor { static int countXorPair ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; System . out . println ( countXorPair ( arr , arr . length ) ) ; } }"], "python": ["def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3422_A", "java": ["import java . util . * ; class GFG { static double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( Math . abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; } static void findSqrt ( double n ) { double i = 1 ; boolean found = false ; while ( ! found ) { if ( i * i == n ) { System . out . println ( i ) ; found = true ; } else if ( i * i > n ) { double res = Square ( n , i - 1 , i ) ; System . out . printf ( \" % .5f \" , res ) ; found = true ; } i ++ ; } } public static void main ( String [ ] args ) { double n = 3 ; findSqrt ( n ) ; } }"], "python": ["import math NEW_LINE def Square ( n , i , j ) : NEW_LINE INDENT mid = ( i + j ) / 2 ; NEW_LINE mul = mid * mid ; NEW_LINE if ( ( mul == n ) or ( abs ( mul - n ) < 0.00001 ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT elif ( mul < n ) : NEW_LINE INDENT return Square ( n , mid , j ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return Square ( n , i , mid ) ; NEW_LINE DEDENT DEDENT def findSqrt ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE found = False ; NEW_LINE while ( found == False ) : NEW_LINE INDENT if ( i * i == n ) : NEW_LINE INDENT print ( i ) ; NEW_LINE found = True ; NEW_LINE DEDENT elif ( i * i > n ) : NEW_LINE INDENT res = Square ( n , i - 1 , i ) ; NEW_LINE print ( \" { 0 : . 5f } \" . format ( res ) ) NEW_LINE found = True NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE findSqrt ( n ) ; NEW_LINE DEDENT"]}
{"id": "aizu_p01305_A", "java": ["import java . util . Scanner ; public class Main { static int [ ] a ; static int [ ] b ; static boolean [ ] k ; static int z ; static void dfs ( int x , int pa , int pb ) { if ( x == 9 ) { z += pb < pa ? 1 : 0 ; return ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( k [ i ] ) continue ; k [ i ] = true ; dfs ( x + 1 , pa + ( b [ x ] < a [ i ] ? a [ i ] + b [ x ] : 0 ) , pb + ( b [ x ] < a [ i ] ? 0 : a [ i ] + b [ x ] ) ) ; k [ i ] = false ; } } public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int N = sc . nextInt ( ) ; while ( N -- != 0 ) { a = new int [ 9 ] ; b = new int [ 9 ] ; k = new boolean [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) b [ i ] = sc . nextInt ( ) ; z = 0 ; dfs ( 0 , 0 , 0 ) ; int bb = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 ; double t = z * 1.0 / bb ; System . out . printf ( \" % .5f \u2581 % .5f \\n \" , t , 1 - t ) ; } } } }", "import java . util . * ; import static java . util . Arrays . * ; import static java . lang . Math . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; static int S , T ; static void f ( int sum , int [ ] a , int [ ] b ) { if ( a . length == 0 ) { if ( sum >= 0 ) S ++ ; T ++ ; return ; } int [ ] na = new int [ a . length - 1 ] ; for ( int i = 0 ; i < a . length - 1 ; i ++ ) na [ i ] = a [ i + 1 ] ; for ( int i = 0 ; i < b . length ; i ++ ) { int [ ] nb = new int [ b . length - 1 ] ; int p = 0 ; for ( int k = 0 ; k < b . length ; k ++ ) { if ( i == k ) continue ; nb [ p ] = b [ k ] ; p ++ ; } int win = a [ 0 ] > b [ i ] ? a [ 0 ] + b [ i ] : - ( a [ 0 ] + b [ i ] ) ; f ( sum + win , na , nb ) ; } } public static void main ( String [ ] args ) { int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] a = new int [ 9 ] , b = new int [ 9 ] ; for ( int j = 0 ; j < 9 ; j ++ ) a [ j ] = sc . nextInt ( ) ; for ( int j = 0 ; j < 9 ; j ++ ) b [ j ] = sc . nextInt ( ) ; S = 0 ; T = 0 ; f ( 0 , a , b ) ; double p = ( double ) S / ( double ) T ; System . out . printf ( \" % .5f \u2581 % .5f \" , p , ( 1.0 - p ) ) ; System . out . println ( ) ; } } }", "import java . util . * ; public class Main { int p1 , p2 ; boolean [ ] used ; int [ ] c1 , c2 , per ; void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; while ( n -- > 0 ) { c1 = new int [ 9 ] ; c2 = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) c1 [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < 9 ; i ++ ) c2 [ i ] = sc . nextInt ( ) ; p1 = 0 ; p2 = 0 ; used = new boolean [ 9 ] ; per = new int [ 9 ] ; dfs ( 0 ) ; double all = p1 + p2 ; System . out . printf ( \" % .5f \u2581 % .5f \\n \" , p1 / all , p2 / all ) ; } } void dfs ( int pos ) { if ( pos == 9 ) { int s1 = 0 , s2 = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( c1 [ per [ i ] ] > c2 [ i ] ) s1 += c1 [ per [ i ] ] + c2 [ i ] ; else s2 += c1 [ per [ i ] ] + c2 [ i ] ; } if ( s1 > s2 ) p1 ++ ; if ( s1 < s2 ) p2 ++ ; return ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( used [ i ] ) continue ; used [ i ] = true ; per [ pos ] = i ; dfs ( pos + 1 ) ; used [ i ] = false ; } } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } }", "import java . util . Scanner ; public class Main { public static int [ ] G = new int [ 9 ] ; public static int [ ] J = new int [ 9 ] ; public static int [ ] G2 = new int [ 9 ] ; public static boolean [ ] used = new boolean [ 9 ] ; public static int win = 0 ; public static int lose = 0 ; public static int draw = 0 ; public static void main ( String [ ] args ) { doIt ( ) ; } public static void doIt ( ) { Scanner sc = new Scanner ( System . in ) ; int num = sc . nextInt ( ) ; for ( int i = 0 ; i < num ; i ++ ) { for ( int j = 0 ; j < 9 ; j ++ ) { G [ j ] = sc . nextInt ( ) ; } for ( int j = 0 ; j < 9 ; j ++ ) { J [ j ] = sc . nextInt ( ) ; } win = 0 ; lose = 0 ; draw = 0 ; setOrder ( 0 ) ; double g = ( double ) win / ( double ) ( win + lose + draw ) ; double j = ( double ) lose / ( double ) ( win + lose + draw ) ; System . out . printf ( \" % .5f \u2581 % .5f \\n \" , g , j ) ; } } public static void battle ( ) { int g = 0 , j = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( G2 [ i ] < J [ i ] ) { j += G2 [ i ] + J [ i ] ; } else { g += G2 [ i ] + J [ i ] ; } } if ( j > g ) { lose ++ ; } else if ( g > j ) { win ++ ; } else { draw ++ ; } } public static void setOrder ( int depth ) { if ( depth == 9 ) { battle ( ) ; } for ( int i = 0 ; i < 9 ; i ++ ) { if ( used [ i ] == false ) { used [ i ] = true ; G2 [ depth ] = G [ i ] ; setOrder ( depth + 1 ) ; used [ i ] = false ; } } } }", "import java . util . Scanner ; import java . util . function . Consumer ; import java . util . stream . IntStream ; public class Main { static void swap ( int a [ ] , int l , int r ) { int tmp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = tmp ; } static void perm ( int [ ] a , int loc , int len , Consumer < int [ ] > f ) { if ( loc + 1 == len ) { f . accept ( a ) ; return ; } perm ( a , loc + 1 , len , f ) ; for ( int i = loc + 1 ; i < a . length ; i ++ ) { swap ( a , loc , i ) ; perm ( a , loc + 1 , len , f ) ; swap ( a , loc , i ) ; } } public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int [ ] gates = IntStream . range ( 0 , 9 ) . map ( d -> sc . nextInt ( ) ) . toArray ( ) ; int [ ] jackies = IntStream . range ( 0 , 9 ) . map ( d -> sc . nextInt ( ) ) . toArray ( ) ; int [ ] counts = new int [ 2 ] ; perm ( gates , 0 , 9 , ( int [ ] g ) -> { int gp = 0 , jp = 0 ; for ( int j = 0 ; j < 9 ; j ++ ) { if ( g [ j ] > jackies [ j ] ) { gp += ( g [ j ] + jackies [ j ] ) ; } else { jp += ( jackies [ j ] + g [ j ] ) ; } } if ( gp > jp ) { counts [ 0 ] ++ ; } else { counts [ 1 ] ++ ; } } ) ; double total = counts [ 0 ] + counts [ 1 ] ; System . out . printf ( \" % .5f \u2581 % .5f \\n \" , counts [ 0 ] / total , counts [ 1 ] / total ) ; } } } }"], "python": ["from itertools import permutations as pm NEW_LINE def main ( ) : NEW_LINE INDENT t = int ( input ( ) ) NEW_LINE fact9 = 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 NEW_LINE for _ in range ( t ) : NEW_LINE INDENT l1 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE l2 = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for hand in pm ( l2 , 9 ) : NEW_LINE INDENT score1 = 0 NEW_LINE score2 = 0 NEW_LINE for i , j in zip ( l1 , hand ) : NEW_LINE INDENT if i < j : NEW_LINE INDENT score2 += ( i + j ) NEW_LINE DEDENT else : NEW_LINE INDENT score1 += ( i + j ) NEW_LINE DEDENT DEDENT if score1 < score2 : NEW_LINE INDENT ans2 += 1 NEW_LINE DEDENT elif score1 > score2 : NEW_LINE INDENT ans1 += 1 NEW_LINE DEDENT DEDENT print ( ans1 / fact9 , ans2 / fact9 ) NEW_LINE DEDENT DEDENT main ( ) NEW_LINE", "import math NEW_LINE from decimal import Decimal , ROUND_HALF_UP NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT a , b = tuple ( sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) ) , tuple ( sorted ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE c = 0 NEW_LINE q = { ( ) : ( 0 , 0 ) } NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nq = { } NEW_LINE for k in q : NEW_LINE INDENT for j in b : NEW_LINE INDENT if j not in k : NEW_LINE INDENT x = q [ k ] [ 0 ] + ( a [ i ] + j ) * ( a [ i ] > j ) NEW_LINE y = q [ k ] [ 1 ] + ( a [ i ] + j ) * ( a [ i ] < j ) NEW_LINE if x > 85 : c += math . factorial ( 9 - i - 1 ) NEW_LINE elif y < 86 : nq [ tuple ( list ( k ) + [ j ] ) ] = ( x , y ) NEW_LINE DEDENT DEDENT DEDENT q = nq NEW_LINE DEDENT c /= 362880 NEW_LINE print ( \" { } \u2581 { } \" . format ( Decimal ( c ) . quantize ( Decimal ( '0.000001' ) , rounding = ROUND_HALF_UP ) , Decimal ( 1 - c ) . quantize ( Decimal ( '0.000001' ) , rounding = ROUND_HALF_UP ) ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_5103_A", "java": ["import java . io . * ; class Combination { static void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }"], "python": ["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r ; NEW_LINE combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; NEW_LINE DEDENT def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT i = start ; NEW_LINE while ( i <= end and end - i + 1 >= r - index ) : NEW_LINE INDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE"]}
{"id": "geeksforgeeks_5104_A", "java": ["import java . io . * ; class Combination { static void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + \" \u2581 \" ) ; System . out . println ( \" \" ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }"], "python": ["def printCombination ( arr , n , r ) : NEW_LINE INDENT data = [ 0 ] * r NEW_LINE combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE DEDENT def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE INDENT if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1183_A", "java": ["class GFG { static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }"], "python": ["def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( bitwiseAndOdd ( n ) ) ; NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4193_A", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) System . out . println ( \" y \u2581 = \u2581 \" + dif + \" x \" + ( x * dif + y ) ) ; else if ( dif > 0 ) System . out . println ( \" y \u2581 = \u2581 \" + dif + \" x + \" + - x * dif + y ) ; else System . out . println ( \" Not \u2581 possible \" ) ; } } public static void main ( String args [ ] ) { int A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ; } }"], "python": ["def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( \" y \u2581 = \" , dif , \" x \" , ( x * dif ) + ( y ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( \" y \u2581 = \" , dif , \" x + \" , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A , x , y = 2 , 2 , 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE DEDENT"]}
{"id": "codeforces_1624_A", "java": ["import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Fast f = new Fast ( System . in ) ; int t = f . nextInt ( ) ; while ( t -- != 0 ) { int n = f . nextInt ( ) ; int max = Integer . MIN_VALUE , min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { int x = f . nextInt ( ) ; if ( x > max ) max = x ; if ( x < min ) min = x ; } System . out . println ( max - min ) ; } System . out . flush ( ) ; System . out . close ( ) ; } } class Fast { StringTokenizer st ; BufferedReader br ; public Fast ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Fast ( String file ) throws IOException { br = new BufferedReader ( new FileReader ( file ) ) ; } public Fast ( FileReader r ) { br = new BufferedReader ( r ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String readAllLines ( BufferedReader reader ) throws IOException { StringBuilder content = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { content . append ( line ) ; content . append ( System . lineSeparator ( ) ) ; } return content . toString ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) throws IOException { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } }", "import java . util . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) throws IOException { Fast f = new Fast ( System . in ) ; int t = f . nextInt ( ) ; while ( t -- != 0 ) { int n = f . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = f . nextInt ( ) ; Arrays . sort ( arr ) ; System . out . println ( arr [ arr . length - 1 ] - arr [ 0 ] ) ; } System . out . flush ( ) ; System . out . close ( ) ; } } class Fast { StringTokenizer st ; BufferedReader br ; public Fast ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public Fast ( String file ) throws IOException { br = new BufferedReader ( new FileReader ( file ) ) ; } public Fast ( FileReader r ) { br = new BufferedReader ( r ) ; } public String next ( ) throws IOException { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public String readAllLines ( BufferedReader reader ) throws IOException { StringBuilder content = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { content . append ( line ) ; content . append ( System . lineSeparator ( ) ) ; } return content . toString ( ) ; } public int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws IOException { return Long . parseLong ( next ( ) ) ; } public int [ ] nextIntArray ( int n ) throws IOException { int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = nextInt ( ) ; return a ; } public boolean ready ( ) throws IOException { return br . ready ( ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; while ( t -- != 0 ) { int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = in . nextInt ( ) ; Arrays . sort ( arr ) ; System . out . println ( arr [ arr . length - 1 ] - arr [ 0 ] ) ; } System . out . flush ( ) ; System . out . close ( ) ; } }", "import java . io . * ; import java . util . * ; public class Main { static void dfs ( ) { } static PrintWriter out = new PrintWriter ( System . out ) ; static Scanner in = new Scanner ( System . in ) ; static BufferedReader re = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter wr = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws IOException { PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int T = in . nextInt ( ) ; while ( T > 0 ) { int n = in . nextInt ( ) ; int max = 0 ; int min = 2100000000 ; for ( int i = 0 ; i < n ; i ++ ) { int x = in . nextInt ( ) ; if ( x > max ) max = x ; if ( x < min ) min = x ; } out . println ( max - min ) ; T -- ; } out . flush ( ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE while n : NEW_LINE INDENT s = int ( input ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE c = max ( a ) - min ( a ) NEW_LINE print ( c ) NEW_LINE n -= 1 NEW_LINE DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE mini = min ( a ) NEW_LINE maxi = max ( a ) NEW_LINE print ( maxi - mini ) NEW_LINE DEDENT", "n = int ( input ( ) ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = int ( input ( ) ) NEW_LINE l = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE print ( max ( l ) - min ( l ) ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE print ( max ( a ) - min ( a ) ) NEW_LINE DEDENT", "def equalizer ( ls ) : NEW_LINE INDENT big = max ( ls ) NEW_LINE small = min ( ls ) NEW_LINE steps = big - small NEW_LINE return steps NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT test_cases = int ( input ( ) ) NEW_LINE answers = [ ] NEW_LINE for i in range ( test_cases ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE ls = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE steps = equalizer ( ls ) NEW_LINE answers . append ( steps ) NEW_LINE DEDENT answer = [ print ( i ) for i in answers ] NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_4222_A", "java": ["import java . io . * ; class GFG { static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { String n = \"43262488612\" ; System . out . println ( \" Rotations : \u2581 \" + countRotationsDivBy8 ( n ) ) ; } }"], "python": ["def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = \"43262488612\" NEW_LINE print ( \" Rotations : \" , countRotationsDivBy8 ( n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3844_A", "java": ["import java . util . * ; class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }"], "python": ["def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3131_A", "java": ["import java . util . * ; class GFG { static void interLeaveQueue ( Queue < Integer > q ) { if ( q . size ( ) % 2 != 0 ) System . out . println ( \" Input \u2581 even \u2581 number \u2581 of \u2581 integers . \" ) ; Stack < Integer > s = new Stack < > ( ) ; int halfSize = q . size ( ) / 2 ; for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { q . add ( q . peek ( ) ) ; q . poll ( ) ; } for ( int i = 0 ; i < halfSize ; i ++ ) { s . push ( q . peek ( ) ) ; q . poll ( ) ; } while ( ! s . empty ( ) ) { q . add ( s . peek ( ) ) ; s . pop ( ) ; q . add ( q . peek ( ) ) ; q . poll ( ) ; } } public static void main ( String [ ] args ) { Queue < Integer > q = new java . util . LinkedList < > ( ) ; q . add ( 11 ) ; q . add ( 12 ) ; q . add ( 13 ) ; q . add ( 14 ) ; q . add ( 15 ) ; q . add ( 16 ) ; q . add ( 17 ) ; q . add ( 18 ) ; q . add ( 19 ) ; q . add ( 20 ) ; interLeaveQueue ( q ) ; int length = q . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) { System . out . print ( q . peek ( ) + \" \u2581 \" ) ; q . poll ( ) ; } } }"], "python": ["from queue import Queue NEW_LINE def interLeaveQueue ( q ) : NEW_LINE INDENT if ( q . qsize ( ) % 2 != 0 ) : NEW_LINE INDENT print ( \" Input \u2581 even \u2581 number \u2581 of \u2581 integers . \" ) NEW_LINE DEDENT s = [ ] NEW_LINE halfSize = int ( q . qsize ( ) / 2 ) NEW_LINE for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT for i in range ( halfSize ) : NEW_LINE INDENT s . append ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT q . put ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE q . put ( q . queue [ 0 ] ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = Queue ( ) NEW_LINE q . put ( 11 ) NEW_LINE q . put ( 12 ) NEW_LINE q . put ( 13 ) NEW_LINE q . put ( 14 ) NEW_LINE q . put ( 15 ) NEW_LINE q . put ( 16 ) NEW_LINE q . put ( 17 ) NEW_LINE q . put ( 18 ) NEW_LINE q . put ( 19 ) NEW_LINE q . put ( 20 ) NEW_LINE interLeaveQueue ( q ) NEW_LINE length = q . qsize ( ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT print ( q . queue [ 0 ] , end = \" \u2581 \" ) NEW_LINE q . get ( ) NEW_LINE DEDENT DEDENT"]}
{"id": "codeforces_1293_A", "java": ["import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int numberOfTestCases = sc . nextInt ( ) ; List < Case > testCases = new ArrayList < > ( ) ; for ( int i = 0 ; i < numberOfTestCases ; i ++ ) { int numberOfFloors = sc . nextInt ( ) ; int currentFloor = sc . nextInt ( ) ; int numberOfClosedFloors = sc . nextInt ( ) ; testCases . add ( new Case ( numberOfFloors , currentFloor , numberOfClosedFloors ) ) ; for ( int j = 0 ; j < testCases . get ( i ) . numberOfClosedFloors ; j ++ ) { testCases . get ( i ) . closedFloors . add ( sc . nextInt ( ) ) ; } } for ( Case t : testCases ) { int i = 0 ; while ( true ) { int up = t . currentFloor + i ; int down = t . currentFloor - i ; if ( ( up <= t . numberOfFloors && ( ! t . closedFloors . contains ( up ) ) || ( down > 0 && ! t . closedFloors . contains ( down ) ) ) ) { System . out . println ( i ) ; break ; } i ++ ; } } } } class Case { int numberOfFloors ; int currentFloor ; int numberOfClosedFloors ; Set < Integer > closedFloors ; public Case ( int numberOfFloors , int currentFloor , int numberOfClosedFloors ) { this . numberOfFloors = numberOfFloors ; this . currentFloor = currentFloor ; this . numberOfClosedFloors = numberOfClosedFloors ; this . closedFloors = new HashSet < > ( ) ; } }"], "python": ["def solve ( ) : NEW_LINE INDENT n , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for i in range ( 0 , k + 1 ) : NEW_LINE INDENT if s - i >= 1 and not s - i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT if s + i <= n and not s + i in a : NEW_LINE INDENT print ( i ) ; NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT assert False NEW_LINE DEDENT DEDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if s not in a : NEW_LINE INDENT print ( 0 ) NEW_LINE continue NEW_LINE DEDENT for i in range ( 1 , 1001 ) : NEW_LINE INDENT if 0 < s - i <= n : NEW_LINE INDENT if s - i not in a : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT if 0 < s + i <= n : NEW_LINE INDENT if s + i not in a : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT n , s , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE j = set ( ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT j . add ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if s - i >= 1 and not ( s - i in j ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT if s + i <= n and not ( s + i in j ) : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT", "t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : NEW_LINE INDENT y = input ( ) . split ( ) NEW_LINE n = int ( y [ 0 ] ) NEW_LINE s = int ( y [ 1 ] ) NEW_LINE k = int ( y [ 2 ] ) NEW_LINE h = input ( ) . split ( ) NEW_LINE a = [ ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT a . append ( int ( h [ i ] ) ) NEW_LINE DEDENT s1 = s NEW_LINE s2 = s NEW_LINE x = 0 NEW_LINE while True : NEW_LINE INDENT if ( s1 not in a and s1 <= n ) or ( s2 not in a and s2 >= 1 ) : NEW_LINE INDENT print ( x ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT s1 += 1 NEW_LINE s2 -= 1 NEW_LINE x += 1 NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , s , k = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE fl = { int ( x ) for x in input ( ) . split ( ) } NEW_LINE i = 0 NEW_LINE while 1 : NEW_LINE INDENT if max ( s - i , 1 ) not in fl or min ( n , s + i ) not in fl : NEW_LINE INDENT print ( i ) ; break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_4952_A", "java": ["public class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void findRatio ( int m , int n ) { int Am = m - 5 , An = n - 5 ; int numerator = Am / GCD ( Am , An ) ; int denominator = An / GCD ( Am , An ) ; System . out . println ( numerator + \" / \" + denominator ) ; } public static void main ( String args [ ] ) { int m = 10 , n = 20 ; findRatio ( m , n ) ; } }"], "python": ["from fractions import gcd NEW_LINE def findRatio ( m , n ) : NEW_LINE INDENT Am = m - 5 NEW_LINE An = n - 5 NEW_LINE numerator = Am // ( gcd ( Am , An ) ) NEW_LINE denominator = An // ( gcd ( Am , An ) ) NEW_LINE print ( numerator , ' / ' , denominator ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 20 NEW_LINE findRatio ( m , n ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_1363_A", "java": ["import java . io . * ; import java . util . * ; class GFG { public static double M_E = 2.71828182845904523536 ; public static double M_PI = 3.141592654 ; static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . log10 ( n / M_E ) + Math . log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . floor ( x ) + 1 ; } public static void main ( String [ ] args ) { System . out . println ( findDigits ( 1 ) ) ; System . out . println ( findDigits ( 50000000 ) ) ; System . out . println ( findDigits ( 1000000000 ) ) ; System . out . println ( findDigits ( 120 ) ) ; } }"], "python": ["import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 50000000 ) ) ; NEW_LINE print ( findDigits ( 1000000000 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE"]}
{"id": "geeksforgeeks_151_A", "java": ["import java . io . * ; class GFG { static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } public static void main ( String [ ] args ) { int n = 11 , k = 2 ; System . out . println ( find_sum ( n , k ) ) ; } }"], "python": ["def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 ; k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE"]}
{"id": "geeksforgeeks_860_A", "java": ["class Test { static int FirstDigit ( int arr [ ] , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . floor ( S ) ; int ans = ( int ) Math . pow ( 10 , fract_S ) ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 8 , 3 , 7 } ; System . out . println ( FirstDigit ( arr , arr . length ) ) ; } }"], "python": ["import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEW_LINE"]}
{"id": "geeksforgeeks_1083_A", "java": ["import java . io . * ; class GFG { static int findSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { sum += arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = arr . length ; int k = 3 ; System . out . println ( findSum ( arr , n , k ) ) ; } }"], "python": ["def findSum ( arr , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % k == 0 : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findSum ( arr , n , k ) ) NEW_LINE DEDENT"]}
{"id": "codejam_15_32", "java": ["package c_2015 ; import java . util . Scanner ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int kases = in . nextInt ( ) ; for ( int kas = 1 ; kas <= kases ; kas ++ ) { int K = in . nextInt ( ) ; int L = in . nextInt ( ) ; int S = in . nextInt ( ) ; String keyboard = in . next ( ) ; String target = in . next ( ) ; int [ ] keys = new int [ 26 ] ; for ( int i = 0 ; i < K ; i ++ ) keys [ keyboard . charAt ( i ) - ' A ' ] ++ ; boolean possible = true ; for ( int i = 0 ; i < L ; i ++ ) if ( keys [ target . charAt ( i ) - ' A ' ] == 0 ) possible = false ; if ( ! possible ) { System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 0.0\" ) ; continue ; } int [ ] EV = new int [ S ] ; int p ; outer : for ( p = L - 1 ; p > 0 ; p -- ) { for ( int i = 0 ; i < p ; i ++ ) { if ( target . charAt ( i ) != target . charAt ( L - p + i ) ) continue outer ; } break ; } int max = ( S - p ) / ( L - p ) ; double prob_word = 1 ; for ( int i = 0 ; i < L ; i ++ ) { prob_word *= keys [ target . charAt ( i ) - ' A ' ] / ( 0.0 + K ) ; } System . out . println ( \" Case \u2581 # \" + kas + \" : \u2581 \" + ( max - prob_word * ( S - L + 1 ) ) ) ; } } }", "import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . util . LinkedList ; public class TypewriterMonkey { public static void main ( String [ ] args ) throws NumberFormatException , IOException { FileReader input = new FileReader ( args [ 0 ] ) ; BufferedReader buffer = new BufferedReader ( input ) ; int max = Integer . parseInt ( buffer . readLine ( ) . trim ( ) ) ; for ( int i = 1 ; i <= max ; i ++ ) { System . out . println ( \" Case \u2581 # \" + i + \" : \u2581 \" + solve ( buffer ) ) ; } } public static double solve ( BufferedReader buffer ) throws NumberFormatException , IOException { String [ ] split = buffer . readLine ( ) . trim ( ) . split ( \" \\\\ s + \" ) ; int K = Integer . parseInt ( split [ 0 ] ) ; int L = Integer . parseInt ( split [ 1 ] ) ; int S = Integer . parseInt ( split [ 2 ] ) ; String keys = buffer . readLine ( ) . trim ( ) ; String target = buffer . readLine ( ) . trim ( ) ; int differentStrings = ( int ) Math . pow ( K , S ) ; int max = 0 ; int sum = 0 ; for ( int i = 0 ; i < differentStrings ; i ++ ) { int number = i ; String result = new String ( ) ; for ( int j = 0 ; j < S ; j ++ ) { result = result . concat ( \" \" + keys . charAt ( number % K ) ) ; number /= K ; } int count = 0 ; int from = 0 ; while ( ( from = result . indexOf ( target , from ) + 1 ) > 0 ) { count ++ ; } sum += count ; if ( count > max ) max = count ; } return 1.0 * max - 1.0 * sum / differentStrings ; } }", "import java . util . Arrays ; import java . util . Scanner ; public final class B { public static void main ( final String ... args ) { final Scanner sc = new Scanner ( System . in ) ; final int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; ++ i ) { System . out . println ( String . format ( \" Case \u2581 # % d : \u2581 % .7f \" , i + 1 , testcase ( sc ) ) ) ; } } private static double testcase ( final Scanner sc ) { final int k = sc . nextInt ( ) ; final int l = sc . nextInt ( ) ; final int s = sc . nextInt ( ) ; final String keyboard = sc . next ( ) ; final String text = sc . next ( ) ; final int [ ] perm = new int [ s ] ; Arrays . fill ( perm , 0 ) ; int maxOccurences = 0 ; double sum = 0.0 ; double denominator = 0 ; do { final StringBuilder builder = new StringBuilder ( s ) ; for ( int i = 0 ; i < s ; ++ i ) { builder . append ( keyboard . charAt ( perm [ i ] ) ) ; } final String result = builder . toString ( ) ; int howMany = 0 ; for ( int i = 0 ; i < s - l + 1 ; ++ i ) { if ( result . substring ( i , i + l ) . equals ( text ) ) { ++ howMany ; } } maxOccurences = Math . max ( maxOccurences , howMany ) ; sum += howMany ; ++ denominator ; } while ( nextPermutation ( perm , k ) ) ; return maxOccurences - ( sum / denominator ) ; } private static boolean nextPermutation ( final int [ ] perm , final int k ) { int i = 0 ; while ( i < perm . length && perm [ i ] == k - 1 ) { perm [ i ] = 0 ; ++ i ; } if ( i == perm . length ) { return false ; } ++ perm [ i ] ; return true ; } }", "import java . io . * ; import java . util . * ; public class SolutionB { static Scanner scan = new Scanner ( System . in ) ; static PrintStream out = System . out ; private static void solve ( ) { int K = scan . nextInt ( ) , L = scan . nextInt ( ) , S = scan . nextInt ( ) ; String keys = scan . next ( ) ; String word = scan . next ( ) ; int [ ] keyCounts = new int [ 26 ] ; for ( char c : keys . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; keyCounts [ k ] ++ ; } int idx = 1 ; while ( idx < L ) { if ( word . substring ( 0 , L - idx ) . equals ( word . substring ( idx ) ) ) break ; ++ idx ; } int totalB = ( idx == L ) ? S / L : ( S - L ) / idx + 1 ; double percentage = 1 ; for ( char c : word . toCharArray ( ) ) { int k = ( int ) ( c - ' A ' ) ; int cnt = keyCounts [ k ] ; if ( cnt == 0 ) { out . println ( \"0.0\" ) ; return ; } percentage *= ( double ) cnt / K ; } out . println ( totalB - percentage * ( S - L + 1 ) ) ; } public static void main ( String [ ] args ) { int T = scan . nextInt ( ) ; for ( int i = 1 ; i <= T ; ++ i ) { out . print ( \" Case \u2581 # \" + i + \" : \u2581 \" ) ; solve ( ) ; } } }"], "python": ["import sys NEW_LINE iFile = open ( sys . argv [ 1 ] , \" r \" ) NEW_LINE T = int ( iFile . readline ( ) . strip ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT line = iFile . readline ( ) . strip ( ) . split ( ) NEW_LINE K = int ( line [ 0 ] ) NEW_LINE L = int ( line [ 1 ] ) NEW_LINE S = int ( line [ 2 ] ) NEW_LINE keyboard = iFile . readline ( ) . strip ( ) NEW_LINE target = iFile . readline ( ) . strip ( ) NEW_LINE effectiveLength = len ( target ) NEW_LINE for strPos in range ( 1 , len ( target ) ) : NEW_LINE INDENT if target [ strPos : ] == target [ : - strPos ] : NEW_LINE INDENT effectiveLength = strPos NEW_LINE break NEW_LINE DEDENT DEDENT max_bananas = 1 + int ( ( S - len ( target ) ) / effectiveLength ) NEW_LINE single_prob = 1.0 NEW_LINE for letter in target : NEW_LINE INDENT if letter in keyboard : NEW_LINE INDENT single_prob *= keyboard . count ( letter ) / len ( keyboard ) NEW_LINE DEDENT else : NEW_LINE INDENT single_prob = 0.0 NEW_LINE max_bananas = 0 NEW_LINE break NEW_LINE DEDENT DEDENT total_prob = single_prob * ( S - len ( target ) + 1 ) NEW_LINE answer = max_bananas - total_prob NEW_LINE output = str ( answer ) NEW_LINE print ( \" Case \u2581 # \" + str ( t + 1 ) + \" : \u2581 \" + output ) NEW_LINE DEDENT", "def maximunBananas ( key , target , length ) : NEW_LINE INDENT if length < len ( target ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] not in d : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT advanced = len ( target ) NEW_LINE for i in range ( len ( target ) - 1 ) : NEW_LINE INDENT if target [ : i + 1 ] == target [ len ( target ) - i - 1 : ] : NEW_LINE INDENT advanced = len ( target ) - i - 1 NEW_LINE DEDENT DEDENT return 1 + int ( ( length - len ( target ) ) / advanced ) NEW_LINE DEDENT def expectedBananas ( key , target , length ) : NEW_LINE INDENT d = { } NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if key [ i ] in d : NEW_LINE INDENT d [ key [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ key [ i ] ] = 1 NEW_LINE DEDENT DEDENT prob = 1 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if target [ i ] in d : NEW_LINE INDENT prob *= d [ target [ i ] ] / len ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return prob * ( length - len ( target ) + 1 ) NEW_LINE DEDENT def calculate ( ) : NEW_LINE INDENT k , l , s = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE key = input ( ) NEW_LINE target = input ( ) NEW_LINE return maximunBananas ( key , target , s ) - expectedBananas ( key , target , s ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ncase = int ( input ( ) ) NEW_LINE for i in range ( ncase ) : NEW_LINE INDENT print ( ' Case \u2581 # { } : \u2581 { } ' . format ( i + 1 , calculate ( ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "from __future__ import print_function , division NEW_LINE from collections import Counter NEW_LINE def overlap_shift ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s . startswith ( s [ i + 1 : ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT def tc ( tci ) : NEW_LINE INDENT [ klen , tlen , s ] = map ( int , raw_input ( ) . split ( ) ) NEW_LINE keyboard = raw_input ( ) NEW_LINE target = raw_input ( ) NEW_LINE assert klen == len ( keyboard ) NEW_LINE assert tlen == len ( target ) NEW_LINE assert s >= tlen NEW_LINE sol = 0.0 NEW_LINE counter = Counter ( keyboard ) NEW_LINE if all ( t in counter for t in target ) : NEW_LINE INDENT sh = overlap_shift ( target ) NEW_LINE occs = 1 + ( s - tlen ) // sh NEW_LINE p = 1.0 NEW_LINE for t in target : NEW_LINE INDENT p *= counter [ t ] / klen NEW_LINE DEDENT sol = occs - p * ( s - tlen + 1 ) NEW_LINE DEDENT print ( \" Case \u2581 # { } : \u2581 { : . 15f } \" . format ( tci , sol ) ) NEW_LINE DEDENT tcn = int ( raw_input ( ) ) NEW_LINE for tci in range ( 1 , tcn + 1 ) : tc ( tci ) NEW_LINE"]}
{"id": "codeforces_376_B", "java": ["import java . util . * ; public class JavaApplication91 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int num1 = sc . nextInt ( ) ; int num2 = sc . nextInt ( ) ; int counter = 0 ; ArrayList < Integer > arr = new ArrayList < > ( ) ; for ( int i = 0 ; i < num1 ; i ++ ) { arr . add ( 0 ) ; } for ( int i = 0 ; i < num2 ; i ++ ) { int num3 = sc . nextInt ( ) ; int num4 = sc . nextInt ( ) ; int num5 = sc . nextInt ( ) ; arr . set ( num3 - 1 , arr . get ( num3 - 1 ) + num5 ) ; arr . set ( num4 - 1 , arr . get ( num4 - 1 ) - num5 ) ; } for ( int i = 0 ; i < num1 ; i ++ ) { counter += Math . abs ( arr . get ( i ) ) ; } System . out . println ( counter / 2 ) ; } }", "import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] debt = new int [ n + 1 ] ; int [ ] owe = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; debt [ b ] += c ; owe [ a ] += c ; } int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( debt [ i ] < owe [ i ] ) { int diff = owe [ i ] - debt [ i ] ; sum += diff ; } } System . out . println ( sum ) ; } }", "import java . util . * ; public class Solution { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; int m = in . nextInt ( ) ; int sum = 0 ; int [ ] debt = new int [ n + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { int x = in . nextInt ( ) ; int y = in . nextInt ( ) ; int d = in . nextInt ( ) ; debt [ x ] += d ; debt [ y ] -= d ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( debt [ i ] > 0 ) sum += debt [ i ] ; } System . out . println ( sum ) ; } }"], "python": ["numbers = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE data = { ' dept ' : 0 } NEW_LINE def change_count ( index ) : NEW_LINE INDENT dif = data [ f ' { index } ' ] [ ' owes ' ] - data [ f ' { index } ' ] [ ' have ' ] NEW_LINE if dif <= 0 : NEW_LINE INDENT data [ ' dept ' ] -= data [ f ' { index } ' ] [ ' count ' ] NEW_LINE data [ f ' { index } ' ] [ ' count ' ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT data [ ' dept ' ] += dif - data [ f ' { index } ' ] [ ' count ' ] NEW_LINE data [ f ' { index } ' ] [ ' count ' ] = dif NEW_LINE DEDENT DEDENT for i in range ( 0 , numbers [ 1 ] ) : NEW_LINE INDENT x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE for z in range ( 0 , 2 ) : NEW_LINE INDENT if not f \" { x [ z ] } \" in data . keys ( ) : NEW_LINE INDENT data [ f ' { x [ z ] } ' ] = { \" owes \" : 0 , \" have \" : 0 , \" count \" : 0 } NEW_LINE DEDENT DEDENT data [ f \" { x [ 0 ] } \" ] [ ' owes ' ] += x [ 2 ] NEW_LINE data [ f \" { x [ 1 ] } \" ] [ ' have ' ] += x [ 2 ] NEW_LINE change_count ( x [ 0 ] ) NEW_LINE change_count ( x [ 1 ] ) NEW_LINE DEDENT print ( data [ ' dept ' ] ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE balances = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT fro , to , am = map ( int , input ( ) . split ( ) ) NEW_LINE balances [ fro - 1 ] -= am NEW_LINE balances [ to - 1 ] += am NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if balances [ i ] < 0 : NEW_LINE INDENT ans += - balances [ i ] NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE", "n , m = [ int ( i ) for i in input ( ) . split ( ) ] ; dic = dict ( ) ; cou = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dic [ i ] = 0 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT a , b , c = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE dic [ a ] -= c ; dic [ b ] += c NEW_LINE DEDENT for i in dic . values ( ) : NEW_LINE INDENT if i > 0 : cou += i NEW_LINE DEDENT print ( cou ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) ; lst = [ 0 ] * ( n + 1 ) ; s = 0 NEW_LINE for i in range ( m ) : a , b , c = map ( int , input ( ) . split ( ) ) ; lst [ a ] += c ; lst [ b ] -= c NEW_LINE for i in lst : s += abs ( i ) NEW_LINE print ( s // 2 ) NEW_LINE", "n , m = map ( int , input ( ) . split ( ) ) NEW_LINE debts = [ 0 ] * n NEW_LINE for _ in range ( m ) : NEW_LINE INDENT minus , plus , value = map ( int , input ( ) . split ( ) ) NEW_LINE debts [ minus - 1 ] -= value NEW_LINE debts [ plus - 1 ] += value NEW_LINE DEDENT print ( sum ( [ debt for debt in debts if debt > 0 ] ) ) NEW_LINE"]}
{"id": "aizu_p00734_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; int [ ] ns = new int [ n ] ; int [ ] ms = new int [ m ] ; int nsum = 0 ; int msum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ns [ i ] = sc . nextInt ( ) ; nsum += ns [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { ms [ i ] = sc . nextInt ( ) ; msum += ms [ i ] ; } int sn = - 1 ; int sm = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( nsum - ns [ i ] + ms [ j ] == msum - ms [ j ] + ns [ i ] ) { if ( sn == - 1 ) { sn = ns [ i ] ; sm = ms [ j ] ; } else if ( ns [ i ] + ms [ j ] < sn + sm ) { sn = ns [ i ] ; sm = ms [ j ] ; } } } } System . out . println ( sn == - 1 ? sn : sn + \" \u2581 \" + sm ) ; } } }", "public class Main { public void run ( java . io . InputStream in , java . io . PrintStream out ) { java . util . Scanner sc = new java . util . Scanner ( in ) ; int n , m , i , j , sumt , sumh , tt , th ; int [ ] st , sh ; for ( ; ; ) { n = sc . nextInt ( ) ; m = sc . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; st = new int [ n ] ; sh = new int [ m ] ; sumt = 0 ; sumh = 0 ; tt = 201 ; th = 201 ; for ( i = 0 ; i < n ; i ++ ) { st [ i ] = sc . nextInt ( ) ; sumt += st [ i ] ; } for ( i = 0 ; i < m ; i ++ ) { sh [ i ] = sc . nextInt ( ) ; sumh += sh [ i ] ; } for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < m ; j ++ ) { if ( sumt - 2 * st [ i ] == sumh - 2 * sh [ j ] && tt + th > st [ i ] + sh [ j ] ) { tt = st [ i ] ; th = sh [ j ] ; } } if ( tt != 201 && th != 201 ) out . println ( tt + \" \u2581 \" + th ) ; else out . println ( \" - 1\" ) ; } sc . close ( ) ; } public static void main ( String [ ] args ) { ( new Main ( ) ) . run ( System . in , System . out ) ; } }", "import java . io . File ; import java . io . FileNotFoundException ; import java . util . ArrayList ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; while ( true ) { String line = sc . nextLine ( ) ; if ( line . equals ( \"0 \u2581 0\" ) ) { return ; } int countCard1 = Integer . valueOf ( line . split ( \" \u2581 \" ) [ 0 ] ) ; int countCard2 = Integer . valueOf ( line . split ( \" \u2581 \" ) [ 1 ] ) ; int [ ] arrCard1 = new int [ countCard1 ] ; int [ ] arrCard2 = new int [ countCard2 ] ; int totalVal1 = 0 ; int totalVal2 = 0 ; for ( int i = 0 ; i < countCard1 ; i ++ ) { arrCard1 [ i ] = Integer . valueOf ( sc . nextLine ( ) ) ; totalVal1 += arrCard1 [ i ] ; } for ( int i = 0 ; i < countCard2 ; i ++ ) { arrCard2 [ i ] = Integer . valueOf ( sc . nextLine ( ) ) ; totalVal2 += arrCard2 [ i ] ; } if ( ( totalVal1 + totalVal2 ) % 2 != 0 ) { System . out . println ( \" - 1\" ) ; } else { int avg = ( totalVal1 + totalVal2 ) / 2 ; int missingValue1 = avg - totalVal1 ; String result = null ; Integer minResult = null ; for ( Integer number1 : arrCard1 ) { for ( Integer number2 : arrCard2 ) { if ( number1 + missingValue1 == number2 ) { if ( minResult == null || number1 + number2 < minResult ) { result = number1 + \" \u2581 \" + number2 ; minResult = number1 + number2 ; } } } } if ( result == null ) { System . out . println ( \" - 1\" ) ; } else { System . out . println ( result ) ; } } } } }", "import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . util . * ; public class Main { Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { while ( sc . hasNext ( ) ) { new aoj1153 ( ) . doIt ( ) ; } } class aoj1153 { String ans ( int a [ ] , int b [ ] ) { int asum = 0 ; int bsum = 0 ; int sum = Integer . MAX_VALUE ; for ( int i = 0 ; i < a . length ; i ++ ) asum = asum + a [ i ] ; for ( int i = 0 ; i < b . length ; i ++ ) bsum = bsum + b [ i ] ; String result = \" - 1\" ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < b . length ; j ++ ) { if ( asum - a [ i ] + b [ j ] == bsum - b [ j ] + a [ i ] ) { if ( a [ i ] + b [ j ] < sum ) { result = a [ i ] + \" \u2581 \" + b [ j ] ; sum = a [ i ] + b [ j ] ; } } } } return result ; } void doIt ( ) { while ( true ) { int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; if ( n + m == 0 ) break ; int a [ ] = new int [ n ] ; int b [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) b [ i ] = sc . nextInt ( ) ; System . out . println ( ans ( a , b ) ) ; } } } }", "import java . util . * ; class Main { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; for ( ; ; ) { int n = in . nextInt ( ) , m = in . nextInt ( ) ; if ( n == 0 && m == 0 ) break ; int as [ ] = new int [ n ] , bs [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) as [ i ] = in . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) bs [ i ] = in . nextInt ( ) ; int totalA = 0 , totalB = 0 ; int a = - 1 , b = - 1 , s = 1 << 29 ; for ( int i = 0 ; i < n ; i ++ ) totalA += as [ i ] ; for ( int i = 0 ; i < m ; i ++ ) totalB += bs [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( as [ i ] + bs [ j ] < s && totalA - as [ i ] + bs [ j ] == totalB - bs [ j ] + as [ i ] ) { s = as [ i ] + bs [ j ] ; a = as [ i ] ; b = bs [ j ] ; } } } if ( a < 0 ) System . out . println ( - 1 ) ; else System . out . println ( a + \" \u2581 \" + b ) ; } } }"], "python": ["while True : NEW_LINE INDENT ( n , m ) = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE if n == 0 and m == 0 : NEW_LINE INDENT exit ( ) NEW_LINE DEDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT b . append ( int ( input ( ) ) ) NEW_LINE DEDENT a_sum = sum ( a ) NEW_LINE b_sum = sum ( b ) NEW_LINE target = a_sum - b_sum NEW_LINE found = False NEW_LINE for ai in a : NEW_LINE INDENT for bi in b : NEW_LINE INDENT if ( ai - bi ) * 2 == target : NEW_LINE INDENT print ( ai , bi ) NEW_LINE found = True NEW_LINE DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if found == False : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT", "while 1 : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT taro = [ ] NEW_LINE hana = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT taro . append ( int ( input ( ) ) ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT hana . append ( int ( input ( ) ) ) NEW_LINE DEDENT t_sum = sum ( taro ) NEW_LINE h_sum = sum ( hana ) NEW_LINE d = t_sum - h_sum NEW_LINE mn = 99999999 NEW_LINE ans = [ - 1 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( t_sum - taro [ i ] + hana [ j ] ) == ( h_sum - hana [ j ] + taro [ i ] ) : NEW_LINE INDENT if mn > taro [ i ] + hana [ j ] : NEW_LINE INDENT mn = taro [ i ] + hana [ j ] NEW_LINE ans = ( taro [ i ] , hana [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( * ans ) NEW_LINE DEDENT", "def search ( t , st , h , sh ) : NEW_LINE INDENT for ta in t : NEW_LINE INDENT for ha in h : NEW_LINE INDENT if st - ta + ha == sh - ha + ta : return ' \u2581 ' . join ( map ( str , [ ta , ha ] ) ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if n == m == 0 : break NEW_LINE t = sorted ( [ int ( input ( ) ) for _ in range ( n ) ] ) NEW_LINE h = sorted ( [ int ( input ( ) ) for _ in range ( m ) ] ) NEW_LINE st , sh = sum ( t ) , sum ( h ) NEW_LINE r = search ( t , st , h , sh ) NEW_LINE print ( r ) NEW_LINE DEDENT", "while True : NEW_LINE INDENT data = input ( ) . split ( ) NEW_LINE n , m = int ( data [ 0 ] ) , int ( data [ 1 ] ) NEW_LINE if n == 0 and m == 0 : break NEW_LINE tarou_cards = [ ] NEW_LINE hanako_cards = [ ] NEW_LINE cards_size = n + m NEW_LINE total = 0 NEW_LINE t_total = 0 NEW_LINE h_total = 0 NEW_LINE for i in range ( 0 , cards_size ) : NEW_LINE INDENT point = int ( input ( ) ) NEW_LINE total += point NEW_LINE if n >= i + 1 : NEW_LINE INDENT tarou_cards . append ( point ) NEW_LINE t_total += point NEW_LINE DEDENT else : NEW_LINE INDENT hanako_cards . append ( point ) NEW_LINE h_total += point NEW_LINE DEDENT DEDENT tarou_cards . sort ( ) NEW_LINE hanako_cards . sort ( ) NEW_LINE if total % 2 != 0 : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE continue NEW_LINE DEDENT exchangeFlg = False NEW_LINE target = t_total - total / 2 NEW_LINE for t_card in tarou_cards : NEW_LINE INDENT for h_card in hanako_cards : NEW_LINE INDENT diff = t_card - h_card NEW_LINE if diff == target : NEW_LINE INDENT print ( \" { } \u2581 { } \" . format ( t_card , h_card ) ) NEW_LINE exchangeFlg = True NEW_LINE break NEW_LINE DEDENT DEDENT if exchangeFlg : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if exchangeFlg != True : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT DEDENT", "ans_list = [ ] NEW_LINE while True : NEW_LINE INDENT n , m = map ( int , input ( ) . split ( ) ) NEW_LINE if ( n , m ) == ( 0 , 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT S = [ int ( input ( ) ) for _ in range ( n ) ] NEW_LINE T = [ int ( input ( ) ) for _ in range ( m ) ] NEW_LINE ss = sum ( S ) NEW_LINE tt = sum ( T ) NEW_LINE ans = ( 101 , 101 ) NEW_LINE for s in S : NEW_LINE INDENT for t in T : NEW_LINE INDENT if ss - s + t == tt - t + s and s + t < sum ( ans ) : NEW_LINE INDENT ans = ( s , t ) NEW_LINE DEDENT DEDENT DEDENT if ans == ( 101 , 101 ) : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = \" { } \u2581 { } \" . format ( ans [ 0 ] , ans [ 1 ] ) NEW_LINE DEDENT ans_list . append ( ans ) NEW_LINE DEDENT for ans in ans_list : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT"]}
{"id": "leetcode_1064_A", "java": ["class Solution { public int fixedPoint ( int [ ] A ) { int l = 0 ; int h = A . length ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( A [ mid ] > mid ) h = mid - 1 ; else if ( A [ mid ] < mid ) l = mid + 1 ; else return mid ; } return - 1 ; } }"], "python": ["class Solution ( object ) : NEW_LINE INDENT def fixedPoint ( self , A ) : NEW_LINE INDENT l , h = 0 , len ( A ) - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if A [ mid ] < mid : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT elif A [ mid ] > mid : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT"]}
{"id": "aizu_p01502_A", "java": ["import java . util . Scanner ; public class Main { public static int INF = 1 << 24 ; public static void main ( String [ ] args ) { Scanner stdIn = new Scanner ( System . in ) ; int n = stdIn . nextInt ( ) ; int cost [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cost [ i ] [ j ] = stdIn . nextInt ( ) ; } } long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans += Math . min ( cost [ i ] [ j ] , cost [ j ] [ i ] ) ; } } System . out . println ( ans ) ; } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; SightseeingTour solver = new SightseeingTour ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class SightseeingTour { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int N = in . nextInt ( ) ; int [ ] [ ] C = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { C [ i ] [ j ] = in . nextInt ( ) ; } } long ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { ans += Math . min ( C [ i ] [ j ] , C [ j ] [ i ] ) ; } } out . println ( ans ) ; } } }", "import java . util . * ; public class Main { private void doit ( ) { Scanner sc = new Scanner ( System . in ) ; while ( sc . hasNext ( ) ) { int n = sc . nextInt ( ) ; int [ ] [ ] data = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { data [ i ] [ j ] = sc . nextInt ( ) ; } } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += Math . min ( data [ i ] [ j ] , data [ j ] [ i ] ) ; } } System . out . println ( sum ) ; } } private void debug ( Object ... o ) { System . out . println ( \" debug \u2581 = \u2581 \" + Arrays . deepToString ( o ) ) ; } public static void main ( String [ ] args ) { new Main ( ) . doit ( ) ; } }", "import java . util . * ; import static java . lang . System . * ; public class Main { Scanner sc = new Scanner ( in ) ; void run ( ) { int n = sc . nextInt ( ) ; int [ ] [ ] mat = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = sc . nextInt ( ) ; long res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { res += Math . min ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } } out . println ( res ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }", "import java . util . ArrayList ; import java . util . Scanner ; public class Main { Scanner sc = new Scanner ( System . in ) ; public void run ( ) { int n = sc . nextInt ( ) ; calc ( n ) ; } public void calc ( int n ) { int [ ] [ ] costs = new int [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { costs [ i ] [ j ] = sc . nextInt ( ) ; } } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { sum += Math . min ( costs [ i ] [ j ] , costs [ j ] [ i ] ) ; } } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { new Main ( ) . run ( ) ; } }"], "python": ["import sys NEW_LINE def main ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE edges = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT edges . append ( list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += min ( edges [ i ] [ j ] , edges [ j ] [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT", "import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE eps = 1.0 / 10 ** 10 NEW_LINE mod = 998244353 NEW_LINE dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] NEW_LINE ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def pf ( s ) : return print ( s , flush = True ) NEW_LINE def main ( ) : NEW_LINE INDENT rr = [ ] NEW_LINE while True : NEW_LINE INDENT n = I ( ) NEW_LINE a = [ LI ( ) for _ in range ( n ) ] NEW_LINE r = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT r += min ( a [ i ] [ j ] , a [ j ] [ i ] ) NEW_LINE DEDENT DEDENT rr . append ( r ) NEW_LINE break NEW_LINE DEDENT return ' \\n ' . join ( map ( str , rr ) ) NEW_LINE DEDENT print ( main ( ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE graph = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT graph [ i ] = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT ans += min ( graph [ i ] [ j ] , graph [ j ] [ i ] ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_3051_A", "java": ["import java . util . * ; class GFG { static int remAnagram ( String str1 , String str2 ) { int count1 [ ] = new int [ 26 ] ; int count2 [ ] = new int [ 26 ] ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 . charAt ( i ) - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += Math . abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } public static void main ( String [ ] args ) { String str1 = \" bcadeh \" , str2 = \" hea \" ; System . out . println ( remAnagram ( str1 , str2 ) ) ; } }"], "python": ["CHARS = 26 NEW_LINE def remAnagram ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3112_A", "java": ["import java . util . * ; class GFG { static double polyarea ( double n , double r ) { if ( r < 0 && n < 0 ) return - 1 ; double A = ( ( r * r * n ) * Math . sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } public static void main ( String [ ] args ) { float r = 9 , n = 6 ; System . out . println ( polyarea ( n , r ) ) ; } }"], "python": ["from math import sin NEW_LINE def polyarea ( n , r ) : NEW_LINE INDENT if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT"]}
{"id": "codeforces_1673_B", "java": ["import java . util . * ; public class code { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int t = sc . nextInt ( ) ; while ( t -- > 0 ) { solve ( ) ; } } static void solve ( ) { String s = sc . next ( ) ; Set < Character > ori = new HashSet < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { ori . add ( s . charAt ( i ) ) ; } if ( ori . size ( ) == 1 || ori . size ( ) == s . length ( ) ) { System . out . println ( \" Yes \" ) ; return ; } int n = ori . size ( ) ; ori . clear ( ) ; int i = 0 , j = 0 ; while ( j < s . length ( ) ) { ori . add ( s . charAt ( j ) ) ; if ( j - i + 1 == n ) { if ( ori . size ( ) < n ) { System . out . println ( \" no \" ) ; return ; } else { ori . remove ( s . charAt ( i ++ ) ) ; } } j ++ ; } System . out . println ( \" Yes \" ) ; } }", "import java . util . * ; public class HelloWorld { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t > 0 ) { String s = sc . next ( ) ; Set < Character > chars = new HashSet < Character > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { chars . add ( s . charAt ( i ) ) ; } int condi = 0 ; int k = chars . size ( ) ; for ( int i = 0 ; i < s . length ( ) - k ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i + k ) ) { condi = 1 ; } } if ( condi == 1 ) { System . out . println ( \" NO \" ) ; } else { System . out . println ( \" YES \" ) ; } t -- ; } } }"], "python": ["from xml . etree . ElementPath import prepare_parent NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE ans = ' YES ' NEW_LINE m = { } NEW_LINE m2 = { } NEW_LINE for i in s : NEW_LINE INDENT if i not in m : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ i ] += 1 NEW_LINE DEDENT DEDENT if len ( m ) == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE continue NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] not in m2 : NEW_LINE INDENT m2 [ s [ i ] ] = [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT m2 [ s [ i ] ] . append ( i ) NEW_LINE DEDENT DEDENT for i in m2 : NEW_LINE INDENT for j in range ( len ( m2 [ i ] ) - 1 ) : NEW_LINE INDENT if abs ( m2 [ i ] [ j ] - m2 [ i ] [ j + 1 ] ) < len ( m ) : NEW_LINE INDENT ans = ' NO ' NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT", "def main ( ) : NEW_LINE INDENT for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT string = input ( ) NEW_LINE n = len ( string ) NEW_LINE mp = { } NEW_LINE flag = True NEW_LINE for i in string : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT count = len ( mp ) NEW_LINE for i in range ( 0 , n - count ) : NEW_LINE INDENT if string [ i ] != string [ i + count ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT DEDENT main ( ) NEW_LINE", "for t in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE c = len ( set ( s ) ) NEW_LINE print ( \" Yes \" if all ( len ( set ( s [ i : : c ] ) ) == 1 for i in range ( c ) ) else \" No \" ) NEW_LINE DEDENT", "T = int ( input ( ) ) NEW_LINE for _ in range ( T ) : NEW_LINE INDENT s = input ( ) NEW_LINE marker = [ ] NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT marker . append ( [ ] ) NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT marker [ ord ( s [ i ] ) - 97 ] . append ( i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if len ( marker [ i ] ) > 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count == 1 : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = True NEW_LINE for item in marker : NEW_LINE INDENT for i in range ( len ( item ) - 1 ) : NEW_LINE INDENT if item [ i + 1 ] - item [ i ] < count : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT DEDENT if ans == False : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if not ans : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT DEDENT DEDENT", "from collections import defaultdict NEW_LINE from bisect import bisect_left NEW_LINE for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT s = input ( ) NEW_LINE st = set ( s ) NEW_LINE n = len ( st ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while j < len ( s ) : NEW_LINE INDENT if j - i + 1 == n : NEW_LINE INDENT st1 = set ( s [ i : j + 1 ] ) NEW_LINE if len ( st1 ) < n : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT DEDENT"]}
{"id": "geeksforgeeks_1231_A", "java": ["import java . io . * ; class GFG { static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . pow ( b , 2 ) ; } public static void main ( String [ ] args ) { int b = 3 , s = 4 ; System . out . println ( surfaceArea ( b , s ) ) ; } }"], "python": ["def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT b = 3 NEW_LINE s = 4 NEW_LINE print ( surfaceArea ( b , s ) ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_3284_A", "java": ["import java . io . * ; class GFG { static int count ( String s , int len ) { int MAX = 1000 ; int cur = 0 , dig = 0 ; int [ ] sum = new int [ MAX ] ; int [ ] [ ] dp = new int [ MAX ] [ 3 ] ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; cur += dig ; cur %= 3 ; sum [ i ] = cur ; dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] ; dp [ i ] [ sum [ i ] ] ++ ; } int ans = 0 , dprev = 0 , value = 0 , dprev2 = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { dig = ( int ) ( s . charAt ( i - 1 ) ) - 48 ; if ( dig == 8 ) ans ++ ; if ( i - 2 >= 0 ) { dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev * 10 + dig ; if ( ( value % 8 == 0 ) && ( value % 3 != 0 ) ) ans ++ ; } if ( i - 3 >= 0 ) { dprev2 = ( int ) ( s . charAt ( i - 3 ) ) - 48 ; dprev = ( int ) ( s . charAt ( i - 2 ) ) - 48 ; value = dprev2 * 100 + dprev * 10 + dig ; if ( value % 8 != 0 ) continue ; ans += ( i - 2 ) ; ans -= ( dp [ i - 3 ] [ sum [ i ] ] ) ; } } return ans ; } public static void main ( String [ ] args ) { String str = \"6564525600\" ; int len = str . length ( ) ; System . out . println ( count ( str , len ) ) ; } }"], "python": ["def count ( s , Len ) : NEW_LINE INDENT global MAX NEW_LINE cur = 0 NEW_LINE dig = 0 NEW_LINE Sum = [ 0 ] * MAX NEW_LINE dp = [ [ 0 , 0 , 0 ] for i in range ( MAX ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE cur += dig NEW_LINE cur %= 3 NEW_LINE Sum [ i ] = cur NEW_LINE dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 2 ] = dp [ i - 1 ] [ 2 ] NEW_LINE dp [ i ] [ Sum [ i ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE dprev = 0 NEW_LINE value = 0 NEW_LINE dprev2 = 0 NEW_LINE for i in range ( 1 , Len + 1 ) : NEW_LINE INDENT dig = int ( s [ i - 1 ] ) - 48 NEW_LINE if dig == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i - 2 >= 0 : NEW_LINE INDENT dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = dprev * 10 + dig NEW_LINE if ( value % 8 == 0 ) and ( value % 3 != 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT if i - 3 >= 0 : NEW_LINE INDENT dprev2 = int ( s [ i - 3 ] ) - 48 NEW_LINE dprev = int ( s [ i - 2 ] ) - 48 NEW_LINE value = ( dprev2 * 100 + dprev * 10 + dig ) NEW_LINE if value % 8 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT ans += ( i - 2 ) NEW_LINE ans -= ( dp [ i - 3 ] [ Sum [ i ] ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT MAX = 1000 NEW_LINE Str = \"6564525600\" NEW_LINE Len = len ( Str ) NEW_LINE print ( count ( Str , Len ) ) NEW_LINE"]}
{"id": "geeksforgeeks_539_A", "java": ["class GFG { static void sieve ( int maxm , int [ ] prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxm ; i ++ ) if ( prime [ i ] == 0 ) for ( int j = 2 * i ; j <= maxm ; j += i ) prime [ j ] = 1 ; } static long countPair ( int [ ] a , int n ) { int maxm = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) if ( a [ i ] > maxm ) maxm = a [ i ] ; int [ ] prime = new int [ maxm + 1 ] ; for ( i = 0 ; i < maxm + 1 ; i ++ ) prime [ i ] = 0 ; sieve ( maxm , prime ) ; int countPrimes = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( prime [ a [ i ] ] == 0 ) countPrimes ++ ; int nonPrimes = n - countPrimes ; long pairswith1Prime = nonPrimes * countPrimes ; long pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) / 2 ; return pairswith1Prime + pairsWith2Primes ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 4 , 7 } ; int n = arr . length ; System . out . println ( countPair ( arr , n ) ) ; } }"], "python": ["def sieve ( maxm , prime ) : NEW_LINE INDENT prime [ 0 ] = prime [ 1 ] = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= maxm ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , maxm + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def countPair ( a , n ) : NEW_LINE INDENT maxm = max ( a ) ; NEW_LINE prime = [ 0 ] * ( maxm + 1 ) ; NEW_LINE sieve ( maxm , prime ) ; NEW_LINE countPrimes = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ a [ i ] ] == 0 ) : NEW_LINE INDENT countPrimes += 1 ; NEW_LINE DEDENT DEDENT nonPrimes = n - countPrimes ; NEW_LINE pairswith1Prime = nonPrimes * countPrimes ; NEW_LINE pairsWith2Primes = ( countPrimes * ( countPrimes - 1 ) ) // 2 ; NEW_LINE return pairswith1Prime + pairsWith2Primes ; NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPair ( arr , n ) ) ; NEW_LINE"]}
{"id": "codeforces_332_A", "java": ["import java . util . Scanner ; public class A332 { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int N = in . nextInt ( ) ; char [ ] S = in . next ( ) . toCharArray ( ) ; int pos = N ; int answer = 0 ; while ( pos < S . length ) { if ( S [ pos - 1 ] == S [ pos - 2 ] && S [ pos - 2 ] == S [ pos - 3 ] ) { answer ++ ; } pos += N ; } System . out . println ( answer ) ; } }", "import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . * ; public class Main { public static void main ( String [ ] args ) throws IOException { FastScanner input = new FastScanner ( ) ; int n = input . nextInt ( ) ; String s = input . next ( ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i += n ) { if ( i >= 4 && ( s . charAt ( i - 1 ) == s . charAt ( i - 2 ) ) && ( s . charAt ( i - 2 ) == s . charAt ( i - 3 ) ) ) { count ++ ; } } System . out . println ( count ) ; } static class FastScanner { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( \" \" ) ; String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) throws IOException { return br . readLine ( ) ; } } }", "import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; ADownTheHatch solver = new ADownTheHatch ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class ADownTheHatch { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; char [ ] s = in . next ( ) . toCharArray ( ) ; int answer = 0 ; for ( int i = 0 ; i < s . length ; i += n ) { if ( i >= 3 && s [ i - 1 ] == s [ i - 2 ] && s [ i - 2 ] == s [ i - 3 ] ) answer ++ ; } out . println ( answer ) ; } } static class InputReader { public final BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }", "import java . util . * ; import java . io . * ; public class A332 { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter pw = new PrintWriter ( System . out ) ; StringTokenizer st ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s = br . readLine ( ) ; int ans = 0 ; for ( int i = n ; i < s . length ( ) ; i += n ) { if ( s . charAt ( i - 1 ) == s . charAt ( i - 2 ) && s . charAt ( i - 1 ) == s . charAt ( i - 3 ) ) { ans ++ ; } } pw . println ( ans ) ; pw . close ( ) ; } }"], "python": ["I = input NEW_LINE n = int ( I ( ) ) NEW_LINE s = I ( ) NEW_LINE print ( sum ( 2 > len ( set ( s [ i - 3 : i ] ) ) for i in range ( n , len ( s ) , n ) ) ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE f = input ( ) NEW_LINE list ( f ) NEW_LINE out = 0 NEW_LINE for i in range ( n , len ( f ) , n ) : NEW_LINE INDENT if ( f [ i - 1 ] == f [ i - 2 ] and f [ i - 2 ] == f [ i - 3 ] ) : NEW_LINE INDENT out = out + 1 NEW_LINE DEDENT DEDENT print ( out ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE s = input ( ) NEW_LINE k = len ( s ) NEW_LINE i = 0 NEW_LINE c = 0 NEW_LINE while ( i < k ) : NEW_LINE INDENT if ( i - 3 >= 0 ) : NEW_LINE INDENT if ( s [ i - 1 ] == s [ i - 2 ] ) : NEW_LINE INDENT if ( s [ i - 2 ] == s [ i - 3 ] ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT i += n NEW_LINE DEDENT print ( c ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE g = input ( ) NEW_LINE r = 0 NEW_LINE for i in range ( n , len ( g ) , n ) : NEW_LINE INDENT if g [ i - 1 ] == g [ i - 2 ] == g [ i - 3 ] : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT print ( r ) NEW_LINE", "n = int ( input ( ) . strip ( ) ) NEW_LINE ans = 0 NEW_LINE s = input ( ) . strip ( ) NEW_LINE for i in range ( n , len ( s ) , n ) : NEW_LINE INDENT if s [ i - 1 ] == s [ i - 2 ] == s [ i - 3 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_2713_A", "java": ["import java . util . Arrays ; class GFG { static void sortString ( String str ) { char [ ] arr = str . toCharArray ( ) ; Arrays . sort ( arr ) ; System . out . print ( String . valueOf ( arr ) ) ; } public static void main ( String [ ] args ) { String s = \" geeksforgeeks \" ; sortString ( s ) ; } }"], "python": ["def sortString ( str ) : NEW_LINE INDENT str = ' ' . join ( sorted ( str ) ) NEW_LINE print ( str ) NEW_LINE DEDENT s = \" geeksforgeeks \" NEW_LINE sortString ( s ) NEW_LINE"]}
{"id": "codeforces_1716_B", "java": ["import java . io . * ; import java . util . * ; public class Main { public static PrintWriter out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; static void solve ( int n ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i + 1 ; } out . println ( n ) ; print1DArray ( arr ) ; for ( int t = 1 ; t < n ; t ++ ) { int temp = arr [ t ] ; arr [ t ] = arr [ t - 1 ] ; arr [ t - 1 ] = temp ; print1DArray ( arr ) ; } } static void print1DArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { out . print ( arr [ i ] ) ; if ( i < arr . length - 1 ) { out . print ( ' \u2581 ' ) ; } } out . print ( ' \\n ' ) ; } public static void main ( String [ ] args ) { MyScanner scanner = new MyScanner ( ) ; int testCount = scanner . nextInt ( ) ; for ( int testIdx = 1 ; testIdx <= testCount ; testIdx ++ ) { int n = scanner . nextInt ( ) ; solve ( n ) ; } out . close ( ) ; } public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }", "import java . io . * ; import java . util . * ; public class Solution { public static void main ( String [ ] args ) throws IOException { BufferedWriter output = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; FastReader fr = new FastReader ( ) ; int test_cases = fr . nextInt ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( int test = 1 ; test <= test_cases ; test ++ ) { int n = fr . nextInt ( ) ; sb . append ( n ) . append ( \" \\n \" ) ; for ( int fixed = n ; fixed > 0 ; fixed -- ) { int number = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == fixed ) sb . append ( n ) . append ( \" \u2581 \" ) ; else { sb . append ( number ) . append ( \" \u2581 \" ) ; number ++ ; } } sb . append ( \" \\n \" ) ; } } output . write ( sb . toString ( ) ) ; output . flush ( ) ; } } class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = \" \" ; try { if ( st . hasMoreTokens ( ) ) { str = st . nextToken ( \" \\n \" ) ; } else { str = br . readLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } }", "import java . io . BufferedReader ; import java . io . File ; import java . io . FileReader ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Solution { static PrintWriter pw ; static FastScanner s ; static int [ ] a ; public static void main ( String [ ] args ) throws Exception { pw = new PrintWriter ( System . out ) ; s = new FastScanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- > 0 ) { int n = s . nextInt ( ) ; pw . println ( n ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = i + 1 ; } for ( int i = 1 ; i < n ; i ++ ) { printArray ( ) ; swap ( i , i - 1 ) ; } printArray ( ) ; } pw . flush ( ) ; } public static void printArray ( ) { for ( int i = 0 ; i < a . length ; i ++ ) pw . print ( a [ i ] + \" \u2581 \" ) ; pw . println ( ) ; } public static void swap ( int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } } class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( InputStream s ) { br = new BufferedReader ( new InputStreamReader ( s ) ) ; } public FastScanner ( String s ) throws Exception { br = new BufferedReader ( new FileReader ( new File ( s ) ) ) ; } public String next ( ) throws Exception { while ( st == null || ! st . hasMoreTokens ( ) ) st = new StringTokenizer ( br . readLine ( ) ) ; return st . nextToken ( ) ; } public int nextInt ( ) throws Exception { return Integer . parseInt ( next ( ) ) ; } public long nextLong ( ) throws Exception { return Long . parseLong ( next ( ) ) ; } }"], "python": ["t = int ( input ( ) ) NEW_LINE for i in range ( t ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT print ( n ) NEW_LINE c = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT l [ c ] , l [ c + 1 ] = l [ c + 1 ] , l [ c ] NEW_LINE c += 1 NEW_LINE DEDENT for each in l : NEW_LINE INDENT print ( each , end = ' \u2581 ' ) NEW_LINE DEDENT i += 1 NEW_LINE print ( ) NEW_LINE DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = [ i + 1 for i in range ( n ) ] NEW_LINE print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * p ) NEW_LINE if i < n - 1 : NEW_LINE INDENT p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = [ i + 1 for i in range ( n ) ] NEW_LINE print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * p ) NEW_LINE if i < n - 1 : NEW_LINE INDENT p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE p = [ i + 1 for i in range ( n ) ] NEW_LINE print ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( * p ) NEW_LINE if i < n - 1 : NEW_LINE INDENT p [ i ] , p [ i + 1 ] = p [ i + 1 ] , p [ i ] NEW_LINE DEDENT DEDENT DEDENT", "for _ in range ( int ( input ( ) ) ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE print ( n ) NEW_LINE a = [ i for i in range ( 1 , n + 1 ) ] NEW_LINE i , j = n - 2 , n - 1 NEW_LINE for _ in range ( n - 1 ) : NEW_LINE INDENT print ( * a ) NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( * a ) NEW_LINE DEDENT"]}
{"id": "atcoder_ABC176_E", "java": ["import java . util . * ; import java . io . * ; public class Main { static Scanner inp = new Scanner ( System . in ) ; static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String args [ ] ) { Main g = new Main ( ) ; g . main ( ) ; out . close ( ) ; } void main ( ) { int n = inp . nextInt ( ) ; int m = inp . nextInt ( ) ; int q = inp . nextInt ( ) ; int r [ ] = new int [ n + 1 ] ; int c [ ] = new int [ m + 1 ] ; HashSet < Long > set = new HashSet < > ( ) ; while ( q -- > 0 ) { int x = inp . nextInt ( ) ; int y = inp . nextInt ( ) ; set . add ( hash ( x , y ) ) ; r [ x ] ++ ; c [ y ] ++ ; } int maxX = 0 , maxY = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { maxX = Math . max ( maxX , r [ i ] ) ; } for ( int i = 0 ; i <= m ; i ++ ) { maxY = Math . max ( maxY , c [ i ] ) ; } int gg = maxX + maxY - 1 ; ArrayList < Integer > xs = new ArrayList < > ( ) ; ArrayList < Integer > ys = new ArrayList < > ( ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( r [ i ] == maxX ) xs . add ( i ) ; } for ( int i = 0 ; i <= m ; i ++ ) { if ( c [ i ] == maxY ) ys . add ( i ) ; } loop : for ( int x : xs ) { for ( int y : ys ) { if ( ! set . contains ( hash ( x , y ) ) ) { gg ++ ; break loop ; } } } System . out . println ( gg ) ; } static long hash ( int x , int y ) { return x * 1000000000l + y ; } }", "import java . io . BufferedReader ; import java . io . InputStreamReader ; public class Main { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String [ ] head = br . readLine ( ) . split ( \" \u2581 \" ) ; int h = Integer . parseInt ( head [ 0 ] ) ; int w = Integer . parseInt ( head [ 1 ] ) ; int m = Integer . parseInt ( head [ 2 ] ) ; int [ ] sum_h = new int [ h ] ; int [ ] sum_w = new int [ w ] ; int [ ] [ ] bombs = new int [ m ] [ 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { String [ ] line = br . readLine ( ) . split ( \" \u2581 \" ) ; bombs [ i ] [ 0 ] = Integer . parseInt ( line [ 0 ] ) - 1 ; bombs [ i ] [ 1 ] = Integer . parseInt ( line [ 1 ] ) - 1 ; sum_h [ bombs [ i ] [ 0 ] ] ++ ; sum_w [ bombs [ i ] [ 1 ] ] ++ ; } br . close ( ) ; int max_sum_h = 0 ; int max_cnt_h = 0 ; for ( int i = 0 ; i < h ; i ++ ) { if ( max_sum_h < sum_h [ i ] ) { max_sum_h = sum_h [ i ] ; max_cnt_h = 1 ; } else if ( max_sum_h == sum_h [ i ] ) { max_cnt_h ++ ; } } int max_sum_w = 0 ; int max_cnt_w = 0 ; for ( int i = 0 ; i < w ; i ++ ) { if ( max_sum_w < sum_w [ i ] ) { max_sum_w = sum_w [ i ] ; max_cnt_w = 1 ; } else if ( max_sum_w == sum_w [ i ] ) { max_cnt_w ++ ; } } long max_bombs_pos_nominee = ( long ) max_cnt_h * max_cnt_w ; for ( int i = 0 ; i < m ; i ++ ) { if ( sum_h [ bombs [ i ] [ 0 ] ] == max_sum_h && sum_w [ bombs [ i ] [ 1 ] ] == max_sum_w ) { max_bombs_pos_nominee -- ; } } if ( max_bombs_pos_nominee == 0 ) { System . out . println ( max_sum_h + max_sum_w - 1 ) ; } else { System . out . println ( max_sum_h + max_sum_w ) ; } } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; Map < Integer , Integer > xM = new HashMap ( ) ; Map < Integer , Integer > yM = new HashMap ( ) ; Set < String > S = new HashSet ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { int x = scan . nextInt ( ) ; int y = scan . nextInt ( ) ; xM . put ( x , xM . getOrDefault ( x , 0 ) + 1 ) ; yM . put ( y , yM . getOrDefault ( y , 0 ) + 1 ) ; String st = x + \" - \" + y ; S . add ( st ) ; } int mxNum = 0 ; for ( int val : xM . values ( ) ) mxNum = Math . max ( mxNum , val ) ; int myNum = 0 ; for ( int val : yM . values ( ) ) myNum = Math . max ( myNum , val ) ; List < Integer > listx = new ArrayList ( ) ; for ( int key : xM . keySet ( ) ) { if ( xM . get ( key ) == mxNum ) listx . add ( key ) ; } List < Integer > listy = new ArrayList ( ) ; for ( int key : yM . keySet ( ) ) { if ( yM . get ( key ) == myNum ) listy . add ( key ) ; } int ans = mxNum + myNum - 1 ; for ( int i = 0 ; i < listx . size ( ) ; i ++ ) { for ( int j = 0 ; j < listy . size ( ) ; j ++ ) { String st = listx . get ( i ) + \" - \" + listy . get ( j ) ; if ( S . contains ( st ) == false ) { System . out . println ( ans + 1 ) ; return ; } } } System . out . println ( ans ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner keyboard = new Scanner ( System . in ) ; int H = keyboard . nextInt ( ) ; int W = keyboard . nextInt ( ) ; int M = keyboard . nextInt ( ) ; HashMap < Long , Integer > Bakuha = new HashMap < Long , Integer > ( ) ; long MaxH = 3 * 100000 ; int [ ] sumH = new int [ H ] ; int [ ] sumW = new int [ W ] ; int SH = 0 ; int SW = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int inH = keyboard . nextInt ( ) - 1 ; int inW = keyboard . nextInt ( ) - 1 ; Bakuha . put ( ( inH * MaxH ) + inW , 1 ) ; sumH [ inH ] ++ ; sumW [ inW ] ++ ; if ( sumH [ inH ] >= SH ) { SH = sumH [ inH ] ; } if ( sumW [ inW ] >= SW ) { SW = sumW [ inW ] ; } } ArrayList < Integer > SHindex = new ArrayList < Integer > ( ) ; ArrayList < Integer > SWindex = new ArrayList < Integer > ( ) ; for ( int h = 0 ; h < H ; h ++ ) { if ( sumH [ h ] == SH ) { SHindex . add ( h ) ; } } for ( int w = 0 ; w < W ; w ++ ) { if ( sumW [ w ] == SW ) { SWindex . add ( w ) ; } } int ans = SH + SW - 1 ; if ( ( long ) SHindex . size ( ) * SWindex . size ( ) > M ) { ans = SH + SW ; } else { for ( int i = 0 ; i < SHindex . size ( ) ; i ++ ) { for ( int j = 0 ; j < SWindex . size ( ) ; j ++ ) { if ( ! Bakuha . containsKey ( SHindex . get ( i ) * MaxH + SWindex . get ( j ) ) ) { ans = SH + SW ; } } } } System . out . print ( ans ) ; keyboard . close ( ) ; } }"], "python": ["from itertools import product NEW_LINE h , w , m = map ( int , input ( ) . split ( ) ) NEW_LINE row = [ set ( ) for _ in range ( h ) ] NEW_LINE col = [ set ( ) for _ in range ( w ) ] NEW_LINE for _ in range ( m ) : NEW_LINE INDENT x , y = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) NEW_LINE row [ x ] . add ( y ) NEW_LINE col [ y ] . add ( x ) NEW_LINE DEDENT crow = 0 NEW_LINE ic = [ ] NEW_LINE for i , x in enumerate ( row ) : NEW_LINE INDENT if crow < len ( x ) : NEW_LINE INDENT crow = len ( x ) NEW_LINE ic = [ i ] NEW_LINE DEDENT elif crow == len ( x ) : NEW_LINE INDENT ic . append ( i ) NEW_LINE DEDENT DEDENT ccol = 0 NEW_LINE jc = [ ] NEW_LINE for j , x in enumerate ( col ) : NEW_LINE INDENT if ccol < len ( x ) : NEW_LINE INDENT ccol = len ( x ) NEW_LINE jc = [ j ] NEW_LINE DEDENT elif ccol == len ( x ) : NEW_LINE INDENT jc . append ( j ) NEW_LINE DEDENT DEDENT ans = crow + ccol NEW_LINE for i , j in product ( ic , jc ) : NEW_LINE INDENT if j not in row [ i ] : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( ans - 1 ) NEW_LINE DEDENT", "from sys import exit , stdin NEW_LINE from collections import deque , Counter NEW_LINE input = stdin . readline NEW_LINE H , W , M = map ( int , input ( ) . split ( ) ) NEW_LINE col = Counter ( ) NEW_LINE row = Counter ( ) NEW_LINE D = Counter ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT h , w = map ( int , input ( ) . split ( ) ) NEW_LINE row . update ( [ h ] ) NEW_LINE col . update ( [ w ] ) NEW_LINE D . update ( [ str ( h ) + str ( w ) ] ) NEW_LINE DEDENT rtmp = row . most_common ( 1 ) [ 0 ] [ 1 ] NEW_LINE ctmp = col . most_common ( 1 ) [ 0 ] [ 1 ] NEW_LINE rmax = [ ] NEW_LINE cmax = [ ] NEW_LINE for r in row . most_common ( ) : NEW_LINE INDENT if r [ 1 ] < rtmp : NEW_LINE INDENT break NEW_LINE DEDENT rmax . append ( r ) NEW_LINE DEDENT for c in col . most_common ( ) : NEW_LINE INDENT if c [ 1 ] < ctmp : NEW_LINE INDENT break NEW_LINE DEDENT cmax . append ( c ) NEW_LINE DEDENT ridx = str ( rmax [ 0 ] [ 0 ] ) NEW_LINE for d in cmax : NEW_LINE INDENT if D [ ridx + str ( d [ 0 ] ) ] == 0 : NEW_LINE INDENT ans = rmax [ 0 ] [ 1 ] + d [ 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans = rmax [ 0 ] [ 1 ] + d [ 1 ] - 1 NEW_LINE DEDENT cidx = str ( cmax [ 0 ] [ 0 ] ) NEW_LINE for d in rmax : NEW_LINE INDENT if D [ str ( d [ 0 ] ) + cidx ] == 0 : NEW_LINE INDENT ans2 = cmax [ 0 ] [ 1 ] + d [ 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT ans2 = cmax [ 0 ] [ 1 ] + d [ 1 ] - 1 NEW_LINE DEDENT print ( max ( ans , ans2 ) ) NEW_LINE", "from collections import defaultdict NEW_LINE h , w , m = map ( int , input ( ) . split ( ) ) NEW_LINE targets = defaultdict ( int ) NEW_LINE targets_count_yoko = defaultdict ( int ) NEW_LINE targets_count_tate = defaultdict ( int ) NEW_LINE for _ in range ( m ) : NEW_LINE INDENT y , x = map ( int , input ( ) . split ( ) ) NEW_LINE y -= 1 NEW_LINE x -= 1 NEW_LINE targets_count_yoko [ x ] += 1 NEW_LINE targets_count_tate [ y ] += 1 NEW_LINE targets [ ( y , x ) ] = - 1 NEW_LINE DEDENT max_row = max ( targets_count_yoko . values ( ) ) NEW_LINE max_line = max ( targets_count_tate . values ( ) ) NEW_LINE y_idx = defaultdict ( bool ) NEW_LINE x_idx = defaultdict ( bool ) NEW_LINE max_count_x = 0 NEW_LINE max_count_y = 0 NEW_LINE for i in range ( w ) : NEW_LINE INDENT if targets_count_yoko [ i ] == max_row : NEW_LINE INDENT x_idx [ i ] = True NEW_LINE max_count_x += 1 NEW_LINE DEDENT DEDENT for i in range ( h ) : NEW_LINE INDENT if targets_count_tate [ i ] == max_line : NEW_LINE INDENT y_idx [ i ] = True NEW_LINE max_count_y += 1 NEW_LINE DEDENT DEDENT ans = max_line + max_row NEW_LINE kumi = max_count_x * max_count_y NEW_LINE for key_y , key_x in targets . keys ( ) : NEW_LINE INDENT if y_idx [ key_y ] and x_idx [ key_x ] : NEW_LINE INDENT kumi -= 1 NEW_LINE DEDENT if kumi == 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if kumi == 0 : NEW_LINE INDENT print ( ans - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT", "import sys NEW_LINE from collections import defaultdict NEW_LINE H , W , M = map ( int , input ( ) . split ( ) ) NEW_LINE X = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] NEW_LINE ctr_h = defaultdict ( int ) NEW_LINE ctr_w = defaultdict ( int ) NEW_LINE appeared = set ( ) NEW_LINE for h , w in X : NEW_LINE INDENT ctr_h [ h ] += 1 NEW_LINE ctr_w [ w ] += 1 NEW_LINE appeared . add ( h * W + w ) NEW_LINE DEDENT val_h = sorted ( ctr_h . items ( ) , key = lambda x : - x [ 1 ] ) NEW_LINE val_w = sorted ( ctr_w . items ( ) , key = lambda x : - x [ 1 ] ) NEW_LINE max_h = val_h [ 0 ] [ 1 ] NEW_LINE max_w = val_w [ 0 ] [ 1 ] NEW_LINE val_h = [ i for i , v in val_h if v == max_h ] NEW_LINE val_w = [ i for i , v in val_w if v == max_w ] NEW_LINE if len ( val_h ) * len ( val_w ) > M : NEW_LINE INDENT print ( max_h + max_w ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT for h in val_h : NEW_LINE INDENT for w in val_w : NEW_LINE INDENT if h * W + w not in appeared : NEW_LINE INDENT print ( max_h + max_w ) NEW_LINE sys . exit ( 0 ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT print ( max_h + max_w - 1 ) NEW_LINE DEDENT", "ans = 0 NEW_LINE h , w , m = map ( int , input ( ) . split ( ) ) NEW_LINE d = list ( ) NEW_LINE from collections import defaultdict NEW_LINE r = defaultdict ( int ) NEW_LINE c = defaultdict ( int ) NEW_LINE r = [ 0 ] * ( h + 1 ) NEW_LINE c = [ 0 ] * ( w + 1 ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d += ( a , b ) , NEW_LINE r [ a ] += 1 NEW_LINE c [ b ] += 1 NEW_LINE DEDENT R = max ( r ) NEW_LINE C = max ( c ) NEW_LINE x = 0 NEW_LINE nr = r . count ( R ) NEW_LINE nc = c . count ( C ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = d [ i ] NEW_LINE if r [ a ] == R and c [ b ] == C : NEW_LINE INDENT x += 1 NEW_LINE DEDENT DEDENT ans = R + C NEW_LINE if x == nr * nc : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( ans ) NEW_LINE"]}
{"id": "geeksforgeeks_2338_A", "java": ["import java . io . * ; class GFG { static void printNumber ( int n ) { int count [ ] = new int [ 10 ] ; while ( n > 0 ) { count [ n % 10 ] ++ ; n /= 10 ; } for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < count [ i ] * i ; j ++ ) System . out . print ( i ) ; } } public static void main ( String [ ] args ) { int n = 3225 ; printNumber ( n ) ; } }"], "python": ["def printNumber ( n ) : NEW_LINE INDENT count = [ 0 ] * 10 NEW_LINE while ( n ) : NEW_LINE INDENT count [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT for j in range ( count [ i ] * i ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3225 NEW_LINE printNumber ( n ) NEW_LINE DEDENT"]}
{"id": "geeksforgeeks_553_A", "java": ["class GFG { static int getMax ( int [ ] Arr ) { int max = Arr [ 0 ] ; for ( int i = 1 ; i < Arr . length ; i ++ ) if ( Arr [ i ] > max ) max = Arr [ i ] ; return max ; } static int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; } public static void main ( String [ ] args ) { int N = 40 ; System . out . println ( maxPrimefactorNum ( N ) ) ; } }"], "python": ["def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE arr [ i ] = 1 ; NEW_LINE DEDENT return max ( arr ) ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE"]}
{"id": "aizu_p02203_A", "java": ["import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int prev = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = sc . nextInt ( ) ; if ( x <= prev ) { count ++ ; } prev = x ; } System . out . println ( count ) ; System . out . println ( n ) ; } }", "import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] nums = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) nums [ i ] = sc . nextInt ( ) ; int ans = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( nums [ i ] >= nums [ i + 1 ] ) ans ++ ; } System . out . println ( ans ) ; System . out . println ( n ) ; } }"], "python": ["n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE cnt = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE print ( n ) NEW_LINE", "from itertools import * NEW_LINE from bisect import * NEW_LINE from math import * NEW_LINE from collections import * NEW_LINE from heapq import * NEW_LINE from random import * NEW_LINE import sys NEW_LINE sys . setrecursionlimit ( 10 ** 6 ) NEW_LINE int1 = lambda x : int ( x ) - 1 NEW_LINE p2D = lambda x : print ( * x , sep = \" \\n \" ) NEW_LINE def II ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def MI ( ) : return map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def MI1 ( ) : return map ( int1 , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def MF ( ) : return map ( float , sys . stdin . readline ( ) . split ( ) ) NEW_LINE def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LI1 ( ) : return list ( map ( int1 , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LF ( ) : return list ( map ( float , sys . stdin . readline ( ) . split ( ) ) ) NEW_LINE def LLI ( rows_number ) : return [ LI ( ) for _ in range ( rows_number ) ] NEW_LINE dij = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] NEW_LINE def main ( ) : NEW_LINE INDENT n = II ( ) NEW_LINE aa = LI ( ) NEW_LINE mn = 1 NEW_LINE for a0 , a1 in zip ( aa , aa [ 1 : ] ) : NEW_LINE INDENT if a0 >= a1 : mn += 1 NEW_LINE DEDENT print ( mn ) NEW_LINE print ( n ) NEW_LINE DEDENT main ( ) NEW_LINE", "def num ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def nums ( ) : NEW_LINE INDENT return list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE DEDENT N = num ( ) NEW_LINE A = nums ( ) NEW_LINE ans_max = N NEW_LINE ans_min = 0 NEW_LINE old_i = 0 NEW_LINE for i in A : NEW_LINE INDENT if not i > old_i : NEW_LINE INDENT ans_min += 1 NEW_LINE DEDENT old_i = i NEW_LINE DEDENT ans_min += 1 NEW_LINE print ( ans_min ) NEW_LINE print ( ans_max ) NEW_LINE", "N = int ( input ( ) ) NEW_LINE A = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE min = 1 NEW_LINE max = N NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if A [ i ] <= A [ i - 1 ] : NEW_LINE INDENT min += 1 NEW_LINE DEDENT DEDENT print ( min ) NEW_LINE print ( max ) NEW_LINE", "n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if a [ i ] >= a [ i + 1 ] : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE print ( n ) NEW_LINE"]}
