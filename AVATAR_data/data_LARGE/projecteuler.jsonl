{"id": "projecteuler_p109_A", "java": [{"id": "1", "code": "import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; public final class p109 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p109 ( ) . run ( ) ) ; } public String run ( ) { points = new ArrayList < > ( ) ; for ( int i = 1 ; i <= 20 ; i ++ ) { for ( int j = 1 ; j <= 3 ; j ++ ) points . add ( i * j ) ; } points . add ( 25 ) ; points . add ( 50 ) ; List < Integer > doublePoints = new ArrayList < > ( ) ; for ( int i = 1 ; i <= 20 ; i ++ ) doublePoints . add ( i * 2 ) ; doublePoints . add ( 25 * 2 ) ; ways = new int [ 3 ] [ 101 ] [ points . size ( ) ] ; for ( int [ ] [ ] x : ways ) { for ( int [ ] y : x ) Arrays . fill ( y , - 1 ) ; } int checkouts = 0 ; for ( int remainingPoints = 1 ; remainingPoints < 100 ; remainingPoints ++ ) { for ( int throwz = 0 ; throwz <= 2 ; throwz ++ ) { for ( int p : doublePoints ) { if ( p <= remainingPoints ) checkouts += ways ( throwz , remainingPoints - p , points . size ( ) - 1 ) ; } } } return Integer . toString ( checkouts ) ; } private List < Integer > points ; private int [ ] [ ] [ ] ways ; private int ways ( int throwz , int total , int maxIndex ) { if ( ways [ throwz ] [ total ] [ maxIndex ] == - 1 ) { int result ; if ( throwz == 0 ) result = total == 0 ? 1 : 0 ; else { result = 0 ; if ( maxIndex > 0 ) result += ways ( throwz , total , maxIndex - 1 ) ; if ( points . get ( maxIndex ) <= total ) result += ways ( throwz - 1 , total - points . get ( maxIndex ) , maxIndex ) ; } ways [ throwz ] [ total ] [ maxIndex ] = result ; } return ways [ throwz ] [ total ] [ maxIndex ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p109 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { points = new ArrayList < > ( ) ; for ( int i = 1 ; i <= 20 ; i ++ ) { for ( int j = 1 ; j <= 3 ; j ++ ) points . add ( i * j ) ; } points . add ( 25 ) ; points . add ( 50 ) ; List < Integer > doublePoints = new ArrayList < > ( ) ; for ( int i = 1 ; i <= 20 ; i ++ ) doublePoints . add ( i * 2 ) ; doublePoints . add ( 25 * 2 ) ; ways = new int [ 3 ] [ 101 ] [ points . size ( ) ] ; for ( int [ ] [ ] x : ways ) { for ( int [ ] y : x ) Arrays . fill ( y , - 1 ) ; } int checkouts = 0 ; for ( int remainingPoints = 1 ; remainingPoints < 100 ; remainingPoints ++ ) { for ( int throwz = 0 ; throwz <= 2 ; throwz ++ ) { for ( int p : doublePoints ) { if ( p <= remainingPoints ) checkouts += ways ( throwz , remainingPoints - p , points . size ( ) - 1 ) ; } } } return Integer . toString ( checkouts ) ; }"], ["ways", "private int ways ( int throwz , int total , int maxIndex ) { if ( ways [ throwz ] [ total ] [ maxIndex ] == - 1 ) { int result ; if ( throwz == 0 ) result = total == 0 ? 1 : 0 ; else { result = 0 ; if ( maxIndex > 0 ) result += ways ( throwz , total , maxIndex - 1 ) ; if ( points . get ( maxIndex ) <= total ) result += ways ( throwz - 1 , total - points . get ( maxIndex ) , maxIndex ) ; } ways [ throwz ] [ total ] [ maxIndex ] = result ; } return ways [ throwz ] [ total ] [ maxIndex ] ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT points = [ i * j for i in range ( 1 , 21 ) for j in range ( 1 , 4 ) ] + [ 25 , 50 ] NEW_LINE doublepoints = [ i * 2 for i in range ( 1 , 21 ) ] + [ 25 * 2 ] NEW_LINE ways = [ [ [ None ] * len ( points ) for j in range ( 101 ) ] for i in range ( 3 ) ] NEW_LINE def calc_ways ( throws , total , maxindex ) : NEW_LINE INDENT if ways [ throws ] [ total ] [ maxindex ] is None : NEW_LINE INDENT if throws == 0 : NEW_LINE INDENT result = 1 if total == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if maxindex > 0 : NEW_LINE INDENT result += calc_ways ( throws , total , maxindex - 1 ) NEW_LINE DEDENT if points [ maxindex ] <= total : NEW_LINE INDENT result += calc_ways ( throws - 1 , total - points [ maxindex ] , maxindex ) NEW_LINE DEDENT DEDENT ways [ throws ] [ total ] [ maxindex ] = result NEW_LINE DEDENT return ways [ throws ] [ total ] [ maxindex ] NEW_LINE DEDENT checkouts = 0 NEW_LINE for remainingpoints in range ( 1 , 100 ) : NEW_LINE INDENT for throws in range ( 3 ) : NEW_LINE INDENT for p in doublepoints : NEW_LINE INDENT if p <= remainingpoints : NEW_LINE INDENT checkouts += calc_ways ( throws , remainingpoints - p , len ( points ) - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( checkouts ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT points = [ i * j for i in range ( 1 , 21 ) for j in range ( 1 , 4 ) ] + [ 25 , 50 ] NEW_LINE doublepoints = [ i * 2 for i in range ( 1 , 21 ) ] + [ 25 * 2 ] NEW_LINE ways = [ [ [ None ] * len ( points ) for j in range ( 101 ) ] for i in range ( 3 ) ] NEW_LINE def calc_ways ( throws , total , maxindex ) : NEW_LINE INDENT if ways [ throws ] [ total ] [ maxindex ] is None : NEW_LINE INDENT if throws == 0 : NEW_LINE INDENT result = 1 if total == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if maxindex > 0 : NEW_LINE INDENT result += calc_ways ( throws , total , maxindex - 1 ) NEW_LINE DEDENT if points [ maxindex ] <= total : NEW_LINE INDENT result += calc_ways ( throws - 1 , total - points [ maxindex ] , maxindex ) NEW_LINE DEDENT DEDENT ways [ throws ] [ total ] [ maxindex ] = result NEW_LINE DEDENT return ways [ throws ] [ total ] [ maxindex ] NEW_LINE DEDENT checkouts = 0 NEW_LINE for remainingpoints in range ( 1 , 100 ) : NEW_LINE INDENT for throws in range ( 3 ) : NEW_LINE INDENT for p in doublepoints : NEW_LINE INDENT if p <= remainingpoints : NEW_LINE INDENT checkouts += calc_ways ( throws , remainingpoints - p , len ( points ) - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return str ( checkouts ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p304_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p304 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p304 ( ) . run ( ) ) ; } private static final long BASE = 100000000000000L ; private static final int SEARCH_RANGE = 10000000 ; private static final long MODULUS = 1234567891011L ; private static final BigInteger MODULUS_BI = BigInteger . valueOf ( MODULUS ) ; private boolean [ ] isComposite ; public String run ( ) { int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( BASE + SEARCH_RANGE ) ) ; isComposite = new boolean [ SEARCH_RANGE ] ; for ( int p : primes ) { for ( int i = ( int ) ( ( BASE + p - 1 ) / p * p - BASE ) ; i < isComposite . length ; i += p ) isComposite [ i ] = true ; } long sum = 0 ; int p = 0 ; for ( int i = 0 ; i < 100000 ; i ++ ) { p = nextPrime ( p ) ; sum = ( sum + fibonacciMod ( BASE + p ) ) % MODULUS ; } return Long . toString ( sum ) ; } private int nextPrime ( int n ) { do { n ++ ; if ( n >= isComposite . length ) throw new AssertionError ( \" Search \u2581 range \u2581 exhausted \" ) ; } while ( isComposite [ n ] ) ; return n ; } private static long fibonacciMod ( long n ) { BigInteger a = BigInteger . ZERO ; BigInteger b = BigInteger . ONE ; for ( int i = 63 ; i >= 0 ; i -- ) { BigInteger d = a . multiply ( b . shiftLeft ( 1 ) . subtract ( a ) ) ; BigInteger e = a . pow ( 2 ) . add ( b . pow ( 2 ) ) ; a = d ; b = e ; if ( ( ( n >>> i ) & 1 ) != 0 ) { BigInteger c = a . add ( b ) ; a = b ; b = c ; } a = a . mod ( MODULUS_BI ) ; b = b . mod ( MODULUS_BI ) ; } return a . longValue ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p304 ( ) . run ( ) ) ; }"], ["fibonacciMod", "private static long fibonacciMod ( long n ) { BigInteger a = BigInteger . ZERO ; BigInteger b = BigInteger . ONE ; for ( int i = 63 ; i >= 0 ; i -- ) { BigInteger d = a . multiply ( b . shiftLeft ( 1 ) . subtract ( a ) ) ; BigInteger e = a . pow ( 2 ) . add ( b . pow ( 2 ) ) ; a = d ; b = e ; if ( ( ( n >>> i ) & 1 ) != 0 ) { BigInteger c = a . add ( b ) ; a = b ; b = c ; } a = a . mod ( MODULUS_BI ) ; b = b . mod ( MODULUS_BI ) ; } return a . longValue ( ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( BASE + SEARCH_RANGE ) ) ; isComposite = new boolean [ SEARCH_RANGE ] ; for ( int p : primes ) { for ( int i = ( int ) ( ( BASE + p - 1 ) / p * p - BASE ) ; i < isComposite . length ; i += p ) isComposite [ i ] = true ; } long sum = 0 ; int p = 0 ; for ( int i = 0 ; i < 100000 ; i ++ ) { p = nextPrime ( p ) ; sum = ( sum + fibonacciMod ( BASE + p ) ) % MODULUS ; } return Long . toString ( sum ) ; }"], ["nextPrime", "private int nextPrime ( int n ) { do { n ++ ; if ( n >= isComposite . length ) throw new AssertionError ( \" Search \u2581 range \u2581 exhausted \" ) ; } while ( isComposite [ n ] ) ; return n ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT BASE = 10 ** 14 NEW_LINE SEARCH_RANGE = 10000000 NEW_LINE MODULUS = 1234567891011 NEW_LINE iscomposite = [ False ] * SEARCH_RANGE NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( BASE + SEARCH_RANGE ) ) NEW_LINE for p in primes : NEW_LINE INDENT for i in range ( ( BASE + p - 1 ) // p * p - BASE , len ( iscomposite ) , p ) : NEW_LINE INDENT iscomposite [ i ] = True NEW_LINE DEDENT DEDENT def next_prime ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT n += 1 NEW_LINE if n >= len ( iscomposite ) : NEW_LINE INDENT raise AssertionError ( \" Search \u2581 range \u2581 exhausted \" ) NEW_LINE DEDENT if not iscomposite [ n ] : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE p = 0 NEW_LINE for i in range ( 100000 ) : NEW_LINE INDENT p = next_prime ( p ) NEW_LINE ans = ( ans + fibonacci_mod ( BASE + p , MODULUS ) ) % MODULUS NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def fibonacci_mod ( n , mod ) : NEW_LINE INDENT a , b = 0 , 1 NEW_LINE binary = bin ( n ) [ 2 : ] NEW_LINE for bit in binary : NEW_LINE INDENT a , b = a * ( b * 2 - a ) , a * a + b * b NEW_LINE if bit == \"1\" : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT a %= mod NEW_LINE b %= mod NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT BASE = 10 ** 14 NEW_LINE SEARCH_RANGE = 10000000 NEW_LINE MODULUS = 1234567891011 NEW_LINE iscomposite = [ False ] * SEARCH_RANGE NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( BASE + SEARCH_RANGE ) ) NEW_LINE for p in primes : NEW_LINE INDENT for i in range ( ( BASE + p - 1 ) // p * p - BASE , len ( iscomposite ) , p ) : NEW_LINE INDENT iscomposite [ i ] = True NEW_LINE DEDENT DEDENT def next_prime ( n ) : NEW_LINE INDENT while True : NEW_LINE INDENT n += 1 NEW_LINE if n >= len ( iscomposite ) : NEW_LINE INDENT raise AssertionError ( \" Search \u2581 range \u2581 exhausted \" ) NEW_LINE DEDENT if not iscomposite [ n ] : NEW_LINE INDENT return n NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE p = 0 NEW_LINE for i in range ( 100000 ) : NEW_LINE INDENT p = next_prime ( p ) NEW_LINE ans = ( ans + fibonacci_mod ( BASE + p , MODULUS ) ) % MODULUS NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"], ["fibonacci_mod", "def fibonacci_mod ( n , mod ) : NEW_LINE INDENT a , b = 0 , 1 NEW_LINE binary = bin ( n ) [ 2 : ] NEW_LINE for bit in binary : NEW_LINE INDENT a , b = a * ( b * 2 - a ) , a * a + b * b NEW_LINE if bit == \"1\" : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT a %= mod NEW_LINE b %= mod NEW_LINE DEDENT return a NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p100_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p100 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p100 ( ) . run ( ) ) ; } public String run ( ) { BigInteger x0 = BigInteger . valueOf ( 3 ) ; BigInteger y0 = BigInteger . valueOf ( 1 ) ; BigInteger x = x0 ; BigInteger y = y0 ; while ( true ) { BigInteger sqrt = Library . sqrt ( y . multiply ( y ) . multiply ( BigInteger . valueOf ( 8 ) ) . add ( BigInteger . ONE ) ) ; if ( sqrt . testBit ( 0 ) ) { BigInteger blue = sqrt . add ( BigInteger . ONE ) . divide ( BigInteger . valueOf ( 2 ) ) . add ( y ) ; if ( blue . add ( y ) . compareTo ( BigInteger . TEN . pow ( 12 ) ) > 0 ) return blue . toString ( ) ; } BigInteger nextx = x . multiply ( x0 ) . add ( y . multiply ( y0 ) . multiply ( BigInteger . valueOf ( 8 ) ) ) ; BigInteger nexty = x . multiply ( y0 ) . add ( y . multiply ( x0 ) ) ; x = nextx ; y = nexty ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p100 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger x0 = BigInteger . valueOf ( 3 ) ; BigInteger y0 = BigInteger . valueOf ( 1 ) ; BigInteger x = x0 ; BigInteger y = y0 ; while ( true ) { BigInteger sqrt = Library . sqrt ( y . multiply ( y ) . multiply ( BigInteger . valueOf ( 8 ) ) . add ( BigInteger . ONE ) ) ; if ( sqrt . testBit ( 0 ) ) { BigInteger blue = sqrt . add ( BigInteger . ONE ) . divide ( BigInteger . valueOf ( 2 ) ) . add ( y ) ; if ( blue . add ( y ) . compareTo ( BigInteger . TEN . pow ( 12 ) ) > 0 ) return blue . toString ( ) ; } BigInteger nextx = x . multiply ( x0 ) . add ( y . multiply ( y0 ) . multiply ( BigInteger . valueOf ( 8 ) ) ) ; BigInteger nexty = x . multiply ( y0 ) . add ( y . multiply ( x0 ) ) ; x = nextx ; y = nexty ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT x0 = 3 NEW_LINE y0 = 1 NEW_LINE x = x0 NEW_LINE y = y0 NEW_LINE while True : NEW_LINE INDENT sqrt = eulerlib . sqrt ( y ** 2 * 8 + 1 ) NEW_LINE if sqrt % 2 == 1 : NEW_LINE INDENT blue = ( sqrt + 1 ) // 2 + y NEW_LINE if blue + y > 10 ** 12 : NEW_LINE INDENT return str ( blue ) NEW_LINE DEDENT DEDENT nextx = x * x0 + y * y0 * 8 NEW_LINE nexty = x * y0 + y * x0 NEW_LINE x = nextx NEW_LINE y = nexty NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT x0 = 3 NEW_LINE y0 = 1 NEW_LINE x = x0 NEW_LINE y = y0 NEW_LINE while True : NEW_LINE INDENT sqrt = eulerlib . sqrt ( y ** 2 * 8 + 1 ) NEW_LINE if sqrt % 2 == 1 : NEW_LINE INDENT blue = ( sqrt + 1 ) // 2 + y NEW_LINE if blue + y > 10 ** 12 : NEW_LINE INDENT return str ( blue ) NEW_LINE DEDENT DEDENT nextx = x * x0 + y * y0 * 8 NEW_LINE nexty = x * y0 + y * x0 NEW_LINE x = nextx NEW_LINE y = nexty NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p191_A", "java": [{"id": "1", "code": "public final class p191 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p191 ( ) . run ( ) ) ; } private static final int NUM_DAYS = 30 ; private static final int MAX_ABSENT = 2 ; private static final int MAX_LATE = 1 ; public String run ( ) { long [ ] [ ] [ ] numPrizeStrings = new long [ NUM_DAYS + 1 ] [ MAX_ABSENT + 1 ] [ MAX_LATE + 1 ] ; numPrizeStrings [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= NUM_DAYS ; i ++ ) { for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) { long sum ; if ( j == 0 ) { sum = 0 ; for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k ] ; if ( k > 0 ) { for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k - 1 ] ; } } else sum = numPrizeStrings [ i - 1 ] [ j - 1 ] [ k ] ; numPrizeStrings [ i ] [ j ] [ k ] = sum ; } } } long sum = 0 ; for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) sum += numPrizeStrings [ NUM_DAYS ] [ j ] [ k ] ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p191 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] [ ] [ ] numPrizeStrings = new long [ NUM_DAYS + 1 ] [ MAX_ABSENT + 1 ] [ MAX_LATE + 1 ] ; numPrizeStrings [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= NUM_DAYS ; i ++ ) { for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) { long sum ; if ( j == 0 ) { sum = 0 ; for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k ] ; if ( k > 0 ) { for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k - 1 ] ; } } else sum = numPrizeStrings [ i - 1 ] [ j - 1 ] [ k ] ; numPrizeStrings [ i ] [ j ] [ k ] = sum ; } } } long sum = 0 ; for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) sum += numPrizeStrings [ NUM_DAYS ] [ j ] [ k ] ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT NUM_DAYS = 30 NEW_LINE MAX_ABSENT = 2 NEW_LINE MAX_LATE = 1 NEW_LINE num_prize_strings = create_nested_lists ( 0 , NUM_DAYS + 1 , MAX_ABSENT + 1 , MAX_LATE + 1 ) NEW_LINE num_prize_strings [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( num_prize_strings ) ) : NEW_LINE INDENT for j in range ( len ( num_prize_strings [ i ] ) ) : NEW_LINE INDENT for k in range ( len ( num_prize_strings [ i ] [ j ] ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT s = 0 NEW_LINE for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k ] NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT s = num_prize_strings [ i - 1 ] [ j - 1 ] [ k ] NEW_LINE DEDENT num_prize_strings [ i ] [ j ] [ k ] = s NEW_LINE DEDENT DEDENT DEDENT ans = sum ( map ( sum , num_prize_strings [ NUM_DAYS ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def create_nested_lists ( value , * dimensions ) : NEW_LINE INDENT if len ( dimensions ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT elif len ( dimensions ) == 1 : NEW_LINE INDENT return [ value ] * dimensions [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ create_nested_lists ( value , * dimensions [ 1 : ] ) for _ in range ( dimensions [ 0 ] ) ] NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT NUM_DAYS = 30 NEW_LINE MAX_ABSENT = 2 NEW_LINE MAX_LATE = 1 NEW_LINE num_prize_strings = create_nested_lists ( 0 , NUM_DAYS + 1 , MAX_ABSENT + 1 , MAX_LATE + 1 ) NEW_LINE num_prize_strings [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( num_prize_strings ) ) : NEW_LINE INDENT for j in range ( len ( num_prize_strings [ i ] ) ) : NEW_LINE INDENT for k in range ( len ( num_prize_strings [ i ] [ j ] ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT s = 0 NEW_LINE for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k ] NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT s = num_prize_strings [ i - 1 ] [ j - 1 ] [ k ] NEW_LINE DEDENT num_prize_strings [ i ] [ j ] [ k ] = s NEW_LINE DEDENT DEDENT DEDENT ans = sum ( map ( sum , num_prize_strings [ NUM_DAYS ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["create_nested_lists", "def create_nested_lists ( value , * dimensions ) : NEW_LINE INDENT if len ( dimensions ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT elif len ( dimensions ) == 1 : NEW_LINE INDENT return [ value ] * dimensions [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ create_nested_lists ( value , * dimensions [ 1 : ] ) for _ in range ( dimensions [ 0 ] ) ] NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p357_A", "java": [{"id": "1", "code": "public final class p357 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p357 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) ; private boolean [ ] isPrime ; public String run ( ) { isPrime = Library . listPrimality ( LIMIT + 1 ) ; long sum = 0 ; for ( int n = 0 ; n <= LIMIT ; n ++ ) { if ( isPrime [ n + 1 ] && isPrimeGenerating ( n ) ) sum += n ; } return Long . toString ( sum ) ; } private boolean isPrimeGenerating ( int n ) { for ( int i = 1 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 && ! isPrime [ i + n / i ] ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p357 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { isPrime = Library . listPrimality ( LIMIT + 1 ) ; long sum = 0 ; for ( int n = 0 ; n <= LIMIT ; n ++ ) { if ( isPrime [ n + 1 ] && isPrimeGenerating ( n ) ) sum += n ; } return Long . toString ( sum ) ; }"], ["isPrimeGenerating", "private boolean isPrimeGenerating ( int n ) { for ( int i = 1 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 && ! isPrime [ i + n / i ] ) return false ; } return true ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE isprime = eulerlib . list_primality ( LIMIT + 1 ) NEW_LINE def is_prime_generating ( n ) : NEW_LINE INDENT return all ( ( n % d != 0 or isprime [ d + n // d ] ) for d in range ( 2 , eulerlib . sqrt ( n ) + 1 ) ) NEW_LINE DEDENT ans = sum ( n for n in range ( LIMIT + 1 ) if isprime [ n + 1 ] and is_prime_generating ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE isprime = eulerlib . list_primality ( LIMIT + 1 ) NEW_LINE def is_prime_generating ( n ) : NEW_LINE INDENT return all ( ( n % d != 0 or isprime [ d + n // d ] ) for d in range ( 2 , eulerlib . sqrt ( n ) + 1 ) ) NEW_LINE DEDENT ans = sum ( n for n in range ( LIMIT + 1 ) if isprime [ n + 1 ] and is_prime_generating ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p162_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p162 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p162 ( ) . run ( ) ) ; } public String run ( ) { BigInteger sum = BigInteger . ZERO ; for ( int n = 1 ; n <= 16 ; n ++ ) { sum = sum . add ( bi ( 15 ) . multiply ( bi ( 16 ) . pow ( n - 1 ) ) ) . subtract ( bi ( 43 ) . multiply ( bi ( 15 ) . pow ( n - 1 ) ) ) . add ( bi ( 41 ) . multiply ( bi ( 14 ) . pow ( n - 1 ) ) ) . subtract ( bi ( 13 ) . pow ( n ) ) ; } return sum . toString ( 16 ) . toUpperCase ( ) ; } private static BigInteger bi ( int n ) { return BigInteger . valueOf ( n ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p162 ( ) . run ( ) ) ; }"], ["bi", "private static BigInteger bi ( int n ) { return BigInteger . valueOf ( n ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger sum = BigInteger . ZERO ; for ( int n = 1 ; n <= 16 ; n ++ ) { sum = sum . add ( bi ( 15 ) . multiply ( bi ( 16 ) . pow ( n - 1 ) ) ) . subtract ( bi ( 43 ) . multiply ( bi ( 15 ) . pow ( n - 1 ) ) ) . add ( bi ( 41 ) . multiply ( bi ( 14 ) . pow ( n - 1 ) ) ) . subtract ( bi ( 13 ) . pow ( n ) ) ; } return sum . toString ( 16 ) . toUpperCase ( ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( ( 15 * 16 ** ( n - 1 ) - 43 * 15 ** ( n - 1 ) + 41 * 14 ** ( n - 1 ) - 13 ** n ) for n in range ( 1 , 17 ) ) NEW_LINE return f \" { ans : X } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( ( 15 * 16 ** ( n - 1 ) - 43 * 15 ** ( n - 1 ) + 41 * 14 ** ( n - 1 ) - 13 ** n ) for n in range ( 1 , 17 ) ) NEW_LINE return f \" { ans : X } \" NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p101_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p101 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p101 ( ) . run ( ) ) ; } private static final int DEGREE = 10 ; public String run ( ) { Fraction sum = Fraction . ZERO ; for ( int k = 1 ; k <= DEGREE ; k ++ ) { for ( int n = k + 1 ; ; n ++ ) { if ( n == DEGREE + 2 ) throw new AssertionError ( ) ; Fraction reference = new Fraction ( generatingFunction ( n ) ) ; Fraction term = optimumPolynomial ( k , n ) ; if ( ! term . equals ( reference ) ) { sum = sum . add ( term ) ; break ; } } } if ( sum . denominator . equals ( BigInteger . ONE ) ) return sum . numerator . toString ( ) ; else return sum . toString ( ) ; } private static Fraction optimumPolynomial ( int k , int n ) { Fraction sum = Fraction . ZERO ; for ( int i = 1 ; i <= k ; i ++ ) { Fraction product = new Fraction ( generatingFunction ( i ) ) ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j != i ) product = product . multiply ( new Fraction ( BigInteger . valueOf ( n - j ) , BigInteger . valueOf ( i - j ) ) ) ; } sum = sum . add ( product ) ; } return sum ; } private static BigInteger generatingFunction ( int n ) { BigInteger sum = BigInteger . ZERO ; BigInteger biN = BigInteger . valueOf ( - n ) ; for ( int i = 0 ; i <= DEGREE ; i ++ ) sum = sum . add ( biN . pow ( i ) ) ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p101 ( ) . run ( ) ) ; }"], ["optimumPolynomial", "private static Fraction optimumPolynomial ( int k , int n ) { Fraction sum = Fraction . ZERO ; for ( int i = 1 ; i <= k ; i ++ ) { Fraction product = new Fraction ( generatingFunction ( i ) ) ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j != i ) product = product . multiply ( new Fraction ( BigInteger . valueOf ( n - j ) , BigInteger . valueOf ( i - j ) ) ) ; } sum = sum . add ( product ) ; } return sum ; }"], ["generatingFunction", "private static BigInteger generatingFunction ( int n ) { BigInteger sum = BigInteger . ZERO ; BigInteger biN = BigInteger . valueOf ( - n ) ; for ( int i = 0 ; i <= DEGREE ; i ++ ) sum = sum . add ( biN . pow ( i ) ) ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { Fraction sum = Fraction . ZERO ; for ( int k = 1 ; k <= DEGREE ; k ++ ) { for ( int n = k + 1 ; ; n ++ ) { if ( n == DEGREE + 2 ) throw new AssertionError ( ) ; Fraction reference = new Fraction ( generatingFunction ( n ) ) ; Fraction term = optimumPolynomial ( k , n ) ; if ( ! term . equals ( reference ) ) { sum = sum . add ( term ) ; break ; } } } if ( sum . denominator . equals ( BigInteger . ONE ) ) return sum . numerator . toString ( ) ; else return sum . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE from fractions import Fraction NEW_LINE DEGREE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" / \" + str ( ans . denominator ) ) NEW_LINE DEDENT def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = Fraction ( 0 , 1 ) NEW_LINE for k in range ( 1 , DEGREE + 1 ) : NEW_LINE INDENT for n in itertools . count ( k + 1 ) : NEW_LINE INDENT if n == DEGREE + 2 : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT reference = Fraction ( generating_function ( n ) , 1 ) NEW_LINE term = optimum_polynomial ( k , n ) NEW_LINE if term != reference : NEW_LINE INDENT ans += term NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans . numerator ) + ( \" \" if ans . denominator == 1 else \" / \" + str ( ans . denominator ) ) NEW_LINE DEDENT"], ["optimum_polynomial", "def optimum_polynomial ( k , n ) : NEW_LINE INDENT sum = Fraction ( 0 , 1 ) NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT product = Fraction ( generating_function ( i ) , 1 ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT product *= Fraction ( n - j , i - j ) NEW_LINE DEDENT DEDENT sum += product NEW_LINE DEDENT return sum NEW_LINE DEDENT"], ["generating_function", "def generating_function ( n ) : NEW_LINE INDENT return sum ( ( - n ) ** i for i in range ( DEGREE + 1 ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p139_A", "java": [{"id": "1", "code": "public final class p139 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p139 ( ) . run ( ) ) ; } private static final int LIMIT = 100000000 ; public String run ( ) { int count = 0 ; for ( int s = 3 ; s * s / 2 < LIMIT ; s += 2 ) { for ( int t = 1 ; t < s ; t += 2 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; int p = a + b + c ; if ( p >= LIMIT ) break ; if ( c % ( a - b ) == 0 && Library . gcd ( s , t ) == 1 ) count += ( LIMIT - 1 ) / p ; } } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p139 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int s = 3 ; s * s / 2 < LIMIT ; s += 2 ) { for ( int t = 1 ; t < s ; t += 2 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; int p = a + b + c ; if ( p >= LIMIT ) break ; if ( c % ( a - b ) == 0 && Library . gcd ( s , t ) == 1 ) count += ( LIMIT - 1 ) / p ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 100000000 NEW_LINE ans = 0 NEW_LINE for s in range ( 3 , eulerlib . sqrt ( LIMIT * 2 ) , 2 ) : NEW_LINE INDENT for t in range ( 1 , s , 2 ) : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE p = a + b + c NEW_LINE if p >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if c % ( a - b ) == 0 and fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT ans += ( LIMIT - 1 ) // p NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 100000000 NEW_LINE ans = 0 NEW_LINE for s in range ( 3 , eulerlib . sqrt ( LIMIT * 2 ) , 2 ) : NEW_LINE INDENT for t in range ( 1 , s , 2 ) : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE p = a + b + c NEW_LINE if p >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if c % ( a - b ) == 0 and fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT ans += ( LIMIT - 1 ) // p NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p106_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p106 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p106 ( ) . run ( ) ) ; } private static final int SET_SIZE = 12 ; public String run ( ) { BigInteger ans = BigInteger . ZERO ; for ( int i = 2 ; i * 2 <= SET_SIZE ; i ++ ) { BigInteger x = Library . binomial ( SET_SIZE , i * 2 ) ; BigInteger y = Library . binomial ( i * 2 , i ) . shiftRight ( 1 ) ; BigInteger z = Library . binomial ( i * 2 , i ) . divide ( BigInteger . valueOf ( i + 1 ) ) ; ans = ans . add ( x . multiply ( y . subtract ( z ) ) ) ; } return ans . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p106 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger ans = BigInteger . ZERO ; for ( int i = 2 ; i * 2 <= SET_SIZE ; i ++ ) { BigInteger x = Library . binomial ( SET_SIZE , i * 2 ) ; BigInteger y = Library . binomial ( i * 2 , i ) . shiftRight ( 1 ) ; BigInteger z = Library . binomial ( i * 2 , i ) . divide ( BigInteger . valueOf ( i + 1 ) ) ; ans = ans . add ( x . multiply ( y . subtract ( z ) ) ) ; } return ans . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT SET_SIZE = 12 NEW_LINE def catalan ( n ) : NEW_LINE INDENT return eulerlib . binomial ( n * 2 , n ) // ( n + 1 ) NEW_LINE DEDENT ans = sum ( eulerlib . binomial ( SET_SIZE , i * 2 ) * ( eulerlib . binomial ( i * 2 , i ) // 2 - catalan ( i ) ) for i in range ( 2 , SET_SIZE // 2 + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT SET_SIZE = 12 NEW_LINE def catalan ( n ) : NEW_LINE INDENT return eulerlib . binomial ( n * 2 , n ) // ( n + 1 ) NEW_LINE DEDENT ans = sum ( eulerlib . binomial ( SET_SIZE , i * 2 ) * ( eulerlib . binomial ( i * 2 , i ) // 2 - catalan ( i ) ) for i in range ( 2 , SET_SIZE // 2 + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p130_A", "java": [{"id": "1", "code": "public final class p130 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p130 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int found = 0 ; for ( int i = 7 ; found < 25 ; i += 2 ) { if ( i % 5 != 0 && ! Library . isPrime ( i ) && ( i - 1 ) % findLeastDivisibleRepunit ( i ) == 0 ) { sum += i ; found ++ ; } } return Integer . toString ( sum ) ; } private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( \" Arithmetic \u2581 overflow \" ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p130 ( ) . run ( ) ) ; }"], ["findLeastDivisibleRepunit", "private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( \" Arithmetic \u2581 overflow \" ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; int found = 0 ; for ( int i = 7 ; found < 25 ; i += 2 ) { if ( i % 5 != 0 && ! Library . isPrime ( i ) && ( i - 1 ) % findLeastDivisibleRepunit ( i ) == 0 ) { sum += i ; found ++ ; } } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : ( i % 5 != 0 ) and ( not eulerlib . is_prime ( i ) ) and ( ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 ) NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 7 , 2 ) ) , 25 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT cond = lambda i : ( i % 5 != 0 ) and ( not eulerlib . is_prime ( i ) ) and ( ( i - 1 ) % find_least_divisible_repunit ( i ) == 0 ) NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 7 , 2 ) ) , 25 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["find_least_divisible_repunit", "def find_least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = 1 NEW_LINE pow = 1 NEW_LINE k = 1 NEW_LINE while sum % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE pow = pow * 10 % n NEW_LINE sum = ( sum + pow ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p108_A", "java": [{"id": "1", "code": "public final class p108 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p108 ( ) . run ( ) ) ; } public String run ( ) { for ( int n = 1 ; ; n ++ ) { if ( ( countDivisorsSquared ( n ) + 1 ) / 2 > 1000 ) return Integer . toString ( n ) ; } } private static int countDivisorsSquared ( int n ) { int count = 1 ; for ( int i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) { int j = 0 ; do { n /= i ; j ++ ; } while ( n % i == 0 ) ; count *= j * 2 + 1 ; end = Library . sqrt ( n ) ; } } if ( n != 1 ) count *= 3 ; return count ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p108 ( ) . run ( ) ) ; }"], ["countDivisorsSquared", "private static int countDivisorsSquared ( int n ) { int count = 1 ; for ( int i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) { int j = 0 ; do { n /= i ; j ++ ; } while ( n % i == 0 ) ; count *= j * 2 + 1 ; end = Library . sqrt ( n ) ; } } if ( n != 1 ) count *= 3 ; return count ; }"]], "functions_class": [["run", "public String run ( ) { for ( int n = 1 ; ; n ++ ) { if ( ( countDivisorsSquared ( n ) + 1 ) / 2 > 1000 ) return Integer . toString ( n ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT for n in itertools . count ( 1 ) : NEW_LINE INDENT if ( count_divisors_squared ( n ) + 1 ) // 2 > 1000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def count_divisors_squared ( n ) : NEW_LINE INDENT count = 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT if i > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT j = 0 NEW_LINE while True : NEW_LINE INDENT n //= i NEW_LINE j += 1 NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count *= j * 2 + 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT for n in itertools . count ( 1 ) : NEW_LINE INDENT if ( count_divisors_squared ( n ) + 1 ) // 2 > 1000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"], ["count_divisors_squared", "def count_divisors_squared ( n ) : NEW_LINE INDENT count = 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT if i > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT j = 0 NEW_LINE while True : NEW_LINE INDENT n //= i NEW_LINE j += 1 NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT count *= j * 2 + 1 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE DEDENT DEDENT if n != 1 : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT return count NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p197_A", "java": [{"id": "1", "code": "public final class p197 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p197 ( ) . run ( ) ) ; } private static long ITERATIONS = 1000000000000L ; public String run ( ) { double x = - 1 ; double y = - 1 ; long i = 0 ; for ( ; i < ITERATIONS ; i ++ ) { if ( i > 0 && x == y ) break ; x = f ( x ) ; y = f ( f ( y ) ) ; } long remain = ( ITERATIONS - i ) % i ; for ( ; remain > 0 ; remain -- ) x = f ( x ) ; double answer = x + f ( x ) ; answer = Math . floor ( answer * 1e9 ) / 1e9 ; return String . format ( \" % .9f \" , answer ) ; } private static double f ( double x ) { return Math . floor ( Math . pow ( 2 , 30.403243784 - x * x ) ) / 1e9 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p197 ( ) . run ( ) ) ; }"], ["f", "private static double f ( double x ) { return Math . floor ( Math . pow ( 2 , 30.403243784 - x * x ) ) / 1e9 ; }"]], "functions_class": [["run", "public String run ( ) { double x = - 1 ; double y = - 1 ; long i = 0 ; for ( ; i < ITERATIONS ; i ++ ) { if ( i > 0 && x == y ) break ; x = f ( x ) ; y = f ( f ( y ) ) ; } long remain = ( ITERATIONS - i ) % i ; for ( ; remain > 0 ; remain -- ) x = f ( x ) ; double answer = x + f ( x ) ; answer = Math . floor ( answer * 1e9 ) / 1e9 ; return String . format ( \" % .9f \" , answer ) ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) / 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) / 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT def f ( x ) : NEW_LINE INDENT return math . floor ( 2.0 ** ( 30.403243784 - x * x ) ) / 1.0e9 NEW_LINE DEDENT ITERATIONS = 10 ** 12 NEW_LINE x = - 1.0 NEW_LINE y = - 1.0 NEW_LINE i = 0 NEW_LINE while i < ITERATIONS : NEW_LINE INDENT if i > 0 and x == y : NEW_LINE INDENT break NEW_LINE DEDENT x = f ( x ) NEW_LINE y = f ( f ( y ) ) NEW_LINE i += 1 NEW_LINE DEDENT remain = ( ITERATIONS - i ) % i NEW_LINE for i in range ( remain ) : NEW_LINE INDENT x = f ( x ) NEW_LINE DEDENT ans = x + f ( x ) NEW_LINE ans = math . floor ( ans * 1.0e9 ) / 1.0e9 NEW_LINE return f \" { ans : .9f } \" NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p164_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p164 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p164 ( ) . run ( ) ) ; } private static final int BASE = 10 ; private static final int DIGITS = 20 ; private static final int CONSECUTIVE = 3 ; private static final int MAX_SUM = 9 ; public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ DIGITS + CONSECUTIVE + 1 ] [ Library . pow ( BASE , CONSECUTIVE ) ] ; ways [ 0 ] [ 0 ] = BigInteger . ONE ; for ( int prefix = 1 ; prefix < ways [ 0 ] . length ; prefix ++ ) ways [ 0 ] [ prefix ] = BigInteger . ZERO ; for ( int digits = 1 ; digits < ways . length ; digits ++ ) { for ( int prefix = 0 ; prefix < ways [ digits ] . length ; prefix ++ ) { BigInteger sum = BigInteger . ZERO ; if ( digitSum ( prefix ) <= MAX_SUM ) { for ( int nextDigit = 0 ; nextDigit < BASE ; nextDigit ++ ) sum = sum . add ( ways [ digits - 1 ] [ prefix % Library . pow ( BASE , CONSECUTIVE - 1 ) * BASE + nextDigit ] ) ; } ways [ digits ] [ prefix ] = sum ; } } return ways [ DIGITS + CONSECUTIVE ] [ 0 ] . subtract ( ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] ) . toString ( ) ; } private static int digitSum ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += n % 10 ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p164 ( ) . run ( ) ) ; }"], ["digitSum", "private static int digitSum ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += n % 10 ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ DIGITS + CONSECUTIVE + 1 ] [ Library . pow ( BASE , CONSECUTIVE ) ] ; ways [ 0 ] [ 0 ] = BigInteger . ONE ; for ( int prefix = 1 ; prefix < ways [ 0 ] . length ; prefix ++ ) ways [ 0 ] [ prefix ] = BigInteger . ZERO ; for ( int digits = 1 ; digits < ways . length ; digits ++ ) { for ( int prefix = 0 ; prefix < ways [ digits ] . length ; prefix ++ ) { BigInteger sum = BigInteger . ZERO ; if ( digitSum ( prefix ) <= MAX_SUM ) { for ( int nextDigit = 0 ; nextDigit < BASE ; nextDigit ++ ) sum = sum . add ( ways [ digits - 1 ] [ prefix % Library . pow ( BASE , CONSECUTIVE - 1 ) * BASE + nextDigit ] ) ; } ways [ digits ] [ prefix ] = sum ; } } return ways [ DIGITS + CONSECUTIVE ] [ 0 ] . subtract ( ways [ DIGITS + CONSECUTIVE - 1 ] [ 0 ] ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT BASE = 10 NEW_LINE DIGITS = 20 NEW_LINE CONSECUTIVE = 3 NEW_LINE MAX_SUM = 9 NEW_LINE innerlen = BASE ** CONSECUTIVE NEW_LINE ways = [ [ 1 ] + [ 0 ] * ( innerlen - 1 ) ] NEW_LINE for digits in range ( 1 , DIGITS + CONSECUTIVE + 1 ) : NEW_LINE INDENT newrow = [ ] NEW_LINE for prefix in range ( innerlen ) : NEW_LINE INDENT sum = 0 NEW_LINE if digit_sum ( prefix ) <= MAX_SUM : NEW_LINE INDENT for nextdigit in range ( BASE ) : NEW_LINE INDENT sum += ways [ digits - 1 ] [ prefix % ( BASE ** ( CONSECUTIVE - 1 ) ) * BASE + nextdigit ] NEW_LINE DEDENT DEDENT newrow . append ( sum ) NEW_LINE DEDENT ways . append ( newrow ) NEW_LINE DEDENT ans = ways [ - 1 ] [ 0 ] - ways [ - 2 ] [ 0 ] NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["digit_sum", "def digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) for c in str ( n ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p500_A", "java": [{"id": "1", "code": "import java . util . PriorityQueue ; import java . util . Queue ; public final class p500 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p500 ( ) . run ( ) ) ; } private static final int TARGET = 500500 ; private static final long MODULUS = 500500507 ; public String run ( ) { Queue < Long > queue = new PriorityQueue < > ( ) ; int nextPrime = 2 ; queue . add ( ( long ) nextPrime ) ; long product = 1 ; for ( int i = 0 ; i < TARGET ; i ++ ) { long item = queue . remove ( ) ; product *= item % MODULUS ; product %= MODULUS ; queue . add ( item * item ) ; if ( item == nextPrime ) { do nextPrime ++ ; while ( ! Library . isPrime ( nextPrime ) ) ; queue . add ( ( long ) nextPrime ) ; } } return Long . toString ( product ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p500 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Queue < Long > queue = new PriorityQueue < > ( ) ; int nextPrime = 2 ; queue . add ( ( long ) nextPrime ) ; long product = 1 ; for ( int i = 0 ; i < TARGET ; i ++ ) { long item = queue . remove ( ) ; product *= item % MODULUS ; product %= MODULUS ; queue . add ( item * item ) ; if ( item == nextPrime ) { do nextPrime ++ ; while ( ! Library . isPrime ( nextPrime ) ) ; queue . add ( ( long ) nextPrime ) ; } } return Long . toString ( product ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , heapq NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE MODULUS = 500500507 NEW_LINE isprime = eulerlib . list_primality ( 7376507 ) NEW_LINE queue = [ ] NEW_LINE nextprime = 2 NEW_LINE heapq . heappush ( queue , nextprime ) NEW_LINE ans = 1 NEW_LINE for _ in range ( TARGET ) : NEW_LINE INDENT item = heapq . heappop ( queue ) NEW_LINE ans *= item NEW_LINE ans %= MODULUS NEW_LINE heapq . heappush ( queue , item ** 2 ) NEW_LINE if item == nextprime : NEW_LINE INDENT nextprime += 1 NEW_LINE while not isprime [ nextprime ] : NEW_LINE INDENT nextprime += 1 NEW_LINE DEDENT heapq . heappush ( queue , nextprime ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TARGET = 500500 NEW_LINE MODULUS = 500500507 NEW_LINE isprime = eulerlib . list_primality ( 7376507 ) NEW_LINE queue = [ ] NEW_LINE nextprime = 2 NEW_LINE heapq . heappush ( queue , nextprime ) NEW_LINE ans = 1 NEW_LINE for _ in range ( TARGET ) : NEW_LINE INDENT item = heapq . heappop ( queue ) NEW_LINE ans *= item NEW_LINE ans %= MODULUS NEW_LINE heapq . heappush ( queue , item ** 2 ) NEW_LINE if item == nextprime : NEW_LINE INDENT nextprime += 1 NEW_LINE while not isprime [ nextprime ] : NEW_LINE INDENT nextprime += 1 NEW_LINE DEDENT heapq . heappush ( queue , nextprime ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p018_A", "java": [{"id": "1", "code": "public final class p018 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p018 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = triangle . length - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < triangle [ i ] . length ; j ++ ) triangle [ i ] [ j ] += Math . max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) ; } return Integer . toString ( triangle [ 0 ] [ 0 ] ) ; } private int [ ] [ ] triangle = { { 75 } , { 95 , 64 } , { 17 , 47 , 82 } , { 18 , 35 , 87 , 10 } , { 20 , 4 , 82 , 47 , 65 } , { 19 , 1 , 23 , 75 , 3 , 34 } , { 88 , 2 , 77 , 73 , 7 , 63 , 67 } , { 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 } , { 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 } , { 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 } , { 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 } , { 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 } , { 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 } , { 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 } , { 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 } , } ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p018 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = triangle . length - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < triangle [ i ] . length ; j ++ ) triangle [ i ] [ j ] += Math . max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) ; } return Integer . toString ( triangle [ 0 ] [ 0 ] ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT triangle = [ [ 75 ] , [ 95 , 64 ] , [ 17 , 47 , 82 ] , [ 18 , 35 , 87 , 10 ] , [ 20 , 4 , 82 , 47 , 65 ] , [ 19 , 1 , 23 , 75 , 3 , 34 ] , [ 88 , 2 , 77 , 73 , 7 , 63 , 67 ] , [ 99 , 65 , 4 , 28 , 6 , 16 , 70 , 92 ] , [ 41 , 41 , 26 , 56 , 83 , 40 , 80 , 70 , 33 ] , [ 41 , 48 , 72 , 33 , 47 , 32 , 37 , 16 , 94 , 29 ] , [ 53 , 71 , 44 , 65 , 25 , 43 , 91 , 52 , 97 , 51 , 14 ] , [ 70 , 11 , 33 , 28 , 77 , 73 , 17 , 78 , 39 , 68 , 17 , 57 ] , [ 91 , 71 , 52 , 38 , 17 , 14 , 91 , 43 , 58 , 50 , 27 , 29 , 48 ] , [ 63 , 66 , 4 , 68 , 89 , 53 , 67 , 30 , 73 , 16 , 69 , 87 , 40 , 31 ] , [ 4 , 62 , 98 , 27 , 23 , 9 , 70 , 98 , 73 , 93 , 38 , 53 , 60 , 4 , 23 ] , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT for i in reversed ( range ( len ( triangle ) - 1 ) ) : NEW_LINE INDENT for j in range ( len ( triangle [ i ] ) ) : NEW_LINE INDENT triangle [ i ] [ j ] += max ( triangle [ i + 1 ] [ j ] , triangle [ i + 1 ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return str ( triangle [ 0 ] [ 0 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p027_A", "java": [{"id": "1", "code": "public final class p027 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p027 ( ) . run ( ) ) ; } public String run ( ) { int bestNum = 0 ; int bestA = 0 ; int bestB = 0 ; for ( int a = - 1000 ; a <= 1000 ; a ++ ) { for ( int b = - 1000 ; b <= 1000 ; b ++ ) { int num = numberOfConsecutivePrimesGenerated ( a , b ) ; if ( num > bestNum ) { bestNum = num ; bestA = a ; bestB = b ; } } } return Integer . toString ( bestA * bestB ) ; } private static int numberOfConsecutivePrimesGenerated ( int a , int b ) { for ( int i = 0 ; ; i ++ ) { int n = i * i + i * a + b ; if ( n < 0 || ! Library . isPrime ( n ) ) return i ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p027 ( ) . run ( ) ) ; }"], ["numberOfConsecutivePrimesGenerated", "private static int numberOfConsecutivePrimesGenerated ( int a , int b ) { for ( int i = 0 ; ; i ++ ) { int n = i * i + i * a + b ; if ( n < 0 || ! Library . isPrime ( n ) ) return i ; } }"]], "functions_class": [["run", "public String run ( ) { int bestNum = 0 ; int bestA = 0 ; int bestB = 0 ; for ( int a = - 1000 ; a <= 1000 ; a ++ ) { for ( int b = - 1000 ; b <= 1000 ; b ++ ) { int num = numberOfConsecutivePrimesGenerated ( a , b ) ; if ( num > bestNum ) { bestNum = num ; bestA = a ; bestB = b ; } } } return Integer . toString ( bestA * bestB ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT isprimecache = eulerlib . list_primality ( 1000 ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( ( ( a , b ) for a in range ( - 999 , 1000 ) for b in range ( 2 , 1000 ) ) , key = count_consecutive_primes ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT"], ["count_consecutive_primes", "def count_consecutive_primes ( ab ) : NEW_LINE INDENT a , b = ab NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT n = i * i + i * a + b NEW_LINE if not is_prime ( n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT"], ["is_prime", "def is_prime ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif n < len ( isprimecache ) : NEW_LINE INDENT return isprimecache [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p020_A", "java": [{"id": "1", "code": "public final class p020 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p020 ( ) . run ( ) ) ; } public String run ( ) { String temp = Library . factorial ( 100 ) . toString ( ) ; int sum = 0 ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) sum += temp . charAt ( i ) - '0' ; return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p020 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { String temp = Library . factorial ( 100 ) . toString ( ) ; int sum = 0 ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) sum += temp . charAt ( i ) - '0' ; return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT n = math . factorial ( 100 ) NEW_LINE ans = sum ( int ( c ) for c in str ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT n = math . factorial ( 100 ) NEW_LINE ans = sum ( int ( c ) for c in str ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p029_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p029 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p029 ( ) . run ( ) ) ; } public String run ( ) { Set < BigInteger > generated = new HashSet < > ( ) ; for ( int a = 2 ; a <= 100 ; a ++ ) { for ( int b = 2 ; b <= 100 ; b ++ ) generated . add ( BigInteger . valueOf ( a ) . pow ( b ) ) ; } return Integer . toString ( generated . size ( ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p029 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < BigInteger > generated = new HashSet < > ( ) ; for ( int a = 2 ; a <= 100 ; a ++ ) { for ( int b = 2 ; b <= 100 ; b ++ ) generated . add ( BigInteger . valueOf ( a ) . pow ( b ) ) ; } return Integer . toString ( generated . size ( ) ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT seen = set ( a ** b for a in range ( 2 , 101 ) for b in range ( 2 , 101 ) ) NEW_LINE return str ( len ( seen ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT seen = set ( a ** b for a in range ( 2 , 101 ) for b in range ( 2 , 101 ) ) NEW_LINE return str ( len ( seen ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p016_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p016 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p016 ( ) . run ( ) ) ; } public String run ( ) { String temp = BigInteger . ONE . shiftLeft ( 1000 ) . toString ( ) ; int sum = 0 ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) sum += temp . charAt ( i ) - '0' ; return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p016 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { String temp = BigInteger . ONE . shiftLeft ( 1000 ) . toString ( ) ; int sum = 0 ; for ( int i = 0 ; i < temp . length ( ) ; i ++ ) sum += temp . charAt ( i ) - '0' ; return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT n = 2 ** 1000 NEW_LINE ans = sum ( int ( c ) for c in str ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT n = 2 ** 1000 NEW_LINE ans = sum ( int ( c ) for c in str ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p045_A", "java": [{"id": "1", "code": "public final class p045 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p045 ( ) . run ( ) ) ; } public String run ( ) { int i = 286 ; int j = 166 ; int k = 144 ; while ( true ) { long triangle = ( long ) i * ( i + 1 ) / 2 ; long pentagon = ( long ) j * ( j * 3 - 1 ) / 2 ; long hexagon = ( long ) k * ( k * 2 - 1 ) ; long min = Math . min ( Math . min ( triangle , pentagon ) , hexagon ) ; if ( min == triangle && min == pentagon && min == hexagon ) return Long . toString ( min ) ; if ( min == triangle ) i ++ ; if ( min == pentagon ) j ++ ; if ( min == hexagon ) k ++ ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p045 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int i = 286 ; int j = 166 ; int k = 144 ; while ( true ) { long triangle = ( long ) i * ( i + 1 ) / 2 ; long pentagon = ( long ) j * ( j * 3 - 1 ) / 2 ; long hexagon = ( long ) k * ( k * 2 - 1 ) ; long min = Math . min ( Math . min ( triangle , pentagon ) , hexagon ) ; if ( min == triangle && min == pentagon && min == hexagon ) return Long . toString ( min ) ; if ( min == triangle ) i ++ ; if ( min == pentagon ) j ++ ; if ( min == hexagon ) k ++ ; } }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) NEW_LINE minimum = min ( triangle , pentagon , hexagon ) NEW_LINE if minimum == max ( triangle , pentagon , hexagon ) : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT if minimum == triangle : i += 1 NEW_LINE if minimum == pentagon : j += 1 NEW_LINE if minimum == hexagon : k += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT i = 286 NEW_LINE j = 166 NEW_LINE k = 144 NEW_LINE while True : NEW_LINE INDENT triangle = i * ( i + 1 ) // 2 NEW_LINE pentagon = j * ( j * 3 - 1 ) // 2 NEW_LINE hexagon = k * ( k * 2 - 1 ) NEW_LINE minimum = min ( triangle , pentagon , hexagon ) NEW_LINE if minimum == max ( triangle , pentagon , hexagon ) : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT if minimum == triangle : i += 1 NEW_LINE if minimum == pentagon : j += 1 NEW_LINE if minimum == hexagon : k += 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p080_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p080 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p080 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { BigInteger x = BigInteger . valueOf ( i ) ; x = x . multiply ( BigInteger . TEN . pow ( 100 * 2 ) ) ; BigInteger y = sqrt ( x ) ; if ( ! y . multiply ( y ) . equals ( x ) ) { String s = y . toString ( ) . substring ( 0 , 100 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) sum += s . charAt ( j ) - '0' ; } } return Integer . toString ( sum ) ; } private static BigInteger sqrt ( BigInteger x ) { int i = 0 ; while ( BigInteger . TEN . pow ( i * 2 ) . compareTo ( x ) <= 0 ) i ++ ; BigInteger y = BigInteger . ZERO ; for ( ; i >= 0 ; i -- ) { int j ; BigInteger delta = null ; for ( j = 9 ; j >= 0 ; j -- ) { BigInteger temp = BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ; delta = y . shiftLeft ( 1 ) . add ( temp ) . multiply ( temp ) ; if ( delta . compareTo ( x ) <= 0 ) break ; } if ( j < 0 ) throw new AssertionError ( ) ; x = x . subtract ( delta ) ; y = y . add ( BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ) ; } return y ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p080 ( ) . run ( ) ) ; }"], ["sqrt", "private static BigInteger sqrt ( BigInteger x ) { int i = 0 ; while ( BigInteger . TEN . pow ( i * 2 ) . compareTo ( x ) <= 0 ) i ++ ; BigInteger y = BigInteger . ZERO ; for ( ; i >= 0 ; i -- ) { int j ; BigInteger delta = null ; for ( j = 9 ; j >= 0 ; j -- ) { BigInteger temp = BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ; delta = y . shiftLeft ( 1 ) . add ( temp ) . multiply ( temp ) ; if ( delta . compareTo ( x ) <= 0 ) break ; } if ( j < 0 ) throw new AssertionError ( ) ; x = x . subtract ( delta ) ; y = y . add ( BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ) ; } return y ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { BigInteger x = BigInteger . valueOf ( i ) ; x = x . multiply ( BigInteger . TEN . pow ( 100 * 2 ) ) ; BigInteger y = sqrt ( x ) ; if ( ! y . multiply ( y ) . equals ( x ) ) { String s = y . toString ( ) . substring ( 0 , 100 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) sum += s . charAt ( j ) - '0' ; } } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE MULTIPLIER = 100 ** DIGITS NEW_LINE ans = sum ( sum ( int ( c ) for c in str ( eulerlib . sqrt ( i * MULTIPLIER ) ) [ : DIGITS ] ) for i in range ( 100 ) if eulerlib . sqrt ( i ) ** 2 != i ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE MULTIPLIER = 100 ** DIGITS NEW_LINE ans = sum ( sum ( int ( c ) for c in str ( eulerlib . sqrt ( i * MULTIPLIER ) ) [ : DIGITS ] ) for i in range ( 100 ) if eulerlib . sqrt ( i ) ** 2 != i ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p074_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p074 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p074 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int count = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) count ++ ; } return Integer . toString ( count ) ; } private static int getChainLength ( int n ) { Set < Integer > seen = new HashSet < > ( ) ; while ( true ) { if ( ! seen . add ( n ) ) return seen . size ( ) ; n = factorialize ( n ) ; } } private static int [ ] FACTORIAL = { 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 } ; private static int factorialize ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += FACTORIAL [ n % 10 ] ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p074 ( ) . run ( ) ) ; }"], ["getChainLength", "private static int getChainLength ( int n ) { Set < Integer > seen = new HashSet < > ( ) ; while ( true ) { if ( ! seen . add ( n ) ) return seen . size ( ) ; n = factorialize ( n ) ; } }"], ["factorialize", "private static int factorialize ( int n ) { int sum = 0 ; for ( ; n != 0 ; n /= 10 ) sum += FACTORIAL [ n % 10 ] ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( getChainLength ( i ) == 60 ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( LIMIT ) if get_chain_length ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT seen . add ( n ) NEW_LINE n = factorialize ( n ) NEW_LINE if n in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT DEDENT DEDENT def factorialize ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT FACTORIAL = [ math . factorial ( i ) for i in range ( 10 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE ans = sum ( 1 for i in range ( LIMIT ) if get_chain_length ( i ) == 60 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["get_chain_length", "def get_chain_length ( n ) : NEW_LINE INDENT seen = set ( ) NEW_LINE while True : NEW_LINE INDENT seen . add ( n ) NEW_LINE n = factorialize ( n ) NEW_LINE if n in seen : NEW_LINE INDENT return len ( seen ) NEW_LINE DEDENT DEDENT DEDENT"], ["factorialize", "def factorialize ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += FACTORIAL [ n % 10 ] NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p073_A", "java": [{"id": "1", "code": "public final class p073 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p073 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( sternBrocotCount ( 1 , 3 , 1 , 2 ) ) ; } private static int sternBrocotCount ( int leftN , int leftD , int rightN , int rightD ) { int n = leftN + rightN ; int d = leftD + rightD ; if ( d > 12000 ) return 0 ; else return 1 + sternBrocotCount ( leftN , leftD , n , d ) + sternBrocotCount ( n , d , rightN , rightD ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p073 ( ) . run ( ) ) ; }"], ["sternBrocotCount", "private static int sternBrocotCount ( int leftN , int leftD , int rightN , int rightD ) { int n = leftN + rightN ; int d = leftD + rightD ; if ( d > 12000 ) return 0 ; else return 1 + sternBrocotCount ( leftN , leftD , n , d ) + sternBrocotCount ( n , d , rightN , rightD ) ; }"]], "functions_class": [["run", "public String run ( ) { return Integer . toString ( sternBrocotCount ( 1 , 3 , 1 , 2 ) ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ( 1 , 3 , 1 , 2 ) ] NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT leftn , leftd , rightn , rightd = stack . pop ( ) NEW_LINE d = leftd + rightd NEW_LINE if d <= 12000 : NEW_LINE INDENT n = leftn + rightn NEW_LINE ans += 1 NEW_LINE stack . append ( ( n , d , rightn , rightd ) ) NEW_LINE stack . append ( ( leftn , leftd , n , d ) ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE stack = [ ( 1 , 3 , 1 , 2 ) ] NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT leftn , leftd , rightn , rightd = stack . pop ( ) NEW_LINE d = leftd + rightd NEW_LINE if d <= 12000 : NEW_LINE INDENT n = leftn + rightn NEW_LINE ans += 1 NEW_LINE stack . append ( ( n , d , rightn , rightd ) ) NEW_LINE stack . append ( ( leftn , leftd , n , d ) ) NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p087_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p087 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p087 ( ) . run ( ) ) ; } private static final int LIMIT = 50000000 ; public String run ( ) { int [ ] primes = Library . listPrimes ( Library . sqrt ( LIMIT ) ) ; Set < Integer > sums = new HashSet < > ( ) ; sums . add ( 0 ) ; for ( int i = 2 ; i <= 4 ; i ++ ) { Set < Integer > newsums = new HashSet < > ( ) ; for ( int p : primes ) { long q = 1 ; for ( int j = 0 ; j < i ; j ++ ) q *= p ; if ( q > LIMIT ) break ; int r = ( int ) q ; for ( int x : sums ) { if ( x + r <= LIMIT ) newsums . add ( x + r ) ; } } sums = newsums ; } return Integer . toString ( sums . size ( ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p087 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] primes = Library . listPrimes ( Library . sqrt ( LIMIT ) ) ; Set < Integer > sums = new HashSet < > ( ) ; sums . add ( 0 ) ; for ( int i = 2 ; i <= 4 ; i ++ ) { Set < Integer > newsums = new HashSet < > ( ) ; for ( int p : primes ) { long q = 1 ; for ( int j = 0 ; j < i ; j ++ ) q *= p ; if ( q > LIMIT ) break ; int r = ( int ) q ; for ( int x : sums ) { if ( x + r <= LIMIT ) newsums . add ( x + r ) ; } } sums = newsums ; } return Integer . toString ( sums . size ( ) ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( LIMIT ) ) NEW_LINE sums = { 0 } NEW_LINE for i in range ( 2 , 5 ) : NEW_LINE INDENT newsums = set ( ) NEW_LINE for p in primes : NEW_LINE INDENT q = p ** i NEW_LINE if q > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for x in sums : NEW_LINE INDENT if x + q <= LIMIT : NEW_LINE INDENT newsums . add ( x + q ) NEW_LINE DEDENT DEDENT DEDENT sums = newsums NEW_LINE DEDENT return str ( len ( sums ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p010_A", "java": [{"id": "1", "code": "public final class p010 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p010 ( ) . run ( ) ) ; } private static final int LIMIT = 2000000 ; public String run ( ) { long sum = 0 ; for ( int p : Library . listPrimes ( LIMIT - 1 ) ) sum += p ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p010 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int p : Library . listPrimes ( LIMIT - 1 ) ) sum += p ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( eulerlib . list_primes ( 1999999 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( eulerlib . list_primes ( 1999999 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p222_A", "java": [{"id": "1", "code": "public final class p222 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p222 ( ) . run ( ) ) ; } public String run ( ) { sphereRadii = new double [ 21 ] ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) sphereRadii [ i ] = ( i + 30 ) * 1000 ; minLength = new double [ sphereRadii . length ] [ 1 << sphereRadii . length ] ; double min = Double . POSITIVE_INFINITY ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) min = Math . min ( findMinimumLength ( i , ( 1 << sphereRadii . length ) - 1 ) + sphereRadii [ i ] , min ) ; return Long . toString ( Math . round ( min ) ) ; } private double [ ] sphereRadii ; private double [ ] [ ] minLength ; private double findMinimumLength ( int currentSphereIndex , int setOfSpheres ) { if ( ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 ) throw new IllegalArgumentException ( ) ; if ( minLength [ currentSphereIndex ] [ setOfSpheres ] == 0 ) { double result ; if ( Integer . bitCount ( setOfSpheres ) == 1 ) result = sphereRadii [ currentSphereIndex ] ; else { result = Double . POSITIVE_INFINITY ; int newSetOfSpheres = setOfSpheres ^ ( 1 << currentSphereIndex ) ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) { if ( ( newSetOfSpheres & ( 1 << i ) ) == 0 ) continue ; double temp = Math . sqrt ( ( sphereRadii [ i ] + sphereRadii [ currentSphereIndex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newSetOfSpheres ) ; result = Math . min ( temp , result ) ; } } minLength [ currentSphereIndex ] [ setOfSpheres ] = result ; } return minLength [ currentSphereIndex ] [ setOfSpheres ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p222 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { sphereRadii = new double [ 21 ] ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) sphereRadii [ i ] = ( i + 30 ) * 1000 ; minLength = new double [ sphereRadii . length ] [ 1 << sphereRadii . length ] ; double min = Double . POSITIVE_INFINITY ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) min = Math . min ( findMinimumLength ( i , ( 1 << sphereRadii . length ) - 1 ) + sphereRadii [ i ] , min ) ; return Long . toString ( Math . round ( min ) ) ; }"], ["findMinimumLength", "private double findMinimumLength ( int currentSphereIndex , int setOfSpheres ) { if ( ( setOfSpheres & ( 1 << currentSphereIndex ) ) == 0 ) throw new IllegalArgumentException ( ) ; if ( minLength [ currentSphereIndex ] [ setOfSpheres ] == 0 ) { double result ; if ( Integer . bitCount ( setOfSpheres ) == 1 ) result = sphereRadii [ currentSphereIndex ] ; else { result = Double . POSITIVE_INFINITY ; int newSetOfSpheres = setOfSpheres ^ ( 1 << currentSphereIndex ) ; for ( int i = 0 ; i < sphereRadii . length ; i ++ ) { if ( ( newSetOfSpheres & ( 1 << i ) ) == 0 ) continue ; double temp = Math . sqrt ( ( sphereRadii [ i ] + sphereRadii [ currentSphereIndex ] - 50000 ) * 200000 ) ; temp += findMinimumLength ( i , newSetOfSpheres ) ; result = Math . min ( temp , result ) ; } } minLength [ currentSphereIndex ] [ setOfSpheres ] = result ; } return minLength [ currentSphereIndex ] [ setOfSpheres ] ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , math NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_SPHERES = 21 NEW_LINE sphereradii = [ ( i + 30 ) * 1000 for i in range ( NUM_SPHERES ) ] NEW_LINE minlength = [ [ None ] * ( 2 ** NUM_SPHERES ) for _ in range ( NUM_SPHERES ) ] NEW_LINE def find_minimum_length ( currentsphereindex , setofspheres ) : NEW_LINE INDENT if setofspheres & ( 1 << currentsphereindex ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if minlength [ currentsphereindex ] [ setofspheres ] is None : NEW_LINE INDENT if eulerlib . popcount ( setofspheres ) == 1 : NEW_LINE INDENT result = sphereradii [ currentsphereindex ] NEW_LINE DEDENT else : NEW_LINE INDENT result = float ( \" inf \" ) NEW_LINE newsetofspheres = setofspheres ^ ( 1 << currentsphereindex ) NEW_LINE for i in range ( NUM_SPHERES ) : NEW_LINE INDENT if newsetofspheres & ( 1 << i ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereindex ] - 50000 ) * 200000 ) NEW_LINE temp += find_minimum_length ( i , newsetofspheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT minlength [ currentsphereindex ] [ setofspheres ] = result NEW_LINE DEDENT return minlength [ currentsphereindex ] [ setofspheres ] NEW_LINE DEDENT ans = min ( ( find_minimum_length ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereradii [ i ] ) for i in range ( NUM_SPHERES ) ) NEW_LINE return str ( int ( round ( ans ) ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT NUM_SPHERES = 21 NEW_LINE sphereradii = [ ( i + 30 ) * 1000 for i in range ( NUM_SPHERES ) ] NEW_LINE minlength = [ [ None ] * ( 2 ** NUM_SPHERES ) for _ in range ( NUM_SPHERES ) ] NEW_LINE def find_minimum_length ( currentsphereindex , setofspheres ) : NEW_LINE INDENT if setofspheres & ( 1 << currentsphereindex ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if minlength [ currentsphereindex ] [ setofspheres ] is None : NEW_LINE INDENT if eulerlib . popcount ( setofspheres ) == 1 : NEW_LINE INDENT result = sphereradii [ currentsphereindex ] NEW_LINE DEDENT else : NEW_LINE INDENT result = float ( \" inf \" ) NEW_LINE newsetofspheres = setofspheres ^ ( 1 << currentsphereindex ) NEW_LINE for i in range ( NUM_SPHERES ) : NEW_LINE INDENT if newsetofspheres & ( 1 << i ) == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT temp = math . sqrt ( ( sphereradii [ i ] + sphereradii [ currentsphereindex ] - 50000 ) * 200000 ) NEW_LINE temp += find_minimum_length ( i , newsetofspheres ) NEW_LINE result = min ( temp , result ) NEW_LINE DEDENT DEDENT minlength [ currentsphereindex ] [ setofspheres ] = result NEW_LINE DEDENT return minlength [ currentsphereindex ] [ setofspheres ] NEW_LINE DEDENT ans = min ( ( find_minimum_length ( i , ( 1 << NUM_SPHERES ) - 1 ) + sphereradii [ i ] ) for i in range ( NUM_SPHERES ) ) NEW_LINE return str ( int ( round ( ans ) ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p028_A", "java": [{"id": "1", "code": "public final class p028 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p028 ( ) . run ( ) ) ; } private static final int SIZE = 1001 ; public String run ( ) { long sum = 1 ; for ( int n = 3 ; n <= SIZE ; n += 2 ) sum += 4 * n * n - 6 * ( n - 1 ) ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p028 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 1 ; for ( int n = 3 ; n <= SIZE ; n += 2 ) sum += 4 * n * n - 6 * ( n - 1 ) ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT SIZE = 1001 NEW_LINE ans = 1 NEW_LINE ans += sum ( 4 * i * i - 6 * ( i - 1 ) for i in range ( 3 , SIZE + 1 , 2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p225_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p225 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p225 ( ) . run ( ) ) ; } private static final int INDEX = 124 ; public String run ( ) { int count = 0 ; for ( int i = 1 ; ; i += 2 ) { if ( ! hasTribonacciMultiple ( i ) ) { count ++ ; if ( count == INDEX ) return Integer . toString ( i ) ; } } } private static boolean hasTribonacciMultiple ( int modulus ) { int [ ] slow = { 1 , 1 , 1 } ; int [ ] fast = slow . clone ( ) ; for ( boolean head = true ; ; head = false ) { if ( slow [ 0 ] % modulus == 0 ) return true ; if ( ! head && Arrays . equals ( slow , fast ) ) return false ; tribonacci ( slow , modulus ) ; tribonacci ( fast , modulus ) ; tribonacci ( fast , modulus ) ; } } private static void tribonacci ( int [ ] state , int mod ) { int a = state [ 0 ] ; int b = state [ 1 ] ; int c = state [ 2 ] ; state [ 0 ] = b ; state [ 1 ] = c ; state [ 2 ] = ( a + b + c ) % mod ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p225 ( ) . run ( ) ) ; }"], ["hasTribonacciMultiple", "private static boolean hasTribonacciMultiple ( int modulus ) { int [ ] slow = { 1 , 1 , 1 } ; int [ ] fast = slow . clone ( ) ; for ( boolean head = true ; ; head = false ) { if ( slow [ 0 ] % modulus == 0 ) return true ; if ( ! head && Arrays . equals ( slow , fast ) ) return false ; tribonacci ( slow , modulus ) ; tribonacci ( fast , modulus ) ; tribonacci ( fast , modulus ) ; } }"], ["tribonacci", "private static void tribonacci ( int [ ] state , int mod ) { int a = state [ 0 ] ; int b = state [ 1 ] ; int c = state [ 2 ] ; state [ 0 ] = b ; state [ 1 ] = c ; state [ 2 ] = ( a + b + c ) % mod ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 1 ; ; i += 2 ) { if ( ! hasTribonacciMultiple ( i ) ) { count ++ ; if ( count == INDEX ) return Integer . toString ( i ) ; } } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE stream = ( i for i in itertools . count ( 1 , 2 ) if not has_tribonacci_multiple ( i ) ) NEW_LINE ans = next ( itertools . islice ( stream , INDEX - 1 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_tribonacci_multiple ( i ) : NEW_LINE INDENT seen = set ( ) NEW_LINE a , b , c = 1 , 1 , 1 NEW_LINE while True : NEW_LINE INDENT key = ( a , b , c ) NEW_LINE if key in seen : NEW_LINE INDENT return False NEW_LINE DEDENT seen . add ( key ) NEW_LINE if a % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT a , b , c = b , c , ( a + b + c ) % i NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT INDEX = 124 NEW_LINE stream = ( i for i in itertools . count ( 1 , 2 ) if not has_tribonacci_multiple ( i ) ) NEW_LINE ans = next ( itertools . islice ( stream , INDEX - 1 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["has_tribonacci_multiple", "def has_tribonacci_multiple ( i ) : NEW_LINE INDENT seen = set ( ) NEW_LINE a , b , c = 1 , 1 , 1 NEW_LINE while True : NEW_LINE INDENT key = ( a , b , c ) NEW_LINE if key in seen : NEW_LINE INDENT return False NEW_LINE DEDENT seen . add ( key ) NEW_LINE if a % i == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT a , b , c = b , c , ( a + b + c ) % i NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p017_A", "java": [{"id": "1", "code": "public final class p017 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p017 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 1000 ; i ++ ) sum += toEnglish ( i ) . length ( ) ; return Integer . toString ( sum ) ; } private static String toEnglish ( int n ) { if ( 0 <= n && n < 20 ) return ONES [ n ] ; else if ( 20 <= n && n < 100 ) return TENS [ n / 10 ] + ( n % 10 != 0 ? ONES [ n % 10 ] : \" \" ) ; else if ( 100 <= n && n < 1000 ) return ONES [ n / 100 ] + \" hundred \" + ( n % 100 != 0 ? \" and \" + toEnglish ( n % 100 ) : \" \" ) ; else if ( 1000 <= n && n < 1000000 ) return toEnglish ( n / 1000 ) + \" thousand \" + ( n % 1000 != 0 ? toEnglish ( n % 1000 ) : \" \" ) ; else throw new IllegalArgumentException ( ) ; } private static String [ ] ONES = { \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" } ; private static String [ ] TENS = { \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" } ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p017 ( ) . run ( ) ) ; }"], ["toEnglish", "private static String toEnglish ( int n ) { if ( 0 <= n && n < 20 ) return ONES [ n ] ; else if ( 20 <= n && n < 100 ) return TENS [ n / 10 ] + ( n % 10 != 0 ? ONES [ n % 10 ] : \" \" ) ; else if ( 100 <= n && n < 1000 ) return ONES [ n / 100 ] + \" hundred \" + ( n % 100 != 0 ? \" and \" + toEnglish ( n % 100 ) : \" \" ) ; else if ( 1000 <= n && n < 1000000 ) return toEnglish ( n / 1000 ) + \" thousand \" + ( n % 1000 != 0 ? toEnglish ( n % 1000 ) : \" \" ) ; else throw new IllegalArgumentException ( ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 1000 ; i ++ ) sum += toEnglish ( i ) . length ( ) ; return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( len ( to_english ( i ) ) for i in range ( 1 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def to_english ( n ) : NEW_LINE INDENT if 0 <= n < 20 : NEW_LINE INDENT return ONES [ n ] NEW_LINE DEDENT elif 20 <= n < 100 : NEW_LINE INDENT return TENS [ n // 10 ] + ( ONES [ n % 10 ] if ( n % 10 != 0 ) else \" \" ) NEW_LINE DEDENT elif 100 <= n < 1000 : NEW_LINE INDENT return ONES [ n // 100 ] + \" hundred \" + ( ( \" and \" + to_english ( n % 100 ) ) if ( n % 100 != 0 ) else \" \" ) NEW_LINE DEDENT elif 1000 <= n < 1000000 : NEW_LINE INDENT return to_english ( n // 1000 ) + \" thousand \" + ( to_english ( n % 1000 ) if ( n % 1000 != 0 ) else \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT DEDENT ONES = [ \" zero \" , \" one \" , \" two \" , \" three \" , \" four \" , \" five \" , \" six \" , \" seven \" , \" eight \" , \" nine \" , \" ten \" , \" eleven \" , \" twelve \" , \" thirteen \" , \" fourteen \" , \" fifteen \" , \" sixteen \" , \" seventeen \" , \" eighteen \" , \" nineteen \" ] NEW_LINE TENS = [ \" \" , \" \" , \" twenty \" , \" thirty \" , \" forty \" , \" fifty \" , \" sixty \" , \" seventy \" , \" eighty \" , \" ninety \" ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( len ( to_english ( i ) ) for i in range ( 1 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["to_english", "def to_english ( n ) : NEW_LINE INDENT if 0 <= n < 20 : NEW_LINE INDENT return ONES [ n ] NEW_LINE DEDENT elif 20 <= n < 100 : NEW_LINE INDENT return TENS [ n // 10 ] + ( ONES [ n % 10 ] if ( n % 10 != 0 ) else \" \" ) NEW_LINE DEDENT elif 100 <= n < 1000 : NEW_LINE INDENT return ONES [ n // 100 ] + \" hundred \" + ( ( \" and \" + to_english ( n % 100 ) ) if ( n % 100 != 0 ) else \" \" ) NEW_LINE DEDENT elif 1000 <= n < 1000000 : NEW_LINE INDENT return to_english ( n // 1000 ) + \" thousand \" + ( to_english ( n % 1000 ) if ( n % 1000 != 0 ) else \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p021_A", "java": [{"id": "1", "code": "public final class p021 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p021 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( isAmicable ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private static boolean isAmicable ( int n ) { int m = divisorSum ( n ) ; return m != n && divisorSum ( m ) == n ; } private static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( n % i == 0 ) sum += i ; } return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p021 ( ) . run ( ) ) ; }"], ["isAmicable", "private static boolean isAmicable ( int n ) { int m = divisorSum ( n ) ; return m != n && divisorSum ( m ) == n ; }"], ["divisorSum", "private static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( n % i == 0 ) sum += i ; } return sum ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( isAmicable ( i ) ) sum += i ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT divisorsum = [ 0 ] * 10000 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisorsum ) , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT j = divisorsum [ i ] NEW_LINE if j != i and j < len ( divisorsum ) and divisorsum [ j ] == i : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT divisorsum = [ 0 ] * 10000 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisorsum ) , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT j = divisorsum [ i ] NEW_LINE if j != i and j < len ( divisorsum ) and divisorsum [ j ] == i : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p019_A", "java": [{"id": "1", "code": "public final class p019 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p019 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int y = 1901 ; y <= 2000 ; y ++ ) { for ( int m = 1 ; m <= 12 ; m ++ ) { if ( dayOfWeek ( y , m , 1 ) == 0 ) count ++ ; } } return Integer . toString ( count ) ; } private static int dayOfWeek ( int year , int month , int day ) { if ( year < 0 || year > 10000 || month < 1 || month > 12 || day < 1 || day > 31 ) throw new IllegalArgumentException ( ) ; int m = ( month - 3 + 4800 ) % 4800 ; int y = ( year + m / 12 ) % 400 ; m %= 12 ; return ( y + y / 4 - y / 100 + ( 13 * m + 2 ) / 5 + day + 2 ) % 7 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p019 ( ) . run ( ) ) ; }"], ["dayOfWeek", "private static int dayOfWeek ( int year , int month , int day ) { if ( year < 0 || year > 10000 || month < 1 || month > 12 || day < 1 || day > 31 ) throw new IllegalArgumentException ( ) ; int m = ( month - 3 + 4800 ) % 4800 ; int y = ( year + m / 12 ) % 400 ; m %= 12 ; return ( y + y / 4 - y / 100 + ( 13 * m + 2 ) / 5 + day + 2 ) % 7 ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int y = 1901 ; y <= 2000 ; y ++ ) { for ( int m = 1 ; m <= 12 ; m ++ ) { if ( dayOfWeek ( y , m , 1 ) == 0 ) count ++ ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import datetime NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for y in range ( 1901 , 2001 ) for m in range ( 1 , 13 ) if datetime . date ( y , m , 1 ) . weekday ( ) == 6 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for y in range ( 1901 , 2001 ) for m in range ( 1 , 13 ) if datetime . date ( y , m , 1 ) . weekday ( ) == 6 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p026_A", "java": [{"id": "1", "code": "import java . util . HashMap ; import java . util . Map ; public final class p026 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p026 ( ) . run ( ) ) ; } public String run ( ) { int bestNumber = 0 ; int bestLength = 0 ; for ( int i = 1 ; i <= 1000 ; i ++ ) { int len = getCycleLength ( i ) ; if ( len > bestLength ) { bestNumber = i ; bestLength = len ; } } return Integer . toString ( bestNumber ) ; } private static int getCycleLength ( int n ) { Map < Integer , Integer > stateToIter = new HashMap < > ( ) ; int state = 1 ; for ( int iter = 0 ; ; iter ++ ) { if ( stateToIter . containsKey ( state ) ) return iter - stateToIter . get ( state ) ; else { stateToIter . put ( state , iter ) ; state = state * 10 % n ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p026 ( ) . run ( ) ) ; }"], ["getCycleLength", "private static int getCycleLength ( int n ) { Map < Integer , Integer > stateToIter = new HashMap < > ( ) ; int state = 1 ; for ( int iter = 0 ; ; iter ++ ) { if ( stateToIter . containsKey ( state ) ) return iter - stateToIter . get ( state ) ; else { stateToIter . put ( state , iter ) ; state = state * 10 % n ; } } }"]], "functions_class": [["run", "public String run ( ) { int bestNumber = 0 ; int bestLength = 0 ; for ( int i = 1 ; i <= 1000 ; i ++ ) { int len = getCycleLength ( i ) ; if ( len > bestLength ) { bestNumber = i ; bestLength = len ; } } return Integer . toString ( bestNumber ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = max ( range ( 1 , 1000 ) , key = reciprocal_cycle_len ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def reciprocal_cycle_len ( n ) : NEW_LINE INDENT seen = { } NEW_LINE x = 1 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if x in seen : NEW_LINE INDENT return i - seen [ x ] NEW_LINE DEDENT else : NEW_LINE INDENT seen [ x ] = i NEW_LINE x = x * 10 % n NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( range ( 1 , 1000 ) , key = reciprocal_cycle_len ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["reciprocal_cycle_len", "def reciprocal_cycle_len ( n ) : NEW_LINE INDENT seen = { } NEW_LINE x = 1 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if x in seen : NEW_LINE INDENT return i - seen [ x ] NEW_LINE DEDENT else : NEW_LINE INDENT seen [ x ] = i NEW_LINE x = x * 10 % n NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p214_A", "java": [{"id": "1", "code": "public final class p214 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p214 ( ) . run ( ) ) ; } private static final int LIMIT = 40000000 ; public String run ( ) { int [ ] totient = Library . listTotients ( LIMIT - 1 ) ; int [ ] totientChainLength = new int [ totient . length ] ; totientChainLength [ 0 ] = 0 ; long sum = 0 ; for ( int i = 1 ; i < totient . length ; i ++ ) { int chainlen = totientChainLength [ totient [ i ] ] + 1 ; totientChainLength [ i ] = chainlen ; if ( chainlen == 25 && totient [ i ] == i - 1 ) sum += i ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p214 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] totient = Library . listTotients ( LIMIT - 1 ) ; int [ ] totientChainLength = new int [ totient . length ] ; totientChainLength [ 0 ] = 0 ; long sum = 0 ; for ( int i = 1 ; i < totient . length ; i ++ ) { int chainlen = totientChainLength [ totient [ i ] ] + 1 ; totientChainLength [ i ] = chainlen ; if ( chainlen == 25 && totient [ i ] == i - 1 ) sum += i ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import array NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = list_totients ( LIMIT - 1 ) NEW_LINE totientchainlen = array . array ( \" L \" , [ 0 , 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( totientchainlen ) , len ( totient ) ) : NEW_LINE INDENT chainlen = totientchainlen [ totient [ i ] ] + 1 NEW_LINE totientchainlen . append ( chainlen ) NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT def list_totients ( n ) : NEW_LINE INDENT assert n < ( 1 << 32 ) NEW_LINE result = array . array ( \" L \" , range ( n + 1 ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if result [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT result [ j ] = result [ j ] // i * ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 40000000 NEW_LINE totient = list_totients ( LIMIT - 1 ) NEW_LINE totientchainlen = array . array ( \" L \" , [ 0 , 1 ] ) NEW_LINE ans = 0 NEW_LINE for i in range ( len ( totientchainlen ) , len ( totient ) ) : NEW_LINE INDENT chainlen = totientchainlen [ totient [ i ] ] + 1 NEW_LINE totientchainlen . append ( chainlen ) NEW_LINE if chainlen == 25 and totient [ i ] == i - 1 : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"], ["list_totients", "def list_totients ( n ) : NEW_LINE INDENT assert n < ( 1 << 32 ) NEW_LINE result = array . array ( \" L \" , range ( n + 1 ) ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if result [ i ] == i : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT result [ j ] = result [ j ] // i * ( i - 1 ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p072_A", "java": [{"id": "1", "code": "public final class p072 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p072 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { long sum = 0 ; int [ ] totients = Library . listTotients ( LIMIT ) ; for ( int i = 2 ; i < totients . length ; i ++ ) sum += totients [ i ] ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p072 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; int [ ] totients = Library . listTotients ( LIMIT ) ; for ( int i = 2 ; i < totients . length ; i ++ ) sum += totients [ i ] ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = sum ( itertools . islice ( totients , 2 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p429_A", "java": [{"id": "1", "code": "public final class p429 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p429 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) ; private static final int MODULUS = 1000000009 ; public String run ( ) { int [ ] primes = Library . listPrimes ( LIMIT ) ; long sum = 1 ; for ( int p : primes ) { int power = countFactors ( LIMIT , p ) ; sum *= 1 + Library . powMod ( p , power * 2 , MODULUS ) ; sum %= MODULUS ; } return Long . toString ( sum ) ; } private static int countFactors ( int n , int p ) { if ( n == 0 ) return 0 ; else return n / p + countFactors ( n / p , p ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p429 ( ) . run ( ) ) ; }"], ["countFactors", "private static int countFactors ( int n , int p ) { if ( n == 0 ) return 0 ; else return n / p + countFactors ( n / p , p ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] primes = Library . listPrimes ( LIMIT ) ; long sum = 1 ; for ( int p : primes ) { int power = countFactors ( LIMIT , p ) ; sum *= 1 + Library . powMod ( p , power * 2 , MODULUS ) ; sum %= MODULUS ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE MOD = 1000000009 NEW_LINE ans = 1 NEW_LINE for p in eulerlib . prime_generator ( LIMIT ) : NEW_LINE INDENT power = count_factors ( LIMIT , p ) NEW_LINE ans *= 1 + pow ( p , power * 2 , MOD ) NEW_LINE ans %= MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def count_factors ( n , p ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return n // p + count_factors ( n // p , p ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE MOD = 1000000009 NEW_LINE ans = 1 NEW_LINE for p in eulerlib . prime_generator ( LIMIT ) : NEW_LINE INDENT power = count_factors ( LIMIT , p ) NEW_LINE ans *= 1 + pow ( p , power * 2 , MOD ) NEW_LINE ans %= MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"], ["count_factors", "def count_factors ( n , p ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return n // p + count_factors ( n // p , p ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p075_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p075 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p075 ( ) . run ( ) ) ; } private static final int LIMIT = 1500000 ; public String run ( ) { Set < IntTriple > triples = new HashSet < > ( ) ; for ( int s = 3 ; s * s <= LIMIT ; s += 2 ) { for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a + b + c <= LIMIT ) triples . add ( new IntTriple ( a , b , c ) ) ; } } } byte [ ] ways = new byte [ LIMIT + 1 ] ; for ( IntTriple triple : triples ) { int sum = triple . a + triple . b + triple . c ; for ( int i = sum ; i < ways . length ; i += sum ) ways [ i ] = ( byte ) Math . min ( ways [ i ] + 1 , 2 ) ; } int count = 0 ; for ( int x : ways ) { if ( x == 1 ) count ++ ; } return Integer . toString ( count ) ; } private static final class IntTriple { public final int a ; public final int b ; public final int c ; public IntTriple ( int a , int b , int c ) { this . a = a ; this . b = b ; this . c = c ; } public boolean equals ( Object obj ) { if ( ! ( obj instanceof IntTriple ) ) return false ; else { IntTriple other = ( IntTriple ) obj ; return a == other . a && b == other . b && c == other . c ; } } public int hashCode ( ) { return a + b + c ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p075 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < IntTriple > triples = new HashSet < > ( ) ; for ( int s = 3 ; s * s <= LIMIT ; s += 2 ) { for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a + b + c <= LIMIT ) triples . add ( new IntTriple ( a , b , c ) ) ; } } } byte [ ] ways = new byte [ LIMIT + 1 ] ; for ( IntTriple triple : triples ) { int sum = triple . a + triple . b + triple . c ; for ( int i = sum ; i < ways . length ; i += sum ) ways [ i ] = ( byte ) Math . min ( ways [ i ] + 1 , 2 ) ; } int count = 0 ; for ( int x : ways ) { if ( x == 1 ) count ++ ; } return Integer . toString ( count ) ; }"], ["IntTriple", "public IntTriple ( int a , int b , int c ) { this . a = a ; this . b = b ; this . c = c ; }"], ["equals", "public boolean equals ( Object obj ) { if ( ! ( obj instanceof IntTriple ) ) return false ; else { IntTriple other = ( IntTriple ) obj ; return a == other . a && b == other . b && c == other . c ; } }"], ["hashCode", "public int hashCode ( ) { return a + b + c ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 1500000 NEW_LINE triples = set ( ) NEW_LINE for s in range ( 3 , eulerlib . sqrt ( LIMIT ) + 1 , 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a + b + c <= LIMIT : NEW_LINE INDENT triples . add ( ( a , b , c ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ways = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for triple in triples : NEW_LINE INDENT sigma = sum ( triple ) NEW_LINE for i in range ( sigma , len ( ways ) , sigma ) : NEW_LINE INDENT ways [ i ] += 1 NEW_LINE DEDENT DEDENT ans = ways . count ( 1 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 1500000 NEW_LINE triples = set ( ) NEW_LINE for s in range ( 3 , eulerlib . sqrt ( LIMIT ) + 1 , 2 ) : NEW_LINE INDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a + b + c <= LIMIT : NEW_LINE INDENT triples . add ( ( a , b , c ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT ways = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for triple in triples : NEW_LINE INDENT sigma = sum ( triple ) NEW_LINE for i in range ( sigma , len ( ways ) , sigma ) : NEW_LINE INDENT ways [ i ] += 1 NEW_LINE DEDENT DEDENT ans = ways . count ( 1 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p043_A", "java": [{"id": "1", "code": "public final class p043 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p043 ( ) . run ( ) ) ; } private static int [ ] DIVISIBILITY_TESTS = { 2 , 3 , 5 , 7 , 11 , 13 , 17 } ; public String run ( ) { long sum = 0 ; int [ ] digits = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; outer : do { for ( int i = 0 ; i < DIVISIBILITY_TESTS . length ; i ++ ) { if ( toInteger ( digits , i + 1 , 3 ) % DIVISIBILITY_TESTS [ i ] != 0 ) continue outer ; } sum += toInteger ( digits , 0 , digits . length ) ; } while ( Library . nextPermutation ( digits ) ) ; return Long . toString ( sum ) ; } private static long toInteger ( int [ ] digits , int off , int len ) { long result = 0 ; for ( int i = off ; i < off + len ; i ++ ) result = result * 10 + digits [ i ] ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p043 ( ) . run ( ) ) ; }"], ["toInteger", "private static long toInteger ( int [ ] digits , int off , int len ) { long result = 0 ; for ( int i = off ; i < off + len ; i ++ ) result = result * 10 + digits [ i ] ; return result ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; int [ ] digits = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; outer : do { for ( int i = 0 ; i < DIVISIBILITY_TESTS . length ; i ++ ) { if ( toInteger ( digits , i + 1 , 3 ) % DIVISIBILITY_TESTS [ i ] != 0 ) continue outer ; } sum += toInteger ( digits , 0 , digits . length ) ; } while ( Library . nextPermutation ( digits ) ) ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( int ( \" \" . join ( map ( str , num ) ) ) for num in itertools . permutations ( list ( range ( 10 ) ) ) if is_substring_divisible ( num ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT DIVISIBILITY_TESTS = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 ] NEW_LINE def is_substring_divisible ( num ) : NEW_LINE INDENT return all ( ( num [ i + 1 ] * 100 + num [ i + 2 ] * 10 + num [ i + 3 ] ) % p == 0 for ( i , p ) in enumerate ( DIVISIBILITY_TESTS ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( int ( \" \" . join ( map ( str , num ) ) ) for num in itertools . permutations ( list ( range ( 10 ) ) ) if is_substring_divisible ( num ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_substring_divisible", "def is_substring_divisible ( num ) : NEW_LINE INDENT return all ( ( num [ i + 1 ] * 100 + num [ i + 2 ] * 10 + num [ i + 3 ] ) % p == 0 for ( i , p ) in enumerate ( DIVISIBILITY_TESTS ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p271_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . ArrayList ; import java . util . HashSet ; import java . util . List ; import java . util . Set ; public final class p271 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p271 ( ) . run ( ) ) ; } private static final int [ ] FACTORS = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 } ; private List < Set < Integer > > factorSolutions = new ArrayList < > ( ) ; public String run ( ) { for ( int fact : FACTORS ) { Set < Integer > sols = new HashSet < > ( ) ; for ( int j = 1 ; j < fact ; j ++ ) { if ( Library . powMod ( j , 3 , fact ) == 1 ) sols . add ( j ) ; } factorSolutions . add ( sols ) ; } BigInteger sum = buildAndSumSolutions ( 0 , BigInteger . ZERO , BigInteger . ONE ) ; return sum . subtract ( BigInteger . ONE ) . toString ( ) ; } private BigInteger buildAndSumSolutions ( int factorIndex , BigInteger x , BigInteger m ) { if ( factorIndex == FACTORS . length ) return x ; else { BigInteger result = BigInteger . ZERO ; BigInteger fact = BigInteger . valueOf ( FACTORS [ factorIndex ] ) ; for ( int sol : factorSolutions . get ( factorIndex ) ) { BigInteger newx = chineseRemainderTheorem ( x , m , BigInteger . valueOf ( sol ) , fact ) ; BigInteger temp = buildAndSumSolutions ( factorIndex + 1 , newx , m . multiply ( fact ) ) ; result = result . add ( temp ) ; } return result ; } } private static BigInteger chineseRemainderTheorem ( BigInteger a , BigInteger p , BigInteger b , BigInteger q ) { return a . add ( b . subtract ( a ) . multiply ( p . modInverse ( q ) ) . multiply ( p ) ) . mod ( p . multiply ( q ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p271 ( ) . run ( ) ) ; }"], ["chineseRemainderTheorem", "private static BigInteger chineseRemainderTheorem ( BigInteger a , BigInteger p , BigInteger b , BigInteger q ) { return a . add ( b . subtract ( a ) . multiply ( p . modInverse ( q ) ) . multiply ( p ) ) . mod ( p . multiply ( q ) ) ; }"]], "functions_class": [["run", "public String run ( ) { for ( int fact : FACTORS ) { Set < Integer > sols = new HashSet < > ( ) ; for ( int j = 1 ; j < fact ; j ++ ) { if ( Library . powMod ( j , 3 , fact ) == 1 ) sols . add ( j ) ; } factorSolutions . add ( sols ) ; } BigInteger sum = buildAndSumSolutions ( 0 , BigInteger . ZERO , BigInteger . ONE ) ; return sum . subtract ( BigInteger . ONE ) . toString ( ) ; }"], ["buildAndSumSolutions", "private BigInteger buildAndSumSolutions ( int factorIndex , BigInteger x , BigInteger m ) { if ( factorIndex == FACTORS . length ) return x ; else { BigInteger result = BigInteger . ZERO ; BigInteger fact = BigInteger . valueOf ( FACTORS [ factorIndex ] ) ; for ( int sol : factorSolutions . get ( factorIndex ) ) { BigInteger newx = chineseRemainderTheorem ( x , m , BigInteger . valueOf ( sol ) , fact ) ; BigInteger temp = buildAndSumSolutions ( factorIndex + 1 , newx , m . multiply ( fact ) ) ; result = result . add ( temp ) ; } return result ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT FACTORS = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 ) NEW_LINE factorsols = [ [ j for j in range ( fact ) if pow ( j , 3 , fact ) == 1 ] for fact in FACTORS ] NEW_LINE def build_and_sum_solutions ( i , x , mod ) : NEW_LINE INDENT if i == len ( FACTORS ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT fact = FACTORS [ i ] NEW_LINE return sum ( build_and_sum_solutions ( i + 1 , chinese_remainder_theorem ( x , mod , sol , fact ) , mod * fact ) for sol in factorsols [ i ] ) NEW_LINE DEDENT DEDENT ans = build_and_sum_solutions ( 0 , 0 , 1 ) - 1 NEW_LINE return str ( ans ) NEW_LINE DEDENT def chinese_remainder_theorem ( a , p , b , q ) : NEW_LINE INDENT return ( a + ( b - a ) * eulerlib . reciprocal_mod ( p % q , q ) * p ) % ( p * q ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT FACTORS = ( 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 ) NEW_LINE factorsols = [ [ j for j in range ( fact ) if pow ( j , 3 , fact ) == 1 ] for fact in FACTORS ] NEW_LINE def build_and_sum_solutions ( i , x , mod ) : NEW_LINE INDENT if i == len ( FACTORS ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT fact = FACTORS [ i ] NEW_LINE return sum ( build_and_sum_solutions ( i + 1 , chinese_remainder_theorem ( x , mod , sol , fact ) , mod * fact ) for sol in factorsols [ i ] ) NEW_LINE DEDENT DEDENT ans = build_and_sum_solutions ( 0 , 0 , 1 ) - 1 NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["chinese_remainder_theorem", "def chinese_remainder_theorem ( a , p , b , q ) : NEW_LINE INDENT return ( a + ( b - a ) * eulerlib . reciprocal_mod ( p % q , q ) * p ) % ( p * q ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p088_A", "java": [{"id": "1", "code": "import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public final class p088 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p088 ( ) . run ( ) ) ; } private static final int LIMIT = 12000 ; private int [ ] minSumProduct ; public String run ( ) { minSumProduct = new int [ LIMIT + 1 ] ; Arrays . fill ( minSumProduct , Integer . MAX_VALUE ) ; for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) factorize ( i , i , i , 0 , 0 ) ; Set < Integer > items = new HashSet < > ( ) ; for ( int i = 2 ; i < minSumProduct . length ; i ++ ) items . add ( minSumProduct [ i ] ) ; int sum = 0 ; for ( int n : items ) sum += n ; return Integer . toString ( sum ) ; } private void factorize ( int n , int remain , int maxFactor , int sum , int terms ) { if ( remain == 1 ) { if ( sum > n ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && n < minSumProduct [ terms ] ) minSumProduct [ terms ] = n ; } else { for ( int i = 2 ; i <= maxFactor ; i ++ ) { if ( remain % i == 0 ) { int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxFactor ) , sum + factor , terms + 1 ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p088 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { minSumProduct = new int [ LIMIT + 1 ] ; Arrays . fill ( minSumProduct , Integer . MAX_VALUE ) ; for ( int i = 2 ; i <= LIMIT * 2 ; i ++ ) factorize ( i , i , i , 0 , 0 ) ; Set < Integer > items = new HashSet < > ( ) ; for ( int i = 2 ; i < minSumProduct . length ; i ++ ) items . add ( minSumProduct [ i ] ) ; int sum = 0 ; for ( int n : items ) sum += n ; return Integer . toString ( sum ) ; }"], ["factorize", "private void factorize ( int n , int remain , int maxFactor , int sum , int terms ) { if ( remain == 1 ) { if ( sum > n ) throw new AssertionError ( ) ; terms += n - sum ; if ( terms <= LIMIT && n < minSumProduct [ terms ] ) minSumProduct [ terms ] = n ; } else { for ( int i = 2 ; i <= maxFactor ; i ++ ) { if ( remain % i == 0 ) { int factor = i ; factorize ( n , remain / factor , Math . min ( factor , maxFactor ) , sum + factor , terms + 1 ) ; } } } }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE minsumproduct = [ None ] * ( LIMIT + 1 ) NEW_LINE def factorize ( n , remain , maxfactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and ( minsumproduct [ terms ] is None or n < minsumproduct [ terms ] ) : NEW_LINE INDENT minsumproduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , maxfactor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE factorize ( n , remain // factor , min ( factor , maxfactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT ans = sum ( set ( minsumproduct [ 2 : ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 12000 NEW_LINE minsumproduct = [ None ] * ( LIMIT + 1 ) NEW_LINE def factorize ( n , remain , maxfactor , sum , terms ) : NEW_LINE INDENT if remain == 1 : NEW_LINE INDENT if sum > n : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT terms += n - sum NEW_LINE if terms <= LIMIT and ( minsumproduct [ terms ] is None or n < minsumproduct [ terms ] ) : NEW_LINE INDENT minsumproduct [ terms ] = n NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 2 , maxfactor + 1 ) : NEW_LINE INDENT if remain % i == 0 : NEW_LINE INDENT factor = i NEW_LINE factorize ( n , remain // factor , min ( factor , maxfactor ) , sum + factor , terms + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 2 , LIMIT * 2 + 1 ) : NEW_LINE INDENT factorize ( i , i , i , 0 , 0 ) NEW_LINE DEDENT ans = sum ( set ( minsumproduct [ 2 : ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p044_A", "java": [{"id": "1", "code": "public final class p044 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p044 ( ) . run ( ) ) ; } public String run ( ) { long minD = - 1 ; for ( int i = 2 ; ; i ++ ) { long pentI = pentagonalNumber ( i ) ; if ( minD != - 1 && pentI - pentagonalNumber ( i - 1 ) >= minD ) break ; for ( int j = i - 1 ; j >= 1 ; j -- ) { long pentJ = pentagonalNumber ( j ) ; long diff = pentI - pentJ ; if ( minD != - 1 && diff >= minD ) break ; else if ( isPentagonalNumber ( pentI + pentJ ) && isPentagonalNumber ( diff ) ) minD = diff ; } } return Long . toString ( minD ) ; } private static long pentagonalNumber ( int x ) { if ( x <= 0 ) throw new IllegalArgumentException ( ) ; return ( long ) x * ( x * 3 - 1 ) >>> 1 ; } private static boolean isPentagonalNumber ( long y ) { if ( y <= 0 ) return false ; long temp = y * 24 + 1 ; long sqrt = Library . sqrt ( temp ) ; return sqrt * sqrt == temp && sqrt % 6 == 5 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p044 ( ) . run ( ) ) ; }"], ["pentagonalNumber", "private static long pentagonalNumber ( int x ) { if ( x <= 0 ) throw new IllegalArgumentException ( ) ; return ( long ) x * ( x * 3 - 1 ) >>> 1 ; }"], ["isPentagonalNumber", "private static boolean isPentagonalNumber ( long y ) { if ( y <= 0 ) return false ; long temp = y * 24 + 1 ; long sqrt = Library . sqrt ( temp ) ; return sqrt * sqrt == temp && sqrt % 6 == 5 ; }"]], "functions_class": [["run", "public String run ( ) { long minD = - 1 ; for ( int i = 2 ; ; i ++ ) { long pentI = pentagonalNumber ( i ) ; if ( minD != - 1 && pentI - pentagonalNumber ( i - 1 ) >= minD ) break ; for ( int j = i - 1 ; j >= 1 ; j -- ) { long pentJ = pentagonalNumber ( j ) ; long diff = pentI - pentJ ; if ( minD != - 1 && diff >= minD ) break ; else if ( isPentagonalNumber ( pentI + pentJ ) && isPentagonalNumber ( diff ) ) minD = diff ; } } return Long . toString ( minD ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT pentanum = PentagonalNumberHelper ( ) NEW_LINE min_d = None NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT pent_i = pentanum . term ( i ) NEW_LINE if min_d is not None and pent_i - pentanum . term ( i - 1 ) >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT pent_j = pentanum . term ( j ) NEW_LINE diff = pent_i - pent_j NEW_LINE if min_d is not None and diff >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT elif pentanum . is_term ( pent_i + pent_j ) and pentanum . is_term ( diff ) : NEW_LINE INDENT min_d = diff NEW_LINE DEDENT DEDENT DEDENT return str ( min_d ) NEW_LINE DEDENT class PentagonalNumberHelper : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . term_list = [ 0 ] NEW_LINE self . term_set = set ( ) NEW_LINE DEDENT def term ( self , x ) : NEW_LINE INDENT assert x > 0 NEW_LINE while len ( self . term_list ) <= x : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return self . term_list [ x ] NEW_LINE DEDENT def is_term ( self , y ) : NEW_LINE INDENT assert y > 0 NEW_LINE while self . term_list [ - 1 ] < y : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return y in self . term_set NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT pentanum = PentagonalNumberHelper ( ) NEW_LINE min_d = None NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT pent_i = pentanum . term ( i ) NEW_LINE if min_d is not None and pent_i - pentanum . term ( i - 1 ) >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT pent_j = pentanum . term ( j ) NEW_LINE diff = pent_i - pent_j NEW_LINE if min_d is not None and diff >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT elif pentanum . is_term ( pent_i + pent_j ) and pentanum . is_term ( diff ) : NEW_LINE INDENT min_d = diff NEW_LINE DEDENT DEDENT DEDENT return str ( min_d ) NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . term_list = [ 0 ] NEW_LINE self . term_set = set ( ) NEW_LINE DEDENT"], ["term", "def term ( self , x ) : NEW_LINE INDENT assert x > 0 NEW_LINE while len ( self . term_list ) <= x : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return self . term_list [ x ] NEW_LINE DEDENT"], ["is_term", "def is_term ( self , y ) : NEW_LINE INDENT assert y > 0 NEW_LINE while self . term_list [ - 1 ] < y : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return y in self . term_set NEW_LINE DEDENT"]]}]}
{"id": "projecteuler_p249_A", "java": [{"id": "1", "code": "public final class p249 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p249 ( ) . run ( ) ) ; } private static final int LIMIT = 5000 ; private static final long MODULUS = 10000000000000000L ; public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT * LIMIT / 2 ) ; long [ ] numSubsets = new long [ LIMIT * LIMIT / 2 ] ; numSubsets [ 0 ] = 1 ; int maxSum = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( ! isPrime [ i ] ) continue ; maxSum += i ; for ( int j = maxSum ; j >= i ; j -- ) { long temp = numSubsets [ j ] + numSubsets [ j - i ] ; if ( temp < MODULUS ) numSubsets [ j ] = temp ; else numSubsets [ j ] = temp - MODULUS ; } } long sum = 0 ; for ( int i = 0 ; i < numSubsets . length ; i ++ ) { if ( isPrime [ i ] ) sum = ( sum + numSubsets [ i ] ) % MODULUS ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p249 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT * LIMIT / 2 ) ; long [ ] numSubsets = new long [ LIMIT * LIMIT / 2 ] ; numSubsets [ 0 ] = 1 ; int maxSum = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { if ( ! isPrime [ i ] ) continue ; maxSum += i ; for ( int j = maxSum ; j >= i ; j -- ) { long temp = numSubsets [ j ] + numSubsets [ j - i ] ; if ( temp < MODULUS ) numSubsets [ j ] = temp ; else numSubsets [ j ] = temp - MODULUS ; } } long sum = 0 ; for ( int i = 0 ; i < numSubsets . length ; i ++ ) { if ( isPrime [ i ] ) sum = ( sum + numSubsets [ i ] ) % MODULUS ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 // 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 5000 NEW_LINE MODULUS = 10 ** 16 NEW_LINE count = [ 0 ] * ( LIMIT ** 2 // 2 ) NEW_LINE count [ 0 ] = 1 NEW_LINE s = 0 NEW_LINE for p in eulerlib . list_primes ( LIMIT ) : NEW_LINE INDENT for i in reversed ( range ( s + 1 ) ) : NEW_LINE INDENT count [ i + p ] = ( count [ i + p ] + count [ i ] ) % MODULUS NEW_LINE DEDENT s += p NEW_LINE DEDENT isprime = eulerlib . list_primality ( s + 1 ) NEW_LINE ans = sum ( count [ i ] for i in range ( s + 1 ) if isprime [ i ] ) % MODULUS NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p092_A", "java": [{"id": "1", "code": "public final class p092 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p092 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int count = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { if ( isClass89 ( i ) ) count ++ ; } return Integer . toString ( count ) ; } private static boolean isClass89 ( int x ) { while ( true ) { switch ( x ) { case 1 : return false ; case 89 : return true ; default : x = nextNumber ( x ) ; } } } private static int nextNumber ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += ( x % 10 ) * ( x % 10 ) ; x /= 10 ; } return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p092 ( ) . run ( ) ) ; }"], ["isClass89", "private static boolean isClass89 ( int x ) { while ( true ) { switch ( x ) { case 1 : return false ; case 89 : return true ; default : x = nextNumber ( x ) ; } } }"], ["nextNumber", "private static int nextNumber ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += ( x % 10 ) * ( x % 10 ) ; x /= 10 ; } return sum ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { if ( isClass89 ( i ) ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10000000 ) if get_terminal ( i ) == 89 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT TERMINALS = ( 1 , 89 ) NEW_LINE def get_terminal ( n ) : NEW_LINE INDENT while n not in TERMINALS : NEW_LINE INDENT n = square_digit_sum ( n ) NEW_LINE DEDENT return n NEW_LINE DEDENT def square_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n > 0 : NEW_LINE INDENT result += SQUARE_DIGITS_SUM [ n % 1000 ] NEW_LINE n //= 1000 NEW_LINE DEDENT return result NEW_LINE DEDENT SQUARE_DIGITS_SUM = [ sum ( int ( c ) ** 2 for c in str ( i ) ) for i in range ( 1000 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10000000 ) if get_terminal ( i ) == 89 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["get_terminal", "def get_terminal ( n ) : NEW_LINE INDENT while n not in TERMINALS : NEW_LINE INDENT n = square_digit_sum ( n ) NEW_LINE DEDENT return n NEW_LINE DEDENT"], ["square_digit_sum", "def square_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n > 0 : NEW_LINE INDENT result += SQUARE_DIGITS_SUM [ n % 1000 ] NEW_LINE n //= 1000 NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p061_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p061 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p061 ( ) . run ( ) ) ; } private Set < Integer > [ ] [ ] numbers ; @ SuppressWarnings ( \" unchecked \" ) public String run ( ) { numbers = new Set [ 9 ] [ 100 ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) { for ( int j = 0 ; j < numbers [ i ] . length ; j ++ ) numbers [ i ] [ j ] = new HashSet < > ( ) ; } for ( int sides = 3 ; sides <= 8 ; sides ++ ) { for ( int n = 1 ; ; n ++ ) { int num = figurateNumber ( sides , n ) ; if ( num >= 10000 ) break ; if ( num >= 1000 ) numbers [ sides ] [ num / 100 ] . add ( num ) ; } } for ( int i = 10 ; i < 100 ; i ++ ) { for ( int num : numbers [ 3 ] [ i ] ) { int temp = findSolutionSum ( num , num , 1 << 3 , num ) ; if ( temp != - 1 ) return Integer . toString ( temp ) ; } } throw new AssertionError ( \" No \u2581 solution \" ) ; } private int findSolutionSum ( int begin , int current , int sidesUsed , int sum ) { if ( sidesUsed == 0x1F8 ) { if ( current % 100 == begin / 100 ) return sum ; } else { for ( int sides = 4 ; sides <= 8 ; sides ++ ) { if ( ( ( sidesUsed >>> sides ) & 1 ) != 0 ) continue ; for ( int num : numbers [ sides ] [ current % 100 ] ) { int temp = findSolutionSum ( begin , num , sidesUsed | ( 1 << sides ) , sum + num ) ; if ( temp != - 1 ) return temp ; } } } return - 1 ; } private static int figurateNumber ( int sides , int n ) { return n * ( ( sides - 2 ) * n - ( sides - 4 ) ) / 2 ; } }", "functions_standalone": [], "functions_class": []}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT numbers = [ [ set ( ) for j in range ( 100 ) ] for i in range ( 9 ) ] NEW_LINE for sides in range ( 3 , 9 ) : NEW_LINE INDENT for n in itertools . count ( 1 ) : NEW_LINE INDENT num = figurate_number ( sides , n ) NEW_LINE if num >= 10000 : NEW_LINE INDENT break NEW_LINE DEDENT if num >= 1000 : NEW_LINE INDENT numbers [ sides ] [ num // 100 ] . add ( num ) NEW_LINE DEDENT DEDENT DEDENT def find_solution_sum ( begin , current , sidesused , sum ) : NEW_LINE INDENT if sidesused == 0b111111000 : NEW_LINE INDENT if current % 100 == begin // 100 : NEW_LINE INDENT return sum NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for sides in range ( 4 , 9 ) : NEW_LINE INDENT if ( sidesused >> sides ) & 1 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for num in numbers [ sides ] [ current % 100 ] : NEW_LINE INDENT temp = find_solution_sum ( begin , num , sidesused | ( 1 << sides ) , sum + num ) NEW_LINE if temp is not None : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT DEDENT for i in range ( 10 , 100 ) : NEW_LINE INDENT for num in numbers [ 3 ] [ i ] : NEW_LINE INDENT temp = find_solution_sum ( num , num , 1 << 3 , num ) NEW_LINE if temp is not None : NEW_LINE INDENT return str ( temp ) NEW_LINE DEDENT DEDENT DEDENT raise AssertionError ( \" No \u2581 solution \" ) NEW_LINE DEDENT def figurate_number ( sides , n ) : NEW_LINE INDENT return n * ( ( sides - 2 ) * n - ( sides - 4 ) ) // 2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT numbers = [ [ set ( ) for j in range ( 100 ) ] for i in range ( 9 ) ] NEW_LINE for sides in range ( 3 , 9 ) : NEW_LINE INDENT for n in itertools . count ( 1 ) : NEW_LINE INDENT num = figurate_number ( sides , n ) NEW_LINE if num >= 10000 : NEW_LINE INDENT break NEW_LINE DEDENT if num >= 1000 : NEW_LINE INDENT numbers [ sides ] [ num // 100 ] . add ( num ) NEW_LINE DEDENT DEDENT DEDENT def find_solution_sum ( begin , current , sidesused , sum ) : NEW_LINE INDENT if sidesused == 0b111111000 : NEW_LINE INDENT if current % 100 == begin // 100 : NEW_LINE INDENT return sum NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for sides in range ( 4 , 9 ) : NEW_LINE INDENT if ( sidesused >> sides ) & 1 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT for num in numbers [ sides ] [ current % 100 ] : NEW_LINE INDENT temp = find_solution_sum ( begin , num , sidesused | ( 1 << sides ) , sum + num ) NEW_LINE if temp is not None : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT DEDENT for i in range ( 10 , 100 ) : NEW_LINE INDENT for num in numbers [ 3 ] [ i ] : NEW_LINE INDENT temp = find_solution_sum ( num , num , 1 << 3 , num ) NEW_LINE if temp is not None : NEW_LINE INDENT return str ( temp ) NEW_LINE DEDENT DEDENT DEDENT raise AssertionError ( \" No \u2581 solution \" ) NEW_LINE DEDENT"], ["figurate_number", "def figurate_number ( sides , n ) : NEW_LINE INDENT return n * ( ( sides - 2 ) * n - ( sides - 4 ) ) // 2 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p095_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p095 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p095 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int [ ] divisorSum = new int [ LIMIT + 1 ] ; for ( int i = 1 ; i <= LIMIT ; i ++ ) { for ( int j = i * 2 ; j <= LIMIT ; j += i ) divisorSum [ j ] += i ; } int maxChainLen = 0 ; int minChainElem = - 1 ; for ( int i = 0 ; i <= LIMIT ; i ++ ) { Set < Integer > visited = new HashSet < > ( ) ; for ( int count = 1 , cur = i ; ; count ++ ) { visited . add ( cur ) ; int next = divisorSum [ cur ] ; if ( next == i ) { if ( count > maxChainLen ) { minChainElem = i ; maxChainLen = count ; } break ; } else if ( next > LIMIT || visited . contains ( next ) ) break ; else cur = next ; } } return Integer . toString ( minChainElem ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p095 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] divisorSum = new int [ LIMIT + 1 ] ; for ( int i = 1 ; i <= LIMIT ; i ++ ) { for ( int j = i * 2 ; j <= LIMIT ; j += i ) divisorSum [ j ] += i ; } int maxChainLen = 0 ; int minChainElem = - 1 ; for ( int i = 0 ; i <= LIMIT ; i ++ ) { Set < Integer > visited = new HashSet < > ( ) ; for ( int count = 1 , cur = i ; ; count ++ ) { visited . add ( cur ) ; int next = divisorSum [ cur ] ; if ( next == i ) { if ( count > maxChainLen ) { minChainElem = i ; maxChainLen = count ; } break ; } else if ( next > LIMIT || visited . contains ( next ) ) break ; else cur = next ; } } return Integer . toString ( minChainElem ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE divisorsum = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT for j in range ( i * 2 , LIMIT + 1 , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT maxchainlen = 0 NEW_LINE ans = - 1 NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT visited = set ( ) NEW_LINE cur = i NEW_LINE for count in itertools . count ( 1 ) : NEW_LINE INDENT visited . add ( cur ) NEW_LINE next = divisorsum [ cur ] NEW_LINE if next == i : NEW_LINE INDENT if count > maxchainlen : NEW_LINE INDENT ans = i NEW_LINE maxchainlen = count NEW_LINE DEDENT break NEW_LINE DEDENT elif next > LIMIT or next in visited : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cur = next NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE divisorsum = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT for j in range ( i * 2 , LIMIT + 1 , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT maxchainlen = 0 NEW_LINE ans = - 1 NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT visited = set ( ) NEW_LINE cur = i NEW_LINE for count in itertools . count ( 1 ) : NEW_LINE INDENT visited . add ( cur ) NEW_LINE next = divisorsum [ cur ] NEW_LINE if next == i : NEW_LINE INDENT if count > maxchainlen : NEW_LINE INDENT ans = i NEW_LINE maxchainlen = count NEW_LINE DEDENT break NEW_LINE DEDENT elif next > LIMIT or next in visited : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT cur = next NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p068_A", "java": [{"id": "1", "code": "public final class p068 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p068 ( ) . run ( ) ) ; } public String run ( ) { int [ ] state = new int [ 10 ] ; for ( int i = 0 ; i < state . length ; i ++ ) state [ i ] = i + 1 ; String max = null ; do { int sum = state [ 0 ] + state [ 5 ] + state [ 6 ] ; if ( state [ 1 ] + state [ 6 ] + state [ 7 ] != sum || state [ 2 ] + state [ 7 ] + state [ 8 ] != sum || state [ 3 ] + state [ 8 ] + state [ 9 ] != sum || state [ 4 ] + state [ 9 ] + state [ 5 ] != sum ) continue ; int minOuterIndex = - 1 ; int minOuter = Integer . MAX_VALUE ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( state [ i ] < minOuter ) { minOuterIndex = i ; minOuter = state [ i ] ; } } String s = \" \" ; for ( int i = 0 ; i < 5 ; i ++ ) s += \" \" + state [ ( minOuterIndex + i ) % 5 ] + state [ ( minOuterIndex + i ) % 5 + 5 ] + state [ ( minOuterIndex + i + 1 ) % 5 + 5 ] ; if ( s . length ( ) == 16 && ( max == null || s . compareTo ( max ) > 0 ) ) max = s ; } while ( Library . nextPermutation ( state ) ) ; if ( max == null ) throw new AssertionError ( ) ; return max ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p068 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] state = new int [ 10 ] ; for ( int i = 0 ; i < state . length ; i ++ ) state [ i ] = i + 1 ; String max = null ; do { int sum = state [ 0 ] + state [ 5 ] + state [ 6 ] ; if ( state [ 1 ] + state [ 6 ] + state [ 7 ] != sum || state [ 2 ] + state [ 7 ] + state [ 8 ] != sum || state [ 3 ] + state [ 8 ] + state [ 9 ] != sum || state [ 4 ] + state [ 9 ] + state [ 5 ] != sum ) continue ; int minOuterIndex = - 1 ; int minOuter = Integer . MAX_VALUE ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( state [ i ] < minOuter ) { minOuterIndex = i ; minOuter = state [ i ] ; } } String s = \" \" ; for ( int i = 0 ; i < 5 ; i ++ ) s += \" \" + state [ ( minOuterIndex + i ) % 5 ] + state [ ( minOuterIndex + i ) % 5 + 5 ] + state [ ( minOuterIndex + i + 1 ) % 5 + 5 ] ; if ( s . length ( ) == 16 && ( max == null || s . compareTo ( max ) > 0 ) ) max = s ; } while ( Library . nextPermutation ( state ) ) ; if ( max == null ) throw new AssertionError ( ) ; return max ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT state = list ( range ( 1 , 11 ) ) NEW_LINE max = None NEW_LINE while True : NEW_LINE INDENT sum = state [ 0 ] + state [ 5 ] + state [ 6 ] NEW_LINE if state [ 1 ] + state [ 6 ] + state [ 7 ] == sum and state [ 2 ] + state [ 7 ] + state [ 8 ] == sum and state [ 3 ] + state [ 8 ] + state [ 9 ] == sum and state [ 4 ] + state [ 9 ] + state [ 5 ] == sum : NEW_LINE INDENT minouterindex = 0 NEW_LINE minouter = state [ 0 ] NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT if state [ i ] < minouter : NEW_LINE INDENT minouterindex = i NEW_LINE minouter = state [ i ] NEW_LINE DEDENT DEDENT s = \" \" NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT s += str ( state [ ( minouterindex + i ) % 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i ) % 5 + 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i + 1 ) % 5 + 5 ] ) NEW_LINE DEDENT if len ( s ) == 16 and ( max is None or s > max ) : NEW_LINE INDENT max = s NEW_LINE DEDENT DEDENT if not eulerlib . next_permutation ( state ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert max is not None NEW_LINE return max NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT state = list ( range ( 1 , 11 ) ) NEW_LINE max = None NEW_LINE while True : NEW_LINE INDENT sum = state [ 0 ] + state [ 5 ] + state [ 6 ] NEW_LINE if state [ 1 ] + state [ 6 ] + state [ 7 ] == sum and state [ 2 ] + state [ 7 ] + state [ 8 ] == sum and state [ 3 ] + state [ 8 ] + state [ 9 ] == sum and state [ 4 ] + state [ 9 ] + state [ 5 ] == sum : NEW_LINE INDENT minouterindex = 0 NEW_LINE minouter = state [ 0 ] NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT if state [ i ] < minouter : NEW_LINE INDENT minouterindex = i NEW_LINE minouter = state [ i ] NEW_LINE DEDENT DEDENT s = \" \" NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT s += str ( state [ ( minouterindex + i ) % 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i ) % 5 + 5 ] ) NEW_LINE s += str ( state [ ( minouterindex + i + 1 ) % 5 + 5 ] ) NEW_LINE DEDENT if len ( s ) == 16 and ( max is None or s > max ) : NEW_LINE INDENT max = s NEW_LINE DEDENT DEDENT if not eulerlib . next_permutation ( state ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT assert max is not None NEW_LINE return max NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p265_A", "java": [{"id": "1", "code": "public final class p265 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p265 ( ) . run ( ) ) ; } private static final int N = 5 ; private static final int TWO_POW_N = 1 << N ; public String run ( ) { long sum = 0 ; int start = ( 1 << ( TWO_POW_N - N - 1 ) ) + 1 ; int end = 1 << ( TWO_POW_N - N ) ; for ( int i = start ; i < end ; i += 2 ) { if ( checkArrangement ( i ) ) sum += i ; } return Long . toString ( sum ) ; } private static final int MASK = TWO_POW_N - 1 ; private static final int FULL_SET = ( int ) ( 1L << TWO_POW_N ) - 1 ; private static boolean checkArrangement ( int digits ) { int seen = 0 ; long temp = ( digits & 0xFFFFFFFFL ) | ( ( digits & 0xFFFFFFFFL ) << TWO_POW_N ) ; for ( int i = 0 ; i < TWO_POW_N ; i ++ ) seen |= 1 << ( ( int ) ( temp >>> i ) & MASK ) ; return seen == FULL_SET ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p265 ( ) . run ( ) ) ; }"], ["checkArrangement", "private static boolean checkArrangement ( int digits ) { int seen = 0 ; long temp = ( digits & 0xFFFFFFFFL ) | ( ( digits & 0xFFFFFFFFL ) << TWO_POW_N ) ; for ( int i = 0 ; i < TWO_POW_N ; i ++ ) seen |= 1 << ( ( int ) ( temp >>> i ) & MASK ) ; return seen == FULL_SET ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; int start = ( 1 << ( TWO_POW_N - N - 1 ) ) + 1 ; int end = 1 << ( TWO_POW_N - N ) ; for ( int i = start ; i < end ; i += 2 ) { if ( checkArrangement ( i ) ) sum += i ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT N = 5 NEW_LINE TWO_POW_N = 2 ** N NEW_LINE MASK = TWO_POW_N - 1 NEW_LINE def check_arrangement ( digits ) : NEW_LINE INDENT seen = set ( ) NEW_LINE digits |= digits << TWO_POW_N NEW_LINE for i in range ( TWO_POW_N ) : NEW_LINE INDENT seen . add ( ( digits >> i ) & MASK ) NEW_LINE DEDENT return len ( seen ) == TWO_POW_N NEW_LINE DEDENT start = 2 ** ( TWO_POW_N - N - 1 ) + 1 NEW_LINE end = 2 ** ( TWO_POW_N - N ) NEW_LINE ans = sum ( i for i in range ( start , end , 2 ) if check_arrangement ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p057_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p057 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p057 ( ) . run ( ) ) ; } private static final int LIMIT = 1000 ; public String run ( ) { BigInteger n = BigInteger . ZERO ; BigInteger d = BigInteger . ONE ; int count = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { BigInteger temp = d . multiply ( BigInteger . valueOf ( 2 ) ) . add ( n ) ; n = d ; d = temp ; if ( n . add ( d ) . toString ( ) . length ( ) > d . toString ( ) . length ( ) ) count ++ ; } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p057 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger n = BigInteger . ZERO ; BigInteger d = BigInteger . ONE ; int count = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { BigInteger temp = d . multiply ( BigInteger . valueOf ( 2 ) ) . add ( n ) ; n = d ; d = temp ; if ( n . add ( d ) . toString ( ) . length ( ) > d . toString ( ) . length ( ) ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 1000 NEW_LINE ans = 0 NEW_LINE numer = 0 NEW_LINE denom = 1 NEW_LINE for _ in range ( LIMIT ) : NEW_LINE INDENT numer , denom = denom , denom * 2 + numer NEW_LINE if len ( str ( numer + denom ) ) > len ( str ( denom ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 1000 NEW_LINE ans = 0 NEW_LINE numer = 0 NEW_LINE denom = 1 NEW_LINE for _ in range ( LIMIT ) : NEW_LINE INDENT numer , denom = denom , denom * 2 + numer NEW_LINE if len ( str ( numer + denom ) ) > len ( str ( denom ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p050_A", "java": [{"id": "1", "code": "public final class p050 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p050 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT ) ; int [ ] primes = Library . listPrimes ( LIMIT ) ; long maxSum = 0 ; int maxRun = - 1 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = 0 ; for ( int j = i ; j < primes . length ; j ++ ) { sum += primes [ j ] ; if ( sum > LIMIT ) break ; else if ( j - i > maxRun && sum > maxSum && isPrime [ sum ] ) { maxSum = sum ; maxRun = j - i ; } } } return Long . toString ( maxSum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p050 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT ) ; int [ ] primes = Library . listPrimes ( LIMIT ) ; long maxSum = 0 ; int maxRun = - 1 ; for ( int i = 0 ; i < primes . length ; i ++ ) { int sum = 0 ; for ( int j = i ; j < primes . length ; j ++ ) { sum += primes [ j ] ; if ( sum > LIMIT ) break ; else if ( j - i > maxRun && sum > maxSum && isPrime [ sum ] ) { maxSum = sum ; maxRun = j - i ; } } } return Long . toString ( maxSum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE isprime = eulerlib . list_primality ( 999999 ) NEW_LINE primes = eulerlib . list_primes ( 999999 ) NEW_LINE consecutive = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = primes [ i ] NEW_LINE consec = 1 NEW_LINE for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE consec += 1 NEW_LINE if sum >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ sum ] and consec > consecutive : NEW_LINE INDENT ans = sum NEW_LINE consecutive = consec NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE isprime = eulerlib . list_primality ( 999999 ) NEW_LINE primes = eulerlib . list_primes ( 999999 ) NEW_LINE consecutive = 0 NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT sum = primes [ i ] NEW_LINE consec = 1 NEW_LINE for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT sum += primes [ j ] NEW_LINE consec += 1 NEW_LINE if sum >= len ( isprime ) : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ sum ] and consec > consecutive : NEW_LINE INDENT ans = sum NEW_LINE consecutive = consec NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p004_A", "java": [{"id": "1", "code": "public final class p004 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p004 ( ) . run ( ) ) ; } public String run ( ) { int maxPalin = - 1 ; for ( int i = 100 ; i < 1000 ; i ++ ) { for ( int j = 100 ; j < 1000 ; j ++ ) { int prod = i * j ; if ( Library . isPalindrome ( prod ) && prod > maxPalin ) maxPalin = prod ; } } return Integer . toString ( maxPalin ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p004 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int maxPalin = - 1 ; for ( int i = 100 ; i < 1000 ; i ++ ) { for ( int j = 100 ; j < 1000 ; j ++ ) { int prod = i * j ; if ( Library . isPalindrome ( prod ) && prod > maxPalin ) maxPalin = prod ; } } return Integer . toString ( maxPalin ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = max ( i * j for i in range ( 100 , 1000 ) for j in range ( 100 , 1000 ) if str ( i * j ) == str ( i * j ) [ : : - 1 ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( i * j for i in range ( 100 , 1000 ) for j in range ( 100 , 1000 ) if str ( i * j ) == str ( i * j ) [ : : - 1 ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p003_A", "java": [{"id": "1", "code": "public final class p003 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p003 ( ) . run ( ) ) ; } public String run ( ) { long n = 600851475143L ; while ( true ) { long p = smallestFactor ( n ) ; if ( p < n ) n /= p ; else return Long . toString ( n ) ; } } private static long smallestFactor ( long n ) { if ( n <= 1 ) throw new IllegalArgumentException ( ) ; for ( long i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) return i ; } return n ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p003 ( ) . run ( ) ) ; }"], ["smallestFactor", "private static long smallestFactor ( long n ) { if ( n <= 1 ) throw new IllegalArgumentException ( ) ; for ( long i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) return i ; } return n ; }"]], "functions_class": [["run", "public String run ( ) { long n = 600851475143L ; while ( true ) { long p = smallestFactor ( n ) ; if ( p < n ) n /= p ; else return Long . toString ( n ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT n = 600851475143 NEW_LINE while True : NEW_LINE INDENT p = smallest_prime_factor ( n ) NEW_LINE if p < n : NEW_LINE INDENT n //= p NEW_LINE DEDENT else : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def smallest_prime_factor ( n ) : NEW_LINE INDENT assert n >= 2 NEW_LINE for i in range ( 2 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT n = 600851475143 NEW_LINE while True : NEW_LINE INDENT p = smallest_prime_factor ( n ) NEW_LINE if p < n : NEW_LINE INDENT n //= p NEW_LINE DEDENT else : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"], ["smallest_prime_factor", "def smallest_prime_factor ( n ) : NEW_LINE INDENT assert n >= 2 NEW_LINE for i in range ( 2 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p231_A", "java": [{"id": "1", "code": "public final class p231 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p231 ( ) . run ( ) ) ; } private static final int N = 20000000 ; private static final int K = 15000000 ; public String run ( ) { smallestPrimeFactor = Library . listSmallestPrimeFactors ( N ) ; return Long . toString ( factorialPrimeFactorSum ( N ) - factorialPrimeFactorSum ( K ) - factorialPrimeFactorSum ( N - K ) ) ; } private int [ ] smallestPrimeFactor ; private long factorialPrimeFactorSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = i ; while ( j > 1 ) { int p = smallestPrimeFactor [ j ] ; sum += p ; j /= p ; } } return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p231 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { smallestPrimeFactor = Library . listSmallestPrimeFactors ( N ) ; return Long . toString ( factorialPrimeFactorSum ( N ) - factorialPrimeFactorSum ( K ) - factorialPrimeFactorSum ( N - K ) ) ; }"], ["factorialPrimeFactorSum", "private long factorialPrimeFactorSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = i ; while ( j > 1 ) { int p = smallestPrimeFactor [ j ] ; sum += p ; j /= p ; } } return sum ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT N = 20000000 NEW_LINE K = 15000000 NEW_LINE smallestprimefactor = eulerlib . list_smallest_prime_factors ( N ) NEW_LINE def factorial_prime_factor_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT j = i NEW_LINE while j > 1 : NEW_LINE INDENT p = smallestprimefactor [ j ] NEW_LINE result += p NEW_LINE j //= p NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT ans = factorial_prime_factor_sum ( N ) - factorial_prime_factor_sum ( K ) - factorial_prime_factor_sum ( N - K ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT N = 20000000 NEW_LINE K = 15000000 NEW_LINE smallestprimefactor = eulerlib . list_smallest_prime_factors ( N ) NEW_LINE def factorial_prime_factor_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT j = i NEW_LINE while j > 1 : NEW_LINE INDENT p = smallestprimefactor [ j ] NEW_LINE result += p NEW_LINE j //= p NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT ans = factorial_prime_factor_sum ( N ) - factorial_prime_factor_sum ( K ) - factorial_prime_factor_sum ( N - K ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p493_A", "java": [{"id": "1", "code": "import java . math . BigDecimal ; import java . math . BigInteger ; import java . math . RoundingMode ; import java . util . Stack ; public final class p493 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p493 ( ) . run ( ) ) ; } private static final int NUM_COLORS = 7 ; private static final int BALLS_PER_COLOR = 10 ; private static final int NUM_PICKED = 20 ; private BigInteger numerator = BigInteger . ZERO ; public String run ( ) { explore ( NUM_PICKED , BALLS_PER_COLOR , new Stack < Integer > ( ) ) ; BigInteger denominator = Library . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) ; BigDecimal num = new BigDecimal ( numerator ) ; BigDecimal den = new BigDecimal ( denominator ) ; return num . divide ( den , 9 , RoundingMode . HALF_EVEN ) . toString ( ) ; } private void explore ( int remain , int limit , Stack < Integer > history ) { if ( remain == 0 ) { int [ ] hist = new int [ NUM_COLORS ] ; for ( int i = 0 ; i < history . size ( ) ; i ++ ) hist [ i ] = history . get ( i ) ; int [ ] histogram = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x : hist ) histogram [ x ] ++ ; BigInteger count = Library . factorial ( NUM_COLORS ) ; for ( int x : histogram ) count = divideExactly ( count , Library . factorial ( x ) ) ; for ( int x : hist ) count = count . multiply ( Library . binomial ( BALLS_PER_COLOR , x ) ) ; int distinctColors = history . size ( ) ; numerator = numerator . add ( count . multiply ( BigInteger . valueOf ( distinctColors ) ) ) ; } else if ( history . size ( ) < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; i -- ) { history . push ( i ) ; explore ( remain - i , i , history ) ; history . pop ( ) ; } } } private static BigInteger divideExactly ( BigInteger x , BigInteger y ) { BigInteger [ ] temp = x . divideAndRemainder ( y ) ; if ( temp [ 1 ] . signum ( ) != 0 ) throw new IllegalArgumentException ( \" Not \u2581 divisible \" ) ; return temp [ 0 ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p493 ( ) . run ( ) ) ; }"], ["divideExactly", "private static BigInteger divideExactly ( BigInteger x , BigInteger y ) { BigInteger [ ] temp = x . divideAndRemainder ( y ) ; if ( temp [ 1 ] . signum ( ) != 0 ) throw new IllegalArgumentException ( \" Not \u2581 divisible \" ) ; return temp [ 0 ] ; }"]], "functions_class": [["run", "public String run ( ) { explore ( NUM_PICKED , BALLS_PER_COLOR , new Stack < Integer > ( ) ) ; BigInteger denominator = Library . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) ; BigDecimal num = new BigDecimal ( numerator ) ; BigDecimal den = new BigDecimal ( denominator ) ; return num . divide ( den , 9 , RoundingMode . HALF_EVEN ) . toString ( ) ; }"], ["explore", "private void explore ( int remain , int limit , Stack < Integer > history ) { if ( remain == 0 ) { int [ ] hist = new int [ NUM_COLORS ] ; for ( int i = 0 ; i < history . size ( ) ; i ++ ) hist [ i ] = history . get ( i ) ; int [ ] histogram = new int [ BALLS_PER_COLOR + 1 ] ; for ( int x : hist ) histogram [ x ] ++ ; BigInteger count = Library . factorial ( NUM_COLORS ) ; for ( int x : histogram ) count = divideExactly ( count , Library . factorial ( x ) ) ; for ( int x : hist ) count = count . multiply ( Library . binomial ( BALLS_PER_COLOR , x ) ) ; int distinctColors = history . size ( ) ; numerator = numerator . add ( count . multiply ( BigInteger . valueOf ( distinctColors ) ) ) ; } else if ( history . size ( ) < NUM_COLORS ) { for ( int i = Math . min ( limit , remain ) ; i > 0 ; i -- ) { history . push ( i ) ; explore ( remain - i , i , history ) ; history . pop ( ) ; } } }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions , math NEW_LINE def compute ( ) : NEW_LINE INDENT NUM_COLORS = 7 NEW_LINE BALLS_PER_COLOR = 10 NEW_LINE NUM_PICKED = 20 NEW_LINE DECIMALS = 9 NEW_LINE numerator = [ 0 ] NEW_LINE def explore ( remain , limit , history ) : NEW_LINE INDENT if remain == 0 : NEW_LINE INDENT hist = list ( history ) NEW_LINE while len ( hist ) < NUM_COLORS : NEW_LINE INDENT hist . append ( 0 ) NEW_LINE DEDENT histogram = [ 0 ] * ( BALLS_PER_COLOR + 1 ) NEW_LINE for x in hist : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT count = math . factorial ( NUM_COLORS ) NEW_LINE for x in histogram : NEW_LINE INDENT count = divide_exactly ( count , math . factorial ( x ) ) NEW_LINE DEDENT for x in hist : NEW_LINE INDENT count *= eulerlib . binomial ( BALLS_PER_COLOR , x ) NEW_LINE DEDENT distinctcolors = len ( history ) NEW_LINE numerator [ 0 ] += count * distinctcolors NEW_LINE DEDENT elif len ( history ) < NUM_COLORS : NEW_LINE INDENT for i in range ( min ( limit , remain ) , 0 , - 1 ) : NEW_LINE INDENT history . append ( i ) NEW_LINE explore ( remain - i , i , history ) NEW_LINE history . pop ( ) NEW_LINE DEDENT DEDENT DEDENT explore ( NUM_PICKED , BALLS_PER_COLOR , [ ] ) NEW_LINE denominator = eulerlib . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) NEW_LINE ans = fractions . Fraction ( numerator [ 0 ] , denominator ) NEW_LINE return format_fraction ( ans , DECIMALS ) NEW_LINE DEDENT def format_fraction ( val , digits ) : NEW_LINE INDENT if digits <= 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if val < 0 : NEW_LINE INDENT return \" - \" + format_fraction ( - val , digits ) NEW_LINE DEDENT s = str ( round ( val * 10 ** digits ) ) . zfill ( digits + 1 ) NEW_LINE return f \" { s [ : - digits ] } . { s [ - digits : ] } \" NEW_LINE DEDENT def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT NUM_COLORS = 7 NEW_LINE BALLS_PER_COLOR = 10 NEW_LINE NUM_PICKED = 20 NEW_LINE DECIMALS = 9 NEW_LINE numerator = [ 0 ] NEW_LINE def explore ( remain , limit , history ) : NEW_LINE INDENT if remain == 0 : NEW_LINE INDENT hist = list ( history ) NEW_LINE while len ( hist ) < NUM_COLORS : NEW_LINE INDENT hist . append ( 0 ) NEW_LINE DEDENT histogram = [ 0 ] * ( BALLS_PER_COLOR + 1 ) NEW_LINE for x in hist : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT count = math . factorial ( NUM_COLORS ) NEW_LINE for x in histogram : NEW_LINE INDENT count = divide_exactly ( count , math . factorial ( x ) ) NEW_LINE DEDENT for x in hist : NEW_LINE INDENT count *= eulerlib . binomial ( BALLS_PER_COLOR , x ) NEW_LINE DEDENT distinctcolors = len ( history ) NEW_LINE numerator [ 0 ] += count * distinctcolors NEW_LINE DEDENT elif len ( history ) < NUM_COLORS : NEW_LINE INDENT for i in range ( min ( limit , remain ) , 0 , - 1 ) : NEW_LINE INDENT history . append ( i ) NEW_LINE explore ( remain - i , i , history ) NEW_LINE history . pop ( ) NEW_LINE DEDENT DEDENT DEDENT explore ( NUM_PICKED , BALLS_PER_COLOR , [ ] ) NEW_LINE denominator = eulerlib . binomial ( NUM_COLORS * BALLS_PER_COLOR , NUM_PICKED ) NEW_LINE ans = fractions . Fraction ( numerator [ 0 ] , denominator ) NEW_LINE return format_fraction ( ans , DECIMALS ) NEW_LINE DEDENT"], ["format_fraction", "def format_fraction ( val , digits ) : NEW_LINE INDENT if digits <= 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT if val < 0 : NEW_LINE INDENT return \" - \" + format_fraction ( - val , digits ) NEW_LINE DEDENT s = str ( round ( val * 10 ** digits ) ) . zfill ( digits + 1 ) NEW_LINE return f \" { s [ : - digits ] } . { s [ - digits : ] } \" NEW_LINE DEDENT"], ["divide_exactly", "def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p035_A", "java": [{"id": "1", "code": "public final class p035 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p035 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; private boolean [ ] isPrime = Library . listPrimality ( LIMIT - 1 ) ; public String run ( ) { int count = 0 ; for ( int i = 0 ; i < isPrime . length ; i ++ ) { if ( isCircularPrime ( i ) ) count ++ ; } return Integer . toString ( count ) ; } private boolean isCircularPrime ( int n ) { String s = Integer . toString ( n ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isPrime [ Integer . parseInt ( s . substring ( i ) + s . substring ( 0 , i ) ) ] ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p035 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 0 ; i < isPrime . length ; i ++ ) { if ( isCircularPrime ( i ) ) count ++ ; } return Integer . toString ( count ) ; }"], ["isCircularPrime", "private boolean isCircularPrime ( int n ) { String s = Integer . toString ( n ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isPrime [ Integer . parseInt ( s . substring ( i ) + s . substring ( 0 , i ) ) ] ) return false ; } return true ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 999999 ) NEW_LINE def is_circular_prime ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE return all ( isprime [ int ( s [ i : ] + s [ : i ] ) ] for i in range ( len ( s ) ) ) NEW_LINE DEDENT ans = sum ( 1 for i in range ( len ( isprime ) ) if is_circular_prime ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 999999 ) NEW_LINE def is_circular_prime ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE return all ( isprime [ int ( s [ i : ] + s [ : i ] ) ] for i in range ( len ( s ) ) ) NEW_LINE DEDENT ans = sum ( 1 for i in range ( len ( isprime ) ) if is_circular_prime ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p032_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p032 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p032 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( hasPandigitalProduct ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private static boolean hasPandigitalProduct ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && isPandigital ( \" \" + n + i + n / i ) ) return true ; } return false ; } private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p032 ( ) . run ( ) ) ; }"], ["hasPandigitalProduct", "private static boolean hasPandigitalProduct ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && isPandigital ( \" \" + n + i + n / i ) ) return true ; } return false ; }"], ["isPandigital", "private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( hasPandigitalProduct ( i ) ) sum += i ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n // i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1 , 10000 ) if has_pandigital_product ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["has_pandigital_product", "def has_pandigital_product ( n ) : NEW_LINE INDENT for i in range ( 1 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT temp = str ( n ) + str ( i ) + str ( n // i ) NEW_LINE if \" \" . join ( sorted ( temp ) ) == \"123456789\" : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p069_A", "java": [{"id": "1", "code": "public final class p069 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p069 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int maxNumer = 0 ; int maxDenom = 1 ; int [ ] totients = Library . listTotients ( LIMIT ) ; for ( int n = 1 ; n < totients . length ; n ++ ) { if ( ( long ) n * maxDenom > ( long ) maxNumer * totients [ n ] ) { maxNumer = n ; maxDenom = totients [ n ] ; } } return Integer . toString ( maxNumer ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p069 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int maxNumer = 0 ; int maxDenom = 1 ; int [ ] totients = Library . listTotients ( LIMIT ) ; for ( int n = 1 ; n < totients . length ; n ++ ) { if ( ( long ) n * maxDenom > ( long ) maxNumer * totients [ n ] ) { maxNumer = n ; maxDenom = totients [ n ] ; } } return Integer . toString ( maxNumer ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 6 ) NEW_LINE ans = max ( range ( 2 , len ( totients ) ) , key = ( lambda i : fractions . Fraction ( i , totients [ i ] ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p056_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p056 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p056 ( ) . run ( ) ) ; } public String run ( ) { int max = 0 ; for ( int a = 1 ; a < 100 ; a ++ ) { for ( int b = 1 ; b < 100 ; b ++ ) { BigInteger pow = BigInteger . valueOf ( a ) . pow ( b ) ; max = Math . max ( digitSum ( pow ) , max ) ; } } return Integer . toString ( max ) ; } private static int digitSum ( BigInteger n ) { int sum = 0 ; String s = n . toString ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum += s . charAt ( i ) - '0' ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p056 ( ) . run ( ) ) ; }"], ["digitSum", "private static int digitSum ( BigInteger n ) { int sum = 0 ; String s = n . toString ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum += s . charAt ( i ) - '0' ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { int max = 0 ; for ( int a = 1 ; a < 100 ; a ++ ) { for ( int b = 1 ; b < 100 ; b ++ ) { BigInteger pow = BigInteger . valueOf ( a ) . pow ( b ) ; max = Math . max ( digitSum ( pow ) , max ) ; } } return Integer . toString ( max ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( sum ( int ( c ) for c in str ( a ** b ) ) for a in range ( 100 ) for b in range ( 100 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p094_A", "java": [{"id": "1", "code": "public final class p094 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p094 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 9 ) ; public String run ( ) { long sum = 0 ; for ( int s = 1 ; s * s <= ( LIMIT + 1 ) / 3 ; s += 2 ) { for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } } } } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p094 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int s = 1 ; s * s <= ( LIMIT + 1 ) / 3 ; s += 2 ) { for ( int t = s - 2 ; t > 0 ; t -= 2 ) { if ( Library . gcd ( s , t ) == 1 ) { int a = s * t ; int b = ( s * s - t * t ) / 2 ; int c = ( s * s + t * t ) / 2 ; if ( a * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( a * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c - 1 ) { int p = c * 3 - 1 ; if ( p <= LIMIT ) sum += p ; } if ( b * 2 == c + 1 ) { int p = c * 3 + 1 ; if ( p <= LIMIT ) sum += p ; } } } } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in itertools . count ( 1 , 2 ) : NEW_LINE INDENT if s * s > ( LIMIT + 1 ) // 3 : NEW_LINE INDENT break NEW_LINE DEDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE ans = 0 NEW_LINE for s in itertools . count ( 1 , 2 ) : NEW_LINE INDENT if s * s > ( LIMIT + 1 ) // 3 : NEW_LINE INDENT break NEW_LINE DEDENT for t in range ( s - 2 , 0 , - 2 ) : NEW_LINE INDENT if fractions . gcd ( s , t ) == 1 : NEW_LINE INDENT a = s * t NEW_LINE b = ( s * s - t * t ) // 2 NEW_LINE c = ( s * s + t * t ) // 2 NEW_LINE if a * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if a * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c - 1 : NEW_LINE INDENT p = c * 3 - 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT if b * 2 == c + 1 : NEW_LINE INDENT p = c * 3 + 1 NEW_LINE if p <= LIMIT : NEW_LINE INDENT ans += p NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p058_A", "java": [{"id": "1", "code": "public final class p058 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p058 ( ) . run ( ) ) ; } public String run ( ) { int numPrimes = 0 ; for ( int n = 1 ; ; n += 2 ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( Library . isPrime ( n * n - i * ( n - 1 ) ) ) numPrimes ++ ; } if ( n > 1 && numPrimes * 10 < n * 2 - 1 ) return Integer . toString ( n ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p058 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int numPrimes = 0 ; for ( int n = 1 ; ; n += 2 ) { for ( int i = 0 ; i < 4 ; i ++ ) { if ( Library . isPrime ( n * n - i * ( n - 1 ) ) ) numPrimes ++ ; } if ( n > 1 && numPrimes * 10 < n * 2 - 1 ) return Integer . toString ( n ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 1 , 10 ) NEW_LINE numprimes = 0 NEW_LINE for n in itertools . count ( 1 , 2 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT if eulerlib . is_prime ( n * n - i * ( n - 1 ) ) : NEW_LINE INDENT numprimes += 1 NEW_LINE DEDENT DEDENT if n > 1 and fractions . Fraction ( numprimes , n * 2 - 1 ) < TARGET : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 1 , 10 ) NEW_LINE numprimes = 0 NEW_LINE for n in itertools . count ( 1 , 2 ) : NEW_LINE INDENT for i in range ( 4 ) : NEW_LINE INDENT if eulerlib . is_prime ( n * n - i * ( n - 1 ) ) : NEW_LINE INDENT numprimes += 1 NEW_LINE DEDENT DEDENT if n > 1 and fractions . Fraction ( numprimes , n * 2 - 1 ) < TARGET : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p033_A", "java": [{"id": "1", "code": "public final class p033 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p033 ( ) . run ( ) ) ; } public String run ( ) { int numer = 1 ; int denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 , n1 = n / 10 ; int d0 = d % 10 , d1 = d / 10 ; if ( n1 == d0 && n0 * d == n * d1 || n0 == d1 && n1 * d == n * d0 ) { numer *= n ; denom *= d ; } } } return Integer . toString ( denom / Library . gcd ( numer , denom ) ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p033 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int numer = 1 ; int denom = 1 ; for ( int d = 10 ; d < 100 ; d ++ ) { for ( int n = 10 ; n < d ; n ++ ) { int n0 = n % 10 , n1 = n / 10 ; int d0 = d % 10 , d1 = d / 10 ; if ( n1 == d0 && n0 * d == n * d1 || n0 == d1 && n1 * d == n * d0 ) { numer *= n ; denom *= d ; } } } return Integer . toString ( denom / Library . gcd ( numer , denom ) ) ; }"]]}], "python": [{"id": "2", "code": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if ( n1 == d0 and n0 * d == n * d1 ) or ( n0 == d1 and n1 * d == n * d0 ) : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom // fractions . gcd ( numer , denom ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 1 NEW_LINE for d in range ( 10 , 100 ) : NEW_LINE INDENT for n in range ( 10 , d ) : NEW_LINE INDENT n0 = n % 10 NEW_LINE n1 = n // 10 NEW_LINE d0 = d % 10 NEW_LINE d1 = d // 10 NEW_LINE if ( n1 == d0 and n0 * d == n * d1 ) or ( n0 == d1 and n1 * d == n * d0 ) : NEW_LINE INDENT numer *= n NEW_LINE denom *= d NEW_LINE DEDENT DEDENT DEDENT return str ( denom // fractions . gcd ( numer , denom ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p206_A", "java": [{"id": "1", "code": "public final class p206 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p206 ( ) . run ( ) ) ; } public String run ( ) { long n = 1000000000 ; int [ ] ndigits = new int [ 10 ] ; int [ ] n2digits = new int [ 19 ] ; long temp = n ; for ( int i = 0 ; i < ndigits . length ; i ++ , temp /= 10 ) ndigits [ i ] = ( int ) ( temp % 10 ) ; temp = n * n ; for ( int i = 0 ; i < n2digits . length ; i ++ , temp /= 10 ) n2digits [ i ] = ( int ) ( temp % 10 ) ; while ( ! isConcealedSquare ( n2digits ) ) { add20n ( ndigits , n2digits ) ; add10Pow ( n2digits , 2 ) ; n += 10 ; add10Pow ( ndigits , 1 ) ; } return Long . toString ( n ) ; } private static boolean isConcealedSquare ( int [ ] n ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( n [ 20 - i * 2 ] != i ) return false ; } return n [ 0 ] == 0 ; } private static void add10Pow ( int [ ] n , int i ) { while ( n [ i ] == 9 ) { n [ i ] = 0 ; i ++ ; } n [ i ] ++ ; } private static void add20n ( int [ ] n , int [ ] n2 ) { int carry = 0 ; int i ; for ( i = 0 ; i < n . length ; i ++ ) { int sum = n [ i ] * 2 + n2 [ i + 1 ] + carry ; n2 [ i + 1 ] = sum % 10 ; carry = sum / 10 ; } for ( i ++ ; carry > 0 ; i ++ ) { int sum = n2 [ i ] + carry ; n2 [ i ] = sum % 10 ; carry = sum / 10 ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p206 ( ) . run ( ) ) ; }"], ["isConcealedSquare", "private static boolean isConcealedSquare ( int [ ] n ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( n [ 20 - i * 2 ] != i ) return false ; } return n [ 0 ] == 0 ; }"], ["add10Pow", "private static void add10Pow ( int [ ] n , int i ) { while ( n [ i ] == 9 ) { n [ i ] = 0 ; i ++ ; } n [ i ] ++ ; }"], ["add20n", "private static void add20n ( int [ ] n , int [ ] n2 ) { int carry = 0 ; int i ; for ( i = 0 ; i < n . length ; i ++ ) { int sum = n [ i ] * 2 + n2 [ i + 1 ] + carry ; n2 [ i + 1 ] = sum % 10 ; carry = sum / 10 ; } for ( i ++ ; carry > 0 ; i ++ ) { int sum = n2 [ i ] + carry ; n2 [ i ] = sum % 10 ; carry = sum / 10 ; } }"]], "functions_class": [["run", "public String run ( ) { long n = 1000000000 ; int [ ] ndigits = new int [ 10 ] ; int [ ] n2digits = new int [ 19 ] ; long temp = n ; for ( int i = 0 ; i < ndigits . length ; i ++ , temp /= 10 ) ndigits [ i ] = ( int ) ( temp % 10 ) ; temp = n * n ; for ( int i = 0 ; i < n2digits . length ; i ++ , temp /= 10 ) n2digits [ i ] = ( int ) ( temp % 10 ) ; while ( ! isConcealedSquare ( n2digits ) ) { add20n ( ndigits , n2digits ) ; add10Pow ( n2digits , 2 ) ; n += 10 ; add10Pow ( ndigits , 1 ) ; } return Long . toString ( n ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT n = 1000000000 NEW_LINE ndigits = [ 0 ] * 10 NEW_LINE temp = n NEW_LINE for i in range ( len ( ndigits ) ) : NEW_LINE INDENT ndigits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT n2digits = [ 0 ] * 19 NEW_LINE temp = n * n NEW_LINE for i in range ( len ( n2digits ) ) : NEW_LINE INDENT n2digits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT while not is_concealed_square ( n2digits ) : NEW_LINE INDENT add_20n ( ndigits , n2digits ) NEW_LINE add_10pow ( n2digits , 2 ) NEW_LINE n += 10 NEW_LINE add_10pow ( ndigits , 1 ) NEW_LINE DEDENT return str ( n ) NEW_LINE DEDENT def is_concealed_square ( n ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if n [ 20 - i * 2 ] != i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return n [ 0 ] == 0 NEW_LINE DEDENT def add_10pow ( n , i ) : NEW_LINE INDENT while n [ i ] == 9 : NEW_LINE INDENT n [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT n [ i ] += 1 NEW_LINE DEDENT def add_20n ( n , n2 ) : NEW_LINE INDENT carry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT sum = n [ i ] * 2 + n2 [ i + 1 ] + carry NEW_LINE n2 [ i + 1 ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE while carry > 0 : NEW_LINE INDENT sum = n2 [ i ] + carry NEW_LINE n2 [ i ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT n = 1000000000 NEW_LINE ndigits = [ 0 ] * 10 NEW_LINE temp = n NEW_LINE for i in range ( len ( ndigits ) ) : NEW_LINE INDENT ndigits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT n2digits = [ 0 ] * 19 NEW_LINE temp = n * n NEW_LINE for i in range ( len ( n2digits ) ) : NEW_LINE INDENT n2digits [ i ] = temp % 10 NEW_LINE temp //= 10 NEW_LINE DEDENT while not is_concealed_square ( n2digits ) : NEW_LINE INDENT add_20n ( ndigits , n2digits ) NEW_LINE add_10pow ( n2digits , 2 ) NEW_LINE n += 10 NEW_LINE add_10pow ( ndigits , 1 ) NEW_LINE DEDENT return str ( n ) NEW_LINE DEDENT"], ["is_concealed_square", "def is_concealed_square ( n ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if n [ 20 - i * 2 ] != i : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return n [ 0 ] == 0 NEW_LINE DEDENT"], ["add_10pow", "def add_10pow ( n , i ) : NEW_LINE INDENT while n [ i ] == 9 : NEW_LINE INDENT n [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT n [ i ] += 1 NEW_LINE DEDENT"], ["add_20n", "def add_20n ( n , n2 ) : NEW_LINE INDENT carry = 0 NEW_LINE i = 0 NEW_LINE while i < len ( n ) : NEW_LINE INDENT sum = n [ i ] * 2 + n2 [ i + 1 ] + carry NEW_LINE n2 [ i + 1 ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE while carry > 0 : NEW_LINE INDENT sum = n2 [ i ] + carry NEW_LINE n2 [ i ] = sum % 10 NEW_LINE carry = sum // 10 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p034_A", "java": [{"id": "1", "code": "public final class p034 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p034 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 3 ; i < 10000000 ; i ++ ) { if ( i == factorialDigitSum ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private static int [ ] FACTORIAL = { 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 } ; private static int factorialDigitSum ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += FACTORIAL [ x % 10 ] ; x /= 10 ; } return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p034 ( ) . run ( ) ) ; }"], ["factorialDigitSum", "private static int factorialDigitSum ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += FACTORIAL [ x % 10 ] ; x /= 10 ; } return sum ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 3 ; i < 10000000 ; i ++ ) { if ( i == factorialDigitSum ( i ) ) sum += i ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 3 , 10000000 ) if i == factorial_digit_sum ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n >= 10000 : NEW_LINE INDENT result += FACTORIAL_DIGITS_SUM_WITH_LEADING_ZEROS [ n % 10000 ] NEW_LINE n //= 10000 NEW_LINE DEDENT return result + FACTORIAL_DIGITS_SUM_WITHOUT_LEADING_ZEROS [ n ] NEW_LINE DEDENT FACTORIAL_DIGITS_SUM_WITHOUT_LEADING_ZEROS = [ sum ( math . factorial ( int ( c ) ) for c in str ( i ) ) for i in range ( 10000 ) ] NEW_LINE FACTORIAL_DIGITS_SUM_WITH_LEADING_ZEROS = [ sum ( math . factorial ( int ( c ) ) for c in str ( i ) . zfill ( 4 ) ) for i in range ( 10000 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 3 , 10000000 ) if i == factorial_digit_sum ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["factorial_digit_sum", "def factorial_digit_sum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE while n >= 10000 : NEW_LINE INDENT result += FACTORIAL_DIGITS_SUM_WITH_LEADING_ZEROS [ n % 10000 ] NEW_LINE n //= 10000 NEW_LINE DEDENT return result + FACTORIAL_DIGITS_SUM_WITHOUT_LEADING_ZEROS [ n ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p002_A", "java": [{"id": "1", "code": "public final class p002 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p002 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int x = 1 ; int y = 2 ; while ( x <= 4000000 ) { if ( x % 2 == 0 ) sum += x ; int z = x + y ; x = y ; y = z ; } return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p002 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; int x = 1 ; int y = 2 ; while ( x <= 4000000 ) { if ( x % 2 == 0 ) sum += x ; int z = x + y ; x = y ; y = z ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE while x <= 4000000 : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT ans += x NEW_LINE DEDENT x , y = y , x + y NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE while x <= 4000000 : NEW_LINE INDENT if x % 2 == 0 : NEW_LINE INDENT ans += x NEW_LINE DEDENT x , y = y , x + y NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p005_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p005 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p005 ( ) . run ( ) ) ; } public String run ( ) { BigInteger allLcm = BigInteger . ONE ; for ( int i = 1 ; i <= 20 ; i ++ ) allLcm = lcm ( BigInteger . valueOf ( i ) , allLcm ) ; return allLcm . toString ( ) ; } private static BigInteger lcm ( BigInteger x , BigInteger y ) { return x . divide ( x . gcd ( y ) ) . multiply ( y ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p005 ( ) . run ( ) ) ; }"], ["lcm", "private static BigInteger lcm ( BigInteger x , BigInteger y ) { return x . divide ( x . gcd ( y ) ) . multiply ( y ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger allLcm = BigInteger . ONE ; for ( int i = 1 ; i <= 20 ; i ++ ) allLcm = lcm ( BigInteger . valueOf ( i ) , allLcm ) ; return allLcm . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p179_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p179 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p179 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int [ ] numDivisors = new int [ LIMIT + 1 ] ; Arrays . fill ( numDivisors , 2 ) ; for ( int i = 2 ; i < numDivisors . length ; i ++ ) { for ( int j = i * 2 ; j < numDivisors . length ; j += i ) numDivisors [ j ] ++ ; } int count = 0 ; for ( int i = 2 ; i < numDivisors . length - 1 ; i ++ ) { if ( numDivisors [ i ] == numDivisors [ i + 1 ] ) count ++ ; } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p179 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] numDivisors = new int [ LIMIT + 1 ] ; Arrays . fill ( numDivisors , 2 ) ; for ( int i = 2 ; i < numDivisors . length ; i ++ ) { for ( int j = i * 2 ; j < numDivisors . length ; j += i ) numDivisors [ j ] ++ ; } int count = 0 ; for ( int i = 2 ; i < numDivisors . length - 1 ; i ++ ) { if ( numDivisors [ i ] == numDivisors [ i + 1 ] ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) // 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT divisors = [ 2 ] * ( 10 ** 7 + 1 ) NEW_LINE for i in range ( 2 , ( len ( divisors ) + 1 ) // 2 ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisors ) , i ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( ( 1 if divisors [ i ] == divisors [ i + 1 ] else 0 ) for i in range ( 2 , len ( divisors ) - 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p146_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p146 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p146 ( ) . run ( ) ) ; } private static final int LIMIT = 150000000 ; private static long [ ] INCREMENTS = { 1 , 3 , 7 , 9 , 13 , 27 } ; public String run ( ) { long sum = 0 ; for ( int n = 0 ; n < LIMIT ; n += 10 ) { if ( hasConsecutivePrimes ( n ) ) sum += n ; } return Long . toString ( sum ) ; } private static long maxNumber = ( long ) LIMIT * LIMIT + INCREMENTS [ INCREMENTS . length - 1 ] ; private static int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( maxNumber ) ) ; private static boolean hasConsecutivePrimes ( int n ) { long n2 = ( long ) n * n ; long [ ] temp = new long [ INCREMENTS . length ] ; for ( int i = 0 ; i < INCREMENTS . length ; i ++ ) temp [ i ] = n2 + INCREMENTS [ i ] ; for ( int p : primes ) { for ( long x : temp ) { if ( x != p && x % p == 0 ) return false ; } } for ( int i = 1 ; i < INCREMENTS [ INCREMENTS . length - 1 ] ; i ++ ) { if ( Arrays . binarySearch ( INCREMENTS , i ) < 0 && isPrime ( n2 + i ) ) return false ; } return true ; } private static boolean isPrime ( long n ) { int end = ( int ) Library . sqrt ( n ) ; for ( int p : primes ) { if ( p > end ) break ; if ( n != p && n % p == 0 ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p146 ( ) . run ( ) ) ; }"], ["hasConsecutivePrimes", "private static boolean hasConsecutivePrimes ( int n ) { long n2 = ( long ) n * n ; long [ ] temp = new long [ INCREMENTS . length ] ; for ( int i = 0 ; i < INCREMENTS . length ; i ++ ) temp [ i ] = n2 + INCREMENTS [ i ] ; for ( int p : primes ) { for ( long x : temp ) { if ( x != p && x % p == 0 ) return false ; } } for ( int i = 1 ; i < INCREMENTS [ INCREMENTS . length - 1 ] ; i ++ ) { if ( Arrays . binarySearch ( INCREMENTS , i ) < 0 && isPrime ( n2 + i ) ) return false ; } return true ; }"], ["isPrime", "private static boolean isPrime ( long n ) { int end = ( int ) Library . sqrt ( n ) ; for ( int p : primes ) { if ( p > end ) break ; if ( n != p && n % p == 0 ) return false ; } return true ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int n = 0 ; n < LIMIT ; n += 10 ) { if ( hasConsecutivePrimes ( n ) ) sum += n ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 150000000 NEW_LINE INCREMENTS = [ 1 , 3 , 7 , 9 , 13 , 27 ] NEW_LINE NON_INCREMENTS = set ( range ( INCREMENTS [ - 1 ] ) ) - set ( INCREMENTS ) NEW_LINE maxnumber = LIMIT ** 2 + INCREMENTS [ - 1 ] NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maxnumber ) ) NEW_LINE def has_consecutive_primes ( n ) : NEW_LINE INDENT n2 = n ** 2 NEW_LINE temp = [ ( n2 + k ) for k in INCREMENTS ] NEW_LINE if any ( ( x != p and x % p == 0 ) for p in primes for x in temp ) : NEW_LINE INDENT return False NEW_LINE DEDENT return all ( ( not is_prime ( n2 + k ) ) for k in NON_INCREMENTS ) NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE for p in primes : NEW_LINE INDENT if p > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in range ( 0 , LIMIT , 10 ) if has_consecutive_primes ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 150000000 NEW_LINE INCREMENTS = [ 1 , 3 , 7 , 9 , 13 , 27 ] NEW_LINE NON_INCREMENTS = set ( range ( INCREMENTS [ - 1 ] ) ) - set ( INCREMENTS ) NEW_LINE maxnumber = LIMIT ** 2 + INCREMENTS [ - 1 ] NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maxnumber ) ) NEW_LINE def has_consecutive_primes ( n ) : NEW_LINE INDENT n2 = n ** 2 NEW_LINE temp = [ ( n2 + k ) for k in INCREMENTS ] NEW_LINE if any ( ( x != p and x % p == 0 ) for p in primes for x in temp ) : NEW_LINE INDENT return False NEW_LINE DEDENT return all ( ( not is_prime ( n2 + k ) ) for k in NON_INCREMENTS ) NEW_LINE DEDENT def is_prime ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE for p in primes : NEW_LINE INDENT if p > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in range ( 0 , LIMIT , 10 ) if has_consecutive_primes ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p387_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p387 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p387 ( ) . run ( ) ) ; } private static final long LIMIT = 100000000000000L ; private BigInteger sum = BigInteger . ZERO ; public String run ( ) { for ( int i = 1 ; i <= 9 ; i ++ ) findHarshadPrimes ( i , i , false ) ; return sum . toString ( ) ; } private void findHarshadPrimes ( long n , int digitSum , boolean isStrong ) { long m = n * 10 ; int s = digitSum ; for ( int i = 0 ; i < 10 && m < LIMIT ; i ++ , m ++ , s ++ ) { if ( isStrong && isPrime ( m ) ) sum = sum . add ( BigInteger . valueOf ( m ) ) ; if ( m % s == 0 ) findHarshadPrimes ( m , s , isPrime ( m / s ) ) ; } } private static boolean isPrime ( long x ) { if ( x < 0 ) throw new IllegalArgumentException ( \" Negative \u2581 number \" ) ; if ( x == 0 || x == 1 ) return false ; for ( long i = 2 , end = Library . sqrt ( x ) ; i <= end ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p387 ( ) . run ( ) ) ; }"], ["isPrime", "private static boolean isPrime ( long x ) { if ( x < 0 ) throw new IllegalArgumentException ( \" Negative \u2581 number \" ) ; if ( x == 0 || x == 1 ) return false ; for ( long i = 2 , end = Library . sqrt ( x ) ; i <= end ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 1 ; i <= 9 ; i ++ ) findHarshadPrimes ( i , i , false ) ; return sum . toString ( ) ; }"], ["findHarshadPrimes", "private void findHarshadPrimes ( long n , int digitSum , boolean isStrong ) { long m = n * 10 ; int s = digitSum ; for ( int i = 0 ; i < 10 && m < LIMIT ; i ++ , m ++ , s ++ ) { if ( isStrong && isPrime ( m ) ) sum = sum . add ( BigInteger . valueOf ( m ) ) ; if ( m % s == 0 ) findHarshadPrimes ( m , s , isPrime ( m / s ) ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m // s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 14 NEW_LINE ans = [ 0 ] NEW_LINE def find_harshad_primes ( n , digitsum , isstrong ) : NEW_LINE INDENT m = n * 10 NEW_LINE s = digitsum NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if m >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isstrong and eulerlib . is_prime ( m ) : NEW_LINE INDENT ans [ 0 ] += m NEW_LINE DEDENT if m % s == 0 : NEW_LINE INDENT find_harshad_primes ( m , s , eulerlib . is_prime ( m // s ) ) NEW_LINE DEDENT m += 1 NEW_LINE s += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT find_harshad_primes ( i , i , False ) NEW_LINE DEDENT return str ( ans [ 0 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p115_A", "java": [{"id": "1", "code": "import java . util . ArrayList ; import java . util . List ; public final class p115 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p115 ( ) . run ( ) ) ; } private static final int M = 50 ; public String run ( ) { List < Long > ways = new ArrayList < > ( ) ; ways . add ( 1L ) ; for ( int n = 1 ; ; n ++ ) { long sum = ways . get ( n - 1 ) ; for ( int k = M ; k < n ; k ++ ) sum += ways . get ( n - k - 1 ) ; if ( n >= M ) sum ++ ; ways . add ( sum ) ; if ( sum > 1000000 ) return Long . toString ( n ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p115 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { List < Long > ways = new ArrayList < > ( ) ; ways . add ( 1L ) ; for ( int n = 1 ; ; n ++ ) { long sum = ways . get ( n - 1 ) ; for ( int k = M ; k < n ; k ++ ) sum += ways . get ( n - k - 1 ) ; if ( n >= M ) sum ++ ; ways . add ( sum ) ; if ( sum > 1000000 ) return Long . toString ( n ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT M = 50 NEW_LINE ways = [ 1 ] NEW_LINE for n in itertools . count ( 1 ) : NEW_LINE INDENT s = ways [ n - 1 ] + sum ( ways [ : max ( n - M , 0 ) ] ) NEW_LINE if n >= M : NEW_LINE INDENT s += 1 NEW_LINE DEDENT ways . append ( s ) NEW_LINE if s > 1000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT M = 50 NEW_LINE ways = [ 1 ] NEW_LINE for n in itertools . count ( 1 ) : NEW_LINE INDENT s = ways [ n - 1 ] + sum ( ways [ : max ( n - M , 0 ) ] ) NEW_LINE if n >= M : NEW_LINE INDENT s += 1 NEW_LINE DEDENT ways . append ( s ) NEW_LINE if s > 1000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p112_A", "java": [{"id": "1", "code": "public final class p112 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p112 ( ) . run ( ) ) ; } public String run ( ) { int bouncy = 0 ; for ( int i = 1 ; ; i ++ ) { if ( isBouncy ( i ) ) bouncy ++ ; if ( bouncy * 100 == i * 99 ) return Integer . toString ( i ) ; } } private static boolean isBouncy ( int x ) { if ( x < 100 ) return false ; else { boolean nonincreasing = true ; boolean nondecreasing = true ; int lastDigit = x % 10 ; x /= 10 ; while ( x != 0 ) { int digit = x % 10 ; if ( digit > lastDigit ) nondecreasing = false ; else if ( digit < lastDigit ) nonincreasing = false ; lastDigit = digit ; x /= 10 ; } return ! nonincreasing && ! nondecreasing ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p112 ( ) . run ( ) ) ; }"], ["isBouncy", "private static boolean isBouncy ( int x ) { if ( x < 100 ) return false ; else { boolean nonincreasing = true ; boolean nondecreasing = true ; int lastDigit = x % 10 ; x /= 10 ; while ( x != 0 ) { int digit = x % 10 ; if ( digit > lastDigit ) nondecreasing = false ; else if ( digit < lastDigit ) nonincreasing = false ; lastDigit = digit ; x /= 10 ; } return ! nonincreasing && ! nondecreasing ; } }"]], "functions_class": [["run", "public String run ( ) { int bouncy = 0 ; for ( int i = 1 ; ; i ++ ) { if ( isBouncy ( i ) ) bouncy ++ ; if ( bouncy * 100 == i * 99 ) return Integer . toString ( i ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT count = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE t = \" \" . join ( sorted ( s ) ) NEW_LINE if s != t and s [ : : - 1 ] != t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count * 100 == 99 * i : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT count = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT s = str ( i ) NEW_LINE t = \" \" . join ( sorted ( s ) ) NEW_LINE if s != t and s [ : : - 1 ] != t : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count * 100 == 99 * i : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p549_A", "java": [{"id": "1", "code": "public final class p549 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p549 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) ; public String run ( ) { int [ ] smallestDivisibleFactorials = new int [ LIMIT + 1 ] ; for ( int i = 2 ; i < smallestDivisibleFactorials . length ; i ++ ) { if ( smallestDivisibleFactorials [ i ] == 0 ) { long power = 1 ; middle : for ( int j = i ; ; j += i ) { power *= i ; if ( power > LIMIT ) break ; for ( int inc = ( int ) power , k = inc ; k < smallestDivisibleFactorials . length ; k += inc ) smallestDivisibleFactorials [ k ] = Math . max ( j , smallestDivisibleFactorials [ k ] ) ; for ( int temp = j / i ; temp % i == 0 ; temp /= i ) { power *= i ; if ( power > LIMIT ) break middle ; } } } } long sum = 0 ; for ( int x : smallestDivisibleFactorials ) sum += x ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p549 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] smallestDivisibleFactorials = new int [ LIMIT + 1 ] ; for ( int i = 2 ; i < smallestDivisibleFactorials . length ; i ++ ) { if ( smallestDivisibleFactorials [ i ] == 0 ) { long power = 1 ; middle : for ( int j = i ; ; j += i ) { power *= i ; if ( power > LIMIT ) break ; for ( int inc = ( int ) power , k = inc ; k < smallestDivisibleFactorials . length ; k += inc ) smallestDivisibleFactorials [ k ] = Math . max ( j , smallestDivisibleFactorials [ k ] ) ; for ( int temp = j / i ; temp % i == 0 ; temp /= i ) { power *= i ; if ( power > LIMIT ) break middle ; } } } } long sum = 0 ; for ( int x : smallestDivisibleFactorials ) sum += x ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE smallestdivisiblefactorials = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( smallestdivisiblefactorials ) ) : NEW_LINE INDENT if smallestdivisiblefactorials [ i ] == 0 : NEW_LINE INDENT power = 1 NEW_LINE for j in itertools . count ( i , i ) : NEW_LINE INDENT power *= i NEW_LINE if power > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( power , len ( smallestdivisiblefactorials ) , power ) : NEW_LINE INDENT smallestdivisiblefactorials [ k ] = max ( j , smallestdivisiblefactorials [ k ] ) NEW_LINE DEDENT temp = j // i NEW_LINE while temp % i == 0 : NEW_LINE INDENT power *= i NEW_LINE temp //= i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( smallestdivisiblefactorials ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE smallestdivisiblefactorials = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( smallestdivisiblefactorials ) ) : NEW_LINE INDENT if smallestdivisiblefactorials [ i ] == 0 : NEW_LINE INDENT power = 1 NEW_LINE for j in itertools . count ( i , i ) : NEW_LINE INDENT power *= i NEW_LINE if power > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( power , len ( smallestdivisiblefactorials ) , power ) : NEW_LINE INDENT smallestdivisiblefactorials [ k ] = max ( j , smallestdivisiblefactorials [ k ] ) NEW_LINE DEDENT temp = j // i NEW_LINE while temp % i == 0 : NEW_LINE INDENT power *= i NEW_LINE temp //= i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( smallestdivisiblefactorials ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p124_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p124 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p124 ( ) . run ( ) ) ; } private static final int LIMIT = 100000 ; public String run ( ) { int [ ] rads = new int [ LIMIT + 1 ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } IntPair [ ] data = new IntPair [ LIMIT ] ; for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = new IntPair ( rads [ i + 1 ] , i + 1 ) ; Arrays . sort ( data ) ; return Integer . toString ( data [ 10000 - 1 ] . b ) ; } private static final class IntPair implements Comparable < IntPair > { public final int a ; public final int b ; public IntPair ( int a , int b ) { this . a = a ; this . b = b ; } public int compareTo ( IntPair other ) { if ( a != other . a ) return Integer . compare ( a , other . a ) ; else return Integer . compare ( b , other . b ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p124 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] rads = new int [ LIMIT + 1 ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } IntPair [ ] data = new IntPair [ LIMIT ] ; for ( int i = 0 ; i < data . length ; i ++ ) data [ i ] = new IntPair ( rads [ i + 1 ] , i + 1 ) ; Arrays . sort ( data ) ; return Integer . toString ( data [ 10000 - 1 ] . b ) ; }"], ["IntPair", "public IntPair ( int a , int b ) { this . a = a ; this . b = b ; }"], ["compareTo", "public int compareTo ( IntPair other ) { if ( a != other . a ) return Integer . compare ( a , other . a ) ; else return Integer . compare ( b , other . b ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 0 ] + [ 1 ] * LIMIT NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT data = sorted ( ( rad , i ) for ( i , rad ) in enumerate ( rads ) ) NEW_LINE return str ( data [ 10000 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 100000 NEW_LINE rads = [ 0 ] + [ 1 ] * LIMIT NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT data = sorted ( ( rad , i ) for ( i , rad ) in enumerate ( rads ) ) NEW_LINE return str ( data [ 10000 ] [ 1 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p329_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p329 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p329 ( ) . run ( ) ) ; } private static final int START_NUM = 1 ; private static final int END_NUM = 500 ; private static final String CROAK_SEQ = \" PPPPNNPPPNPPNPN \" ; static { assert 0 <= START_NUM && START_NUM < END_NUM && END_NUM < Integer . MAX_VALUE ; assert 1 <= CROAK_SEQ . length ( ) && CROAK_SEQ . length ( ) <= 31 ; } private static final int NUM_JUMPS = CROAK_SEQ . length ( ) - 1 ; private static final int NUM_TRIALS = 1 << NUM_JUMPS ; public String run ( ) { long globalNumerator = 0 ; boolean [ ] isPrime = Library . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialNumerator = 1 ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) trialNumerator *= 2 ; for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) pos ++ ; else if ( pos >= END_NUM ) pos -- ; else if ( ( ( j >>> k ) & 1 ) == 0 ) pos ++ ; else pos -- ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) trialNumerator *= 2 ; } globalNumerator += trialNumerator ; } } BigInteger globalDenominator = BigInteger . valueOf ( END_NUM + 1L - START_NUM ) . shiftLeft ( NUM_JUMPS ) . multiply ( BigInteger . valueOf ( 3 ) . pow ( CROAK_SEQ . length ( ) ) ) ; return new Fraction ( BigInteger . valueOf ( globalNumerator ) , globalDenominator ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p329 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long globalNumerator = 0 ; boolean [ ] isPrime = Library . listPrimality ( END_NUM ) ; for ( int i = START_NUM ; i <= END_NUM ; i ++ ) { for ( int j = 0 ; j < NUM_TRIALS ; j ++ ) { int pos = i ; int trialNumerator = 1 ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( 0 ) == ' P ' ) ) trialNumerator *= 2 ; for ( int k = 0 ; k < NUM_JUMPS ; k ++ ) { if ( pos <= START_NUM ) pos ++ ; else if ( pos >= END_NUM ) pos -- ; else if ( ( ( j >>> k ) & 1 ) == 0 ) pos ++ ; else pos -- ; if ( isPrime [ pos ] == ( CROAK_SEQ . charAt ( k + 1 ) == ' P ' ) ) trialNumerator *= 2 ; } globalNumerator += trialNumerator ; } } BigInteger globalDenominator = BigInteger . valueOf ( END_NUM + 1L - START_NUM ) . shiftLeft ( NUM_JUMPS ) . multiply ( BigInteger . valueOf ( 3 ) . pow ( CROAK_SEQ . length ( ) ) ) ; return new Fraction ( BigInteger . valueOf ( globalNumerator ) , globalDenominator ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT START_NUM = 1 NEW_LINE END_NUM = 500 NEW_LINE CROAK_SEQ = \" PPPPNNPPPNPPNPN \" NEW_LINE assert 0 <= START_NUM < END_NUM NEW_LINE assert 1 <= len ( CROAK_SEQ ) NEW_LINE NUM_JUMPS = len ( CROAK_SEQ ) - 1 NEW_LINE NUM_TRIALS = 2 ** NUM_JUMPS NEW_LINE globalnumerator = 0 NEW_LINE isprime = eulerlib . list_primality ( END_NUM ) NEW_LINE for i in range ( START_NUM , END_NUM + 1 ) : NEW_LINE INDENT for j in range ( NUM_TRIALS ) : NEW_LINE INDENT pos = i NEW_LINE trialnumerator = 1 NEW_LINE if isprime [ pos ] == ( CROAK_SEQ [ 0 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT for k in range ( NUM_JUMPS ) : NEW_LINE INDENT if pos <= START_NUM : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT elif pos >= END_NUM : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT elif ( j >> k ) & 1 == 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos -= 1 NEW_LINE DEDENT if isprime [ pos ] == ( CROAK_SEQ [ k + 1 ] == ' P ' ) : NEW_LINE INDENT trialnumerator *= 2 NEW_LINE DEDENT DEDENT globalnumerator += trialnumerator NEW_LINE DEDENT DEDENT globaldenominator = ( END_NUM + 1 - START_NUM ) * 2 ** NUM_JUMPS * 3 ** len ( CROAK_SEQ ) NEW_LINE ans = fractions . Fraction ( globalnumerator , globaldenominator ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p123_A", "java": [{"id": "1", "code": "public final class p123 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p123 ( ) . run ( ) ) ; } private static final int PRIME_LIMIT = 1000000 ; private static final long THRESHOLD = 10000000000L ; public String run ( ) { int [ ] primes = Library . listPrimes ( PRIME_LIMIT ) ; for ( int n = 5 ; n <= primes . length ; n += 2 ) { long rem = ( long ) n * primes [ n - 1 ] * 2 ; if ( rem > THRESHOLD ) return Integer . toString ( n ) ; } throw new AssertionError ( \" Not \u2581 found \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p123 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] primes = Library . listPrimes ( PRIME_LIMIT ) ; for ( int n = 5 ; n <= primes . length ; n += 2 ) { long rem = ( long ) n * primes [ n - 1 ] * 2 ; if ( rem > THRESHOLD ) return Integer . toString ( n ) ; } throw new AssertionError ( \" Not \u2581 found \" ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE for n in range ( 5 , len ( primes ) , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > 10000000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 1000000 ) NEW_LINE for n in range ( 5 , len ( primes ) , 2 ) : NEW_LINE INDENT rem = n * primes [ n - 1 ] * 2 NEW_LINE if rem > 10000000000 : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p178_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p178 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p178 ( ) . run ( ) ) ; } private static final int LIMIT = 40 ; public String run ( ) { BigInteger [ ] [ ] [ ] [ ] ways = new BigInteger [ LIMIT + 1 ] [ 10 ] [ 10 ] [ 10 ] ; BigInteger sum = BigInteger . ZERO ; for ( int digits = 0 ; digits < ways . length ; digits ++ ) { for ( int head = 0 ; head < 10 ; head ++ ) { for ( int low = 0 ; low < 10 ; low ++ ) { for ( int high = 0 ; high < 10 ; high ++ ) { BigInteger val ; if ( digits <= 1 ) val = ( low == head && head == high ) ? BigInteger . ONE : BigInteger . ZERO ; else { val = BigInteger . ZERO ; BigInteger [ ] [ ] [ ] prevWays = ways [ digits - 1 ] ; if ( head - 1 >= low ) { val = val . add ( prevWays [ head - 1 ] [ low ] [ high ] ) ; if ( head == high ) val = val . add ( prevWays [ head - 1 ] [ low ] [ high - 1 ] ) ; } if ( head + 1 <= high ) { val = val . add ( prevWays [ head + 1 ] [ low ] [ high ] ) ; if ( head == low ) val = val . add ( prevWays [ head + 1 ] [ low + 1 ] [ high ] ) ; } } ways [ digits ] [ head ] [ low ] [ high ] = val ; if ( head > 0 && low == 0 && high == 9 ) sum = sum . add ( val ) ; } } } } return sum . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p178 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger [ ] [ ] [ ] [ ] ways = new BigInteger [ LIMIT + 1 ] [ 10 ] [ 10 ] [ 10 ] ; BigInteger sum = BigInteger . ZERO ; for ( int digits = 0 ; digits < ways . length ; digits ++ ) { for ( int head = 0 ; head < 10 ; head ++ ) { for ( int low = 0 ; low < 10 ; low ++ ) { for ( int high = 0 ; high < 10 ; high ++ ) { BigInteger val ; if ( digits <= 1 ) val = ( low == head && head == high ) ? BigInteger . ONE : BigInteger . ZERO ; else { val = BigInteger . ZERO ; BigInteger [ ] [ ] [ ] prevWays = ways [ digits - 1 ] ; if ( head - 1 >= low ) { val = val . add ( prevWays [ head - 1 ] [ low ] [ high ] ) ; if ( head == high ) val = val . add ( prevWays [ head - 1 ] [ low ] [ high - 1 ] ) ; } if ( head + 1 <= high ) { val = val . add ( prevWays [ head + 1 ] [ low ] [ high ] ) ; if ( head == low ) val = val . add ( prevWays [ head + 1 ] [ low + 1 ] [ high ] ) ; } } ways [ digits ] [ head ] [ low ] [ high ] = val ; if ( head > 0 && low == 0 && high == 9 ) sum = sum . add ( val ) ; } } } } return sum . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40 NEW_LINE ans = sum ( count_step_pandigital ( digits , head , 0 , 9 ) for digits in range ( LIMIT + 1 ) for head in range ( 1 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_step_pandigital ( digits , head , low , high ) : NEW_LINE INDENT assert digits >= 0 NEW_LINE assert low <= head <= high NEW_LINE if digits <= 1 : NEW_LINE INDENT return 1 if ( low == head == high ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if head - 1 >= low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high ) NEW_LINE if head == high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high - 1 ) NEW_LINE DEDENT DEDENT if head + 1 <= high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low , high ) NEW_LINE if head == low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low + 1 , high ) NEW_LINE DEDENT DEDENT assert 0 <= result < 10 ** digits NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 40 NEW_LINE ans = sum ( count_step_pandigital ( digits , head , 0 , 9 ) for digits in range ( LIMIT + 1 ) for head in range ( 1 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["count_step_pandigital", "def count_step_pandigital ( digits , head , low , high ) : NEW_LINE INDENT assert digits >= 0 NEW_LINE assert low <= head <= high NEW_LINE if digits <= 1 : NEW_LINE INDENT return 1 if ( low == head == high ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if head - 1 >= low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high ) NEW_LINE if head == high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high - 1 ) NEW_LINE DEDENT DEDENT if head + 1 <= high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low , high ) NEW_LINE if head == low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low + 1 , high ) NEW_LINE DEDENT DEDENT assert 0 <= result < 10 ** digits NEW_LINE return result NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p381_A", "java": [{"id": "1", "code": "public final class p381 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p381 ( ) . run ( ) ) ; } public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( Library . pow ( 10 , 8 ) ) ; long sum = 0 ; for ( int i = 5 ; i < isPrime . length ; i ++ ) { if ( isPrime [ i ] ) sum += s ( i ) ; } return Long . toString ( sum ) ; } private static int s ( int p ) { return ( int ) ( ( long ) ( p - 3 ) * Library . reciprocalMod ( 8 % p , p ) % p ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p381 ( ) . run ( ) ) ; }"], ["s", "private static int s ( int p ) { return ( int ) ( ( long ) ( p - 3 ) * Library . reciprocalMod ( 8 % p , p ) % p ) ; }"]], "functions_class": [["run", "public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( Library . pow ( 10 , 8 ) ) ; long sum = 0 ; for ( int i = 5 ; i < isPrime . length ; i ++ ) { if ( isPrime [ i ] ) sum += s ( i ) ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT def s ( p ) : NEW_LINE INDENT return ( p - 3 ) * eulerlib . reciprocal_mod ( 8 % p , p ) % p NEW_LINE DEDENT ans = sum ( s ( p ) for p in eulerlib . prime_generator ( 10 ** 8 ) if p >= 5 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p171_A", "java": [{"id": "1", "code": "public final class p171 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p171 ( ) . run ( ) ) ; } private static final int LENGTH = 20 ; private static final int BASE = 10 ; private static final int MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { int MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH ; long [ ] [ ] sum = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; long [ ] [ ] count = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= LENGTH ; i ++ ) { for ( int j = 0 ; j < BASE ; j ++ ) { for ( int k = 0 ; k + j * j <= MAX_SQR_DIGIT_SUM ; k ++ ) { sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ] [ k ] + Library . powMod ( BASE , i - 1 , MODULUS ) * j % MODULUS * count [ i - 1 ] [ k ] ) % MODULUS ; count [ i ] [ k + j * j ] = ( count [ i ] [ k + j * j ] + count [ i - 1 ] [ k ] ) % MODULUS ; } } } long s = 0 ; for ( int i = 1 ; i * i <= MAX_SQR_DIGIT_SUM ; i ++ ) s = ( s + sum [ LENGTH ] [ i * i ] ) % MODULUS ; return String . format ( \" % 09d \" , s ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p171 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int MAX_SQR_DIGIT_SUM = ( BASE - 1 ) * ( BASE - 1 ) * LENGTH ; long [ ] [ ] sum = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; long [ ] [ ] count = new long [ LENGTH + 1 ] [ MAX_SQR_DIGIT_SUM + 1 ] ; count [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= LENGTH ; i ++ ) { for ( int j = 0 ; j < BASE ; j ++ ) { for ( int k = 0 ; k + j * j <= MAX_SQR_DIGIT_SUM ; k ++ ) { sum [ i ] [ k + j * j ] = ( sum [ i ] [ k + j * j ] + sum [ i - 1 ] [ k ] + Library . powMod ( BASE , i - 1 , MODULUS ) * j % MODULUS * count [ i - 1 ] [ k ] ) % MODULUS ; count [ i ] [ k + j * j ] = ( count [ i ] [ k + j * j ] + count [ i - 1 ] [ k ] ) % MODULUS ; } } } long s = 0 ; for ( int i = 1 ; i * i <= MAX_SQR_DIGIT_SUM ; i ++ ) s = ( s + sum [ LENGTH ] [ i * i ] ) % MODULUS ; return String . format ( \" % 09d \" , s ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MODULUS = 10 ** 9 NEW_LINE MAX_SQR_DIGIT_SUM = ( BASE - 1 ) ** 2 * LENGTH NEW_LINE sqsum = [ ] NEW_LINE count = [ ] NEW_LINE for i in range ( LENGTH + 1 ) : NEW_LINE INDENT sqsum . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE count . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE if i == 0 : NEW_LINE INDENT count [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in itertools . count ( ) : NEW_LINE INDENT index = k + j ** 2 NEW_LINE if index > MAX_SQR_DIGIT_SUM : NEW_LINE INDENT break NEW_LINE DEDENT sqsum [ i ] [ index ] = ( sqsum [ i ] [ index ] + sqsum [ i - 1 ] [ k ] + pow ( BASE , i - 1 , MODULUS ) * j * count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE count [ i ] [ index ] = ( count [ i ] [ index ] + count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( sqsum [ LENGTH ] [ i ** 2 ] for i in range ( 1 , eulerlib . sqrt ( MAX_SQR_DIGIT_SUM ) ) ) NEW_LINE return f \" { ans % MODULUS : 09 } \" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LENGTH = 20 NEW_LINE BASE = 10 NEW_LINE MODULUS = 10 ** 9 NEW_LINE MAX_SQR_DIGIT_SUM = ( BASE - 1 ) ** 2 * LENGTH NEW_LINE sqsum = [ ] NEW_LINE count = [ ] NEW_LINE for i in range ( LENGTH + 1 ) : NEW_LINE INDENT sqsum . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE count . append ( [ 0 ] * ( MAX_SQR_DIGIT_SUM + 1 ) ) NEW_LINE if i == 0 : NEW_LINE INDENT count [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( BASE ) : NEW_LINE INDENT for k in itertools . count ( ) : NEW_LINE INDENT index = k + j ** 2 NEW_LINE if index > MAX_SQR_DIGIT_SUM : NEW_LINE INDENT break NEW_LINE DEDENT sqsum [ i ] [ index ] = ( sqsum [ i ] [ index ] + sqsum [ i - 1 ] [ k ] + pow ( BASE , i - 1 , MODULUS ) * j * count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE count [ i ] [ index ] = ( count [ i ] [ index ] + count [ i - 1 ] [ k ] ) % MODULUS NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( sqsum [ LENGTH ] [ i ** 2 ] for i in range ( 1 , eulerlib . sqrt ( MAX_SQR_DIGIT_SUM ) ) ) NEW_LINE return f \" { ans % MODULUS : 09 } \" NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p182_A", "java": [{"id": "1", "code": "public final class p182 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p182 ( ) . run ( ) ) ; } private static final int P = 1009 ; private static final int Q = 3643 ; private static final int TOTIENT = ( P - 1 ) * ( Q - 1 ) ; public String run ( ) { int [ ] numUnconcealedP = countAllUnconcealed ( P ) ; int [ ] numUnconcealedQ = countAllUnconcealed ( Q ) ; int minUnconcealedP = Integer . MAX_VALUE ; for ( int x : numUnconcealedP ) minUnconcealedP = Math . min ( x , minUnconcealedP ) ; int minUnconcealedQ = Integer . MAX_VALUE ; for ( int x : numUnconcealedQ ) minUnconcealedQ = Math . min ( x , minUnconcealedQ ) ; long sum = 0 ; for ( int e = 0 ; e < TOTIENT ; e ++ ) { if ( numUnconcealedP [ e % ( P - 1 ) ] == minUnconcealedP && numUnconcealedQ [ e % ( Q - 1 ) ] == minUnconcealedQ ) sum += e ; } return Long . toString ( sum ) ; } private static int [ ] countAllUnconcealed ( int prime ) { int [ ] numUnconcealed = new int [ prime - 1 ] ; for ( int e = 0 ; e < numUnconcealed . length ; e ++ ) { if ( Library . gcd ( e , prime - 1 ) == 1 ) numUnconcealed [ e ] = countUnconcealed ( prime , e ) ; else numUnconcealed [ e ] = Integer . MAX_VALUE ; } return numUnconcealed ; } private static int countUnconcealed ( int modulus , int e ) { int count = 0 ; for ( int m = 0 ; m < modulus ; m ++ ) { if ( Library . powMod ( m , e , modulus ) == m ) count ++ ; } return count ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p182 ( ) . run ( ) ) ; }"], ["countAllUnconcealed", "private static int [ ] countAllUnconcealed ( int prime ) { int [ ] numUnconcealed = new int [ prime - 1 ] ; for ( int e = 0 ; e < numUnconcealed . length ; e ++ ) { if ( Library . gcd ( e , prime - 1 ) == 1 ) numUnconcealed [ e ] = countUnconcealed ( prime , e ) ; else numUnconcealed [ e ] = Integer . MAX_VALUE ; } return numUnconcealed ; }"], ["countUnconcealed", "private static int countUnconcealed ( int modulus , int e ) { int count = 0 ; for ( int m = 0 ; m < modulus ; m ++ ) { if ( Library . powMod ( m , e , modulus ) == m ) count ++ ; } return count ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] numUnconcealedP = countAllUnconcealed ( P ) ; int [ ] numUnconcealedQ = countAllUnconcealed ( Q ) ; int minUnconcealedP = Integer . MAX_VALUE ; for ( int x : numUnconcealedP ) minUnconcealedP = Math . min ( x , minUnconcealedP ) ; int minUnconcealedQ = Integer . MAX_VALUE ; for ( int x : numUnconcealedQ ) minUnconcealedQ = Math . min ( x , minUnconcealedQ ) ; long sum = 0 ; for ( int e = 0 ; e < TOTIENT ; e ++ ) { if ( numUnconcealedP [ e % ( P - 1 ) ] == minUnconcealedP && numUnconcealedQ [ e % ( Q - 1 ) ] == minUnconcealedQ ) sum += e ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT P = 1009 NEW_LINE Q = 3643 NEW_LINE TOTIENT = ( P - 1 ) * ( Q - 1 ) NEW_LINE numunconcealedp = count_all_unconcealed ( P ) NEW_LINE numunconcealedq = count_all_unconcealed ( Q ) NEW_LINE minunconcealedp = min ( numunconcealedp ) NEW_LINE minunconcealedq = min ( numunconcealedq ) NEW_LINE ans = sum ( e for e in range ( TOTIENT ) if numunconcealedp [ e % ( P - 1 ) ] == minunconcealedp and numunconcealedq [ e % ( Q - 1 ) ] == minunconcealedq ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def count_all_unconcealed ( prime ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in range ( prime - 1 ) : NEW_LINE INDENT if fractions . gcd ( e , prime - 1 ) == 1 : NEW_LINE INDENT result . append ( count_unconcealed ( prime , e ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( 10 ** 20 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def count_unconcealed ( modulus , e ) : NEW_LINE INDENT result = 0 NEW_LINE for m in range ( modulus ) : NEW_LINE INDENT if pow ( m , e , modulus ) == m : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT P = 1009 NEW_LINE Q = 3643 NEW_LINE TOTIENT = ( P - 1 ) * ( Q - 1 ) NEW_LINE numunconcealedp = count_all_unconcealed ( P ) NEW_LINE numunconcealedq = count_all_unconcealed ( Q ) NEW_LINE minunconcealedp = min ( numunconcealedp ) NEW_LINE minunconcealedq = min ( numunconcealedq ) NEW_LINE ans = sum ( e for e in range ( TOTIENT ) if numunconcealedp [ e % ( P - 1 ) ] == minunconcealedp and numunconcealedq [ e % ( Q - 1 ) ] == minunconcealedq ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["count_all_unconcealed", "def count_all_unconcealed ( prime ) : NEW_LINE INDENT result = [ ] NEW_LINE for e in range ( prime - 1 ) : NEW_LINE INDENT if fractions . gcd ( e , prime - 1 ) == 1 : NEW_LINE INDENT result . append ( count_unconcealed ( prime , e ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result . append ( 10 ** 20 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"], ["count_unconcealed", "def count_unconcealed ( modulus , e ) : NEW_LINE INDENT result = 0 NEW_LINE for m in range ( modulus ) : NEW_LINE INDENT if pow ( m , e , modulus ) == m : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p122_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p122 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p122 ( ) . run ( ) ) ; } private static final int LIMIT = 200 ; private int [ ] minOperations ; private int numUnknown ; public String run ( ) { minOperations = new int [ LIMIT + 1 ] ; Arrays . fill ( minOperations , - 1 ) ; minOperations [ 0 ] = 0 ; minOperations [ 1 ] = 0 ; numUnknown = LIMIT - 1 ; for ( int ops = 1 ; numUnknown > 0 ; ops ++ ) { IntStack chain = new IntStack ( ops + 1 ) ; chain . push ( 1 ) ; exploreChains ( chain , ops ) ; } int sum = 0 ; for ( int x : minOperations ) sum += x ; return Integer . toString ( sum ) ; } private void exploreChains ( IntStack chain , int maxOps ) { if ( chain . size > maxOps || numUnknown == 0 ) return ; int max = chain . values [ chain . size - 1 ] ; for ( int i = chain . size - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j >= 0 ; j -- ) { int x = chain . values [ i ] + chain . values [ j ] ; if ( x <= max ) break ; if ( x <= LIMIT ) { chain . push ( x ) ; if ( minOperations [ x ] == - 1 ) { minOperations [ x ] = chain . size - 1 ; numUnknown -- ; } exploreChains ( chain , maxOps ) ; chain . pop ( ) ; } } } } private static final class IntStack { public int [ ] values ; public int size ; public IntStack ( int capacity ) { values = new int [ capacity ] ; size = 0 ; } public void push ( int x ) { if ( size >= values . length ) throw new IllegalStateException ( ) ; values [ size ] = x ; size ++ ; } public int pop ( ) { if ( size <= 0 ) throw new IllegalStateException ( ) ; size -- ; return values [ size ] ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p122 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { minOperations = new int [ LIMIT + 1 ] ; Arrays . fill ( minOperations , - 1 ) ; minOperations [ 0 ] = 0 ; minOperations [ 1 ] = 0 ; numUnknown = LIMIT - 1 ; for ( int ops = 1 ; numUnknown > 0 ; ops ++ ) { IntStack chain = new IntStack ( ops + 1 ) ; chain . push ( 1 ) ; exploreChains ( chain , ops ) ; } int sum = 0 ; for ( int x : minOperations ) sum += x ; return Integer . toString ( sum ) ; }"], ["exploreChains", "private void exploreChains ( IntStack chain , int maxOps ) { if ( chain . size > maxOps || numUnknown == 0 ) return ; int max = chain . values [ chain . size - 1 ] ; for ( int i = chain . size - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j >= 0 ; j -- ) { int x = chain . values [ i ] + chain . values [ j ] ; if ( x <= max ) break ; if ( x <= LIMIT ) { chain . push ( x ) ; if ( minOperations [ x ] == - 1 ) { minOperations [ x ] = chain . size - 1 ; numUnknown -- ; } exploreChains ( chain , maxOps ) ; chain . pop ( ) ; } } } }"], ["IntStack", "public IntStack ( int capacity ) { values = new int [ capacity ] ; size = 0 ; }"], ["push", "public void push ( int x ) { if ( size >= values . length ) throw new IllegalStateException ( ) ; values [ size ] = x ; size ++ ; }"], ["pop", "public int pop ( ) { if ( size <= 0 ) throw new IllegalStateException ( ) ; size -- ; return values [ size ] ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 200 NEW_LINE minoperations = [ 0 , 0 ] + [ None ] * ( LIMIT - 1 ) NEW_LINE numunknown = [ LIMIT - 1 ] NEW_LINE def explore_chains ( chain , maxops ) : NEW_LINE INDENT if len ( chain ) > maxops or numunknown [ 0 ] == 0 : NEW_LINE INDENT return NEW_LINE DEDENT max = chain [ - 1 ] NEW_LINE for i in reversed ( range ( len ( chain ) ) ) : NEW_LINE INDENT for j in reversed ( range ( i + 1 ) ) : NEW_LINE INDENT x = chain [ i ] + chain [ j ] NEW_LINE if x <= max : NEW_LINE INDENT break NEW_LINE DEDENT if x <= LIMIT : NEW_LINE INDENT chain . append ( x ) NEW_LINE if minoperations [ x ] is None : NEW_LINE INDENT minoperations [ x ] = len ( chain ) - 1 NEW_LINE numunknown [ 0 ] -= 1 NEW_LINE DEDENT explore_chains ( chain , maxops ) NEW_LINE chain . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for ops in itertools . count ( 1 ) : NEW_LINE INDENT if numunknown [ 0 ] == 0 : NEW_LINE INDENT return str ( sum ( minoperations ) ) NEW_LINE DEDENT explore_chains ( [ 1 ] , ops ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 200 NEW_LINE minoperations = [ 0 , 0 ] + [ None ] * ( LIMIT - 1 ) NEW_LINE numunknown = [ LIMIT - 1 ] NEW_LINE def explore_chains ( chain , maxops ) : NEW_LINE INDENT if len ( chain ) > maxops or numunknown [ 0 ] == 0 : NEW_LINE INDENT return NEW_LINE DEDENT max = chain [ - 1 ] NEW_LINE for i in reversed ( range ( len ( chain ) ) ) : NEW_LINE INDENT for j in reversed ( range ( i + 1 ) ) : NEW_LINE INDENT x = chain [ i ] + chain [ j ] NEW_LINE if x <= max : NEW_LINE INDENT break NEW_LINE DEDENT if x <= LIMIT : NEW_LINE INDENT chain . append ( x ) NEW_LINE if minoperations [ x ] is None : NEW_LINE INDENT minoperations [ x ] = len ( chain ) - 1 NEW_LINE numunknown [ 0 ] -= 1 NEW_LINE DEDENT explore_chains ( chain , maxops ) NEW_LINE chain . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for ops in itertools . count ( 1 ) : NEW_LINE INDENT if numunknown [ 0 ] == 0 : NEW_LINE INDENT return str ( sum ( minoperations ) ) NEW_LINE DEDENT explore_chains ( [ 1 ] , ops ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p125_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p125 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p125 ( ) . run ( ) ) ; } public String run ( ) { Set < Integer > nums = new HashSet < > ( ) ; for ( int i = 1 ; i <= 10000 ; i ++ ) { int sum = i * i ; for ( int j = i + 1 ; ; j ++ ) { sum += j * j ; if ( sum >= 100000000 ) break ; if ( Library . isPalindrome ( sum ) ) nums . add ( sum ) ; } } long sum = 0 ; for ( int x : nums ) sum += x ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p125 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < Integer > nums = new HashSet < > ( ) ; for ( int i = 1 ; i <= 10000 ; i ++ ) { int sum = i * i ; for ( int j = i + 1 ; ; j ++ ) { sum += j * j ; if ( sum >= 100000000 ) break ; if ( Library . isPalindrome ( sum ) ) nums . add ( sum ) ; } } long sum = 0 ; for ( int x : nums ) sum += x ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT nums = set ( ) NEW_LINE for i in range ( 1 , 10001 ) : NEW_LINE INDENT sigma = i * i NEW_LINE for j in itertools . count ( i + 1 ) : NEW_LINE INDENT sigma += j * j NEW_LINE if sigma >= 100000000 : NEW_LINE INDENT break NEW_LINE DEDENT s = str ( sigma ) NEW_LINE if s == s [ : : - 1 ] : NEW_LINE INDENT nums . add ( sigma ) NEW_LINE DEDENT DEDENT DEDENT return str ( sum ( nums ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT nums = set ( ) NEW_LINE for i in range ( 1 , 10001 ) : NEW_LINE INDENT sigma = i * i NEW_LINE for j in itertools . count ( i + 1 ) : NEW_LINE INDENT sigma += j * j NEW_LINE if sigma >= 100000000 : NEW_LINE INDENT break NEW_LINE DEDENT s = str ( sigma ) NEW_LINE if s == s [ : : - 1 ] : NEW_LINE INDENT nums . add ( sigma ) NEW_LINE DEDENT DEDENT DEDENT return str ( sum ( nums ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p113_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p113 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p113 ( ) . run ( ) ) ; } private static final int DIGITS = 100 ; public String run ( ) { BigInteger increasing = Library . binomial ( DIGITS + 9 , 9 ) . subtract ( BigInteger . ONE ) ; BigInteger decreasing = Library . binomial ( DIGITS + 10 , 10 ) . subtract ( BigInteger . valueOf ( DIGITS + 1 ) ) ; BigInteger flat = BigInteger . valueOf ( DIGITS * 9 ) ; return increasing . add ( decreasing ) . subtract ( flat ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p113 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger increasing = Library . binomial ( DIGITS + 9 , 9 ) . subtract ( BigInteger . ONE ) ; BigInteger decreasing = Library . binomial ( DIGITS + 10 , 10 ) . subtract ( BigInteger . valueOf ( DIGITS + 1 ) ) ; BigInteger flat = BigInteger . valueOf ( DIGITS * 9 ) ; return increasing . add ( decreasing ) . subtract ( flat ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE increasing = eulerlib . binomial ( DIGITS + 9 , 9 ) - 1 NEW_LINE decreasing = eulerlib . binomial ( DIGITS + 10 , 10 ) - ( DIGITS + 1 ) NEW_LINE flat = DIGITS * 9 NEW_LINE ans = increasing + decreasing - flat NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE increasing = eulerlib . binomial ( DIGITS + 9 , 9 ) - 1 NEW_LINE decreasing = eulerlib . binomial ( DIGITS + 10 , 10 ) - ( DIGITS + 1 ) NEW_LINE flat = DIGITS * 9 NEW_LINE ans = increasing + decreasing - flat NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p114_A", "java": [{"id": "1", "code": "public final class p114 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p114 ( ) . run ( ) ) ; } private static final int LENGTH = 50 ; public String run ( ) { long [ ] ways = new long [ LENGTH + 1 ] ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 1 ; for ( int n = 3 ; n <= LENGTH ; n ++ ) { long sum = ways [ n - 1 ] + 1 ; for ( int k = 3 ; k < n ; k ++ ) sum += ways [ n - k - 1 ] ; ways [ n ] = sum ; } return Long . toString ( ways [ LENGTH ] ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p114 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] ways = new long [ LENGTH + 1 ] ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 1 ; for ( int n = 3 ; n <= LENGTH ; n ++ ) { long sum = ways [ n - 1 ] + 1 ; for ( int k = 3 ; k < n ; k ++ ) sum += ways [ n - k - 1 ] ; ways [ n ] = sum ; } return Long . toString ( ways [ LENGTH ] ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( len ( ways ) ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT ways [ n ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways [ n ] = ways [ n - 1 ] + sum ( ways [ : n - 3 ] ) + 1 NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 0 ] * ( LENGTH + 1 ) NEW_LINE for n in range ( len ( ways ) ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT ways [ n ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways [ n ] = ways [ n - 1 ] + sum ( ways [ : n - 3 ] ) + 1 NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p166_A", "java": [{"id": "1", "code": "public final class p166 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p166 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; int [ ] num = new int [ 8 ] ; do { int a = num [ 0 ] , b = num [ 1 ] , c = num [ 2 ] , d = num [ 3 ] ; int e = num [ 4 ] , g = num [ 5 ] , i = num [ 6 ] , k = num [ 7 ] ; int m = b + c + d - e - i ; if ( m < 0 || m > 9 ) continue ; int o = a + b + d - g - k ; if ( o < 0 || o > 9 ) continue ; int j = a + b + c - g - m ; if ( j < 0 || j > 9 ) continue ; int l = a + b + c + d - i - j - k ; if ( l < 0 || l > 9 ) continue ; int f = b + c + d * 2 - e - i - k ; if ( f < 0 || f > 9 ) continue ; int h = a + b + c + d - e - f - g ; if ( h < 0 || h > 9 ) continue ; int n = a + c + d - f - j ; if ( n < 0 || n > 9 ) continue ; int p = a + b + c - h - l ; if ( p < 0 || p > 9 ) continue ; count ++ ; } while ( increment ( num ) ) ; return Integer . toString ( count ) ; } private static boolean increment ( int [ ] num ) { int i = 0 ; while ( num [ i ] == 9 ) { num [ i ] = 0 ; i ++ ; if ( i == num . length ) return false ; } num [ i ] ++ ; return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p166 ( ) . run ( ) ) ; }"], ["increment", "private static boolean increment ( int [ ] num ) { int i = 0 ; while ( num [ i ] == 9 ) { num [ i ] = 0 ; i ++ ; if ( i == num . length ) return false ; } num [ i ] ++ ; return true ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; int [ ] num = new int [ 8 ] ; do { int a = num [ 0 ] , b = num [ 1 ] , c = num [ 2 ] , d = num [ 3 ] ; int e = num [ 4 ] , g = num [ 5 ] , i = num [ 6 ] , k = num [ 7 ] ; int m = b + c + d - e - i ; if ( m < 0 || m > 9 ) continue ; int o = a + b + d - g - k ; if ( o < 0 || o > 9 ) continue ; int j = a + b + c - g - m ; if ( j < 0 || j > 9 ) continue ; int l = a + b + c + d - i - j - k ; if ( l < 0 || l > 9 ) continue ; int f = b + c + d * 2 - e - i - k ; if ( f < 0 || f > 9 ) continue ; int h = a + b + c + d - e - f - g ; if ( h < 0 || h > 9 ) continue ; int n = a + c + d - f - j ; if ( n < 0 || n > 9 ) continue ; int p = a + b + c - h - l ; if ( p < 0 || p > 9 ) continue ; count ++ ; } while ( increment ( num ) ) ; return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE digits = tuple ( range ( 10 ) ) NEW_LINE for b in digits : NEW_LINE INDENT for c in digits : NEW_LINE INDENT for d in digits : NEW_LINE INDENT for e in digits : NEW_LINE INDENT for i in digits : NEW_LINE INDENT m = b + c + d - e - i NEW_LINE if m < 0 or m > 9 : continue NEW_LINE for k in digits : NEW_LINE INDENT f = b + c + d * 2 - e - i - k NEW_LINE if f < 0 or f > 9 : continue NEW_LINE for a in digits : NEW_LINE INDENT for g in digits : NEW_LINE INDENT o = a + b + d - g - k NEW_LINE if o < 0 or o > 9 : continue NEW_LINE j = a + b + c - g - m NEW_LINE if j < 0 or j > 9 : continue NEW_LINE l = a + b + c + d - i - j - k NEW_LINE if l < 0 or l > 9 : continue NEW_LINE h = a + b + c + d - e - f - g NEW_LINE if h < 0 or h > 9 : continue NEW_LINE n = a + c + d - f - j NEW_LINE if n < 0 or n > 9 : continue NEW_LINE p = a + b + c - h - l NEW_LINE if p < 0 or p > 9 : continue NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p132_A", "java": [{"id": "1", "code": "public final class p132 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p132 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int count = 0 ; for ( int i = 2 ; count < 40 ; i ++ ) { if ( Library . isPrime ( i ) && repunitMod ( 1000000000 , i ) == 0 ) { sum += i ; count ++ ; } } return Integer . toString ( sum ) ; } private static int repunitMod ( int k , int m ) { return ( Library . powMod ( 10 , k , m * 9 ) - 1 ) / 9 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p132 ( ) . run ( ) ) ; }"], ["repunitMod", "private static int repunitMod ( int k , int m ) { return ( Library . powMod ( 10 , k , m * 9 ) - 1 ) / 9 ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; int count = 0 ; for ( int i = 2 ; count < 40 ; i ++ ) { if ( Library . isPrime ( i ) && repunitMod ( 1000000000 , i ) == 0 ) { sum += i ; count ++ ; } } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : eulerlib . is_prime ( i ) and repunit_mod ( 10 ** 9 , i ) == 0 NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 2 ) ) , 40 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def repunit_mod ( k , m ) : NEW_LINE INDENT return ( pow ( 10 , k , m * 9 ) - 1 ) // 9 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT cond = lambda i : eulerlib . is_prime ( i ) and repunit_mod ( 10 ** 9 , i ) == 0 NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 2 ) ) , 40 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["repunit_mod", "def repunit_mod ( k , m ) : NEW_LINE INDENT return ( pow ( 10 , k , m * 9 ) - 1 ) // 9 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p135_A", "java": [{"id": "1", "code": "public final class p135 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p135 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int [ ] solutions = new int [ LIMIT ] ; for ( int m = 1 ; m < LIMIT * 2 ; m ++ ) { for ( int k = m / 5 + 1 ; k * 2 < m ; k ++ ) { long temp = ( long ) ( m - k ) * ( k * 5 - m ) ; if ( temp >= solutions . length ) break ; solutions [ ( int ) temp ] ++ ; } } int count = 0 ; for ( int x : solutions ) { if ( x == 10 ) count ++ ; } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p135 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] solutions = new int [ LIMIT ] ; for ( int m = 1 ; m < LIMIT * 2 ; m ++ ) { for ( int k = m / 5 + 1 ; k * 2 < m ; k ++ ) { long temp = ( long ) ( m - k ) * ( k * 5 - m ) ; if ( temp >= solutions . length ) break ; solutions [ ( int ) temp ] ++ ; } } int count = 0 ; for ( int x : solutions ) { if ( x == 10 ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE solutions = [ 0 ] * LIMIT NEW_LINE for m in range ( 1 , LIMIT * 2 ) : NEW_LINE INDENT for k in range ( m // 5 + 1 , ( m + 1 ) // 2 ) : NEW_LINE INDENT temp = ( m - k ) * ( k * 5 - m ) NEW_LINE if temp >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT solutions [ temp ] += 1 NEW_LINE DEDENT DEDENT ans = solutions . count ( 10 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE solutions = [ 0 ] * LIMIT NEW_LINE for m in range ( 1 , LIMIT * 2 ) : NEW_LINE INDENT for k in range ( m // 5 + 1 , ( m + 1 ) // 2 ) : NEW_LINE INDENT temp = ( m - k ) * ( k * 5 - m ) NEW_LINE if temp >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT solutions [ temp ] += 1 NEW_LINE DEDENT DEDENT ans = solutions . count ( 10 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p104_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . Arrays ; public final class p104 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p104 ( ) . run ( ) ) ; } public String run ( ) { int i = 0 ; int a = 0 ; int b = 1 ; while ( ! isFound ( i , a ) ) { int c = ( a + b ) % 1000000000 ; a = b ; b = c ; i ++ ; } return Integer . toString ( i ) ; } private static boolean isFound ( int n , int fibMod ) { if ( ! isPandigital ( Integer . toString ( fibMod ) ) ) return false ; BigInteger fib = fibonacci ( n ) [ 0 ] ; if ( fib . mod ( BigInteger . valueOf ( 1000000000 ) ) . intValue ( ) != fibMod ) throw new AssertionError ( ) ; return isPandigital ( leading9Digits ( fib ) ) ; } private static String leading9Digits ( BigInteger x ) { int log10 = ( x . bitLength ( ) - 1 ) * 3 / 10 ; x = x . divide ( BigInteger . TEN . pow ( Math . max ( log10 + 1 - 9 , 0 ) ) ) ; return x . toString ( ) . substring ( 0 , 9 ) ; } private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; } private static BigInteger [ ] fibonacci ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( ) ; else if ( n == 0 ) return new BigInteger [ ] { BigInteger . ZERO , BigInteger . ONE } ; else { BigInteger [ ] ab = fibonacci ( n / 2 ) ; BigInteger a = ab [ 0 ] ; BigInteger b = ab [ 1 ] ; BigInteger c = a . multiply ( b . shiftLeft ( 1 ) . subtract ( a ) ) ; BigInteger d = a . multiply ( a ) . add ( b . multiply ( b ) ) ; if ( n % 2 == 0 ) return new BigInteger [ ] { c , d } ; else return new BigInteger [ ] { d , c . add ( d ) } ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p104 ( ) . run ( ) ) ; }"], ["isFound", "private static boolean isFound ( int n , int fibMod ) { if ( ! isPandigital ( Integer . toString ( fibMod ) ) ) return false ; BigInteger fib = fibonacci ( n ) [ 0 ] ; if ( fib . mod ( BigInteger . valueOf ( 1000000000 ) ) . intValue ( ) != fibMod ) throw new AssertionError ( ) ; return isPandigital ( leading9Digits ( fib ) ) ; }"], ["leading9Digits", "private static String leading9Digits ( BigInteger x ) { int log10 = ( x . bitLength ( ) - 1 ) * 3 / 10 ; x = x . divide ( BigInteger . TEN . pow ( Math . max ( log10 + 1 - 9 , 0 ) ) ) ; return x . toString ( ) . substring ( 0 , 9 ) ; }"], ["isPandigital", "private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; }"], ["fibonacci", "private static BigInteger [ ] fibonacci ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( ) ; else if ( n == 0 ) return new BigInteger [ ] { BigInteger . ZERO , BigInteger . ONE } ; else { BigInteger [ ] ab = fibonacci ( n / 2 ) ; BigInteger a = ab [ 0 ] ; BigInteger b = ab [ 1 ] ; BigInteger c = a . multiply ( b . shiftLeft ( 1 ) . subtract ( a ) ) ; BigInteger d = a . multiply ( a ) . add ( b . multiply ( b ) ) ; if ( n % 2 == 0 ) return new BigInteger [ ] { c , d } ; else return new BigInteger [ ] { d , c . add ( d ) } ; } }"]], "functions_class": [["run", "public String run ( ) { int i = 0 ; int a = 0 ; int b = 1 ; while ( ! isFound ( i , a ) ) { int c = ( a + b ) % 1000000000 ; a = b ; b = c ; i ++ ; } return Integer . toString ( i ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT MOD = 10 ** 9 NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if \" \" . join ( sorted ( str ( a ) ) ) == \"123456789\" : NEW_LINE INDENT f = fibonacci ( i ) [ 0 ] NEW_LINE if \" \" . join ( sorted ( str ( f ) [ : 9 ] ) ) == \"123456789\" : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT a , b = b , ( a + b ) % MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def fibonacci ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ( 0 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = fibonacci ( n // 2 ) NEW_LINE c = a * ( b * 2 - a ) NEW_LINE d = a * a + b * b NEW_LINE if n % 2 == 0 : NEW_LINE INDENT return ( c , d ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( d , c + d ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 9 NEW_LINE a = 0 NEW_LINE b = 1 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if \" \" . join ( sorted ( str ( a ) ) ) == \"123456789\" : NEW_LINE INDENT f = fibonacci ( i ) [ 0 ] NEW_LINE if \" \" . join ( sorted ( str ( f ) [ : 9 ] ) ) == \"123456789\" : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT a , b = b , ( a + b ) % MOD NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"], ["fibonacci", "def fibonacci ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return ( 0 , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a , b = fibonacci ( n // 2 ) NEW_LINE c = a * ( b * 2 - a ) NEW_LINE d = a * a + b * b NEW_LINE if n % 2 == 0 : NEW_LINE INDENT return ( c , d ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( d , c + d ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p160_A", "java": [{"id": "1", "code": "public final class p160 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p160 ( ) . run ( ) ) ; } public String run ( ) { return Long . toString ( factorialSuffix ( 1000000000000L ) ) ; } private static long factorialSuffix ( long n ) { long twos = countFactors ( n , 2 ) - countFactors ( n , 5 ) ; if ( twos >= 2505 ) twos = ( twos - 5 ) % 2500 + 5 ; return factorialish ( n ) * Library . powMod ( 2 , ( int ) twos , 100000 ) % 100000 ; } private static long factorialish ( long n ) { return evenFactorialish ( n ) * oddFactorialish ( n ) % 100000 ; } private static long evenFactorialish ( long n ) { if ( n == 0 ) return 1 ; else return factorialish ( n / 2 ) ; } private static long oddFactorialish ( long n ) { if ( n == 0 ) return 1 ; else return oddFactorialish ( n / 5 ) * factorialCoprime ( n ) % 100000 ; } private static long factorialCoprime ( long n ) { n %= 100000 ; long product = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 != 0 && i % 5 != 0 ) product = i * product % 100000 ; } return product ; } private static long countFactors ( long end , long n ) { if ( end == 0 ) return 0 ; else return end / n + countFactors ( end / n , n ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p160 ( ) . run ( ) ) ; }"], ["factorialSuffix", "private static long factorialSuffix ( long n ) { long twos = countFactors ( n , 2 ) - countFactors ( n , 5 ) ; if ( twos >= 2505 ) twos = ( twos - 5 ) % 2500 + 5 ; return factorialish ( n ) * Library . powMod ( 2 , ( int ) twos , 100000 ) % 100000 ; }"], ["factorialish", "private static long factorialish ( long n ) { return evenFactorialish ( n ) * oddFactorialish ( n ) % 100000 ; }"], ["evenFactorialish", "private static long evenFactorialish ( long n ) { if ( n == 0 ) return 1 ; else return factorialish ( n / 2 ) ; }"], ["oddFactorialish", "private static long oddFactorialish ( long n ) { if ( n == 0 ) return 1 ; else return oddFactorialish ( n / 5 ) * factorialCoprime ( n ) % 100000 ; }"], ["factorialCoprime", "private static long factorialCoprime ( long n ) { n %= 100000 ; long product = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 != 0 && i % 5 != 0 ) product = i * product % 100000 ; } return product ; }"], ["countFactors", "private static long countFactors ( long end , long n ) { if ( end == 0 ) return 0 ; else return end / n + countFactors ( end / n , n ) ; }"]], "functions_class": [["run", "public String run ( ) { return Long . toString ( factorialSuffix ( 1000000000000L ) ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n // 2 ) NEW_LINE DEDENT DEDENT def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n // 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end // n + count_factors ( end // n , n ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = factorial_suffix ( 10 ** 12 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["factorial_suffix", "def factorial_suffix ( n ) : NEW_LINE INDENT twos = count_factors ( n , 2 ) - count_factors ( n , 5 ) NEW_LINE if twos >= 2505 : NEW_LINE INDENT twos = ( twos - 5 ) % 2500 + 5 NEW_LINE DEDENT return factorialish ( n ) * pow ( 2 , twos , 100000 ) % 100000 NEW_LINE DEDENT"], ["factorialish", "def factorialish ( n ) : NEW_LINE INDENT return even_factorialish ( n ) * odd_factorialish ( n ) % 100000 NEW_LINE DEDENT"], ["even_factorialish", "def even_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorialish ( n // 2 ) NEW_LINE DEDENT DEDENT"], ["odd_factorialish", "def odd_factorialish ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return odd_factorialish ( n // 5 ) * factorial_coprime ( n ) % 100000 NEW_LINE DEDENT DEDENT"], ["factorial_coprime", "def factorial_coprime ( n ) : NEW_LINE INDENT n %= 100000 NEW_LINE product = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i % 2 != 0 and i % 5 != 0 : NEW_LINE INDENT product = i * product % 100000 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT"], ["count_factors", "def count_factors ( end , n ) : NEW_LINE INDENT if end == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return end // n + count_factors ( end // n , n ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p169_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . Arrays ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public final class p169 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p169 ( ) . run ( ) ) ; } private static final BigInteger NUMBER = BigInteger . TEN . pow ( 25 ) ; public String run ( ) { return countWays ( NUMBER , NUMBER . bitLength ( ) - 1 , 2 ) . toString ( ) ; } private Map < List < BigInteger > , BigInteger > ways = new HashMap < > ( ) ; private BigInteger countWays ( BigInteger number , int exponent , int repetitions ) { List < BigInteger > key = Arrays . asList ( number , BigInteger . valueOf ( exponent ) , BigInteger . valueOf ( repetitions ) ) ; if ( ways . containsKey ( key ) ) return ways . get ( key ) ; BigInteger result ; if ( exponent < 0 ) result = number . equals ( BigInteger . ZERO ) ? BigInteger . ONE : BigInteger . ZERO ; else { result = countWays ( number , exponent - 1 , 2 ) ; BigInteger pow = BigInteger . ONE . shiftLeft ( exponent ) ; BigInteger upper = pow . multiply ( BigInteger . valueOf ( repetitions + 2 ) ) ; if ( repetitions > 0 && pow . compareTo ( number ) <= 0 && number . compareTo ( upper ) < 0 ) result = result . add ( countWays ( number . subtract ( pow ) , exponent , repetitions - 1 ) ) ; } ways . put ( key , result ) ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p169 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { return countWays ( NUMBER , NUMBER . bitLength ( ) - 1 , 2 ) . toString ( ) ; }"], ["countWays", "private BigInteger countWays ( BigInteger number , int exponent , int repetitions ) { List < BigInteger > key = Arrays . asList ( number , BigInteger . valueOf ( exponent ) , BigInteger . valueOf ( repetitions ) ) ; if ( ways . containsKey ( key ) ) return ways . get ( key ) ; BigInteger result ; if ( exponent < 0 ) result = number . equals ( BigInteger . ZERO ) ? BigInteger . ONE : BigInteger . ZERO ; else { result = countWays ( number , exponent - 1 , 2 ) ; BigInteger pow = BigInteger . ONE . shiftLeft ( exponent ) ; BigInteger upper = pow . multiply ( BigInteger . valueOf ( repetitions + 2 ) ) ; if ( repetitions > 0 && pow . compareTo ( number ) <= 0 && number . compareTo ( upper ) < 0 ) result = result . add ( countWays ( number . subtract ( pow ) , exponent , repetitions - 1 ) ) ; } ways . put ( key , result ) ; return result ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE NUMBER = 10 ** 25 NEW_LINE ans = count_ways ( NUMBER , NUMBER . bit_length ( ) - 1 , 2 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_ways ( number , exponent , repetitions ) : NEW_LINE INDENT if exponent < 0 : NEW_LINE INDENT return 1 if number == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = count_ways ( number , exponent - 1 , 2 ) NEW_LINE power = 1 << exponent NEW_LINE upper = power * ( repetitions + 2 ) NEW_LINE if repetitions > 0 and power <= number < upper : NEW_LINE INDENT result += count_ways ( number - power , exponent , repetitions - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE NUMBER = 10 ** 25 NEW_LINE ans = count_ways ( NUMBER , NUMBER . bit_length ( ) - 1 , 2 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["count_ways", "def count_ways ( number , exponent , repetitions ) : NEW_LINE INDENT if exponent < 0 : NEW_LINE INDENT return 1 if number == 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = count_ways ( number , exponent - 1 , 2 ) NEW_LINE power = 1 << exponent NEW_LINE upper = power * ( repetitions + 2 ) NEW_LINE if repetitions > 0 and power <= number < upper : NEW_LINE INDENT result += count_ways ( number - power , exponent , repetitions - 1 ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p151_A", "java": [{"id": "1", "code": "import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; public final class p151 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p151 ( ) . run ( ) ) ; } public String run ( ) { List < Integer > startState = Arrays . asList ( 1 ) ; return String . format ( \" % .6f \" , getExpectedSingles ( startState ) - 2 ) ; } private Map < List < Integer > , Double > expectedSingles = new HashMap < > ( ) ; private double getExpectedSingles ( List < Integer > state ) { if ( expectedSingles . containsKey ( state ) ) return expectedSingles . get ( state ) ; double result = 0 ; if ( ! state . isEmpty ( ) ) { for ( int i = 0 ; i < state . size ( ) ; i ++ ) { List < Integer > newState = new ArrayList < > ( state ) ; int sheet = state . get ( i ) ; newState . remove ( i ) ; for ( int j = sheet + 1 ; j <= 5 ; j ++ ) newState . add ( j ) ; Collections . sort ( newState ) ; result += getExpectedSingles ( newState ) ; } result /= state . size ( ) ; if ( state . size ( ) == 1 ) result ++ ; } expectedSingles . put ( state , result ) ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p151 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { List < Integer > startState = Arrays . asList ( 1 ) ; return String . format ( \" % .6f \" , getExpectedSingles ( startState ) - 2 ) ; }"], ["getExpectedSingles", "private double getExpectedSingles ( List < Integer > state ) { if ( expectedSingles . containsKey ( state ) ) return expectedSingles . get ( state ) ; double result = 0 ; if ( ! state . isEmpty ( ) ) { for ( int i = 0 ; i < state . size ( ) ; i ++ ) { List < Integer > newState = new ArrayList < > ( state ) ; int sheet = state . get ( i ) ; newState . remove ( i ) ; for ( int j = sheet + 1 ; j <= 5 ; j ++ ) newState . add ( j ) ; Collections . sort ( newState ) ; result += getExpectedSingles ( newState ) ; } result /= state . size ( ) ; if ( state . size ( ) == 1 ) result ++ ; } expectedSingles . put ( state , result ) ; return result ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = get_expected_singles ( ( 1 , ) ) - 2 NEW_LINE return f \" { ans : .6f } \" NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def get_expected_singles ( state ) : NEW_LINE INDENT result = 0.0 NEW_LINE if len ( state ) > 0 : NEW_LINE INDENT for i in range ( len ( state ) ) : NEW_LINE INDENT tempstate = list ( state ) NEW_LINE sheet = state [ i ] NEW_LINE del tempstate [ i ] NEW_LINE for j in range ( sheet + 1 , 6 ) : NEW_LINE INDENT tempstate . append ( j ) NEW_LINE DEDENT tempstate . sort ( ) NEW_LINE result += get_expected_singles ( tuple ( tempstate ) ) NEW_LINE DEDENT result /= len ( state ) NEW_LINE if len ( state ) == 1 : NEW_LINE INDENT result += 1.0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = get_expected_singles ( ( 1 , ) ) - 2 NEW_LINE return f \" { ans : .6f } \" NEW_LINE DEDENT"], ["get_expected_singles", "def get_expected_singles ( state ) : NEW_LINE INDENT result = 0.0 NEW_LINE if len ( state ) > 0 : NEW_LINE INDENT for i in range ( len ( state ) ) : NEW_LINE INDENT tempstate = list ( state ) NEW_LINE sheet = state [ i ] NEW_LINE del tempstate [ i ] NEW_LINE for j in range ( sheet + 1 , 6 ) : NEW_LINE INDENT tempstate . append ( j ) NEW_LINE DEDENT tempstate . sort ( ) NEW_LINE result += get_expected_singles ( tuple ( tempstate ) ) NEW_LINE DEDENT result /= len ( state ) NEW_LINE if len ( state ) == 1 : NEW_LINE INDENT result += 1.0 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p134_A", "java": [{"id": "1", "code": "public final class p134 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p134 ( ) . run ( ) ) ; } public String run ( ) { long sum = 0 ; int [ ] primes = Library . listPrimes ( 2000000 ) ; for ( int i = 2 ; primes [ i ] <= 1000000 ; i ++ ) { int p = primes [ i ] ; int q = primes [ i + 1 ] ; int k = 1 ; while ( k < p ) k *= 10 ; long m = ( long ) ( q - p ) * Library . reciprocalMod ( k % q , q ) % q ; sum += m * k + p ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p134 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; int [ ] primes = Library . listPrimes ( 2000000 ) ; for ( int i = 2 ; primes [ i ] <= 1000000 ; i ++ ) { int p = primes [ i ] ; int q = primes [ i + 1 ] ; int k = 1 ; while ( k < p ) k *= 10 ; long m = ( long ) ( q - p ) * Library . reciprocalMod ( k % q , q ) % q ; sum += m * k + p ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = 0 NEW_LINE primes = eulerlib . list_primes ( 2000000 ) NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE q = primes [ i + 1 ] NEW_LINE if p > 1000000 : NEW_LINE INDENT break NEW_LINE DEDENT k = 1 NEW_LINE while k < p : NEW_LINE INDENT k *= 10 NEW_LINE DEDENT m = ( q - p ) * eulerlib . reciprocal_mod ( k % q , q ) % q NEW_LINE ans += m * k + p NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p133_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p133 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p133 ( ) . run ( ) ) ; } public String run ( ) { long sum = 0 ; for ( int p : Library . listPrimes ( 100000 ) ) { if ( p == 2 || p == 5 || ! hasDivisibleRepunit ( p ) ) sum += p ; } return Long . toString ( sum ) ; } private static final BigInteger EXPONENT = BigInteger . TEN . pow ( 16 ) ; private static boolean hasDivisibleRepunit ( int p ) { return ( BigInteger . TEN . modPow ( EXPONENT , BigInteger . valueOf ( p * 9 ) ) . intValue ( ) - 1 ) / 9 % p == 0 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p133 ( ) . run ( ) ) ; }"], ["hasDivisibleRepunit", "private static boolean hasDivisibleRepunit ( int p ) { return ( BigInteger . TEN . modPow ( EXPONENT , BigInteger . valueOf ( p * 9 ) ) . intValue ( ) - 1 ) / 9 % p == 0 ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int p : Library . listPrimes ( 100000 ) ) { if ( p == 2 || p == 5 || ! hasDivisibleRepunit ( p ) ) sum += p ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 100000 ) NEW_LINE ans = sum ( p for p in primes if p == 2 or p == 5 or not has_divisible_repunit ( p ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def has_divisible_repunit ( p ) : NEW_LINE INDENT return ( pow ( 10 , 10 ** 16 , p * 9 ) - 1 ) // 9 % p == 0 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT primes = eulerlib . list_primes ( 100000 ) NEW_LINE ans = sum ( p for p in primes if p == 2 or p == 5 or not has_divisible_repunit ( p ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["has_divisible_repunit", "def has_divisible_repunit ( p ) : NEW_LINE INDENT return ( pow ( 10 , 10 ** 16 , p * 9 ) - 1 ) // 9 % p == 0 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p301_A", "java": [{"id": "1", "code": "public final class p301 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p301 ( ) . run ( ) ) ; } public String run ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int c = a + b ; a = b ; b = c ; } return Integer . toString ( a ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p301 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int a = 0 ; int b = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int c = a + b ; a = b ; b = c ; } return Integer . toString ( a ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT a , b = b , a + b NEW_LINE DEDENT return str ( a ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p287_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p287 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p287 ( ) . run ( ) ) ; } private static final int N = 24 ; private static final long RADIUS_SQUARED = 1L << ( 2 * N - 2 ) ; public String run ( ) { int temp = 1 << ( N - 1 ) ; return compressedLength ( N , - temp , temp , - temp , temp ) . toString ( ) ; } private BigInteger compressedLength ( int n , int xStart , int xEnd , int yStart , int yEnd ) { assert n >= 0 ; assert xStart < xEnd && xEnd - xStart == 1 << n ; assert yStart < yEnd && yEnd - yStart == 1 << n ; int minAbsX = xStart <= 0 && 0 < xEnd ? 0 : Math . min ( Math . abs ( xStart ) , Math . abs ( xEnd - 1 ) ) ; int minAbsY = yStart <= 0 && 0 < yEnd ? 0 : Math . min ( Math . abs ( yStart ) , Math . abs ( yEnd - 1 ) ) ; int maxAbsX = Math . max ( Math . abs ( xStart ) , Math . abs ( xEnd - 1 ) ) ; int maxAbsY = Math . max ( Math . abs ( yStart ) , Math . abs ( yEnd - 1 ) ) ; long minRadius = ( long ) minAbsX * minAbsX + ( long ) minAbsY * minAbsY ; long maxRadius = ( long ) maxAbsX * maxAbsX + ( long ) maxAbsY * maxAbsY ; if ( maxRadius <= RADIUS_SQUARED || minRadius > RADIUS_SQUARED ) return BigInteger . valueOf ( 2 ) ; else { int xMid = ( xStart + xEnd ) / 2 ; int yMid = ( yStart + yEnd ) / 2 ; return BigInteger . ONE . add ( compressedLength ( n - 1 , xStart , xMid , yMid , yEnd ) ) . add ( compressedLength ( n - 1 , xMid , xEnd , yMid , yEnd ) ) . add ( compressedLength ( n - 1 , xStart , xMid , yStart , yMid ) ) . add ( compressedLength ( n - 1 , xMid , xEnd , yStart , yMid ) ) ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p287 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int temp = 1 << ( N - 1 ) ; return compressedLength ( N , - temp , temp , - temp , temp ) . toString ( ) ; }"], ["compressedLength", "private BigInteger compressedLength ( int n , int xStart , int xEnd , int yStart , int yEnd ) { assert n >= 0 ; assert xStart < xEnd && xEnd - xStart == 1 << n ; assert yStart < yEnd && yEnd - yStart == 1 << n ; int minAbsX = xStart <= 0 && 0 < xEnd ? 0 : Math . min ( Math . abs ( xStart ) , Math . abs ( xEnd - 1 ) ) ; int minAbsY = yStart <= 0 && 0 < yEnd ? 0 : Math . min ( Math . abs ( yStart ) , Math . abs ( yEnd - 1 ) ) ; int maxAbsX = Math . max ( Math . abs ( xStart ) , Math . abs ( xEnd - 1 ) ) ; int maxAbsY = Math . max ( Math . abs ( yStart ) , Math . abs ( yEnd - 1 ) ) ; long minRadius = ( long ) minAbsX * minAbsX + ( long ) minAbsY * minAbsY ; long maxRadius = ( long ) maxAbsX * maxAbsX + ( long ) maxAbsY * maxAbsY ; if ( maxRadius <= RADIUS_SQUARED || minRadius > RADIUS_SQUARED ) return BigInteger . valueOf ( 2 ) ; else { int xMid = ( xStart + xEnd ) / 2 ; int yMid = ( yStart + yEnd ) / 2 ; return BigInteger . ONE . add ( compressedLength ( n - 1 , xStart , xMid , yMid , yEnd ) ) . add ( compressedLength ( n - 1 , xMid , xEnd , yMid , yEnd ) ) . add ( compressedLength ( n - 1 , xStart , xMid , yStart , yMid ) ) . add ( compressedLength ( n - 1 , xMid , xEnd , yStart , yMid ) ) ; } }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT N = 24 NEW_LINE RADIUS_SQUARED = 2 ** ( 2 * N - 2 ) NEW_LINE def compressed_length ( xstart , xend , ystart , yend ) : NEW_LINE INDENT if xstart * xstart + ystart * ystart > RADIUS_SQUARED : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( xend - 1 ) * ( xend - 1 ) + ( yend - 1 ) * ( yend - 1 ) <= RADIUS_SQUARED : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT xmid = ( xstart + xend ) >> 1 NEW_LINE ymid = ( ystart + yend ) >> 1 NEW_LINE return ( 1 + compressed_length ( xstart , xmid , ymid , yend ) + compressed_length ( xmid , xend , ymid , yend ) + compressed_length ( xstart , xmid , ystart , ymid ) + compressed_length ( xmid , xend , ystart , ymid ) ) NEW_LINE DEDENT DEDENT temp = 2 ** ( N - 1 ) NEW_LINE return str ( 1 + compressed_length ( 0 , temp , 0 , temp ) + compressed_length ( 0 , temp , 1 , temp + 1 ) + compressed_length ( 1 , temp + 1 , 0 , temp ) + compressed_length ( 1 , temp + 1 , 1 , temp + 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT N = 24 NEW_LINE RADIUS_SQUARED = 2 ** ( 2 * N - 2 ) NEW_LINE def compressed_length ( xstart , xend , ystart , yend ) : NEW_LINE INDENT if xstart * xstart + ystart * ystart > RADIUS_SQUARED : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( xend - 1 ) * ( xend - 1 ) + ( yend - 1 ) * ( yend - 1 ) <= RADIUS_SQUARED : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT xmid = ( xstart + xend ) >> 1 NEW_LINE ymid = ( ystart + yend ) >> 1 NEW_LINE return ( 1 + compressed_length ( xstart , xmid , ymid , yend ) + compressed_length ( xmid , xend , ymid , yend ) + compressed_length ( xstart , xmid , ystart , ymid ) + compressed_length ( xmid , xend , ystart , ymid ) ) NEW_LINE DEDENT DEDENT temp = 2 ** ( N - 1 ) NEW_LINE return str ( 1 + compressed_length ( 0 , temp , 0 , temp ) + compressed_length ( 0 , temp , 1 , temp + 1 ) + compressed_length ( 1 , temp + 1 , 0 , temp ) + compressed_length ( 1 , temp + 1 , 1 , temp + 1 ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p041_A", "java": [{"id": "1", "code": "public final class p041 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p041 ( ) . run ( ) ) ; } public String run ( ) { for ( int n = 9 ; n >= 1 ; n -- ) { int [ ] digits = new int [ n ] ; for ( int i = 0 ; i < digits . length ; i ++ ) digits [ i ] = i + 1 ; int result = - 1 ; do { if ( Library . isPrime ( toInteger ( digits ) ) ) result = toInteger ( digits ) ; } while ( Library . nextPermutation ( digits ) ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } throw new RuntimeException ( \" Not \u2581 found \" ) ; } private static int toInteger ( int [ ] digits ) { int result = 0 ; for ( int x : digits ) result = result * 10 + x ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p041 ( ) . run ( ) ) ; }"], ["toInteger", "private static int toInteger ( int [ ] digits ) { int result = 0 ; for ( int x : digits ) result = result * 10 + x ; return result ; }"]], "functions_class": [["run", "public String run ( ) { for ( int n = 9 ; n >= 1 ; n -- ) { int [ ] digits = new int [ n ] ; for ( int i = 0 ; i < digits . length ; i ++ ) digits [ i ] = i + 1 ; int result = - 1 ; do { if ( Library . isPrime ( toInteger ( digits ) ) ) result = toInteger ( digits ) ; } while ( Library . nextPermutation ( digits ) ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } throw new RuntimeException ( \" Not \u2581 found \" ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT for n in reversed ( range ( 2 , 10 ) ) : NEW_LINE INDENT arr = list ( reversed ( range ( 1 , n + 1 ) ) ) NEW_LINE while True : NEW_LINE INDENT if arr [ - 1 ] not in NONPRIME_LAST_DIGITS : NEW_LINE INDENT n = int ( \" \" . join ( str ( x ) for x in arr ) ) NEW_LINE if eulerlib . is_prime ( n ) : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT if not prev_permutation ( arr ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT raise AssertionError ( ) NEW_LINE DEDENT NONPRIME_LAST_DIGITS = { 0 , 2 , 4 , 5 , 6 , 8 } NEW_LINE def prev_permutation ( arr ) : NEW_LINE INDENT i = len ( arr ) - 1 NEW_LINE while i > 0 and arr [ i - 1 ] <= arr [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT j = len ( arr ) - 1 NEW_LINE while arr [ j ] >= arr [ i - 1 ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT arr [ i - 1 ] , arr [ j ] = arr [ j ] , arr [ i - 1 ] NEW_LINE arr [ i : ] = arr [ len ( arr ) - 1 : i - 1 : - 1 ] NEW_LINE return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT for n in reversed ( range ( 2 , 10 ) ) : NEW_LINE INDENT arr = list ( reversed ( range ( 1 , n + 1 ) ) ) NEW_LINE while True : NEW_LINE INDENT if arr [ - 1 ] not in NONPRIME_LAST_DIGITS : NEW_LINE INDENT n = int ( \" \" . join ( str ( x ) for x in arr ) ) NEW_LINE if eulerlib . is_prime ( n ) : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT if not prev_permutation ( arr ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT raise AssertionError ( ) NEW_LINE DEDENT"], ["prev_permutation", "def prev_permutation ( arr ) : NEW_LINE INDENT i = len ( arr ) - 1 NEW_LINE while i > 0 and arr [ i - 1 ] <= arr [ i ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT j = len ( arr ) - 1 NEW_LINE while arr [ j ] >= arr [ i - 1 ] : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT arr [ i - 1 ] , arr [ j ] = arr [ j ] , arr [ i - 1 ] NEW_LINE arr [ i : ] = arr [ len ( arr ) - 1 : i - 1 : - 1 ] NEW_LINE return True NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p046_A", "java": [{"id": "1", "code": "public final class p046 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p046 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 9 ; ; i += 2 ) { if ( ! satisfiesConjecture ( i ) ) return Integer . toString ( i ) ; } } private static boolean satisfiesConjecture ( int n ) { if ( n % 2 == 0 || Library . isPrime ( n ) ) return true ; for ( int i = 1 ; i * i * 2 <= n ; i ++ ) { if ( Library . isPrime ( n - i * i * 2 ) ) return true ; } return false ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p046 ( ) . run ( ) ) ; }"], ["satisfiesConjecture", "private static boolean satisfiesConjecture ( int n ) { if ( n % 2 == 0 || Library . isPrime ( n ) ) return true ; for ( int i = 1 ; i * i * 2 <= n ; i ++ ) { if ( Library . isPrime ( n - i * i * 2 ) ) return true ; } return false ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 9 ; ; i += 2 ) { if ( ! satisfiesConjecture ( i ) ) return Integer . toString ( i ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = next ( itertools . filterfalse ( test_goldbach , itertools . count ( 9 , 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def test_goldbach ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in itertools . count ( 1 ) : NEW_LINE INDENT k = n - 2 * i * i NEW_LINE if k <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif eulerlib . is_prime ( k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = next ( itertools . filterfalse ( test_goldbach , itertools . count ( 9 , 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["test_goldbach", "def test_goldbach ( n ) : NEW_LINE INDENT if n % 2 == 0 or eulerlib . is_prime ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in itertools . count ( 1 ) : NEW_LINE INDENT k = n - 2 * i * i NEW_LINE if k <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT elif eulerlib . is_prime ( k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p070_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p070 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p070 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 7 ) ; public String run ( ) { int minNumer = 1 ; int minDenom = 0 ; int [ ] totients = Library . listTotients ( LIMIT - 1 ) ; for ( int n = 2 ; n < totients . length ; n ++ ) { int tot = totients [ n ] ; if ( ( long ) n * minDenom < ( long ) minNumer * tot && hasSameDigits ( n , tot ) ) { minNumer = n ; minDenom = tot ; } } if ( minDenom == 0 ) throw new RuntimeException ( \" Not \u2581 found \" ) ; return Integer . toString ( minNumer ) ; } private static boolean hasSameDigits ( int x , int y ) { char [ ] xdigits = Integer . toString ( x ) . toCharArray ( ) ; char [ ] ydigits = Integer . toString ( y ) . toCharArray ( ) ; Arrays . sort ( xdigits ) ; Arrays . sort ( ydigits ) ; return Arrays . equals ( xdigits , ydigits ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p070 ( ) . run ( ) ) ; }"], ["hasSameDigits", "private static boolean hasSameDigits ( int x , int y ) { char [ ] xdigits = Integer . toString ( x ) . toCharArray ( ) ; char [ ] ydigits = Integer . toString ( y ) . toCharArray ( ) ; Arrays . sort ( xdigits ) ; Arrays . sort ( ydigits ) ; return Arrays . equals ( xdigits , ydigits ) ; }"]], "functions_class": [["run", "public String run ( ) { int minNumer = 1 ; int minDenom = 0 ; int [ ] totients = Library . listTotients ( LIMIT - 1 ) ; for ( int n = 2 ; n < totients . length ; n ++ ) { int tot = totients [ n ] ; if ( ( long ) n * minDenom < ( long ) minNumer * tot && hasSameDigits ( n , tot ) ) { minNumer = n ; minDenom = tot ; } } if ( minDenom == 0 ) throw new RuntimeException ( \" Not \u2581 found \" ) ; return Integer . toString ( minNumer ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 7 - 1 ) NEW_LINE minnumer = 1 NEW_LINE mindenom = 0 NEW_LINE for ( i , tot ) in enumerate ( totients [ 2 : ] , 2 ) : NEW_LINE INDENT if i * mindenom < minnumer * tot and sorted ( str ( i ) ) == sorted ( str ( tot ) ) : NEW_LINE INDENT minnumer = i NEW_LINE mindenom = totients [ i ] NEW_LINE DEDENT DEDENT return str ( minnumer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT totients = eulerlib . list_totients ( 10 ** 7 - 1 ) NEW_LINE minnumer = 1 NEW_LINE mindenom = 0 NEW_LINE for ( i , tot ) in enumerate ( totients [ 2 : ] , 2 ) : NEW_LINE INDENT if i * mindenom < minnumer * tot and sorted ( str ( i ) ) == sorted ( str ( tot ) ) : NEW_LINE INDENT minnumer = i NEW_LINE mindenom = totients [ i ] NEW_LINE DEDENT DEDENT return str ( minnumer ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p077_A", "java": [{"id": "1", "code": "public final class p077 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p077 ( ) . run ( ) ) ; } private static final int TARGET = 5000 ; public String run ( ) { for ( int limit = 1 ; ; limit *= 2 ) { int result = search ( limit , TARGET ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } } private static int search ( int limit , int target ) { int [ ] partitions = new int [ limit ] ; partitions [ 0 ] = 1 ; for ( int i = 0 ; i < partitions . length ; i ++ ) { if ( ! Library . isPrime ( i ) ) continue ; for ( int j = i ; j < partitions . length ; j ++ ) partitions [ j ] += partitions [ j - i ] ; } for ( int i = 0 ; i < limit ; i ++ ) { if ( partitions [ i ] > target ) return i ; } return - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p077 ( ) . run ( ) ) ; }"], ["search", "private static int search ( int limit , int target ) { int [ ] partitions = new int [ limit ] ; partitions [ 0 ] = 1 ; for ( int i = 0 ; i < partitions . length ; i ++ ) { if ( ! Library . isPrime ( i ) ) continue ; for ( int j = i ; j < partitions . length ; j ++ ) partitions [ j ] += partitions [ j - i ] ; } for ( int i = 0 ; i < limit ; i ++ ) { if ( partitions [ i ] > target ) return i ; } return - 1 ; }"]], "functions_class": [["run", "public String run ( ) { for ( int limit = 1 ; ; limit *= 2 ) { int result = search ( limit , TARGET ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda n : num_prime_sum_ways ( n ) > 5000 NEW_LINE ans = next ( filter ( cond , itertools . count ( 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT primes = [ 2 ] NEW_LINE def num_prime_sum_ways ( n ) : NEW_LINE INDENT for i in range ( primes [ - 1 ] + 1 , n + 1 ) : NEW_LINE INDENT if eulerlib . is_prime ( i ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT ways = [ 1 ] + [ 0 ] * n NEW_LINE for p in primes : NEW_LINE INDENT for i in range ( n + 1 - p ) : NEW_LINE INDENT ways [ i + p ] += ways [ i ] NEW_LINE DEDENT DEDENT return ways [ n ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT cond = lambda n : num_prime_sum_ways ( n ) > 5000 NEW_LINE ans = next ( filter ( cond , itertools . count ( 2 ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["num_prime_sum_ways", "def num_prime_sum_ways ( n ) : NEW_LINE INDENT for i in range ( primes [ - 1 ] + 1 , n + 1 ) : NEW_LINE INDENT if eulerlib . is_prime ( i ) : NEW_LINE INDENT primes . append ( i ) NEW_LINE DEDENT DEDENT ways = [ 1 ] + [ 0 ] * n NEW_LINE for p in primes : NEW_LINE INDENT for i in range ( n + 1 - p ) : NEW_LINE INDENT ways [ i + p ] += ways [ i ] NEW_LINE DEDENT DEDENT return ways [ n ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p048_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p048 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p048 ( ) . run ( ) ) ; } public String run ( ) { BigInteger modulus = BigInteger . TEN . pow ( 10 ) ; BigInteger sum = BigInteger . ZERO ; for ( int i = 1 ; i <= 1000 ; i ++ ) sum = sum . add ( BigInteger . valueOf ( i ) . modPow ( BigInteger . valueOf ( i ) , modulus ) ) ; return sum . mod ( modulus ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p048 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger modulus = BigInteger . TEN . pow ( 10 ) ; BigInteger sum = BigInteger . ZERO ; for ( int i = 1 ; i <= 1000 ; i ++ ) sum = sum . add ( BigInteger . valueOf ( i ) . modPow ( BigInteger . valueOf ( i ) , modulus ) ) ; return sum . mod ( modulus ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = sum ( pow ( i , i , MOD ) for i in range ( 1 , 1001 ) ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p211_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p211 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p211 ( ) . run ( ) ) ; } private static final int LIMIT = 64000000 ; public String run ( ) { long [ ] sigma2 = new long [ LIMIT ] ; Arrays . fill ( sigma2 , 1 , sigma2 . length , 1 ) ; for ( int i = 2 ; i < sigma2 . length ; i ++ ) { if ( sigma2 [ i ] == 1 ) { for ( int j = i ; j < sigma2 . length ; j += i ) sigma2 [ j ] *= powerSquareSum ( j , i ) ; } } long sum = 0 ; SquareTester sqt = new SquareTester ( 3 * 5 * 7 * 11 * 13 * 17 ) ; for ( int i = 1 ; i < sigma2 . length ; i ++ ) { if ( sqt . isPerfectSquare ( sigma2 [ i ] ) ) sum += i ; } return Long . toString ( sum ) ; } private static long powerSquareSum ( int n , int k ) { long result = 1 ; long k2 = ( long ) k * k ; while ( n % k == 0 ) { n /= k ; result = result * k2 + 1 ; } return result ; } private static final class SquareTester { private boolean [ ] isResidue ; public SquareTester ( int modulus ) { if ( modulus < 1 ) throw new IllegalArgumentException ( ) ; isResidue = new boolean [ modulus ] ; for ( int i = 0 ; i < modulus ; i ++ ) isResidue [ ( int ) ( ( long ) i * i % modulus ) ] = true ; } public boolean isPerfectSquare ( long x ) { if ( ! isResidue [ ( int ) ( x % isResidue . length ) ] ) return false ; long y = 0 ; for ( long i = 1L << 31 ; i != 0 ; i >>>= 1 ) { y |= i ; if ( y > 3037000499L || y * y > x ) y ^= i ; } return y * y == x ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p211 ( ) . run ( ) ) ; }"], ["powerSquareSum", "private static long powerSquareSum ( int n , int k ) { long result = 1 ; long k2 = ( long ) k * k ; while ( n % k == 0 ) { n /= k ; result = result * k2 + 1 ; } return result ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] sigma2 = new long [ LIMIT ] ; Arrays . fill ( sigma2 , 1 , sigma2 . length , 1 ) ; for ( int i = 2 ; i < sigma2 . length ; i ++ ) { if ( sigma2 [ i ] == 1 ) { for ( int j = i ; j < sigma2 . length ; j += i ) sigma2 [ j ] *= powerSquareSum ( j , i ) ; } } long sum = 0 ; SquareTester sqt = new SquareTester ( 3 * 5 * 7 * 11 * 13 * 17 ) ; for ( int i = 1 ; i < sigma2 . length ; i ++ ) { if ( sqt . isPerfectSquare ( sigma2 [ i ] ) ) sum += i ; } return Long . toString ( sum ) ; }"], ["SquareTester", "public SquareTester ( int modulus ) { if ( modulus < 1 ) throw new IllegalArgumentException ( ) ; isResidue = new boolean [ modulus ] ; for ( int i = 0 ; i < modulus ; i ++ ) isResidue [ ( int ) ( ( long ) i * i % modulus ) ] = true ; }"], ["isPerfectSquare", "public boolean isPerfectSquare ( long x ) { if ( ! isResidue [ ( int ) ( x % isResidue . length ) ] ) return false ; long y = 0 ; for ( long i = 1L << 31 ; i != 0 ; i >>>= 1 ) { y |= i ; if ( y > 3037000499L || y * y > x ) y ^= i ; } return y * y == x ; }"]]}], "python": [{"id": "2", "code": "import array , eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 64000000 NEW_LINE RESIDUE_TEST = 3 * 5 * 7 * 11 * 13 NEW_LINE isresidue = [ False ] * RESIDUE_TEST NEW_LINE for i in range ( RESIDUE_TEST ) : NEW_LINE INDENT isresidue [ i * i % RESIDUE_TEST ] = True NEW_LINE DEDENT def is_perfect_square ( x ) : NEW_LINE INDENT return isresidue [ x % RESIDUE_TEST ] and eulerlib . is_square ( x ) NEW_LINE DEDENT sigma2 = list_sigma2 ( LIMIT - 1 ) NEW_LINE ans = sum ( i for i in range ( 1 , LIMIT ) if is_perfect_square ( sigma2 [ i ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def list_sigma2 ( n ) : NEW_LINE INDENT sqrt = eulerlib . sqrt ( n ) NEW_LINE quasiprimefactor = array . array ( \" H \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE for i in range ( 2 , sqrt + 1 ) : NEW_LINE INDENT if quasiprimefactor [ i ] == 0 : NEW_LINE INDENT quasiprimefactor [ i ] = i NEW_LINE for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT if quasiprimefactor [ j ] == 0 : NEW_LINE INDENT quasiprimefactor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT sigma2 = array . array ( \" Q \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE sigma2 [ 1 ] = 1 NEW_LINE for i in range ( 2 , len ( sigma2 ) ) : NEW_LINE INDENT p = quasiprimefactor [ i ] NEW_LINE if p == 0 : NEW_LINE INDENT p = i NEW_LINE DEDENT sum = 1 NEW_LINE j = i NEW_LINE p2 = p * p NEW_LINE k = p2 NEW_LINE while j % p == 0 : NEW_LINE INDENT sum += k NEW_LINE j //= p NEW_LINE k *= p2 NEW_LINE DEDENT sigma2 [ i ] = sum * sigma2 [ j ] NEW_LINE DEDENT return sigma2 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 64000000 NEW_LINE RESIDUE_TEST = 3 * 5 * 7 * 11 * 13 NEW_LINE isresidue = [ False ] * RESIDUE_TEST NEW_LINE for i in range ( RESIDUE_TEST ) : NEW_LINE INDENT isresidue [ i * i % RESIDUE_TEST ] = True NEW_LINE DEDENT def is_perfect_square ( x ) : NEW_LINE INDENT return isresidue [ x % RESIDUE_TEST ] and eulerlib . is_square ( x ) NEW_LINE DEDENT sigma2 = list_sigma2 ( LIMIT - 1 ) NEW_LINE ans = sum ( i for i in range ( 1 , LIMIT ) if is_perfect_square ( sigma2 [ i ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["list_sigma2", "def list_sigma2 ( n ) : NEW_LINE INDENT sqrt = eulerlib . sqrt ( n ) NEW_LINE quasiprimefactor = array . array ( \" H \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE for i in range ( 2 , sqrt + 1 ) : NEW_LINE INDENT if quasiprimefactor [ i ] == 0 : NEW_LINE INDENT quasiprimefactor [ i ] = i NEW_LINE for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT if quasiprimefactor [ j ] == 0 : NEW_LINE INDENT quasiprimefactor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT sigma2 = array . array ( \" Q \" , ( 0 for _ in range ( n + 1 ) ) ) NEW_LINE sigma2 [ 1 ] = 1 NEW_LINE for i in range ( 2 , len ( sigma2 ) ) : NEW_LINE INDENT p = quasiprimefactor [ i ] NEW_LINE if p == 0 : NEW_LINE INDENT p = i NEW_LINE DEDENT sum = 1 NEW_LINE j = i NEW_LINE p2 = p * p NEW_LINE k = p2 NEW_LINE while j % p == 0 : NEW_LINE INDENT sum += k NEW_LINE j //= p NEW_LINE k *= p2 NEW_LINE DEDENT sigma2 [ i ] = sum * sigma2 [ j ] NEW_LINE DEDENT return sigma2 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p023_A", "java": [{"id": "1", "code": "public final class p023 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p023 ( ) . run ( ) ) ; } private static final int LIMIT = 28123 ; private boolean [ ] isAbundant = new boolean [ LIMIT + 1 ] ; public String run ( ) { for ( int i = 1 ; i < isAbundant . length ; i ++ ) isAbundant [ i ] = isAbundant ( i ) ; int sum = 0 ; for ( int i = 1 ; i <= LIMIT ; i ++ ) { if ( ! isSumOf2Abundants ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private boolean isSumOf2Abundants ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( isAbundant [ i ] && isAbundant [ n - i ] ) return true ; } return false ; } private static boolean isAbundant ( int n ) { if ( n < 1 ) throw new IllegalArgumentException ( ) ; int sum = 1 ; int end = Library . sqrt ( n ) ; for ( int i = 2 ; i <= end ; i ++ ) { if ( n % i == 0 ) sum += i + n / i ; } if ( end * end == n ) sum -= end ; return sum > n ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p023 ( ) . run ( ) ) ; }"], ["isAbundant", "private static boolean isAbundant ( int n ) { if ( n < 1 ) throw new IllegalArgumentException ( ) ; int sum = 1 ; int end = Library . sqrt ( n ) ; for ( int i = 2 ; i <= end ; i ++ ) { if ( n % i == 0 ) sum += i + n / i ; } if ( end * end == n ) sum -= end ; return sum > n ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 1 ; i < isAbundant . length ; i ++ ) isAbundant [ i ] = isAbundant ( i ) ; int sum = 0 ; for ( int i = 1 ; i <= LIMIT ; i ++ ) { if ( ! isSumOf2Abundants ( i ) ) sum += i ; } return Integer . toString ( sum ) ; }"], ["isSumOf2Abundants", "private boolean isSumOf2Abundants ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( isAbundant [ i ] && isAbundant [ n - i ] ) return true ; } return false ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 28124 NEW_LINE divisorsum = [ 0 ] * LIMIT NEW_LINE for i in range ( 1 , LIMIT ) : NEW_LINE INDENT for j in range ( i * 2 , LIMIT , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT abundantnums = [ i for ( i , x ) in enumerate ( divisorsum ) if x > i ] NEW_LINE expressible = [ False ] * LIMIT NEW_LINE for i in abundantnums : NEW_LINE INDENT for j in abundantnums : NEW_LINE INDENT if i + j < LIMIT : NEW_LINE INDENT expressible [ i + j ] = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT ans = sum ( i for ( i , x ) in enumerate ( expressible ) if not x ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 28124 NEW_LINE divisorsum = [ 0 ] * LIMIT NEW_LINE for i in range ( 1 , LIMIT ) : NEW_LINE INDENT for j in range ( i * 2 , LIMIT , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT abundantnums = [ i for ( i , x ) in enumerate ( divisorsum ) if x > i ] NEW_LINE expressible = [ False ] * LIMIT NEW_LINE for i in abundantnums : NEW_LINE INDENT for j in abundantnums : NEW_LINE INDENT if i + j < LIMIT : NEW_LINE INDENT expressible [ i + j ] = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT ans = sum ( i for ( i , x ) in enumerate ( expressible ) if not x ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p024_A", "java": [{"id": "1", "code": "public final class p024 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p024 ( ) . run ( ) ) ; } public String run ( ) { int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] = i ; for ( int i = 0 ; i < 999999 ; i ++ ) { if ( ! Library . nextPermutation ( array ) ) throw new AssertionError ( ) ; } String ans = \" \" ; for ( int i = 0 ; i < array . length ; i ++ ) ans += array [ i ] ; return ans ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p024 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] array = new int [ 10 ] ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] = i ; for ( int i = 0 ; i < 999999 ; i ++ ) { if ( ! Library . nextPermutation ( array ) ) throw new AssertionError ( ) ; } String ans = \" \" ; for ( int i = 0 ; i < array . length ; i ++ ) ans += array [ i ] ; return ans ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT arr = list ( range ( 10 ) ) NEW_LINE temp = itertools . islice ( itertools . permutations ( arr ) , 999999 , None ) NEW_LINE return \" \" . join ( str ( x ) for x in next ( temp ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT arr = list ( range ( 10 ) ) NEW_LINE temp = itertools . islice ( itertools . permutations ( arr ) , 999999 , None ) NEW_LINE return \" \" . join ( str ( x ) for x in next ( temp ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p216_A", "java": [{"id": "1", "code": "public final class p216 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p216 ( ) . run ( ) ) ; } private static final int LIMIT = 50000000 ; public String run ( ) { long [ ] sequence = new long [ LIMIT + 1 ] ; sequence [ 0 ] = sequence [ 1 ] = - 1 ; for ( int i = 2 ; i < sequence . length ; i ++ ) sequence [ i ] = 2L * i * i - 1 ; int count = 0 ; for ( int i = 2 ; i < sequence . length ; i ++ ) { long term = sequence [ i ] ; if ( term == 2L * i * i - 1 ) count ++ ; if ( 1 < term && term <= LIMIT * 2 ) { int p = ( int ) term ; for ( int j = i + p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } for ( int j = i + ( p - i ) * 2 % p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } } } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p216 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] sequence = new long [ LIMIT + 1 ] ; sequence [ 0 ] = sequence [ 1 ] = - 1 ; for ( int i = 2 ; i < sequence . length ; i ++ ) sequence [ i ] = 2L * i * i - 1 ; int count = 0 ; for ( int i = 2 ; i < sequence . length ; i ++ ) { long term = sequence [ i ] ; if ( term == 2L * i * i - 1 ) count ++ ; if ( 1 < term && term <= LIMIT * 2 ) { int p = ( int ) term ; for ( int j = i + p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } for ( int j = i + ( p - i ) * 2 % p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE sequence = [ ( 2 * i * i - 1 ) for i in range ( LIMIT + 1 ) ] NEW_LINE sequence [ 0 ] = sequence [ 1 ] = - 1 NEW_LINE ans = 0 NEW_LINE for ( i , term ) in enumerate ( sequence ) : NEW_LINE INDENT if i < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if term == 2 * i * i - 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if 1 < term <= LIMIT * 2 : NEW_LINE INDENT p = term NEW_LINE for j in range ( i + p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for j in range ( i + ( p - i ) * 2 % p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE sequence = [ ( 2 * i * i - 1 ) for i in range ( LIMIT + 1 ) ] NEW_LINE sequence [ 0 ] = sequence [ 1 ] = - 1 NEW_LINE ans = 0 NEW_LINE for ( i , term ) in enumerate ( sequence ) : NEW_LINE INDENT if i < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if term == 2 * i * i - 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if 1 < term <= LIMIT * 2 : NEW_LINE INDENT p = term NEW_LINE for j in range ( i + p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for j in range ( i + ( p - i ) * 2 % p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p012_A", "java": [{"id": "1", "code": "public final class p012 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p012 ( ) . run ( ) ) ; } public String run ( ) { int triangle = 0 ; for ( int i = 1 ; ; i ++ ) { if ( Integer . MAX_VALUE - triangle < i ) throw new ArithmeticException ( \" Overflow \" ) ; triangle += i ; if ( countDivisors ( triangle ) > 500 ) return Integer . toString ( triangle ) ; } } private static int countDivisors ( int n ) { int count = 0 ; int end = Library . sqrt ( n ) ; for ( int i = 1 ; i < end ; i ++ ) { if ( n % i == 0 ) count += 2 ; } if ( end * end == n ) count ++ ; return count ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p012 ( ) . run ( ) ) ; }"], ["countDivisors", "private static int countDivisors ( int n ) { int count = 0 ; int end = Library . sqrt ( n ) ; for ( int i = 1 ; i < end ; i ++ ) { if ( n % i == 0 ) count += 2 ; } if ( end * end == n ) count ++ ; return count ; }"]], "functions_class": [["run", "public String run ( ) { int triangle = 0 ; for ( int i = 1 ; ; i ++ ) { if ( Integer . MAX_VALUE - triangle < i ) throw new ArithmeticException ( \" Overflow \" ) ; triangle += i ; if ( countDivisors ( triangle ) > 500 ) return Integer . toString ( triangle ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT triangle += i NEW_LINE if num_divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT def num_divisors ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE result = sum ( 2 for i in range ( 1 , end + 1 ) if n % i == 0 ) NEW_LINE if end ** 2 == n : NEW_LINE INDENT result -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT triangle = 0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT triangle += i NEW_LINE if num_divisors ( triangle ) > 500 : NEW_LINE INDENT return str ( triangle ) NEW_LINE DEDENT DEDENT DEDENT"], ["num_divisors", "def num_divisors ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE result = sum ( 2 for i in range ( 1 , end + 1 ) if n % i == 0 ) NEW_LINE if end ** 2 == n : NEW_LINE INDENT result -= 1 NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p218_A", "java": [{"id": "1", "code": "public final class p218 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p218 ( ) . run ( ) ) ; } public String run ( ) { return \"0\" ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p218 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { return \"0\" ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT return \"0\" NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p015_A", "java": [{"id": "1", "code": "public final class p015 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p015 ( ) . run ( ) ) ; } public String run ( ) { return Library . binomial ( 40 , 20 ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p015 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { return Library . binomial ( 40 , 20 ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT return str ( eulerlib . binomial ( 40 , 20 ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p076_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p076 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p076 ( ) . run ( ) ) ; } public String run ( ) { return partitions ( 100 , 1 ) . subtract ( BigInteger . ONE ) . toString ( ) ; } private static BigInteger partitions ( int n , int k ) { BigInteger [ ] [ ] table = new BigInteger [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = n ; j >= 0 ; j -- ) { if ( j == i ) table [ i ] [ j ] = BigInteger . ONE ; else if ( j > i ) table [ i ] [ j ] = BigInteger . ZERO ; else if ( j == 0 ) table [ i ] [ j ] = table [ i ] [ j + 1 ] ; else table [ i ] [ j ] = table [ i ] [ j + 1 ] . add ( table [ i - j ] [ j ] ) ; } } return table [ n ] [ k ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p076 ( ) . run ( ) ) ; }"], ["partitions", "private static BigInteger partitions ( int n , int k ) { BigInteger [ ] [ ] table = new BigInteger [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = n ; j >= 0 ; j -- ) { if ( j == i ) table [ i ] [ j ] = BigInteger . ONE ; else if ( j > i ) table [ i ] [ j ] = BigInteger . ZERO ; else if ( j == 0 ) table [ i ] [ j ] = table [ i ] [ j + 1 ] ; else table [ i ] [ j ] = table [ i ] [ j + 1 ] . add ( table [ i - j ] [ j ] ) ; } } return table [ n ] [ k ] ; }"]], "functions_class": [["run", "public String run ( ) { return partitions ( 100 , 1 ) . subtract ( BigInteger . ONE ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 100 NEW_LINE partitions = [ ] NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT partitions . append ( [ None ] * ( LIMIT + 1 ) ) NEW_LINE for j in reversed ( range ( LIMIT + 1 ) ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT val = 1 NEW_LINE DEDENT elif j > i : NEW_LINE INDENT val = 0 NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT val = partitions [ i ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT val = partitions [ i ] [ j + 1 ] + partitions [ i - j ] [ j ] NEW_LINE DEDENT partitions [ i ] [ j ] = val NEW_LINE DEDENT DEDENT ans = partitions [ LIMIT ] [ 1 ] - 1 NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 100 NEW_LINE partitions = [ ] NEW_LINE for i in range ( LIMIT + 1 ) : NEW_LINE INDENT partitions . append ( [ None ] * ( LIMIT + 1 ) ) NEW_LINE for j in reversed ( range ( LIMIT + 1 ) ) : NEW_LINE INDENT if j == i : NEW_LINE INDENT val = 1 NEW_LINE DEDENT elif j > i : NEW_LINE INDENT val = 0 NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT val = partitions [ i ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT val = partitions [ i ] [ j + 1 ] + partitions [ i - j ] [ j ] NEW_LINE DEDENT partitions [ i ] [ j ] = val NEW_LINE DEDENT DEDENT ans = partitions [ LIMIT ] [ 1 ] - 1 NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p049_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p049 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p049 ( ) . run ( ) ) ; } private static final int LIMIT = 10000 ; public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT - 1 ) ; for ( int base = 1000 ; base < LIMIT ; base ++ ) { if ( isPrime [ base ] ) { for ( int step = 1 ; step < LIMIT ; step ++ ) { int a = base + step ; int b = a + step ; if ( a < LIMIT && isPrime [ a ] && hasSameDigits ( a , base ) && b < LIMIT && isPrime [ b ] && hasSameDigits ( b , base ) && ( base != 1487 || a != 4817 ) ) return \" \" + base + a + b ; } } } throw new RuntimeException ( \" Not \u2581 found \" ) ; } private static boolean hasSameDigits ( int x , int y ) { char [ ] xdigits = Integer . toString ( x ) . toCharArray ( ) ; char [ ] ydigits = Integer . toString ( y ) . toCharArray ( ) ; Arrays . sort ( xdigits ) ; Arrays . sort ( ydigits ) ; return Arrays . equals ( xdigits , ydigits ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p049 ( ) . run ( ) ) ; }"], ["hasSameDigits", "private static boolean hasSameDigits ( int x , int y ) { char [ ] xdigits = Integer . toString ( x ) . toCharArray ( ) ; char [ ] ydigits = Integer . toString ( y ) . toCharArray ( ) ; Arrays . sort ( xdigits ) ; Arrays . sort ( ydigits ) ; return Arrays . equals ( xdigits , ydigits ) ; }"]], "functions_class": [["run", "public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( LIMIT - 1 ) ; for ( int base = 1000 ; base < LIMIT ; base ++ ) { if ( isPrime [ base ] ) { for ( int step = 1 ; step < LIMIT ; step ++ ) { int a = base + step ; int b = a + step ; if ( a < LIMIT && isPrime [ a ] && hasSameDigits ( a , base ) && b < LIMIT && isPrime [ b ] && hasSameDigits ( b , base ) && ( base != 1487 || a != 4817 ) ) return \" \" + base + a + b ; } } } throw new RuntimeException ( \" Not \u2581 found \" ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for base in range ( 1000 , LIMIT ) : NEW_LINE INDENT if isprime [ base ] : NEW_LINE INDENT for step in range ( 1 , LIMIT ) : NEW_LINE INDENT a = base + step NEW_LINE b = a + step NEW_LINE if a < LIMIT and isprime [ a ] and has_same_digits ( a , base ) and b < LIMIT and isprime [ b ] and has_same_digits ( b , base ) and ( base != 1487 or a != 4817 ) : NEW_LINE INDENT return str ( base ) + str ( a ) + str ( b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT raise RuntimeError ( \" Not \u2581 found \" ) NEW_LINE DEDENT def has_same_digits ( x , y ) : NEW_LINE INDENT return sorted ( str ( x ) ) == sorted ( str ( y ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10000 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for base in range ( 1000 , LIMIT ) : NEW_LINE INDENT if isprime [ base ] : NEW_LINE INDENT for step in range ( 1 , LIMIT ) : NEW_LINE INDENT a = base + step NEW_LINE b = a + step NEW_LINE if a < LIMIT and isprime [ a ] and has_same_digits ( a , base ) and b < LIMIT and isprime [ b ] and has_same_digits ( b , base ) and ( base != 1487 or a != 4817 ) : NEW_LINE INDENT return str ( base ) + str ( a ) + str ( b ) NEW_LINE DEDENT DEDENT DEDENT DEDENT raise RuntimeError ( \" Not \u2581 found \" ) NEW_LINE DEDENT"], ["has_same_digits", "def has_same_digits ( x , y ) : NEW_LINE INDENT return sorted ( str ( x ) ) == sorted ( str ( y ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p085_A", "java": [{"id": "1", "code": "public final class p085 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p085 ( ) . run ( ) ) ; } private static final int TARGET = 2000000 ; public String run ( ) { int bestDiff = Integer . MAX_VALUE ; int bestArea = - 1 ; int sqrt = Library . sqrt ( TARGET ) ; for ( int w = 1 ; w <= sqrt ; w ++ ) { for ( int h = 1 ; h <= sqrt ; h ++ ) { int diff = Math . abs ( numberOfRectangles ( w , h ) - TARGET ) ; if ( diff < bestDiff ) { bestDiff = diff ; bestArea = w * h ; } } } return Integer . toString ( bestArea ) ; } private static int numberOfRectangles ( int m , int n ) { return ( m + 1 ) * m * ( n + 1 ) * n / 4 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p085 ( ) . run ( ) ) ; }"], ["numberOfRectangles", "private static int numberOfRectangles ( int m , int n ) { return ( m + 1 ) * m * ( n + 1 ) * n / 4 ; }"]], "functions_class": [["run", "public String run ( ) { int bestDiff = Integer . MAX_VALUE ; int bestArea = - 1 ; int sqrt = Library . sqrt ( TARGET ) ; for ( int w = 1 ; w <= sqrt ; w ++ ) { for ( int h = 1 ; h <= sqrt ; h ++ ) { int diff = Math . abs ( numberOfRectangles ( w , h ) - TARGET ) ; if ( diff < bestDiff ) { bestDiff = diff ; bestArea = w * h ; } } } return Integer . toString ( bestArea ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 2000000 NEW_LINE end = eulerlib . sqrt ( TARGET ) + 1 NEW_LINE gen = ( ( w , h ) for w in range ( 1 , end ) for h in range ( 1 , end ) ) NEW_LINE func = lambda wh : abs ( num_rectangles ( * wh ) - TARGET ) NEW_LINE ans = min ( gen , key = func ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT def num_rectangles ( m , n ) : NEW_LINE INDENT return ( m + 1 ) * m * ( n + 1 ) * n // 4 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TARGET = 2000000 NEW_LINE end = eulerlib . sqrt ( TARGET ) + 1 NEW_LINE gen = ( ( w , h ) for w in range ( 1 , end ) for h in range ( 1 , end ) ) NEW_LINE func = lambda wh : abs ( num_rectangles ( * wh ) - TARGET ) NEW_LINE ans = min ( gen , key = func ) NEW_LINE return str ( ans [ 0 ] * ans [ 1 ] ) NEW_LINE DEDENT"], ["num_rectangles", "def num_rectangles ( m , n ) : NEW_LINE INDENT return ( m + 1 ) * m * ( n + 1 ) * n // 4 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p071_A", "java": [{"id": "1", "code": "public final class p071 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p071 ( ) . run ( ) ) ; } private static final int LIMIT = 1000000 ; public String run ( ) { int maxN = 0 ; int maxD = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) n -- ; if ( ( long ) n * maxD > ( long ) maxN * d ) { maxN = n ; maxD = d ; } } return Integer . toString ( maxN ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p071 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int maxN = 0 ; int maxD = 1 ; for ( int d = 1 ; d <= LIMIT ; d ++ ) { int n = d * 3 / 7 ; if ( d % 7 == 0 ) n -- ; if ( ( long ) n * maxD > ( long ) maxN * d ) { maxN = n ; maxD = d ; } } return Integer . toString ( maxN ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE maxnumer = 0 NEW_LINE maxdenom = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * maxdenom > d * maxnumer : NEW_LINE INDENT maxnumer = n NEW_LINE maxdenom = d NEW_LINE DEDENT DEDENT return str ( maxnumer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 1000000 NEW_LINE maxnumer = 0 NEW_LINE maxdenom = 1 NEW_LINE for d in range ( 1 , LIMIT + 1 ) : NEW_LINE INDENT n = d * 3 // 7 NEW_LINE if d % 7 == 0 : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT if n * maxdenom > d * maxnumer : NEW_LINE INDENT maxnumer = n NEW_LINE maxdenom = d NEW_LINE DEDENT DEDENT return str ( maxnumer ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p243_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p243 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p243 ( ) . run ( ) ) ; } private static final Fraction TARGET = new Fraction ( BigInteger . valueOf ( 15499 ) , BigInteger . valueOf ( 94744 ) ) ; public String run ( ) { BigInteger totient = BigInteger . ONE ; BigInteger denominator = BigInteger . ONE ; for ( int p = 2 ; ; ) { totient = totient . multiply ( BigInteger . valueOf ( p - 1 ) ) ; denominator = denominator . multiply ( BigInteger . valueOf ( p ) ) ; do p ++ ; while ( ! Library . isPrime ( p ) ) ; if ( new Fraction ( totient , denominator ) . compareTo ( TARGET ) < 0 ) { for ( int i = 1 ; i < p ; i ++ ) { BigInteger numer = BigInteger . valueOf ( i ) . multiply ( totient ) ; BigInteger denom = BigInteger . valueOf ( i ) . multiply ( denominator ) ; if ( new Fraction ( numer , denom . subtract ( BigInteger . ONE ) ) . compareTo ( TARGET ) < 0 ) return denom . toString ( ) ; } } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p243 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger totient = BigInteger . ONE ; BigInteger denominator = BigInteger . ONE ; for ( int p = 2 ; ; ) { totient = totient . multiply ( BigInteger . valueOf ( p - 1 ) ) ; denominator = denominator . multiply ( BigInteger . valueOf ( p ) ) ; do p ++ ; while ( ! Library . isPrime ( p ) ) ; if ( new Fraction ( totient , denominator ) . compareTo ( TARGET ) < 0 ) { for ( int i = 1 ; i < p ; i ++ ) { BigInteger numer = BigInteger . valueOf ( i ) . multiply ( totient ) ; BigInteger denom = BigInteger . valueOf ( i ) . multiply ( denominator ) ; if ( new Fraction ( numer , denom . subtract ( BigInteger . ONE ) ) . compareTo ( TARGET ) < 0 ) return denom . toString ( ) ; } } } }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 15499 , 94744 ) NEW_LINE totient = 1 NEW_LINE denominator = 1 NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient *= p - 1 NEW_LINE denominator *= p NEW_LINE while True : NEW_LINE INDENT p += 1 NEW_LINE if eulerlib . is_prime ( p ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if fractions . Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = i * totient NEW_LINE denom = i * denominator NEW_LINE if fractions . Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TARGET = fractions . Fraction ( 15499 , 94744 ) NEW_LINE totient = 1 NEW_LINE denominator = 1 NEW_LINE p = 2 NEW_LINE while True : NEW_LINE INDENT totient *= p - 1 NEW_LINE denominator *= p NEW_LINE while True : NEW_LINE INDENT p += 1 NEW_LINE if eulerlib . is_prime ( p ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if fractions . Fraction ( totient , denominator ) < TARGET : NEW_LINE INDENT for i in range ( 1 , p ) : NEW_LINE INDENT numer = i * totient NEW_LINE denom = i * denominator NEW_LINE if fractions . Fraction ( numer , denom - 1 ) < TARGET : NEW_LINE INDENT return str ( denom ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p047_A", "java": [{"id": "1", "code": "public final class p047 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p047 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 2 ; ; i ++ ) { if ( has4PrimeFactors ( i + 0 ) && has4PrimeFactors ( i + 1 ) && has4PrimeFactors ( i + 2 ) && has4PrimeFactors ( i + 3 ) ) return Integer . toString ( i ) ; } } private static boolean has4PrimeFactors ( int n ) { return countDistinctPrimeFactors ( n ) == 4 ; } private static int countDistinctPrimeFactors ( int n ) { int count = 0 ; for ( int i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) { do n /= i ; while ( n % i == 0 ) ; count ++ ; end = Library . sqrt ( n ) ; } } if ( n > 1 ) count ++ ; return count ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p047 ( ) . run ( ) ) ; }"], ["has4PrimeFactors", "private static boolean has4PrimeFactors ( int n ) { return countDistinctPrimeFactors ( n ) == 4 ; }"], ["countDistinctPrimeFactors", "private static int countDistinctPrimeFactors ( int n ) { int count = 0 ; for ( int i = 2 , end = Library . sqrt ( n ) ; i <= end ; i ++ ) { if ( n % i == 0 ) { do n /= i ; while ( n % i == 0 ) ; count ++ ; end = Library . sqrt ( n ) ; } } if ( n > 1 ) count ++ ; return count ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 2 ; ; i ++ ) { if ( has4PrimeFactors ( i + 0 ) && has4PrimeFactors ( i + 1 ) && has4PrimeFactors ( i + 2 ) && has4PrimeFactors ( i + 3 ) ) return Integer . toString ( i ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( ( count_distinct_prime_factors ( i + j ) == 4 ) for j in range ( 4 ) ) NEW_LINE ans = next ( filter ( cond , itertools . count ( ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_distinct_prime_factors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 1 : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( 2 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while True : NEW_LINE INDENT n //= i NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( ( count_distinct_prime_factors ( i + j ) == 4 ) for j in range ( 4 ) ) NEW_LINE ans = next ( filter ( cond , itertools . count ( ) ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["count_distinct_prime_factors", "def count_distinct_prime_factors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 1 : NEW_LINE INDENT count += 1 NEW_LINE for i in range ( 2 , eulerlib . sqrt ( n ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while True : NEW_LINE INDENT n //= i NEW_LINE if n % i != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p078_A", "java": [{"id": "1", "code": "public final class p078 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p078 ( ) . run ( ) ) ; } private static final int MODULUS = Library . pow ( 10 , 6 ) ; public String run ( ) { for ( int limit = 1 ; ; limit *= 2 ) { int result = search ( limit ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } } private static int search ( int limit ) { int [ ] partitions = new int [ limit ] ; partitions [ 0 ] = 1 ; for ( int i = 1 ; i < limit ; i ++ ) { for ( int j = i ; j < limit ; j ++ ) partitions [ j ] = ( partitions [ j ] + partitions [ j - i ] ) % MODULUS ; } for ( int i = 0 ; i < limit ; i ++ ) { if ( partitions [ i ] == 0 ) return i ; } return - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p078 ( ) . run ( ) ) ; }"], ["search", "private static int search ( int limit ) { int [ ] partitions = new int [ limit ] ; partitions [ 0 ] = 1 ; for ( int i = 1 ; i < limit ; i ++ ) { for ( int j = i ; j < limit ; j ++ ) partitions [ j ] = ( partitions [ j ] + partitions [ j - i ] ) % MODULUS ; } for ( int i = 0 ; i < limit ; i ++ ) { if ( partitions [ i ] == 0 ) return i ; } return - 1 ; }"]], "functions_class": [["run", "public String run ( ) { for ( int limit = 1 ; ; limit *= 2 ) { int result = search ( limit ) ; if ( result != - 1 ) return Integer . toString ( result ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE MODULUS = 10 ** 6 NEW_LINE def compute ( ) : NEW_LINE INDENT partitions = [ 1 ] NEW_LINE for i in itertools . count ( len ( partitions ) ) : NEW_LINE INDENT item = 0 NEW_LINE for j in itertools . count ( 1 ) : NEW_LINE INDENT sign = - 1 if j % 2 == 0 else + 1 NEW_LINE index = ( j * j * 3 - j ) // 2 NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE index += j NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE item %= MODULUS NEW_LINE DEDENT if item == 0 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT partitions . append ( item ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT partitions = [ 1 ] NEW_LINE for i in itertools . count ( len ( partitions ) ) : NEW_LINE INDENT item = 0 NEW_LINE for j in itertools . count ( 1 ) : NEW_LINE INDENT sign = - 1 if j % 2 == 0 else + 1 NEW_LINE index = ( j * j * 3 - j ) // 2 NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE index += j NEW_LINE if index > i : NEW_LINE INDENT break NEW_LINE DEDENT item += partitions [ i - index ] * sign NEW_LINE item %= MODULUS NEW_LINE DEDENT if item == 0 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT partitions . append ( item ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p040_A", "java": [{"id": "1", "code": "public final class p040 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p040 ( ) . run ( ) ) ; } public String run ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 1 ; i < 1000000 ; i ++ ) sb . append ( i ) ; int prod = 1 ; for ( int i = 0 ; i <= 6 ; i ++ ) prod *= sb . charAt ( Library . pow ( 10 , i ) - 1 ) - '0' ; return Integer . toString ( prod ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p040 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 1 ; i < 1000000 ; i ++ ) sb . append ( i ) ; int prod = 1 ; for ( int i = 0 ; i <= 6 ; i ++ ) prod *= sb . charAt ( Library . pow ( 10 , i ) - 1 ) - '0' ; return Integer . toString ( prod ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT s = \" \" . join ( str ( i ) for i in range ( 1 , 1000000 ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT ans *= int ( s [ 10 ** i - 1 ] ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT s = \" \" . join ( str ( i ) for i in range ( 1 , 1000000 ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT ans *= int ( s [ 10 ** i - 1 ] ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p014_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p014 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p014 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int maxArg = - 1 ; int maxChain = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { int chainLen = collatzChainLength ( BigInteger . valueOf ( i ) ) ; if ( chainLen > maxChain ) { maxArg = i ; maxChain = chainLen ; } } return Integer . toString ( maxArg ) ; } private static final BigInteger CACHE_SIZE = BigInteger . valueOf ( LIMIT ) ; private int [ ] collatzChainLength = new int [ CACHE_SIZE . intValue ( ) ] ; private int collatzChainLength ( BigInteger n ) { if ( n . signum ( ) < 0 ) throw new IllegalArgumentException ( ) ; if ( n . compareTo ( CACHE_SIZE ) >= 0 ) return collatzChainLengthDirect ( n ) ; int index = n . intValue ( ) ; if ( collatzChainLength [ index ] == 0 ) collatzChainLength [ index ] = collatzChainLengthDirect ( n ) ; return collatzChainLength [ index ] ; } private int collatzChainLengthDirect ( BigInteger n ) { if ( n . equals ( BigInteger . ONE ) ) return 1 ; else if ( ! n . testBit ( 0 ) ) return collatzChainLength ( n . shiftRight ( 1 ) ) + 1 ; else return collatzChainLength ( n . multiply ( BigInteger . valueOf ( 3 ) ) . add ( BigInteger . ONE ) ) + 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p014 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int maxArg = - 1 ; int maxChain = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { int chainLen = collatzChainLength ( BigInteger . valueOf ( i ) ) ; if ( chainLen > maxChain ) { maxArg = i ; maxChain = chainLen ; } } return Integer . toString ( maxArg ) ; }"], ["collatzChainLength", "private int collatzChainLength ( BigInteger n ) { if ( n . signum ( ) < 0 ) throw new IllegalArgumentException ( ) ; if ( n . compareTo ( CACHE_SIZE ) >= 0 ) return collatzChainLengthDirect ( n ) ; int index = n . intValue ( ) ; if ( collatzChainLength [ index ] == 0 ) collatzChainLength [ index ] = collatzChainLengthDirect ( n ) ; return collatzChainLength [ index ] ; }"], ["collatzChainLengthDirect", "private int collatzChainLengthDirect ( BigInteger n ) { if ( n . equals ( BigInteger . ONE ) ) return 1 ; else if ( ! n . testBit ( 0 ) ) return collatzChainLength ( n . shiftRight ( 1 ) ) + 1 ; else return collatzChainLength ( n . multiply ( BigInteger . valueOf ( 3 ) ) . add ( BigInteger . ONE ) ) + 1 ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE ans = max ( range ( 1 , 1000000 ) , key = collatz_chain_length ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def collatz_chain_length ( x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y = x // 2 NEW_LINE DEDENT else : NEW_LINE INDENT y = x * 3 + 1 NEW_LINE DEDENT return collatz_chain_length ( y ) + 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE ans = max ( range ( 1 , 1000000 ) , key = collatz_chain_length ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["collatz_chain_length", "def collatz_chain_length ( x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y = x // 2 NEW_LINE DEDENT else : NEW_LINE INDENT y = x * 3 + 1 NEW_LINE DEDENT return collatz_chain_length ( y ) + 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p013_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p013 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p013 ( ) . run ( ) ) ; } public String run ( ) { BigInteger sum = BigInteger . ZERO ; for ( String num : NUMBERS ) sum = sum . add ( new BigInteger ( num ) ) ; return sum . toString ( ) . substring ( 0 , 10 ) ; } private static String [ ] NUMBERS = { \"37107287533902102798797998220837590246510135740250\" , \"46376937677490009712648124896970078050417018260538\" , \"74324986199524741059474233309513058123726617309629\" , \"91942213363574161572522430563301811072406154908250\" , \"23067588207539346171171980310421047513778063246676\" , \"89261670696623633820136378418383684178734361726757\" , \"28112879812849979408065481931592621691275889832738\" , \"44274228917432520321923589422876796487670272189318\" , \"47451445736001306439091167216856844588711603153276\" , \"70386486105843025439939619828917593665686757934951\" , \"62176457141856560629502157223196586755079324193331\" , \"64906352462741904929101432445813822663347944758178\" , \"92575867718337217661963751590579239728245598838407\" , \"58203565325359399008402633568948830189458628227828\" , \"80181199384826282014278194139940567587151170094390\" , \"35398664372827112653829987240784473053190104293586\" , \"86515506006295864861532075273371959191420517255829\" , \"71693888707715466499115593487603532921714970056938\" , \"54370070576826684624621495650076471787294438377604\" , \"53282654108756828443191190634694037855217779295145\" , \"36123272525000296071075082563815656710885258350721\" , \"45876576172410976447339110607218265236877223636045\" , \"17423706905851860660448207621209813287860733969412\" , \"81142660418086830619328460811191061556940512689692\" , \"51934325451728388641918047049293215058642563049483\" , \"62467221648435076201727918039944693004732956340691\" , \"15732444386908125794514089057706229429197107928209\" , \"55037687525678773091862540744969844508330393682126\" , \"18336384825330154686196124348767681297534375946515\" , \"80386287592878490201521685554828717201219257766954\" , \"78182833757993103614740356856449095527097864797581\" , \"16726320100436897842553539920931837441497806860984\" , \"48403098129077791799088218795327364475675590848030\" , \"87086987551392711854517078544161852424320693150332\" , \"59959406895756536782107074926966537676326235447210\" , \"69793950679652694742597709739166693763042633987085\" , \"41052684708299085211399427365734116182760315001271\" , \"65378607361501080857009149939512557028198746004375\" , \"35829035317434717326932123578154982629742552737307\" , \"94953759765105305946966067683156574377167401875275\" , \"88902802571733229619176668713819931811048770190271\" , \"25267680276078003013678680992525463401061632866526\" , \"36270218540497705585629946580636237993140746255962\" , \"24074486908231174977792365466257246923322810917141\" , \"91430288197103288597806669760892938638285025333403\" , \"34413065578016127815921815005561868836468420090470\" , \"23053081172816430487623791969842487255036638784583\" , \"11487696932154902810424020138335124462181441773470\" , \"63783299490636259666498587618221225225512486764533\" , \"67720186971698544312419572409913959008952310058822\" , \"95548255300263520781532296796249481641953868218774\" , \"76085327132285723110424803456124867697064507995236\" , \"37774242535411291684276865538926205024910326572967\" , \"23701913275725675285653248258265463092207058596522\" , \"29798860272258331913126375147341994889534765745501\" , \"18495701454879288984856827726077713721403798879715\" , \"38298203783031473527721580348144513491373226651381\" , \"34829543829199918180278916522431027392251122869539\" , \"40957953066405232632538044100059654939159879593635\" , \"29746152185502371307642255121183693803580388584903\" , \"41698116222072977186158236678424689157993532961922\" , \"62467957194401269043877107275048102390895523597457\" , \"23189706772547915061505504953922979530901129967519\" , \"86188088225875314529584099251203829009407770775672\" , \"11306739708304724483816533873502340845647058077308\" , \"82959174767140363198008187129011875491310547126581\" , \"97623331044818386269515456334926366572897563400500\" , \"42846280183517070527831839425882145521227251250327\" , \"55121603546981200581762165212827652751691296897789\" , \"32238195734329339946437501907836945765883352399886\" , \"75506164965184775180738168837861091527357929701337\" , \"62177842752192623401942399639168044983993173312731\" , \"32924185707147349566916674687634660915035914677504\" , \"99518671430235219628894890102423325116913619626622\" , \"73267460800591547471830798392868535206946944540724\" , \"76841822524674417161514036427982273348055556214818\" , \"97142617910342598647204516893989422179826088076852\" , \"87783646182799346313767754307809363333018982642090\" , \"10848802521674670883215120185883543223812876952786\" , \"71329612474782464538636993009049310363619763878039\" , \"62184073572399794223406235393808339651327408011116\" , \"66627891981488087797941876876144230030984490851411\" , \"60661826293682836764744779239180335110989069790714\" , \"85786944089552990653640447425576083659976645795096\" , \"66024396409905389607120198219976047599490197230297\" , \"64913982680032973156037120041377903785566085089252\" , \"16730939319872750275468906903707539413042652315011\" , \"94809377245048795150954100921645863754710598436791\" , \"78639167021187492431995700641917969777599028300699\" , \"15368713711936614952811305876380278410754449733078\" , \"40789923115535562561142322423255033685442488917353\" , \"44889911501440648020369068063960672322193204149535\" , \"41503128880339536053299340368006977710650566631954\" , \"81234880673210146739058568557934581403627822703280\" , \"82616570773948327592232845941706525094512325230608\" , \"22918802058777319719839450180888072429661980811197\" , \"77158542502016545090413245809786882778948721859617\" , \"72107838435069186155435662884062257473692284509516\" , \"20849603980134001723930671666823555245252804609722\" , \"53503534226472524250874054075591789781264330331690\" , } ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p013 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger sum = BigInteger . ZERO ; for ( String num : NUMBERS ) sum = sum . add ( new BigInteger ( num ) ) ; return sum . toString ( ) . substring ( 0 , 10 ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT return str ( sum ( NUMBERS ) ) [ : 10 ] NEW_LINE DEDENT NUMBERS = [ 37107287533902102798797998220837590246510135740250 , 46376937677490009712648124896970078050417018260538 , 74324986199524741059474233309513058123726617309629 , 91942213363574161572522430563301811072406154908250 , 23067588207539346171171980310421047513778063246676 , 89261670696623633820136378418383684178734361726757 , 28112879812849979408065481931592621691275889832738 , 44274228917432520321923589422876796487670272189318 , 47451445736001306439091167216856844588711603153276 , 70386486105843025439939619828917593665686757934951 , 62176457141856560629502157223196586755079324193331 , 64906352462741904929101432445813822663347944758178 , 92575867718337217661963751590579239728245598838407 , 58203565325359399008402633568948830189458628227828 , 80181199384826282014278194139940567587151170094390 , 35398664372827112653829987240784473053190104293586 , 86515506006295864861532075273371959191420517255829 , 71693888707715466499115593487603532921714970056938 , 54370070576826684624621495650076471787294438377604 , 53282654108756828443191190634694037855217779295145 , 36123272525000296071075082563815656710885258350721 , 45876576172410976447339110607218265236877223636045 , 17423706905851860660448207621209813287860733969412 , 81142660418086830619328460811191061556940512689692 , 51934325451728388641918047049293215058642563049483 , 62467221648435076201727918039944693004732956340691 , 15732444386908125794514089057706229429197107928209 , 55037687525678773091862540744969844508330393682126 , 18336384825330154686196124348767681297534375946515 , 80386287592878490201521685554828717201219257766954 , 78182833757993103614740356856449095527097864797581 , 16726320100436897842553539920931837441497806860984 , 48403098129077791799088218795327364475675590848030 , 87086987551392711854517078544161852424320693150332 , 59959406895756536782107074926966537676326235447210 , 69793950679652694742597709739166693763042633987085 , 41052684708299085211399427365734116182760315001271 , 65378607361501080857009149939512557028198746004375 , 35829035317434717326932123578154982629742552737307 , 94953759765105305946966067683156574377167401875275 , 88902802571733229619176668713819931811048770190271 , 25267680276078003013678680992525463401061632866526 , 36270218540497705585629946580636237993140746255962 , 24074486908231174977792365466257246923322810917141 , 91430288197103288597806669760892938638285025333403 , 34413065578016127815921815005561868836468420090470 , 23053081172816430487623791969842487255036638784583 , 11487696932154902810424020138335124462181441773470 , 63783299490636259666498587618221225225512486764533 , 67720186971698544312419572409913959008952310058822 , 95548255300263520781532296796249481641953868218774 , 76085327132285723110424803456124867697064507995236 , 37774242535411291684276865538926205024910326572967 , 23701913275725675285653248258265463092207058596522 , 29798860272258331913126375147341994889534765745501 , 18495701454879288984856827726077713721403798879715 , 38298203783031473527721580348144513491373226651381 , 34829543829199918180278916522431027392251122869539 , 40957953066405232632538044100059654939159879593635 , 29746152185502371307642255121183693803580388584903 , 41698116222072977186158236678424689157993532961922 , 62467957194401269043877107275048102390895523597457 , 23189706772547915061505504953922979530901129967519 , 86188088225875314529584099251203829009407770775672 , 11306739708304724483816533873502340845647058077308 , 82959174767140363198008187129011875491310547126581 , 97623331044818386269515456334926366572897563400500 , 42846280183517070527831839425882145521227251250327 , 55121603546981200581762165212827652751691296897789 , 32238195734329339946437501907836945765883352399886 , 75506164965184775180738168837861091527357929701337 , 62177842752192623401942399639168044983993173312731 , 32924185707147349566916674687634660915035914677504 , 99518671430235219628894890102423325116913619626622 , 73267460800591547471830798392868535206946944540724 , 76841822524674417161514036427982273348055556214818 , 97142617910342598647204516893989422179826088076852 , 87783646182799346313767754307809363333018982642090 , 10848802521674670883215120185883543223812876952786 , 71329612474782464538636993009049310363619763878039 , 62184073572399794223406235393808339651327408011116 , 66627891981488087797941876876144230030984490851411 , 60661826293682836764744779239180335110989069790714 , 85786944089552990653640447425576083659976645795096 , 66024396409905389607120198219976047599490197230297 , 64913982680032973156037120041377903785566085089252 , 16730939319872750275468906903707539413042652315011 , 94809377245048795150954100921645863754710598436791 , 78639167021187492431995700641917969777599028300699 , 15368713711936614952811305876380278410754449733078 , 40789923115535562561142322423255033685442488917353 , 44889911501440648020369068063960672322193204149535 , 41503128880339536053299340368006977710650566631954 , 81234880673210146739058568557934581403627822703280 , 82616570773948327592232845941706525094512325230608 , 22918802058777319719839450180888072429661980811197 , 77158542502016545090413245809786882778948721859617 , 72107838435069186155435662884062257473692284509516 , 20849603980134001723930671666823555245252804609722 , 53503534226472524250874054075591789781264330331690 , ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT return str ( sum ( NUMBERS ) ) [ : 10 ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p025_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p025 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p025 ( ) . run ( ) ) ; } private static final int DIGITS = 1000 ; public String run ( ) { BigInteger lowerThres = BigInteger . TEN . pow ( DIGITS - 1 ) ; BigInteger upperThres = BigInteger . TEN . pow ( DIGITS ) ; BigInteger prev = BigInteger . ONE ; BigInteger cur = BigInteger . ZERO ; for ( int i = 0 ; ; i ++ ) { if ( cur . compareTo ( upperThres ) >= 0 ) throw new RuntimeException ( \" Not \u2581 found \" ) ; else if ( cur . compareTo ( lowerThres ) >= 0 ) return Integer . toString ( i ) ; BigInteger temp = cur . add ( prev ) ; prev = cur ; cur = temp ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p025 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger lowerThres = BigInteger . TEN . pow ( DIGITS - 1 ) ; BigInteger upperThres = BigInteger . TEN . pow ( DIGITS ) ; BigInteger prev = BigInteger . ONE ; BigInteger cur = BigInteger . ZERO ; for ( int i = 0 ; ; i ++ ) { if ( cur . compareTo ( upperThres ) >= 0 ) throw new RuntimeException ( \" Not \u2581 found \" ) ; else if ( cur . compareTo ( lowerThres ) >= 0 ) return Integer . toString ( i ) ; BigInteger temp = cur . add ( prev ) ; prev = cur ; cur = temp ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 1000 NEW_LINE prev = 1 NEW_LINE cur = 0 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if len ( str ( cur ) ) > DIGITS : NEW_LINE INDENT raise RuntimeError ( \" Not \u2581 found \" ) NEW_LINE DEDENT elif len ( str ( cur ) ) == DIGITS : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT prev , cur = cur , prev + cur NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT DIGITS = 1000 NEW_LINE prev = 1 NEW_LINE cur = 0 NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT if len ( str ( cur ) ) > DIGITS : NEW_LINE INDENT raise RuntimeError ( \" Not \u2581 found \" ) NEW_LINE DEDENT elif len ( str ( cur ) ) == DIGITS : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT prev , cur = cur , prev + cur NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p007_A", "java": [{"id": "1", "code": "public final class p007 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p007 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 2 , count = 0 ; ; i ++ ) { if ( Library . isPrime ( i ) ) { count ++ ; if ( count == 10001 ) return Integer . toString ( i ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p007 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 2 , count = 0 ; ; i ++ ) { if ( Library . isPrime ( i ) ) { count ++ ; if ( count == 10001 ) return Integer . toString ( i ) ; } } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = next ( itertools . islice ( filter ( eulerlib . is_prime , itertools . count ( 2 ) ) , 10000 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = next ( itertools . islice ( filter ( eulerlib . is_prime , itertools . count ( 2 ) ) , 10000 , None ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p038_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p038 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p038 ( ) . run ( ) ) ; } public String run ( ) { int max = - 1 ; for ( int n = 2 ; n <= 9 ; n ++ ) { for ( int i = 1 ; i < Library . pow ( 10 , 9 / n ) ; i ++ ) { String concat = \" \" ; for ( int j = 1 ; j <= n ; j ++ ) concat += i * j ; if ( isPandigital ( concat ) ) max = Math . max ( Integer . parseInt ( concat ) , max ) ; } } return Integer . toString ( max ) ; } private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p038 ( ) . run ( ) ) ; }"], ["isPandigital", "private static boolean isPandigital ( String s ) { if ( s . length ( ) != 9 ) return false ; char [ ] temp = s . toCharArray ( ) ; Arrays . sort ( temp ) ; return new String ( temp ) . equals ( \"123456789\" ) ; }"]], "functions_class": [["run", "public String run ( ) { int max = - 1 ; for ( int n = 2 ; n <= 9 ; n ++ ) { for ( int i = 1 ; i < Library . pow ( 10 , 9 / n ) ; i ++ ) { String concat = \" \" ; for ( int j = 1 ; j <= n ; j ++ ) concat += i * j ; if ( isPandigital ( concat ) ) max = Math . max ( Integer . parseInt ( concat ) , max ) ; } } return Integer . toString ( max ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = \" \" NEW_LINE for n in range ( 2 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ** ( 9 // n ) ) : NEW_LINE INDENT s = \" \" . join ( str ( i * j ) for j in range ( 1 , n + 1 ) ) NEW_LINE if \" \" . join ( sorted ( s ) ) == \"123456789\" : NEW_LINE INDENT ans = max ( s , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = \" \" NEW_LINE for n in range ( 2 , 10 ) : NEW_LINE INDENT for i in range ( 1 , 10 ** ( 9 // n ) ) : NEW_LINE INDENT s = \" \" . join ( str ( i * j ) for j in range ( 1 , n + 1 ) ) NEW_LINE if \" \" . join ( sorted ( s ) ) == \"123456789\" : NEW_LINE INDENT ans = max ( s , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p031_A", "java": [{"id": "1", "code": "public final class p031 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; } private static final int TOTAL = 200 ; private static int [ ] COINS = { 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 } ; public String run ( ) { int [ ] [ ] ways = new int [ COINS . length + 1 ] [ TOTAL + 1 ] ; ways [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < COINS . length ; i ++ ) { int coin = COINS [ i ] ; for ( int j = 0 ; j <= TOTAL ; j ++ ) ways [ i + 1 ] [ j ] = ways [ i ] [ j ] + ( j >= coin ? ways [ i + 1 ] [ j - coin ] : 0 ) ; } return Integer . toString ( ways [ COINS . length ] [ TOTAL ] ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p031 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] [ ] ways = new int [ COINS . length + 1 ] [ TOTAL + 1 ] ; ways [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < COINS . length ; i ++ ) { int coin = COINS [ i ] ; for ( int j = 0 ; j <= TOTAL ; j ++ ) ways [ i + 1 ] [ j ] = ways [ i ] [ j ] + ( j >= coin ? ways [ i + 1 ] [ j - coin ] : 0 ) ; } return Integer . toString ( ways [ COINS . length ] [ TOTAL ] ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TOTAL = 200 NEW_LINE ways = [ 1 ] + [ 0 ] * TOTAL NEW_LINE for coin in [ 1 , 2 , 5 , 10 , 20 , 50 , 100 , 200 ] : NEW_LINE INDENT for i in range ( len ( ways ) - coin ) : NEW_LINE INDENT ways [ i + coin ] += ways [ i ] NEW_LINE DEDENT DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p203_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p203 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p203 ( ) . run ( ) ) ; } public String run ( ) { Set < Long > numbers = new HashSet < > ( ) ; long max = 0 ; for ( int n = 0 ; n <= 50 ; n ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { BigInteger x = Library . binomial ( n , k ) ; if ( x . bitLength ( ) >= 64 ) throw new AssertionError ( \" Number \u2581 too \u2581 large \u2581 to \u2581 handle \" ) ; numbers . add ( x . longValue ( ) ) ; max = Math . max ( x . longValue ( ) , max ) ; } } int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( max ) ) ; primesSquared = new long [ primes . length ] ; for ( int i = 0 ; i < primes . length ; i ++ ) primesSquared [ i ] = ( long ) primes [ i ] * primes [ i ] ; long sum = 0 ; for ( long n : numbers ) { if ( isSquarefree ( n ) ) sum += n ; } return Long . toString ( sum ) ; } private long [ ] primesSquared ; private boolean isSquarefree ( long n ) { for ( long p2 : primesSquared ) { if ( p2 > n ) break ; if ( n % p2 == 0 ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p203 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < Long > numbers = new HashSet < > ( ) ; long max = 0 ; for ( int n = 0 ; n <= 50 ; n ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { BigInteger x = Library . binomial ( n , k ) ; if ( x . bitLength ( ) >= 64 ) throw new AssertionError ( \" Number \u2581 too \u2581 large \u2581 to \u2581 handle \" ) ; numbers . add ( x . longValue ( ) ) ; max = Math . max ( x . longValue ( ) , max ) ; } } int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( max ) ) ; primesSquared = new long [ primes . length ] ; for ( int i = 0 ; i < primes . length ; i ++ ) primesSquared [ i ] = ( long ) primes [ i ] * primes [ i ] ; long sum = 0 ; for ( long n : numbers ) { if ( isSquarefree ( n ) ) sum += n ; } return Long . toString ( sum ) ; }"], ["isSquarefree", "private boolean isSquarefree ( long n ) { for ( long p2 : primesSquared ) { if ( p2 > n ) break ; if ( n % p2 == 0 ) return false ; } return true ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT numbers = set ( eulerlib . binomial ( n , k ) for n in range ( 51 ) for k in range ( n + 1 ) ) NEW_LINE maximum = max ( numbers ) NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maximum ) ) NEW_LINE primessquared = [ p * p for p in primes ] NEW_LINE def is_squarefree ( n ) : NEW_LINE INDENT for p2 in primessquared : NEW_LINE INDENT if p2 > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % p2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in numbers if is_squarefree ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT numbers = set ( eulerlib . binomial ( n , k ) for n in range ( 51 ) for k in range ( n + 1 ) ) NEW_LINE maximum = max ( numbers ) NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maximum ) ) NEW_LINE primessquared = [ p * p for p in primes ] NEW_LINE def is_squarefree ( n ) : NEW_LINE INDENT for p2 in primessquared : NEW_LINE INDENT if p2 > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % p2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in numbers if is_squarefree ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p204_A", "java": [{"id": "1", "code": "public final class p204 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p204 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( count ( 0 , 1 ) ) ; } private static long LIMIT = Library . pow ( 10 , 9 ) ; private int [ ] primes = Library . listPrimes ( 100 ) ; private int count ( int primeIndex , long product ) { if ( primeIndex == primes . length ) return product <= LIMIT ? 1 : 0 ; else { int count = 0 ; while ( product <= LIMIT ) { count += count ( primeIndex + 1 , product ) ; product *= primes [ primeIndex ] ; } return count ; } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p204 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { return Integer . toString ( count ( 0 , 1 ) ) ; }"], ["count", "private int count ( int primeIndex , long product ) { if ( primeIndex == primes . length ) return product <= LIMIT ? 1 : 0 ; else { int count = 0 ; while ( product <= LIMIT ) { count += count ( primeIndex + 1 , product ) ; product *= primes [ primeIndex ] ; } return count ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE primes = eulerlib . list_primes ( 100 ) NEW_LINE def count ( primeindex , product ) : NEW_LINE INDENT if primeindex == len ( primes ) : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT result += count ( primeindex + 1 , product ) NEW_LINE product *= primes [ primeindex ] NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT return str ( count ( 0 , 1 ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 9 NEW_LINE primes = eulerlib . list_primes ( 100 ) NEW_LINE def count ( primeindex , product ) : NEW_LINE INDENT if primeindex == len ( primes ) : NEW_LINE INDENT return 1 if product <= LIMIT else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE while product <= LIMIT : NEW_LINE INDENT result += count ( primeindex + 1 , product ) NEW_LINE product *= primes [ primeindex ] NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT return str ( count ( 0 , 1 ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p036_A", "java": [{"id": "1", "code": "public final class p036 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p036 ( ) . run ( ) ) ; } public String run ( ) { long sum = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { if ( Library . isPalindrome ( Integer . toString ( i , 10 ) ) && Library . isPalindrome ( Integer . toString ( i , 2 ) ) ) sum += i ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p036 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int i = 1 ; i < 1000000 ; i ++ ) { if ( Library . isPalindrome ( Integer . toString ( i , 10 ) ) && Library . isPalindrome ( Integer . toString ( i , 2 ) ) ) sum += i ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000000 ) if is_decimal_binary_palindrome ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_decimal_binary_palindrome ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE if s != s [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT t = bin ( n ) [ 2 : ] NEW_LINE return t == t [ : : - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 1000000 ) if is_decimal_binary_palindrome ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_decimal_binary_palindrome", "def is_decimal_binary_palindrome ( n ) : NEW_LINE INDENT s = str ( n ) NEW_LINE if s != s [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT t = bin ( n ) [ 2 : ] NEW_LINE return t == t [ : : - 1 ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p009_A", "java": [{"id": "1", "code": "public final class p009 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p009 ( ) . run ( ) ) ; } private static final int PERIMETER = 1000 ; public String run ( ) { for ( int a = 1 ; a < PERIMETER ; a ++ ) { for ( int b = a + 1 ; b < PERIMETER ; b ++ ) { int c = PERIMETER - a - b ; if ( a * a + b * b == c * c ) { return Integer . toString ( a * b * c ) ; } } } throw new AssertionError ( \" Not \u2581 found \" ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p009 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { for ( int a = 1 ; a < PERIMETER ; a ++ ) { for ( int b = a + 1 ; b < PERIMETER ; b ++ ) { int c = PERIMETER - a - b ; if ( a * a + b * b == c * c ) { return Integer . toString ( a * b * c ) ; } } } throw new AssertionError ( \" Not \u2581 found \" ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT PERIMETER = 1000 NEW_LINE for a in range ( 1 , PERIMETER + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , PERIMETER + 1 ) : NEW_LINE INDENT c = PERIMETER - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT return str ( a * b * c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT PERIMETER = 1000 NEW_LINE for a in range ( 1 , PERIMETER + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , PERIMETER + 1 ) : NEW_LINE INDENT c = PERIMETER - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT return str ( a * b * c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p062_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; public final class p062 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p062 ( ) . run ( ) ) ; } public String run ( ) { int numDigits = 0 ; Map < String , Integer > lowest = new HashMap < > ( ) ; Map < String , Integer > counts = new HashMap < > ( ) ; for ( int i = 0 ; ; i ++ ) { String numClass = getCubeNumberClass ( i ) ; if ( numClass . length ( ) > numDigits ) { int min = Integer . MAX_VALUE ; for ( String nc : counts . keySet ( ) ) { if ( counts . get ( nc ) == 5 ) min = Math . min ( lowest . get ( nc ) , min ) ; } if ( min != Integer . MAX_VALUE ) return cube ( min ) . toString ( ) ; lowest . clear ( ) ; counts . clear ( ) ; numDigits = numClass . length ( ) ; } if ( ! lowest . containsKey ( numClass ) ) { lowest . put ( numClass , i ) ; counts . put ( numClass , 0 ) ; } counts . put ( numClass , counts . get ( numClass ) + 1 ) ; } } private static String getCubeNumberClass ( int x ) { char [ ] digits = cube ( x ) . toString ( ) . toCharArray ( ) ; Arrays . sort ( digits ) ; return new String ( digits ) ; } private static BigInteger cube ( int x ) { return BigInteger . valueOf ( x ) . pow ( 3 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p062 ( ) . run ( ) ) ; }"], ["getCubeNumberClass", "private static String getCubeNumberClass ( int x ) { char [ ] digits = cube ( x ) . toString ( ) . toCharArray ( ) ; Arrays . sort ( digits ) ; return new String ( digits ) ; }"], ["cube", "private static BigInteger cube ( int x ) { return BigInteger . valueOf ( x ) . pow ( 3 ) ; }"]], "functions_class": [["run", "public String run ( ) { int numDigits = 0 ; Map < String , Integer > lowest = new HashMap < > ( ) ; Map < String , Integer > counts = new HashMap < > ( ) ; for ( int i = 0 ; ; i ++ ) { String numClass = getCubeNumberClass ( i ) ; if ( numClass . length ( ) > numDigits ) { int min = Integer . MAX_VALUE ; for ( String nc : counts . keySet ( ) ) { if ( counts . get ( nc ) == 5 ) min = Math . min ( lowest . get ( nc ) , min ) ; } if ( min != Integer . MAX_VALUE ) return cube ( min ) . toString ( ) ; lowest . clear ( ) ; counts . clear ( ) ; numDigits = numClass . length ( ) ; } if ( ! lowest . containsKey ( numClass ) ) { lowest . put ( numClass , i ) ; counts . put ( numClass , 0 ) ; } counts . put ( numClass , counts . get ( numClass ) + 1 ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT numdigits = 0 NEW_LINE data = { } NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT digits = [ int ( c ) for c in str ( i ** 3 ) ] NEW_LINE digits . sort ( ) NEW_LINE numclass = \" \" . join ( str ( d ) for d in digits ) NEW_LINE if len ( numclass ) > numdigits : NEW_LINE INDENT candidates = [ lowest for ( lowest , count ) in data . values ( ) if count == 5 ] NEW_LINE if len ( candidates ) > 0 : NEW_LINE INDENT return str ( min ( candidates ) ** 3 ) NEW_LINE DEDENT data = { } NEW_LINE numdigits = len ( numclass ) NEW_LINE DEDENT lowest , count = data . get ( numclass , ( i , 0 ) ) NEW_LINE data [ numclass ] = ( lowest , count + 1 ) NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT numdigits = 0 NEW_LINE data = { } NEW_LINE for i in itertools . count ( ) : NEW_LINE INDENT digits = [ int ( c ) for c in str ( i ** 3 ) ] NEW_LINE digits . sort ( ) NEW_LINE numclass = \" \" . join ( str ( d ) for d in digits ) NEW_LINE if len ( numclass ) > numdigits : NEW_LINE INDENT candidates = [ lowest for ( lowest , count ) in data . values ( ) if count == 5 ] NEW_LINE if len ( candidates ) > 0 : NEW_LINE INDENT return str ( min ( candidates ) ** 3 ) NEW_LINE DEDENT data = { } NEW_LINE numdigits = len ( numclass ) NEW_LINE DEDENT lowest , count = data . get ( numclass , ( i , 0 ) ) NEW_LINE data [ numclass ] = ( lowest , count + 1 ) NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p250_A", "java": [{"id": "1", "code": "public final class p250 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p250 ( ) . run ( ) ) ; } private static final long MODULUS = 10000000000000000L ; public String run ( ) { long [ ] numSubsets = new long [ 250 ] ; numSubsets [ 0 ] = 1 ; for ( int i = 1 ; i <= 250250 ; i ++ ) { int temp = Library . powMod ( i , i , 250 ) ; long [ ] newArray = new long [ numSubsets . length ] ; for ( int j = 0 ; j < 250 ; j ++ ) newArray [ ( j + temp ) % 250 ] = ( numSubsets [ j ] + numSubsets [ ( j + temp ) % 250 ] ) % MODULUS ; numSubsets = newArray ; } return Long . toString ( ( numSubsets [ 0 ] - 1 + MODULUS ) % MODULUS ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p250 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] numSubsets = new long [ 250 ] ; numSubsets [ 0 ] = 1 ; for ( int i = 1 ; i <= 250250 ; i ++ ) { int temp = Library . powMod ( i , i , 250 ) ; long [ ] newArray = new long [ numSubsets . length ] ; for ( int j = 0 ; j < 250 ; j ++ ) newArray [ ( j + temp ) % 250 ] = ( numSubsets [ j ] + numSubsets [ ( j + temp ) % 250 ] ) % MODULUS ; numSubsets = newArray ; } return Long . toString ( ( numSubsets [ 0 ] - 1 + MODULUS ) % MODULUS ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 16 NEW_LINE subsets = [ 0 ] * 250 NEW_LINE subsets [ 0 ] = 1 NEW_LINE for i in range ( 1 , 250250 + 1 ) : NEW_LINE INDENT offset = pow ( i , i , 250 ) NEW_LINE subsets = [ ( val + subsets [ ( j - offset ) % 250 ] ) % MOD for ( j , val ) in enumerate ( subsets ) ] NEW_LINE DEDENT ans = ( subsets [ 0 ] - 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p091_A", "java": [{"id": "1", "code": "public final class p091 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p091 ( ) . run ( ) ) ; } private static final int LIMIT = 50 ; public String run ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= LIMIT ; x1 ++ ) { for ( int y1 = 0 ; y1 <= LIMIT ; y1 ++ ) { for ( int x2 = 0 ; x2 <= LIMIT ; x2 ++ ) { for ( int y2 = 0 ; y2 <= LIMIT ; y2 ++ ) { if ( y2 * x1 < y1 * x2 && isRightTriangle ( x1 , y1 , x2 , y2 ) ) count ++ ; } } } } return Integer . toString ( count ) ; } private static boolean isRightTriangle ( int x1 , int y1 , int x2 , int y2 ) { int a = x1 * x1 + y1 * y1 ; int b = x2 * x2 + y2 * y2 ; int c = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; return a + b == c || b + c == a || c + a == b ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p091 ( ) . run ( ) ) ; }"], ["isRightTriangle", "private static boolean isRightTriangle ( int x1 , int y1 , int x2 , int y2 ) { int a = x1 * x1 + y1 * y1 ; int b = x2 * x2 + y2 * y2 ; int c = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ; return a + b == c || b + c == a || c + a == b ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int x1 = 0 ; x1 <= LIMIT ; x1 ++ ) { for ( int y1 = 0 ; y1 <= LIMIT ; y1 ++ ) { for ( int x2 = 0 ; x2 <= LIMIT ; x2 ++ ) { for ( int y2 = 0 ; y2 <= LIMIT ; y2 ++ ) { if ( y2 * x1 < y1 * x2 && isRightTriangle ( x1 , y1 , x2 , y2 ) ) count ++ ; } } } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LIMIT = 51 NEW_LINE ans = sum ( 1 for x1 in range ( LIMIT ) for y1 in range ( LIMIT ) for x2 in range ( LIMIT ) for y2 in range ( LIMIT ) if y2 * x1 < y1 * x2 and is_right_triangle ( x1 , y1 , x2 , y2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_right_triangle ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT a = x1 ** 2 + y1 ** 2 NEW_LINE b = x2 ** 2 + y2 ** 2 NEW_LINE c = ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 NEW_LINE return ( a + b == c ) or ( b + c == a ) or ( c + a == b ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 51 NEW_LINE ans = sum ( 1 for x1 in range ( LIMIT ) for y1 in range ( LIMIT ) for x2 in range ( LIMIT ) for y2 in range ( LIMIT ) if y2 * x1 < y1 * x2 and is_right_triangle ( x1 , y1 , x2 , y2 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_right_triangle", "def is_right_triangle ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT a = x1 ** 2 + y1 ** 2 NEW_LINE b = x2 ** 2 + y2 ** 2 NEW_LINE c = ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 NEW_LINE return ( a + b == c ) or ( b + c == a ) or ( c + a == b ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p401_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p401 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p401 ( ) . run ( ) ) ; } private static final long LIMIT = 1000000000000000L ; private static final long MODULUS = Library . pow ( 10 , 9 ) ; public String run ( ) { int splitCount = ( int ) Library . sqrt ( LIMIT ) ; splitCount = Math . max ( splitCount / 3 , 1 ) ; int splitAt = ( int ) ( LIMIT / ( splitCount + 1 ) ) ; long sum = 0 ; for ( int i = 1 ; i <= splitAt ; i ++ ) { long count = LIMIT / i % MODULUS ; long term = ( long ) i * i % MODULUS ; term = term * count % MODULUS ; sum = ( sum + term ) % MODULUS ; } for ( int i = splitCount ; i >= 1 ; i -- ) { long start = LIMIT / ( i + 1 ) ; long end = LIMIT / i ; long sumSquares = sumSquaresMod ( end ) - sumSquaresMod ( start ) ; sumSquares = ( sumSquares + MODULUS ) % MODULUS ; sum = ( sum + i * sumSquares % MODULUS ) % MODULUS ; } return Long . toString ( sum ) ; } private static final BigInteger MODULUS_BI = BigInteger . valueOf ( MODULUS ) ; private static final BigInteger SIX_BI = BigInteger . valueOf ( 6 ) ; private static long sumSquaresMod ( long n ) { BigInteger x = BigInteger . valueOf ( n ) ; BigInteger y = x . multiply ( x . add ( BigInteger . ONE ) ) ; y = y . multiply ( x . shiftLeft ( 1 ) . add ( BigInteger . ONE ) ) ; y = y . divide ( SIX_BI ) ; y = y . mod ( MODULUS_BI ) ; return y . longValue ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p401 ( ) . run ( ) ) ; }"], ["sumSquaresMod", "private static long sumSquaresMod ( long n ) { BigInteger x = BigInteger . valueOf ( n ) ; BigInteger y = x . multiply ( x . add ( BigInteger . ONE ) ) ; y = y . multiply ( x . shiftLeft ( 1 ) . add ( BigInteger . ONE ) ) ; y = y . divide ( SIX_BI ) ; y = y . mod ( MODULUS_BI ) ; return y . longValue ( ) ; }"]], "functions_class": [["run", "public String run ( ) { int splitCount = ( int ) Library . sqrt ( LIMIT ) ; splitCount = Math . max ( splitCount / 3 , 1 ) ; int splitAt = ( int ) ( LIMIT / ( splitCount + 1 ) ) ; long sum = 0 ; for ( int i = 1 ; i <= splitAt ; i ++ ) { long count = LIMIT / i % MODULUS ; long term = ( long ) i * i % MODULUS ; term = term * count % MODULUS ; sum = ( sum + term ) % MODULUS ; } for ( int i = splitCount ; i >= 1 ; i -- ) { long start = LIMIT / ( i + 1 ) ; long end = LIMIT / i ; long sumSquares = sumSquaresMod ( end ) - sumSquaresMod ( start ) ; sumSquares = ( sumSquares + MODULUS ) % MODULUS ; sum = ( sum + i * sumSquares % MODULUS ) % MODULUS ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT // ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) // 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT // i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT // ( i + 1 ) , LIMIT // i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 15 NEW_LINE MODULUS = 10 ** 9 NEW_LINE splitcount = eulerlib . sqrt ( LIMIT ) NEW_LINE splitat = LIMIT // ( splitcount + 1 ) NEW_LINE def sum_squares ( s , e ) : NEW_LINE INDENT return ( e * ( e + 1 ) * ( e * 2 + 1 ) - s * ( s + 1 ) * ( s * 2 + 1 ) ) // 6 NEW_LINE DEDENT ans = sum ( ( i * i * ( LIMIT // i ) ) for i in range ( 1 , splitat + 1 ) ) NEW_LINE ans += sum ( ( sum_squares ( LIMIT // ( i + 1 ) , LIMIT // i ) * i ) for i in range ( 1 , splitcount + 1 ) ) NEW_LINE return str ( ans % MODULUS ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p065_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p065 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p065 ( ) . run ( ) ) ; } public String run ( ) { BigInteger n = BigInteger . ONE ; BigInteger d = BigInteger . ZERO ; for ( int i = 99 ; i >= 0 ; i -- ) { BigInteger temp = BigInteger . valueOf ( continuedFractionTerm ( i ) ) . multiply ( n ) . add ( d ) ; d = n ; n = temp ; } int sum = 0 ; while ( ! n . equals ( BigInteger . ZERO ) ) { BigInteger [ ] divrem = n . divideAndRemainder ( BigInteger . TEN ) ; sum += divrem [ 1 ] . intValue ( ) ; n = divrem [ 0 ] ; } return Integer . toString ( sum ) ; } private static int continuedFractionTerm ( int i ) { if ( i == 0 ) return 2 ; else if ( i % 3 == 2 ) return i / 3 * 2 + 2 ; else return 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p065 ( ) . run ( ) ) ; }"], ["continuedFractionTerm", "private static int continuedFractionTerm ( int i ) { if ( i == 0 ) return 2 ; else if ( i % 3 == 2 ) return i / 3 * 2 + 2 ; else return 1 ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger n = BigInteger . ONE ; BigInteger d = BigInteger . ZERO ; for ( int i = 99 ; i >= 0 ; i -- ) { BigInteger temp = BigInteger . valueOf ( continuedFractionTerm ( i ) ) . multiply ( n ) . add ( d ) ; d = n ; n = temp ; } int sum = 0 ; while ( ! n . equals ( BigInteger . ZERO ) ) { BigInteger [ ] divrem = n . divideAndRemainder ( BigInteger . TEN ) ; sum += divrem [ 1 ] . intValue ( ) ; n = divrem [ 0 ] ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 0 NEW_LINE for i in reversed ( range ( 100 ) ) : NEW_LINE INDENT numer , denom = e_contfrac_term ( i ) * numer + denom , numer NEW_LINE DEDENT ans = sum ( int ( c ) for c in str ( numer ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def e_contfrac_term ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT numer = 1 NEW_LINE denom = 0 NEW_LINE for i in reversed ( range ( 100 ) ) : NEW_LINE INDENT numer , denom = e_contfrac_term ( i ) * numer + denom , numer NEW_LINE DEDENT ans = sum ( int ( c ) for c in str ( numer ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["e_contfrac_term", "def e_contfrac_term ( i ) : NEW_LINE INDENT if i == 0 : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif i % 3 == 2 : NEW_LINE INDENT return i // 3 * 2 + 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p053_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p053 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p053 ( ) . run ( ) ) ; } public String run ( ) { BigInteger MILLION = BigInteger . TEN . pow ( 6 ) ; int count = 0 ; for ( int n = 1 ; n <= 100 ; n ++ ) { for ( int r = 0 ; r <= n ; r ++ ) { if ( Library . binomial ( n , r ) . compareTo ( MILLION ) > 0 ) count ++ ; } } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p053 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger MILLION = BigInteger . TEN . pow ( 6 ) ; int count = 0 ; for ( int n = 1 ; n <= 100 ; n ++ ) { for ( int r = 0 ; r <= n ; r ++ ) { if ( Library . binomial ( n , r ) . compareTo ( MILLION ) > 0 ) count ++ ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for n in range ( 1 , 101 ) for k in range ( 0 , n + 1 ) if eulerlib . binomial ( n , k ) > 1000000 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for n in range ( 1 , 101 ) for k in range ( 0 , n + 1 ) if eulerlib . binomial ( n , k ) > 1000000 ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p037_A", "java": [{"id": "1", "code": "public final class p037 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p037 ( ) . run ( ) ) ; } public String run ( ) { long sum = 0 ; for ( int count = 0 , n = 10 ; count < 11 ; n ++ ) { if ( isTruncatablePrime ( n ) ) { sum += n ; count ++ ; } } return Long . toString ( sum ) ; } private static boolean isTruncatablePrime ( int n ) { for ( long i = 10 ; i <= n ; i *= 10 ) { if ( ! Library . isPrime ( n % ( int ) i ) ) return false ; } for ( ; n != 0 ; n /= 10 ) { if ( ! Library . isPrime ( n ) ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p037 ( ) . run ( ) ) ; }"], ["isTruncatablePrime", "private static boolean isTruncatablePrime ( int n ) { for ( long i = 10 ; i <= n ; i *= 10 ) { if ( ! Library . isPrime ( n % ( int ) i ) ) return false ; } for ( ; n != 0 ; n /= 10 ) { if ( ! Library . isPrime ( n ) ) return false ; } return true ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; for ( int count = 0 , n = 10 ; count < 11 ; n ++ ) { if ( isTruncatablePrime ( n ) ) { sum += n ; count ++ ; } } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . islice ( filter ( is_truncatable_prime , itertools . count ( 10 ) ) , 11 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_truncatable_prime ( n ) : NEW_LINE INDENT i = 10 NEW_LINE while i <= n : NEW_LINE INDENT if not eulerlib . is_prime ( n % i ) : NEW_LINE INDENT return False NEW_LINE DEDENT i *= 10 NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT if not eulerlib . is_prime ( n ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( itertools . islice ( filter ( is_truncatable_prime , itertools . count ( 10 ) ) , 11 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_truncatable_prime", "def is_truncatable_prime ( n ) : NEW_LINE INDENT i = 10 NEW_LINE while i <= n : NEW_LINE INDENT if not eulerlib . is_prime ( n % i ) : NEW_LINE INDENT return False NEW_LINE DEDENT i *= 10 NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT if not eulerlib . is_prime ( n ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p205_A", "java": [{"id": "1", "code": "public final class p205 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p205 ( ) . run ( ) ) ; } private static final int [ ] PYRAMIDAL_DIE_PDF = { 0 , 1 , 1 , 1 , 1 } ; private static final int [ ] CUBIC_DIE_PDF = { 0 , 1 , 1 , 1 , 1 , 1 , 1 } ; public String run ( ) { int [ ] ninePyramidalPdf = { 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) ninePyramidalPdf = convolve ( ninePyramidalPdf , PYRAMIDAL_DIE_PDF ) ; int [ ] sixCubicPdf = { 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) sixCubicPdf = convolve ( sixCubicPdf , CUBIC_DIE_PDF ) ; long numer = 0 ; for ( int i = 0 ; i < ninePyramidalPdf . length ; i ++ ) numer += ( long ) ninePyramidalPdf [ i ] * sum ( sixCubicPdf , 0 , i ) ; long denom = ( long ) sum ( ninePyramidalPdf , 0 , ninePyramidalPdf . length ) * sum ( sixCubicPdf , 0 , sixCubicPdf . length ) ; return String . format ( \" % .7f \" , ( double ) numer / denom ) ; } private static int [ ] convolve ( int [ ] a , int [ ] b ) { int [ ] c = new int [ a . length + b . length - 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < b . length ; j ++ ) c [ i + j ] += a [ i ] * b [ j ] ; } return c ; } private static int sum ( int [ ] array , int start , int end ) { int sum = 0 ; for ( int i = start ; i < end ; i ++ ) sum += array [ i ] ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p205 ( ) . run ( ) ) ; }"], ["convolve", "private static int [ ] convolve ( int [ ] a , int [ ] b ) { int [ ] c = new int [ a . length + b . length - 1 ] ; for ( int i = 0 ; i < a . length ; i ++ ) { for ( int j = 0 ; j < b . length ; j ++ ) c [ i + j ] += a [ i ] * b [ j ] ; } return c ; }"], ["sum", "private static int sum ( int [ ] array , int start , int end ) { int sum = 0 ; for ( int i = start ; i < end ; i ++ ) sum += array [ i ] ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] ninePyramidalPdf = { 1 } ; for ( int i = 0 ; i < 9 ; i ++ ) ninePyramidalPdf = convolve ( ninePyramidalPdf , PYRAMIDAL_DIE_PDF ) ; int [ ] sixCubicPdf = { 1 } ; for ( int i = 0 ; i < 6 ; i ++ ) sixCubicPdf = convolve ( sixCubicPdf , CUBIC_DIE_PDF ) ; long numer = 0 ; for ( int i = 0 ; i < ninePyramidalPdf . length ; i ++ ) numer += ( long ) ninePyramidalPdf [ i ] * sum ( sixCubicPdf , 0 , i ) ; long denom = ( long ) sum ( ninePyramidalPdf , 0 , ninePyramidalPdf . length ) * sum ( sixCubicPdf , 0 , sixCubicPdf . length ) ; return String . format ( \" % .7f \" , ( double ) numer / denom ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT nine_pyramidal_pdf = [ 1 ] NEW_LINE PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidal_pdf = convolve ( nine_pyramidal_pdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT six_cubic_pdf = [ 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT six_cubic_pdf = convolve ( six_cubic_pdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( nine_pyramidal_pdf ) ) : NEW_LINE INDENT ans += nine_pyramidal_pdf [ i ] * sum ( six_cubic_pdf [ : i ] ) NEW_LINE DEDENT ans = float ( ans ) / ( sum ( nine_pyramidal_pdf ) * sum ( six_cubic_pdf ) ) NEW_LINE return f \" { ans : .7f } \" NEW_LINE DEDENT def convolve ( a , b ) : NEW_LINE INDENT c = [ 0 ] * ( len ( a ) + len ( b ) - 1 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT c [ i + j ] += a [ i ] * b [ j ] NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT nine_pyramidal_pdf = [ 1 ] NEW_LINE PYRAMIDAL_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT nine_pyramidal_pdf = convolve ( nine_pyramidal_pdf , PYRAMIDAL_DIE_PDF ) NEW_LINE DEDENT six_cubic_pdf = [ 1 ] NEW_LINE CUBIC_DIE_PDF = [ 0 , 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE for i in range ( 6 ) : NEW_LINE INDENT six_cubic_pdf = convolve ( six_cubic_pdf , CUBIC_DIE_PDF ) NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( len ( nine_pyramidal_pdf ) ) : NEW_LINE INDENT ans += nine_pyramidal_pdf [ i ] * sum ( six_cubic_pdf [ : i ] ) NEW_LINE DEDENT ans = float ( ans ) / ( sum ( nine_pyramidal_pdf ) * sum ( six_cubic_pdf ) ) NEW_LINE return f \" { ans : .7f } \" NEW_LINE DEDENT"], ["convolve", "def convolve ( a , b ) : NEW_LINE INDENT c = [ 0 ] * ( len ( a ) + len ( b ) - 1 ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( b ) ) : NEW_LINE INDENT c [ i + j ] += a [ i ] * b [ j ] NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p008_A", "java": [{"id": "1", "code": "public final class p008 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p008 ( ) . run ( ) ) ; } public String run ( ) { long maxProd = - 1 ; for ( int i = 0 ; i + ADJACENT <= NUMBER . length ( ) ; i ++ ) { long prod = 1 ; for ( int j = 0 ; j < ADJACENT ; j ++ ) prod *= NUMBER . charAt ( i + j ) - '0' ; maxProd = Math . max ( prod , maxProd ) ; } return Long . toString ( maxProd ) ; } private static final int ADJACENT = 13 ; private static final String NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p008 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long maxProd = - 1 ; for ( int i = 0 ; i + ADJACENT <= NUMBER . length ( ) ; i ++ ) { long prod = 1 ; for ( int j = 0 ; j < ADJACENT ; j ++ ) prod *= NUMBER . charAt ( i + j ) - '0' ; maxProd = Math . max ( prod , maxProd ) ; } return Long . toString ( maxProd ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT NUMBER = \"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450\" NEW_LINE ADJACENT = 13 NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( digit_product ( NUMBER [ i : i + ADJACENT ] ) for i in range ( len ( NUMBER ) - ADJACENT + 1 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["digit_product", "def digit_product ( s ) : NEW_LINE INDENT result = 1 NEW_LINE for c in s : NEW_LINE INDENT result *= int ( c ) NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p030_A", "java": [{"id": "1", "code": "public final class p030 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p030 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 2 ; i < 1000000 ; i ++ ) { if ( i == fifthPowerDigitSum ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private static int fifthPowerDigitSum ( int x ) { int sum = 0 ; while ( x != 0 ) { int y = x % 10 ; sum += y * y * y * y * y ; x /= 10 ; } return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p030 ( ) . run ( ) ) ; }"], ["fifthPowerDigitSum", "private static int fifthPowerDigitSum ( int x ) { int sum = 0 ; while ( x != 0 ) { int y = x % 10 ; sum += y * y * y * y * y ; x /= 10 ; } return sum ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 2 ; i < 1000000 ; i ++ ) { if ( i == fifthPowerDigitSum ( i ) ) sum += i ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 2 , 1000000 ) if i == fifth_power_digit_sum ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def fifth_power_digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) ** 5 for c in str ( n ) ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( i for i in range ( 2 , 1000000 ) if i == fifth_power_digit_sum ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["fifth_power_digit_sum", "def fifth_power_digit_sum ( n ) : NEW_LINE INDENT return sum ( int ( c ) ** 5 for c in str ( n ) ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p006_A", "java": [{"id": "1", "code": "public final class p006 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p006 ( ) . run ( ) ) ; } private static final int N = 100 ; public String run ( ) { int sum = 0 ; int sum2 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; sum2 += i * i ; } return Integer . toString ( sum * sum - sum2 ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p006 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; int sum2 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; sum2 += i * i ; } return Integer . toString ( sum * sum - sum2 ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT N = 100 NEW_LINE s = sum ( i for i in range ( 1 , N + 1 ) ) NEW_LINE s2 = sum ( i ** 2 for i in range ( 1 , N + 1 ) ) NEW_LINE return str ( s ** 2 - s2 ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT N = 100 NEW_LINE s = sum ( i for i in range ( 1 , N + 1 ) ) NEW_LINE s2 = sum ( i ** 2 for i in range ( 1 , N + 1 ) ) NEW_LINE return str ( s ** 2 - s2 ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p039_A", "java": [{"id": "1", "code": "public final class p039 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p039 ( ) . run ( ) ) ; } public String run ( ) { int maxPerimeter = 0 ; int maxTriangles = 0 ; for ( int p = 1 ; p <= 1000 ; p ++ ) { int triangles = countSolutions ( p ) ; if ( triangles > maxTriangles ) { maxTriangles = triangles ; maxPerimeter = p ; } } return Integer . toString ( maxPerimeter ) ; } private static int countSolutions ( int p ) { int count = 0 ; for ( int a = 1 ; a <= p ; a ++ ) { for ( int b = a ; b <= p ; b ++ ) { int c = p - a - b ; if ( b <= c && a * a + b * b == c * c ) count ++ ; } } return count ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p039 ( ) . run ( ) ) ; }"], ["countSolutions", "private static int countSolutions ( int p ) { int count = 0 ; for ( int a = 1 ; a <= p ; a ++ ) { for ( int b = a ; b <= p ; b ++ ) { int c = p - a - b ; if ( b <= c && a * a + b * b == c * c ) count ++ ; } } return count ; }"]], "functions_class": [["run", "public String run ( ) { int maxPerimeter = 0 ; int maxTriangles = 0 ; for ( int p = 1 ; p <= 1000 ; p ++ ) { int triangles = countSolutions ( p ) ; if ( triangles > maxTriangles ) { maxTriangles = triangles ; maxPerimeter = p ; } } return Integer . toString ( maxPerimeter ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = max ( range ( 1 , 1001 ) , key = count_solutions ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def count_solutions ( p ) : NEW_LINE INDENT result = 0 NEW_LINE for a in range ( 1 , p + 1 ) : NEW_LINE INDENT for b in range ( a , ( p - a ) // 2 + 1 ) : NEW_LINE INDENT c = p - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = max ( range ( 1 , 1001 ) , key = count_solutions ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["count_solutions", "def count_solutions ( p ) : NEW_LINE INDENT result = 0 NEW_LINE for a in range ( 1 , p + 1 ) : NEW_LINE INDENT for b in range ( a , ( p - a ) // 2 + 1 ) : NEW_LINE INDENT c = p - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p001_A", "java": [{"id": "1", "code": "public final class p001 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p001 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( i % 3 == 0 || i % 5 == 0 ) sum += i ; } return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p001 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int i = 0 ; i < 1000 ; i ++ ) { if ( i % 3 == 0 || i % 5 == 0 ) sum += i ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( x for x in range ( 1000 ) if ( x % 3 == 0 or x % 5 == 0 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( x for x in range ( 1000 ) if ( x % 3 == 0 or x % 5 == 0 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p055_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p055 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p055 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int i = 0 ; i < 10000 ; i ++ ) { if ( isLychrel ( i ) ) count ++ ; } return Integer . toString ( count ) ; } private static boolean isLychrel ( int n ) { BigInteger temp = BigInteger . valueOf ( n ) ; for ( int i = 0 ; i < 49 ; i ++ ) { temp = temp . add ( new BigInteger ( Library . reverse ( temp . toString ( ) ) ) ) ; if ( Library . isPalindrome ( temp . toString ( ) ) ) return false ; } return true ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p055 ( ) . run ( ) ) ; }"], ["isLychrel", "private static boolean isLychrel ( int n ) { BigInteger temp = BigInteger . valueOf ( n ) ; for ( int i = 0 ; i < 49 ; i ++ ) { temp = temp . add ( new BigInteger ( Library . reverse ( temp . toString ( ) ) ) ) ; if ( Library . isPalindrome ( temp . toString ( ) ) ) return false ; } return true ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 0 ; i < 10000 ; i ++ ) { if ( isLychrel ( i ) ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 10000 ) if is_lychrel ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_lychrel ( n ) : NEW_LINE INDENT for i in range ( 50 ) : NEW_LINE INDENT n += int ( str ( n ) [ : : - 1 ] ) NEW_LINE if str ( n ) == str ( n ) [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 10000 ) if is_lychrel ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_lychrel", "def is_lychrel ( n ) : NEW_LINE INDENT for i in range ( 50 ) : NEW_LINE INDENT n += int ( str ( n ) [ : : - 1 ] ) NEW_LINE if str ( n ) == str ( n ) [ : : - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p052_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p052 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p052 ( ) . run ( ) ) ; } public String run ( ) { for ( int i = 1 ; ; i ++ ) { if ( i > Integer . MAX_VALUE / 6 ) throw new ArithmeticException ( \" Overflow \" ) ; if ( multiplesHaveSameDigits ( i ) ) return Integer . toString ( i ) ; } } private static boolean multiplesHaveSameDigits ( int x ) { for ( int i = 2 ; i <= 6 ; i ++ ) { if ( ! Arrays . equals ( toSortedDigits ( x ) , toSortedDigits ( i * x ) ) ) return false ; } return true ; } private static char [ ] toSortedDigits ( int x ) { char [ ] result = Integer . toString ( x ) . toCharArray ( ) ; Arrays . sort ( result ) ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p052 ( ) . run ( ) ) ; }"], ["multiplesHaveSameDigits", "private static boolean multiplesHaveSameDigits ( int x ) { for ( int i = 2 ; i <= 6 ; i ++ ) { if ( ! Arrays . equals ( toSortedDigits ( x ) , toSortedDigits ( i * x ) ) ) return false ; } return true ; }"], ["toSortedDigits", "private static char [ ] toSortedDigits ( int x ) { char [ ] result = Integer . toString ( x ) . toCharArray ( ) ; Arrays . sort ( result ) ; return result ; }"]], "functions_class": [["run", "public String run ( ) { for ( int i = 1 ; ; i ++ ) { if ( i > Integer . MAX_VALUE / 6 ) throw new ArithmeticException ( \" Overflow \" ) ; if ( multiplesHaveSameDigits ( i ) ) return Integer . toString ( i ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( sorted ( str ( i ) ) == sorted ( str ( j * i ) ) for j in range ( 2 , 7 ) ) NEW_LINE ans = next ( i for i in itertools . count ( 1 ) if cond ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT cond = lambda i : all ( sorted ( str ( i ) ) == sorted ( str ( j * i ) ) for j in range ( 2 , 7 ) ) NEW_LINE ans = next ( i for i in itertools . count ( 1 ) if cond ( i ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p090_A", "java": [{"id": "1", "code": "public final class p090 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p090 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { for ( int j = i ; j < ( 1 << 10 ) ; j ++ ) { if ( Integer . bitCount ( i ) == 6 && Integer . bitCount ( j ) == 6 && isArrangementValid ( i , j ) ) count ++ ; } } return Integer . toString ( count ) ; } private static int [ ] [ ] SQUARES = { { 0 , 1 } , { 0 , 4 } , { 0 , 9 } , { 1 , 6 } , { 2 , 5 } , { 3 , 6 } , { 4 , 9 } , { 6 , 4 } , { 8 , 1 } } ; private static boolean isArrangementValid ( int a , int b ) { if ( testBit ( a , 6 ) || testBit ( a , 9 ) ) a |= ( 1 << 6 ) | ( 1 << 9 ) ; if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) b |= ( 1 << 6 ) | ( 1 << 9 ) ; for ( int [ ] sqr : SQUARES ) { if ( ! ( testBit ( a , sqr [ 0 ] ) && testBit ( b , sqr [ 1 ] ) || testBit ( a , sqr [ 1 ] ) && testBit ( b , sqr [ 0 ] ) ) ) return false ; } return true ; } private static boolean testBit ( int x , int i ) { return ( ( x >>> i ) & 1 ) != 0 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p090 ( ) . run ( ) ) ; }"], ["isArrangementValid", "private static boolean isArrangementValid ( int a , int b ) { if ( testBit ( a , 6 ) || testBit ( a , 9 ) ) a |= ( 1 << 6 ) | ( 1 << 9 ) ; if ( testBit ( b , 6 ) || testBit ( b , 9 ) ) b |= ( 1 << 6 ) | ( 1 << 9 ) ; for ( int [ ] sqr : SQUARES ) { if ( ! ( testBit ( a , sqr [ 0 ] ) && testBit ( b , sqr [ 1 ] ) || testBit ( a , sqr [ 1 ] ) && testBit ( b , sqr [ 0 ] ) ) ) return false ; } return true ; }"], ["testBit", "private static boolean testBit ( int x , int i ) { return ( ( x >>> i ) & 1 ) != 0 ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { for ( int j = i ; j < ( 1 << 10 ) ; j ++ ) { if ( Integer . bitCount ( i ) == 6 && Integer . bitCount ( j ) == 6 && isArrangementValid ( i , j ) ) count ++ ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 << 10 ) for j in range ( i , 1 << 10 ) if eulerlib . popcount ( i ) == eulerlib . popcount ( j ) == 6 and is_arrangement_valid ( i , j ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def is_arrangement_valid ( a , b ) : NEW_LINE INDENT if test_bit ( a , 6 ) or test_bit ( a , 9 ) : NEW_LINE INDENT a |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT if test_bit ( b , 6 ) or test_bit ( b , 9 ) : NEW_LINE INDENT b |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT return all ( ( ( test_bit ( a , c ) and test_bit ( b , d ) ) or ( test_bit ( a , d ) and test_bit ( b , c ) ) ) for ( c , d ) in SQUARES ) NEW_LINE DEDENT def test_bit ( x , i ) : NEW_LINE INDENT return ( ( x >> i ) & 1 ) != 0 NEW_LINE DEDENT SQUARES = [ ( i ** 2 // 10 , i ** 2 % 10 ) for i in range ( 1 , 10 ) ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 << 10 ) for j in range ( i , 1 << 10 ) if eulerlib . popcount ( i ) == eulerlib . popcount ( j ) == 6 and is_arrangement_valid ( i , j ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["is_arrangement_valid", "def is_arrangement_valid ( a , b ) : NEW_LINE INDENT if test_bit ( a , 6 ) or test_bit ( a , 9 ) : NEW_LINE INDENT a |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT if test_bit ( b , 6 ) or test_bit ( b , 9 ) : NEW_LINE INDENT b |= ( 1 << 6 ) | ( 1 << 9 ) NEW_LINE DEDENT return all ( ( ( test_bit ( a , c ) and test_bit ( b , d ) ) or ( test_bit ( a , d ) and test_bit ( b , c ) ) ) for ( c , d ) in SQUARES ) NEW_LINE DEDENT"], ["test_bit", "def test_bit ( x , i ) : NEW_LINE INDENT return ( ( x >> i ) & 1 ) != 0 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p097_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p097 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p097 ( ) . run ( ) ) ; } public String run ( ) { BigInteger modulus = BigInteger . TEN . pow ( 10 ) ; BigInteger n = BigInteger . valueOf ( 2 ) . modPow ( BigInteger . valueOf ( 7830457 ) , modulus ) ; n = n . multiply ( BigInteger . valueOf ( 28433 ) ) . mod ( modulus ) ; n = n . add ( BigInteger . ONE ) . mod ( modulus ) ; return String . format ( \" % 010d \" , n ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p097 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger modulus = BigInteger . TEN . pow ( 10 ) ; BigInteger n = BigInteger . valueOf ( 2 ) . modPow ( BigInteger . valueOf ( 7830457 ) , modulus ) ; n = n . multiply ( BigInteger . valueOf ( 28433 ) ) . mod ( modulus ) ; n = n . add ( BigInteger . ONE ) . mod ( modulus ) ; return String . format ( \" % 010d \" , n ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT MOD = 10 ** 10 NEW_LINE ans = ( 28433 * pow ( 2 , 7830457 , MOD ) + 1 ) % MOD NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p063_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p063 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p063 ( ) . run ( ) ) ; } public String run ( ) { int count = 0 ; for ( int n = 1 ; n <= 9 ; n ++ ) { for ( int k = 1 ; k <= 21 ; k ++ ) { if ( BigInteger . valueOf ( n ) . pow ( k ) . toString ( ) . length ( ) == k ) count ++ ; } } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p063 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int n = 1 ; n <= 9 ; n ++ ) { for ( int k = 1 ; k <= 21 ; k ++ ) { if ( BigInteger . valueOf ( n ) . pow ( k ) . toString ( ) . length ( ) == k ) count ++ ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( 1 for i in range ( 1 , 10 ) for j in range ( 1 , 22 ) if len ( str ( i ** j ) ) == j ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p111_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p111 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p111 ( ) . run ( ) ) ; } private static final int DIGITS = 10 ; private int [ ] primes ; public String run ( ) { primes = Library . listPrimes ( ( int ) Library . sqrt ( pow ( 10 , DIGITS ) ) ) ; long total = 0 ; for ( int digit = 0 ; digit < 10 ; digit ++ ) { for ( int rep = DIGITS ; rep >= 0 ; rep -- ) { long sum = 0 ; int [ ] digits = new int [ DIGITS ] ; long count = pow ( 9 , DIGITS - rep ) ; level2 : for ( long i = 0 ; i < count ; i ++ ) { Arrays . fill ( digits , 0 , rep , digit ) ; long temp = i ; for ( int j = 0 ; j < DIGITS - rep ; j ++ ) { int d = ( int ) ( temp % 9 ) ; if ( d >= digit ) d ++ ; if ( j > 0 && d > digits [ DIGITS - j ] ) continue level2 ; digits [ DIGITS - 1 - j ] = d ; temp /= 9 ; } Arrays . sort ( digits ) ; do { if ( digits [ 0 ] > 0 ) { long num = toInteger ( digits ) ; if ( isPrime ( num ) ) sum += num ; } } while ( Library . nextPermutation ( digits ) ) ; } if ( sum > 0 ) { total += sum ; break ; } } } return Long . toString ( total ) ; } private boolean isPrime ( long n ) { for ( int p : primes ) { if ( n % p == 0 ) return false ; } return true ; } private static long toInteger ( int [ ] digits ) { long result = 0 ; for ( int x : digits ) result = result * 10 + x ; return result ; } private static long pow ( int x , int y ) { long z = 1 ; for ( int i = 0 ; i < y ; i ++ ) z *= x ; return z ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p111 ( ) . run ( ) ) ; }"], ["toInteger", "private static long toInteger ( int [ ] digits ) { long result = 0 ; for ( int x : digits ) result = result * 10 + x ; return result ; }"], ["pow", "private static long pow ( int x , int y ) { long z = 1 ; for ( int i = 0 ; i < y ; i ++ ) z *= x ; return z ; }"]], "functions_class": [["run", "public String run ( ) { primes = Library . listPrimes ( ( int ) Library . sqrt ( pow ( 10 , DIGITS ) ) ) ; long total = 0 ; for ( int digit = 0 ; digit < 10 ; digit ++ ) { for ( int rep = DIGITS ; rep >= 0 ; rep -- ) { long sum = 0 ; int [ ] digits = new int [ DIGITS ] ; long count = pow ( 9 , DIGITS - rep ) ; level2 : for ( long i = 0 ; i < count ; i ++ ) { Arrays . fill ( digits , 0 , rep , digit ) ; long temp = i ; for ( int j = 0 ; j < DIGITS - rep ; j ++ ) { int d = ( int ) ( temp % 9 ) ; if ( d >= digit ) d ++ ; if ( j > 0 && d > digits [ DIGITS - j ] ) continue level2 ; digits [ DIGITS - 1 - j ] = d ; temp /= 9 ; } Arrays . sort ( digits ) ; do { if ( digits [ 0 ] > 0 ) { long num = toInteger ( digits ) ; if ( isPrime ( num ) ) sum += num ; } } while ( Library . nextPermutation ( digits ) ) ; } if ( sum > 0 ) { total += sum ; break ; } } } return Long . toString ( total ) ; }"], ["isPrime", "private boolean isPrime ( long n ) { for ( int p : primes ) { if ( n % p == 0 ) return false ; } return true ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 10 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( 10 ** DIGITS ) ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE for p in primes : NEW_LINE INDENT if p > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = 0 NEW_LINE for digit in range ( 10 ) : NEW_LINE INDENT for rep in range ( DIGITS , - 1 , - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE digits = [ 0 ] * DIGITS NEW_LINE for i in range ( 9 ** ( DIGITS - rep ) ) : NEW_LINE INDENT for j in range ( rep ) : NEW_LINE INDENT digits [ j ] = digit NEW_LINE DEDENT temp = i NEW_LINE for j in range ( DIGITS - rep ) : NEW_LINE INDENT d = temp % 9 NEW_LINE if d >= digit : NEW_LINE INDENT d += 1 NEW_LINE DEDENT if j > 0 and d > digits [ DIGITS - j ] : NEW_LINE INDENT break NEW_LINE DEDENT digits [ - 1 - j ] = d NEW_LINE temp //= 9 NEW_LINE DEDENT else : NEW_LINE INDENT digits . sort ( ) NEW_LINE while True : NEW_LINE INDENT if digits [ 0 ] > 0 : NEW_LINE INDENT num = int ( \" \" . join ( map ( str , digits ) ) ) NEW_LINE if is_prime ( num ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT if not eulerlib . next_permutation ( digits ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if sum > 0 : NEW_LINE INDENT ans += sum NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT DIGITS = 10 NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( 10 ** DIGITS ) ) NEW_LINE def is_prime ( n ) : NEW_LINE INDENT end = eulerlib . sqrt ( n ) NEW_LINE for p in primes : NEW_LINE INDENT if p > end : NEW_LINE INDENT break NEW_LINE DEDENT if n % p == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = 0 NEW_LINE for digit in range ( 10 ) : NEW_LINE INDENT for rep in range ( DIGITS , - 1 , - 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE digits = [ 0 ] * DIGITS NEW_LINE for i in range ( 9 ** ( DIGITS - rep ) ) : NEW_LINE INDENT for j in range ( rep ) : NEW_LINE INDENT digits [ j ] = digit NEW_LINE DEDENT temp = i NEW_LINE for j in range ( DIGITS - rep ) : NEW_LINE INDENT d = temp % 9 NEW_LINE if d >= digit : NEW_LINE INDENT d += 1 NEW_LINE DEDENT if j > 0 and d > digits [ DIGITS - j ] : NEW_LINE INDENT break NEW_LINE DEDENT digits [ - 1 - j ] = d NEW_LINE temp //= 9 NEW_LINE DEDENT else : NEW_LINE INDENT digits . sort ( ) NEW_LINE while True : NEW_LINE INDENT if digits [ 0 ] > 0 : NEW_LINE INDENT num = int ( \" \" . join ( map ( str , digits ) ) ) NEW_LINE if is_prime ( num ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT if not eulerlib . next_permutation ( digits ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if sum > 0 : NEW_LINE INDENT ans += sum NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p116_A", "java": [{"id": "1", "code": "public final class p116 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p116 ( ) . run ( ) ) ; } private static final int LENGTH = 50 ; public String run ( ) { return Long . toString ( countWays ( LENGTH , 2 ) + countWays ( LENGTH , 3 ) + countWays ( LENGTH , 4 ) ) ; } private static long countWays ( int length , int m ) { long [ ] ways = new long [ length + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= length ; n ++ ) { ways [ n ] += ways [ n - 1 ] ; if ( n >= m ) ways [ n ] += ways [ n - m ] ; } return ways [ length ] - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p116 ( ) . run ( ) ) ; }"], ["countWays", "private static long countWays ( int length , int m ) { long [ ] ways = new long [ length + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= length ; n ++ ) { ways [ n ] += ways [ n - 1 ] ; if ( n >= m ) ways [ n ] += ways [ n - m ] ; } return ways [ length ] - 1 ; }"]], "functions_class": [["run", "public String run ( ) { return Long . toString ( countWays ( LENGTH , 2 ) + countWays ( LENGTH , 3 ) + countWays ( LENGTH , 4 ) ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE return str ( sum ( count_ways ( LENGTH , i ) for i in range ( 2 , 5 ) ) ) NEW_LINE DEDENT def count_ways ( length , m ) : NEW_LINE INDENT ways = [ 1 ] + [ 0 ] * length NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ - 1 ] - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE return str ( sum ( count_ways ( LENGTH , i ) for i in range ( 2 , 5 ) ) ) NEW_LINE DEDENT"], ["count_ways", "def count_ways ( length , m ) : NEW_LINE INDENT ways = [ 1 ] + [ 0 ] * length NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += ways [ n - 1 ] NEW_LINE if n >= m : NEW_LINE INDENT ways [ n ] += ways [ n - m ] NEW_LINE DEDENT DEDENT return ways [ - 1 ] - 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p129_A", "java": [{"id": "1", "code": "public final class p129 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p129 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { for ( int n = LIMIT ; ; n ++ ) { if ( findLeastDivisibleRepunit ( n ) > LIMIT ) return Integer . toString ( n ) ; } } private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( \" Arithmetic \u2581 overflow \" ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p129 ( ) . run ( ) ) ; }"], ["findLeastDivisibleRepunit", "private static int findLeastDivisibleRepunit ( int n ) { if ( n % 2 == 0 || n % 5 == 0 ) return 0 ; if ( n > Integer . MAX_VALUE / 10 ) throw new IllegalArgumentException ( \" Arithmetic \u2581 overflow \" ) ; int sum = 1 ; int pow = 1 ; int k = 1 ; while ( sum % n != 0 ) { k ++ ; pow = pow * 10 % n ; sum = ( sum + pow ) % n ; } return k ; }"]], "functions_class": [["run", "public String run ( ) { for ( int n = LIMIT ; ; n ++ ) { if ( findLeastDivisibleRepunit ( n ) > LIMIT ) return Integer . toString ( n ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 6 NEW_LINE for n in itertools . count ( LIMIT ) : NEW_LINE INDENT if least_divisible_repunit ( n ) > LIMIT : NEW_LINE INDENT return str ( n ) NEW_LINE DEDENT DEDENT DEDENT"], ["least_divisible_repunit", "def least_divisible_repunit ( n ) : NEW_LINE INDENT if n % 2 == 0 or n % 5 == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = 1 NEW_LINE s = 1 NEW_LINE p = 1 NEW_LINE while s % n != 0 : NEW_LINE INDENT k += 1 NEW_LINE p = p * 10 % n NEW_LINE s = ( s + p ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p120_A", "java": [{"id": "1", "code": "public final class p120 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p120 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int a = 3 ; a <= 1000 ; a ++ ) sum += a * ( a - ( a % 2 == 0 ? 2 : 1 ) ) ; return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p120 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int a = 3 ; a <= 1000 ; a ++ ) sum += a * ( a - ( a % 2 == 0 ? 2 : 1 ) ) ; return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT ans = sum ( i * ( i - ( 2 if i % 2 == 0 else 1 ) ) for i in range ( 3 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = sum ( i * ( i - ( 2 if i % 2 == 0 else 1 ) ) for i in range ( 3 , 1001 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p315_A", "java": [{"id": "1", "code": "public final class p315 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p315 ( ) . run ( ) ) ; } public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( 20000000 ) ; int sum = 0 ; for ( int i = 10000000 ; i < isPrime . length ; i ++ ) { if ( isPrime [ i ] ) sum += samTransitionsMinusMaxTransitions ( i ) ; } return Integer . toString ( sum ) ; } private static int samTransitionsMinusMaxTransitions ( int n ) { int samTrans = 0 ; int maxTrans = 0 ; long segmentState = 0 ; while ( true ) { long newState = numberToSegments ( n ) ; if ( newState == segmentState ) break ; maxTrans += Long . bitCount ( newState ^ segmentState ) ; segmentState = newState ; samTrans += 2 * Long . bitCount ( newState ) ; n = digitSum ( n ) ; } maxTrans += Long . bitCount ( segmentState ) ; return samTrans - maxTrans ; } private static long numberToSegments ( int n ) { if ( n < 0 || n > 999999999 ) throw new IllegalArgumentException ( ) ; long result = 0 ; int i = 0 ; do { result |= ( long ) DECIMAL_DIGIT_TO_SEGMENT [ n % 10 ] << ( i * 7 ) ; n /= 10 ; i ++ ; } while ( n != 0 ) ; return result ; } private static int digitSum ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( ) ; int result = 0 ; while ( n != 0 ) { result += n % 10 ; n /= 10 ; } return result ; } private static final int [ ] DECIMAL_DIGIT_TO_SEGMENT = { 0x77 , 0x12 , 0x5D , 0x5B , 0x3A , 0x6B , 0x6F , 0x72 , 0x7F , 0x7B } ; }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p315 ( ) . run ( ) ) ; }"], ["samTransitionsMinusMaxTransitions", "private static int samTransitionsMinusMaxTransitions ( int n ) { int samTrans = 0 ; int maxTrans = 0 ; long segmentState = 0 ; while ( true ) { long newState = numberToSegments ( n ) ; if ( newState == segmentState ) break ; maxTrans += Long . bitCount ( newState ^ segmentState ) ; segmentState = newState ; samTrans += 2 * Long . bitCount ( newState ) ; n = digitSum ( n ) ; } maxTrans += Long . bitCount ( segmentState ) ; return samTrans - maxTrans ; }"], ["numberToSegments", "private static long numberToSegments ( int n ) { if ( n < 0 || n > 999999999 ) throw new IllegalArgumentException ( ) ; long result = 0 ; int i = 0 ; do { result |= ( long ) DECIMAL_DIGIT_TO_SEGMENT [ n % 10 ] << ( i * 7 ) ; n /= 10 ; i ++ ; } while ( n != 0 ) ; return result ; }"], ["digitSum", "private static int digitSum ( int n ) { if ( n < 0 ) throw new IllegalArgumentException ( ) ; int result = 0 ; while ( n != 0 ) { result += n % 10 ; n /= 10 ; } return result ; }"]], "functions_class": [["run", "public String run ( ) { boolean [ ] isPrime = Library . listPrimality ( 20000000 ) ; int sum = 0 ; for ( int i = 10000000 ; i < isPrime . length ; i ++ ) { if ( isPrime [ i ] ) sum += samTransitionsMinusMaxTransitions ( i ) ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 20000000 ) NEW_LINE ans = sum ( sam_transitions_minus_max_transitions ( i ) for ( i , p ) in enumerate ( isprime ) if i >= 10000000 and p ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def sam_transitions_minus_max_transitions ( n ) : NEW_LINE INDENT samtrans = 0 NEW_LINE maxtrans = 0 NEW_LINE segmentstate = 0 NEW_LINE while True : NEW_LINE INDENT newstate = number_to_segments ( n ) NEW_LINE if newstate == segmentstate : NEW_LINE INDENT break NEW_LINE DEDENT maxtrans += eulerlib . popcount ( newstate ^ segmentstate ) NEW_LINE segmentstate = newstate NEW_LINE samtrans += 2 * eulerlib . popcount ( newstate ) NEW_LINE n = digit_sum ( n ) NEW_LINE DEDENT maxtrans += eulerlib . popcount ( segmentstate ) NEW_LINE return samtrans - maxtrans NEW_LINE DEDENT def number_to_segments ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT result = 0 NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT result |= DECIMAL_DIGIT_TO_SEGMENT [ n % 10 ] << ( i * 7 ) NEW_LINE n //= 10 NEW_LINE i += 1 NEW_LINE if n == 0 : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT def digit_sum ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT DECIMAL_DIGIT_TO_SEGMENT = [ 0b1110111 , 0b0010010 , 0b1011101 , 0b1011011 , 0b0111010 , 0b1101011 , 0b1101111 , 0b1110010 , 0b1111111 , 0b1111011 ] NEW_LINE if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 20000000 ) NEW_LINE ans = sum ( sam_transitions_minus_max_transitions ( i ) for ( i , p ) in enumerate ( isprime ) if i >= 10000000 and p ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["sam_transitions_minus_max_transitions", "def sam_transitions_minus_max_transitions ( n ) : NEW_LINE INDENT samtrans = 0 NEW_LINE maxtrans = 0 NEW_LINE segmentstate = 0 NEW_LINE while True : NEW_LINE INDENT newstate = number_to_segments ( n ) NEW_LINE if newstate == segmentstate : NEW_LINE INDENT break NEW_LINE DEDENT maxtrans += eulerlib . popcount ( newstate ^ segmentstate ) NEW_LINE segmentstate = newstate NEW_LINE samtrans += 2 * eulerlib . popcount ( newstate ) NEW_LINE n = digit_sum ( n ) NEW_LINE DEDENT maxtrans += eulerlib . popcount ( segmentstate ) NEW_LINE return samtrans - maxtrans NEW_LINE DEDENT"], ["number_to_segments", "def number_to_segments ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT result = 0 NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT result |= DECIMAL_DIGIT_TO_SEGMENT [ n % 10 ] << ( i * 7 ) NEW_LINE n //= 10 NEW_LINE i += 1 NEW_LINE if n == 0 : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT"], ["digit_sum", "def digit_sum ( n ) : NEW_LINE INDENT if n < 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT result = 0 NEW_LINE while n != 0 : NEW_LINE INDENT result += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return result NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p127_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p127 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p127 ( ) . run ( ) ) ; } private static final int LIMIT = 120000 ; public String run ( ) { int [ ] rads = new int [ LIMIT ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } long sum = 0 ; for ( int c = 2 ; c < LIMIT ; c ++ ) { if ( rads [ c ] == c ) continue ; for ( int a = 1 , end = ( c - 1 ) / 2 ; a <= end ; a ++ ) { int b = c - a ; assert a < b ; if ( ( long ) rads [ a ] * rads [ b ] * rads [ c ] < c && Library . gcd ( a , b ) == 1 ) sum += c ; } } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p127 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] rads = new int [ LIMIT ] ; Arrays . fill ( rads , 1 , rads . length , 1 ) ; for ( int i = 2 ; i < rads . length ; i ++ ) { if ( rads [ i ] == 1 ) { for ( int j = i ; j < rads . length ; j += i ) rads [ j ] *= i ; } } long sum = 0 ; for ( int c = 2 ; c < LIMIT ; c ++ ) { if ( rads [ c ] == c ) continue ; for ( int a = 1 , end = ( c - 1 ) / 2 ; a <= end ; a ++ ) { int b = c - a ; assert a < b ; if ( ( long ) rads [ a ] * rads [ b ] * rads [ c ] < c && Library . gcd ( a , b ) == 1 ) sum += c ; } } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 120000 NEW_LINE rads = [ 0 ] + [ 1 ] * ( LIMIT - 1 ) NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT sortedrads = sorted ( ( rad , n ) for ( n , rad ) in enumerate ( rads ) ) NEW_LINE sortedrads = sortedrads [ 1 : ] NEW_LINE ans = 0 NEW_LINE for c in range ( 2 , LIMIT ) : NEW_LINE INDENT for ( rad , a ) in sortedrads : NEW_LINE INDENT rad *= rads [ c ] NEW_LINE if rad >= c : NEW_LINE INDENT break NEW_LINE DEDENT b = c - a NEW_LINE if a < b and rad * rads [ b ] < c and fractions . gcd ( a , b ) == 1 : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 120000 NEW_LINE rads = [ 0 ] + [ 1 ] * ( LIMIT - 1 ) NEW_LINE for i in range ( 2 , len ( rads ) ) : NEW_LINE INDENT if rads [ i ] == 1 : NEW_LINE INDENT for j in range ( i , len ( rads ) , i ) : NEW_LINE INDENT rads [ j ] *= i NEW_LINE DEDENT DEDENT DEDENT sortedrads = sorted ( ( rad , n ) for ( n , rad ) in enumerate ( rads ) ) NEW_LINE sortedrads = sortedrads [ 1 : ] NEW_LINE ans = 0 NEW_LINE for c in range ( 2 , LIMIT ) : NEW_LINE INDENT for ( rad , a ) in sortedrads : NEW_LINE INDENT rad *= rads [ c ] NEW_LINE if rad >= c : NEW_LINE INDENT break NEW_LINE DEDENT b = c - a NEW_LINE if a < b and rad * rads [ b ] < c and fractions . gcd ( a , b ) == 1 : NEW_LINE INDENT ans += c NEW_LINE DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p118_A", "java": [{"id": "1", "code": "public final class p118 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p118 ( ) . run ( ) ) ; } public String run ( ) { isPrime = Library . listPrimality ( 10000 ) ; count = 0 ; int [ ] digits = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; do countPrimeSets ( digits , 0 , 0 ) ; while ( Library . nextPermutation ( digits ) ) ; return Integer . toString ( count ) ; } private boolean [ ] isPrime ; private int count ; private void countPrimeSets ( int [ ] digits , int startIndex , int prevNum ) { if ( startIndex == digits . length ) count ++ ; else { for ( int split = startIndex + 1 ; split <= digits . length ; split ++ ) { int num = toInteger ( digits , startIndex , split ) ; if ( num > prevNum && isPrime ( num ) ) countPrimeSets ( digits , split , num ) ; } } } private boolean isPrime ( int n ) { if ( n < isPrime . length ) return isPrime [ n ] ; else return Library . isPrime ( n ) ; } private static int toInteger ( int [ ] digits , int start , int end ) { int result = 0 ; for ( int i = start ; i < end ; i ++ ) result = result * 10 + digits [ i ] ; return result ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p118 ( ) . run ( ) ) ; }"], ["toInteger", "private static int toInteger ( int [ ] digits , int start , int end ) { int result = 0 ; for ( int i = start ; i < end ; i ++ ) result = result * 10 + digits [ i ] ; return result ; }"]], "functions_class": [["run", "public String run ( ) { isPrime = Library . listPrimality ( 10000 ) ; count = 0 ; int [ ] digits = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; do countPrimeSets ( digits , 0 , 0 ) ; while ( Library . nextPermutation ( digits ) ) ; return Integer . toString ( count ) ; }"], ["countPrimeSets", "private void countPrimeSets ( int [ ] digits , int startIndex , int prevNum ) { if ( startIndex == digits . length ) count ++ ; else { for ( int split = startIndex + 1 ; split <= digits . length ; split ++ ) { int num = toInteger ( digits , startIndex , split ) ; if ( num > prevNum && isPrime ( num ) ) countPrimeSets ( digits , split , num ) ; } } }"], ["isPrime", "private boolean isPrime ( int n ) { if ( n < isPrime . length ) return isPrime [ n ] ; else return Library . isPrime ( n ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10000 ) NEW_LINE digits = list ( range ( 1 , 10 ) ) NEW_LINE def count_prime_sets ( startindex , prevnum ) : NEW_LINE INDENT if startindex == len ( digits ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE for split in range ( startindex + 1 , len ( digits ) + 1 ) : NEW_LINE INDENT num = int ( \" \" . join ( map ( str , digits [ startindex : split ] ) ) ) NEW_LINE if num > prevnum and is_prime ( num ) : NEW_LINE INDENT result += count_prime_sets ( split , num ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n < len ( isprime ) : NEW_LINE INDENT return isprime [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE while True : NEW_LINE INDENT ans += count_prime_sets ( 0 , 0 ) NEW_LINE if not eulerlib . next_permutation ( digits ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT isprime = eulerlib . list_primality ( 10000 ) NEW_LINE digits = list ( range ( 1 , 10 ) ) NEW_LINE def count_prime_sets ( startindex , prevnum ) : NEW_LINE INDENT if startindex == len ( digits ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE for split in range ( startindex + 1 , len ( digits ) + 1 ) : NEW_LINE INDENT num = int ( \" \" . join ( map ( str , digits [ startindex : split ] ) ) ) NEW_LINE if num > prevnum and is_prime ( num ) : NEW_LINE INDENT result += count_prime_sets ( split , num ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT def is_prime ( n ) : NEW_LINE INDENT if n < len ( isprime ) : NEW_LINE INDENT return isprime [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return eulerlib . is_prime ( n ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE while True : NEW_LINE INDENT ans += count_prime_sets ( 0 , 0 ) NEW_LINE if not eulerlib . next_permutation ( digits ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p173_A", "java": [{"id": "1", "code": "public final class p173 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p173 ( ) . run ( ) ) ; } private static final int TILES = 1000000 ; public String run ( ) { int count = 0 ; for ( int n = 3 ; n <= TILES / 4 + 1 ; n ++ ) { for ( int k = n - 2 ; k >= 1 ; k -= 2 ) { if ( ( long ) n * n - ( long ) k * k > TILES ) break ; count ++ ; } } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p173 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; for ( int n = 3 ; n <= TILES / 4 + 1 ; n ++ ) { for ( int k = n - 2 ; k >= 1 ; k -= 2 ) { if ( ( long ) n * n - ( long ) k * k > TILES ) break ; count ++ ; } } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT TILES = 10 ** 6 NEW_LINE ans = 0 NEW_LINE for n in range ( 3 , TILES // 4 + 2 ) : NEW_LINE INDENT for k in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT if n * n - k * k > TILES : NEW_LINE INDENT break NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TILES = 10 ** 6 NEW_LINE ans = 0 NEW_LINE for n in range ( 3 , TILES // 4 + 2 ) : NEW_LINE INDENT for k in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT if n * n - k * k > TILES : NEW_LINE INDENT break NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p187_A", "java": [{"id": "1", "code": "import java . util . Arrays ; public final class p187 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p187 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) - 1 ; public String run ( ) { int count = 0 ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; for ( int i = 0 , sqrt = Library . sqrt ( LIMIT ) ; i < primes . length && primes [ i ] <= sqrt ; i ++ ) { int end = Arrays . binarySearch ( primes , LIMIT / primes [ i ] ) ; if ( end >= 0 ) end ++ ; else end = - end - 1 ; count += end - i ; } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p187 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 0 ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; for ( int i = 0 , sqrt = Library . sqrt ( LIMIT ) ; i < primes . length && primes [ i ] <= sqrt ; i ++ ) { int end = Arrays . binarySearch ( primes , LIMIT / primes [ i ] ) ; if ( end >= 0 ) end ++ ; else end = - end - 1 ; count += end - i ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = 0 NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE sqrt = eulerlib . sqrt ( LIMIT ) NEW_LINE for ( i , p ) in enumerate ( primes ) : NEW_LINE INDENT if p > sqrt : NEW_LINE INDENT break NEW_LINE DEDENT end = binary_search ( primes , LIMIT // p ) NEW_LINE ans += ( end + 1 if end >= 0 else - end - 1 ) - i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT def binary_search ( lst , x ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( lst ) NEW_LINE while start < end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if x < lst [ mid ] : NEW_LINE INDENT end = mid NEW_LINE DEDENT elif x > lst [ mid ] : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif x == lst [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT return - start - 1 NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 - 1 NEW_LINE ans = 0 NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE sqrt = eulerlib . sqrt ( LIMIT ) NEW_LINE for ( i , p ) in enumerate ( primes ) : NEW_LINE INDENT if p > sqrt : NEW_LINE INDENT break NEW_LINE DEDENT end = binary_search ( primes , LIMIT // p ) NEW_LINE ans += ( end + 1 if end >= 0 else - end - 1 ) - i NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT"], ["binary_search", "def binary_search ( lst , x ) : NEW_LINE INDENT start = 0 NEW_LINE end = len ( lst ) NEW_LINE while start < end : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if x < lst [ mid ] : NEW_LINE INDENT end = mid NEW_LINE DEDENT elif x > lst [ mid ] : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT elif x == lst [ mid ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT return - start - 1 NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p346_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p346 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p346 ( ) . run ( ) ) ; } private static final long LIMIT = 1_000_000_000_000L ; public String run ( ) { Set < Long > strongRepunits = new HashSet < > ( ) ; strongRepunits . add ( 1L ) ; for ( int length = 3 ; length <= BigInteger . valueOf ( LIMIT ) . bitLength ( ) ; length ++ ) { middle : for ( int base = 2 ; ; base ++ ) { long value = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( Long . MAX_VALUE / base < value ) break middle ; value *= base ; if ( value + 1 < value ) break middle ; value ++ ; } if ( value >= LIMIT ) break ; strongRepunits . add ( value ) ; } } long sum = 0 ; for ( long x : strongRepunits ) { if ( sum + x < sum ) throw new ArithmeticException ( \" Overflow \" ) ; sum += x ; } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p346 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < Long > strongRepunits = new HashSet < > ( ) ; strongRepunits . add ( 1L ) ; for ( int length = 3 ; length <= BigInteger . valueOf ( LIMIT ) . bitLength ( ) ; length ++ ) { middle : for ( int base = 2 ; ; base ++ ) { long value = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( Long . MAX_VALUE / base < value ) break middle ; value *= base ; if ( value + 1 < value ) break middle ; value ++ ; } if ( value >= LIMIT ) break ; strongRepunits . add ( value ) ; } } long sum = 0 ; for ( long x : strongRepunits ) { if ( sum + x < sum ) throw new ArithmeticException ( \" Overflow \" ) ; sum += x ; } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 12 NEW_LINE strongrepunits = { 1 } NEW_LINE for length in range ( 3 , LIMIT . bit_length ( ) + 1 ) : NEW_LINE INDENT for base in itertools . count ( 2 ) : NEW_LINE INDENT value = ( base ** length - 1 ) // ( base - 1 ) NEW_LINE if value >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT strongrepunits . add ( value ) NEW_LINE DEDENT DEDENT ans = sum ( strongrepunits ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 12 NEW_LINE strongrepunits = { 1 } NEW_LINE for length in range ( 3 , LIMIT . bit_length ( ) + 1 ) : NEW_LINE INDENT for base in itertools . count ( 2 ) : NEW_LINE INDENT value = ( base ** length - 1 ) // ( base - 1 ) NEW_LINE if value >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT strongrepunits . add ( value ) NEW_LINE DEDENT DEDENT ans = sum ( strongrepunits ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p174_A", "java": [{"id": "1", "code": "public final class p174 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p174 ( ) . run ( ) ) ; } private static final int SIZE_LIMIT = 1000000 ; private static final int TYPE_LIMIT = 10 ; public String run ( ) { int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; ( n - 1 ) * 4 <= SIZE_LIMIT ; n ++ ) { for ( int m = n - 2 ; m >= 1 ; m -= 2 ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int count = 0 ; for ( int t : type ) { if ( 1 <= t && t <= TYPE_LIMIT ) count ++ ; } return Integer . toString ( count ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p174 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int [ ] type = new int [ SIZE_LIMIT + 1 ] ; for ( int n = 3 ; ( n - 1 ) * 4 <= SIZE_LIMIT ; n ++ ) { for ( int m = n - 2 ; m >= 1 ; m -= 2 ) { int tiles = n * n - m * m ; if ( tiles > SIZE_LIMIT ) break ; type [ tiles ] ++ ; } } int count = 0 ; for ( int t : type ) { if ( 1 <= t && t <= TYPE_LIMIT ) count ++ ; } return Integer . toString ( count ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT SIZE_LIMIT = 1000000 NEW_LINE TYPE_LIMIT = 10 NEW_LINE type = [ 0 ] * ( SIZE_LIMIT + 1 ) NEW_LINE for n in range ( 3 , SIZE_LIMIT // 4 + 2 ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( 1 for t in type if 1 <= t <= TYPE_LIMIT ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT SIZE_LIMIT = 1000000 NEW_LINE TYPE_LIMIT = 10 NEW_LINE type = [ 0 ] * ( SIZE_LIMIT + 1 ) NEW_LINE for n in range ( 3 , SIZE_LIMIT // 4 + 2 ) : NEW_LINE INDENT for m in range ( n - 2 , 0 , - 2 ) : NEW_LINE INDENT tiles = n * n - m * m NEW_LINE if tiles > SIZE_LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT type [ tiles ] += 1 NEW_LINE DEDENT DEDENT ans = sum ( 1 for t in type if 1 <= t <= TYPE_LIMIT ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p142_A", "java": [{"id": "1", "code": "public final class p142 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p142 ( ) . run ( ) ) ; } private boolean [ ] isSquare ; public String run ( ) { int sumLimit = 10 ; while ( true ) { isSquare = new boolean [ sumLimit ] ; for ( int i = 0 ; i * i < sumLimit ; i ++ ) isSquare [ i * i ] = true ; int sum = findSum ( sumLimit ) ; if ( sum != - 1 ) { sum = sumLimit ; break ; } sumLimit *= 10 ; } while ( true ) { int sum = findSum ( sumLimit ) ; if ( sum == - 1 ) return Integer . toString ( sumLimit ) ; sumLimit = sum ; } } private int findSum ( int limit ) { for ( int a = 1 ; a * a < limit ; a ++ ) { for ( int b = a - 1 ; b > 0 ; b -- ) { if ( ( a + b ) % 2 != 0 ) continue ; int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) continue ; int zlimit = Math . min ( y , limit - x - y ) ; for ( int c = Library . sqrt ( y ) + 1 ; c * c - y < zlimit ; c ++ ) { int z = c * c - y ; if ( isSquare [ x + z ] && isSquare [ x - z ] && isSquare [ y - z ] ) return x + y + z ; } } } return - 1 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p142 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sumLimit = 10 ; while ( true ) { isSquare = new boolean [ sumLimit ] ; for ( int i = 0 ; i * i < sumLimit ; i ++ ) isSquare [ i * i ] = true ; int sum = findSum ( sumLimit ) ; if ( sum != - 1 ) { sum = sumLimit ; break ; } sumLimit *= 10 ; } while ( true ) { int sum = findSum ( sumLimit ) ; if ( sum == - 1 ) return Integer . toString ( sumLimit ) ; sumLimit = sum ; } }"], ["findSum", "private int findSum ( int limit ) { for ( int a = 1 ; a * a < limit ; a ++ ) { for ( int b = a - 1 ; b > 0 ; b -- ) { if ( ( a + b ) % 2 != 0 ) continue ; int x = ( a * a + b * b ) / 2 ; int y = ( a * a - b * b ) / 2 ; if ( x + y + 1 >= limit ) continue ; int zlimit = Math . min ( y , limit - x - y ) ; for ( int c = Library . sqrt ( y ) + 1 ; c * c - y < zlimit ; c ++ ) { int z = c * c - y ; if ( isSquare [ x + z ] && isSquare [ x - z ] && isSquare [ y - z ] ) return x + y + z ; } } } return - 1 ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT def find_sum ( limit ) : NEW_LINE INDENT for a in itertools . count ( 1 ) : NEW_LINE INDENT if a * a >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for b in reversed ( range ( 1 , a ) ) : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in itertools . count ( eulerlib . sqrt ( y ) + 1 ) : NEW_LINE INDENT z = c * c - y NEW_LINE if z >= zlimit : NEW_LINE INDENT break NEW_LINE DEDENT if issquare [ x + z ] and issquare [ x - z ] and issquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT sumlimit = 10 NEW_LINE while True : NEW_LINE INDENT issquare = [ False ] * sumlimit NEW_LINE for i in range ( eulerlib . sqrt ( len ( issquare ) - 1 ) + 1 ) : NEW_LINE INDENT issquare [ i * i ] = True NEW_LINE DEDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is not None : NEW_LINE INDENT sum = sumlimit NEW_LINE break NEW_LINE DEDENT sumlimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is None : NEW_LINE INDENT return str ( sumlimit ) NEW_LINE DEDENT sumlimit = sum NEW_LINE DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT def find_sum ( limit ) : NEW_LINE INDENT for a in itertools . count ( 1 ) : NEW_LINE INDENT if a * a >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for b in reversed ( range ( 1 , a ) ) : NEW_LINE INDENT if ( a + b ) % 2 != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = ( a * a + b * b ) // 2 NEW_LINE y = ( a * a - b * b ) // 2 NEW_LINE if x + y + 1 >= limit : NEW_LINE INDENT continue NEW_LINE DEDENT zlimit = min ( y , limit - x - y ) NEW_LINE for c in itertools . count ( eulerlib . sqrt ( y ) + 1 ) : NEW_LINE INDENT z = c * c - y NEW_LINE if z >= zlimit : NEW_LINE INDENT break NEW_LINE DEDENT if issquare [ x + z ] and issquare [ x - z ] and issquare [ y - z ] : NEW_LINE INDENT return x + y + z NEW_LINE DEDENT DEDENT DEDENT DEDENT return None NEW_LINE DEDENT sumlimit = 10 NEW_LINE while True : NEW_LINE INDENT issquare = [ False ] * sumlimit NEW_LINE for i in range ( eulerlib . sqrt ( len ( issquare ) - 1 ) + 1 ) : NEW_LINE INDENT issquare [ i * i ] = True NEW_LINE DEDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is not None : NEW_LINE INDENT sum = sumlimit NEW_LINE break NEW_LINE DEDENT sumlimit *= 10 NEW_LINE DEDENT while True : NEW_LINE INDENT sum = find_sum ( sumlimit ) NEW_LINE if sum is None : NEW_LINE INDENT return str ( sumlimit ) NEW_LINE DEDENT sumlimit = sum NEW_LINE DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p348_A", "java": [{"id": "1", "code": "public final class p348 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p348 ( ) . run ( ) ) ; } private static final int TARGET_WAYS = 4 ; private static final int TARGET_COUNT = 5 ; static { assert 0 <= TARGET_COUNT ; assert 0 <= TARGET_WAYS && TARGET_WAYS <= Byte . MAX_VALUE - 1 ; } public String run ( ) { for ( long limit = 1 ; ; limit *= 10 ) { if ( limit > Integer . MAX_VALUE ) throw new AssertionError ( \" Overflow \" ) ; long answer = trySearch ( ( int ) limit ) ; if ( answer != - 1 ) return Long . toString ( answer ) ; } } private static long trySearch ( int limit ) { byte [ ] ways = new byte [ limit ] ; for ( int i = cbrt ( limit - 1 ) ; i > 1 ; i -- ) { int cube = i * i * i ; for ( int j = Library . sqrt ( limit - 1 - cube ) ; j > 1 ; j -- ) { int index = cube + j * j ; ways [ index ] = ( byte ) Math . min ( ways [ index ] + 1 , TARGET_WAYS + 1 ) ; } } long result = 0 ; int count = 0 ; for ( int i = 0 ; i < ways . length ; i ++ ) { if ( ways [ i ] == TARGET_WAYS && Library . isPalindrome ( i ) ) { result += i ; count ++ ; if ( count == TARGET_COUNT ) return result ; } } return - 1 ; } private static int cbrt ( int x ) { if ( x < 0 ) throw new IllegalArgumentException ( \" Not \u2581 implemented \" ) ; int y = 0 ; for ( int i = 1 << 10 ; i != 0 ; i >>>= 1 ) { y |= i ; if ( y > 1290 || y * y * y > x ) y ^= i ; } return y ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p348 ( ) . run ( ) ) ; }"], ["trySearch", "private static long trySearch ( int limit ) { byte [ ] ways = new byte [ limit ] ; for ( int i = cbrt ( limit - 1 ) ; i > 1 ; i -- ) { int cube = i * i * i ; for ( int j = Library . sqrt ( limit - 1 - cube ) ; j > 1 ; j -- ) { int index = cube + j * j ; ways [ index ] = ( byte ) Math . min ( ways [ index ] + 1 , TARGET_WAYS + 1 ) ; } } long result = 0 ; int count = 0 ; for ( int i = 0 ; i < ways . length ; i ++ ) { if ( ways [ i ] == TARGET_WAYS && Library . isPalindrome ( i ) ) { result += i ; count ++ ; if ( count == TARGET_COUNT ) return result ; } } return - 1 ; }"], ["cbrt", "private static int cbrt ( int x ) { if ( x < 0 ) throw new IllegalArgumentException ( \" Not \u2581 implemented \" ) ; int y = 0 ; for ( int i = 1 << 10 ; i != 0 ; i >>>= 1 ) { y |= i ; if ( y > 1290 || y * y * y > x ) y ^= i ; } return y ; }"]], "functions_class": [["run", "public String run ( ) { for ( long limit = 1 ; ; limit *= 10 ) { if ( limit > Integer . MAX_VALUE ) throw new AssertionError ( \" Overflow \" ) ; long answer = trySearch ( ( int ) limit ) ; if ( answer != - 1 ) return Long . toString ( answer ) ; } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE TARGET_WAYS = 4 NEW_LINE TARGET_COUNT = 5 NEW_LINE def compute ( ) : NEW_LINE INDENT for i in itertools . count ( ) : NEW_LINE INDENT limit = 10 ** i NEW_LINE ans = try_search ( limit ) NEW_LINE if ans is not None : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT DEDENT DEDENT def try_search ( limit ) : NEW_LINE INDENT ways = { } NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT cube = i ** 3 NEW_LINE if cube >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 2 , eulerlib . sqrt ( limit - 1 - cube ) + 1 ) : NEW_LINE INDENT index = cube + j ** 2 NEW_LINE ways [ index ] = ways . get ( index , 0 ) + 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE count = 0 NEW_LINE for i in sorted ( ways . keys ( ) ) : NEW_LINE INDENT if ways [ i ] == TARGET_WAYS and is_palindrome ( i ) : NEW_LINE INDENT result += i NEW_LINE count += 1 NEW_LINE if count == TARGET_COUNT : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT def is_palindrome ( x ) : NEW_LINE INDENT s = str ( x ) NEW_LINE return s == s [ : : - 1 ] NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT for i in itertools . count ( ) : NEW_LINE INDENT limit = 10 ** i NEW_LINE ans = try_search ( limit ) NEW_LINE if ans is not None : NEW_LINE INDENT return str ( ans ) NEW_LINE DEDENT DEDENT DEDENT"], ["try_search", "def try_search ( limit ) : NEW_LINE INDENT ways = { } NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT cube = i ** 3 NEW_LINE if cube >= limit : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( 2 , eulerlib . sqrt ( limit - 1 - cube ) + 1 ) : NEW_LINE INDENT index = cube + j ** 2 NEW_LINE ways [ index ] = ways . get ( index , 0 ) + 1 NEW_LINE DEDENT DEDENT result = 0 NEW_LINE count = 0 NEW_LINE for i in sorted ( ways . keys ( ) ) : NEW_LINE INDENT if ways [ i ] == TARGET_WAYS and is_palindrome ( i ) : NEW_LINE INDENT result += i NEW_LINE count += 1 NEW_LINE if count == TARGET_COUNT : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT DEDENT return None NEW_LINE DEDENT"], ["is_palindrome", "def is_palindrome ( x ) : NEW_LINE INDENT s = str ( x ) NEW_LINE return s == s [ : : - 1 ] NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p145_A", "java": [{"id": "1", "code": "public final class p145 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p145 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int digits = 1 ; digits <= 9 ; digits ++ ) { if ( digits % 2 == 0 ) sum += 20 * Library . pow ( 30 , digits / 2 - 1 ) ; else if ( digits % 4 == 3 ) sum += 100 * Library . pow ( 500 , ( digits - 3 ) / 4 ) ; else if ( digits % 4 == 1 ) sum += 0 ; else throw new AssertionError ( ) ; } return Integer . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p145 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int sum = 0 ; for ( int digits = 1 ; digits <= 9 ; digits ++ ) { if ( digits % 2 == 0 ) sum += 20 * Library . pow ( 30 , digits / 2 - 1 ) ; else if ( digits % 4 == 3 ) sum += 100 * Library . pow ( 500 , ( digits - 3 ) / 4 ) ; else if ( digits % 4 == 1 ) sum += 0 ; else throw new AssertionError ( ) ; } return Integer . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT def count_reversibles ( numdigits ) : NEW_LINE INDENT if numdigits % 2 == 0 : NEW_LINE INDENT return 20 * 30 ** ( numdigits // 2 - 1 ) NEW_LINE DEDENT elif numdigits % 4 == 3 : NEW_LINE INDENT return 100 * 500 ** ( ( numdigits - 3 ) // 4 ) NEW_LINE DEDENT elif numdigits % 4 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT ans = sum ( count_reversibles ( d ) for d in range ( 2 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT def count_reversibles ( numdigits ) : NEW_LINE INDENT if numdigits % 2 == 0 : NEW_LINE INDENT return 20 * 30 ** ( numdigits // 2 - 1 ) NEW_LINE DEDENT elif numdigits % 4 == 3 : NEW_LINE INDENT return 100 * 500 ** ( ( numdigits - 3 ) // 4 ) NEW_LINE DEDENT elif numdigits % 4 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT raise AssertionError ( ) NEW_LINE DEDENT DEDENT ans = sum ( count_reversibles ( d ) for d in range ( 2 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p119_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . ArrayList ; import java . util . SortedSet ; import java . util . TreeSet ; public final class p119 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p119 ( ) . run ( ) ) ; } private static final int INDEX = 30 ; public String run ( ) { for ( BigInteger limit = BigInteger . ONE ; ; limit = limit . shiftLeft ( 8 ) ) { SortedSet < BigInteger > candidates = new TreeSet < > ( ) ; for ( int k = 2 ; BigInteger . valueOf ( 1 ) . shiftLeft ( k ) . compareTo ( limit ) < 0 ; k ++ ) { for ( int n = 2 ; ; n ++ ) { BigInteger pow = BigInteger . valueOf ( n ) . pow ( k ) ; if ( pow . compareTo ( limit ) >= 0 && pow . toString ( ) . length ( ) * 9 < n ) break ; if ( pow . compareTo ( BigInteger . TEN ) >= 0 && isDigitSumPower ( pow ) ) candidates . add ( pow ) ; } } if ( candidates . size ( ) >= INDEX ) return new ArrayList < > ( candidates ) . get ( INDEX - 1 ) . toString ( ) ; } } private static boolean isDigitSumPower ( BigInteger x ) { int digitSum = digitSum ( x ) ; if ( digitSum == 1 ) return false ; BigInteger base = BigInteger . valueOf ( digitSum ) ; BigInteger pow = base ; while ( pow . compareTo ( x ) < 0 ) pow = pow . multiply ( base ) ; return pow . equals ( x ) ; } private static int digitSum ( BigInteger x ) { if ( x . signum ( ) < 1 ) throw new IllegalArgumentException ( \" Only \u2581 for \u2581 positive \u2581 integers \" ) ; int sum = 0 ; for ( char c : x . toString ( ) . toCharArray ( ) ) sum += c - '0' ; return sum ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p119 ( ) . run ( ) ) ; }"], ["isDigitSumPower", "private static boolean isDigitSumPower ( BigInteger x ) { int digitSum = digitSum ( x ) ; if ( digitSum == 1 ) return false ; BigInteger base = BigInteger . valueOf ( digitSum ) ; BigInteger pow = base ; while ( pow . compareTo ( x ) < 0 ) pow = pow . multiply ( base ) ; return pow . equals ( x ) ; }"], ["digitSum", "private static int digitSum ( BigInteger x ) { if ( x . signum ( ) < 1 ) throw new IllegalArgumentException ( \" Only \u2581 for \u2581 positive \u2581 integers \" ) ; int sum = 0 ; for ( char c : x . toString ( ) . toCharArray ( ) ) sum += c - '0' ; return sum ; }"]], "functions_class": [["run", "public String run ( ) { for ( BigInteger limit = BigInteger . ONE ; ; limit = limit . shiftLeft ( 8 ) ) { SortedSet < BigInteger > candidates = new TreeSet < > ( ) ; for ( int k = 2 ; BigInteger . valueOf ( 1 ) . shiftLeft ( k ) . compareTo ( limit ) < 0 ; k ++ ) { for ( int n = 2 ; ; n ++ ) { BigInteger pow = BigInteger . valueOf ( n ) . pow ( k ) ; if ( pow . compareTo ( limit ) >= 0 && pow . toString ( ) . length ( ) * 9 < n ) break ; if ( pow . compareTo ( BigInteger . TEN ) >= 0 && isDigitSumPower ( pow ) ) candidates . add ( pow ) ; } } if ( candidates . size ( ) >= INDEX ) return new ArrayList < > ( candidates ) . get ( INDEX - 1 ) . toString ( ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT INDEX = 30 NEW_LINE limit = 1 NEW_LINE while True : NEW_LINE INDENT candidates = set ( ) NEW_LINE k = 2 NEW_LINE while ( 1 << k ) < limit : NEW_LINE INDENT for n in itertools . count ( 2 ) : NEW_LINE INDENT pow = n ** k NEW_LINE if pow >= limit and len ( str ( pow ) ) * 9 < n : NEW_LINE INDENT break NEW_LINE DEDENT if pow >= 10 and is_digit_sum_power ( pow ) : NEW_LINE INDENT candidates . add ( pow ) NEW_LINE DEDENT DEDENT k += 1 NEW_LINE DEDENT if len ( candidates ) >= INDEX : NEW_LINE INDENT return str ( sorted ( candidates ) [ INDEX - 1 ] ) NEW_LINE DEDENT limit <<= 8 NEW_LINE DEDENT DEDENT def is_digit_sum_power ( x ) : NEW_LINE INDENT digitsum = sum ( int ( c ) for c in str ( x ) ) NEW_LINE if digitsum == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT pow = digitsum NEW_LINE while pow < x : NEW_LINE INDENT pow *= digitsum NEW_LINE DEDENT return pow == x NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT INDEX = 30 NEW_LINE limit = 1 NEW_LINE while True : NEW_LINE INDENT candidates = set ( ) NEW_LINE k = 2 NEW_LINE while ( 1 << k ) < limit : NEW_LINE INDENT for n in itertools . count ( 2 ) : NEW_LINE INDENT pow = n ** k NEW_LINE if pow >= limit and len ( str ( pow ) ) * 9 < n : NEW_LINE INDENT break NEW_LINE DEDENT if pow >= 10 and is_digit_sum_power ( pow ) : NEW_LINE INDENT candidates . add ( pow ) NEW_LINE DEDENT DEDENT k += 1 NEW_LINE DEDENT if len ( candidates ) >= INDEX : NEW_LINE INDENT return str ( sorted ( candidates ) [ INDEX - 1 ] ) NEW_LINE DEDENT limit <<= 8 NEW_LINE DEDENT DEDENT"], ["is_digit_sum_power", "def is_digit_sum_power ( x ) : NEW_LINE INDENT digitsum = sum ( int ( c ) for c in str ( x ) ) NEW_LINE if digitsum == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT pow = digitsum NEW_LINE while pow < x : NEW_LINE INDENT pow *= digitsum NEW_LINE DEDENT return pow == x NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p121_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; public final class p121 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p121 ( ) . run ( ) ) ; } private static final int TURNS = 15 ; public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ TURNS + 1 ] [ ] ; ways [ 0 ] = new BigInteger [ ] { BigInteger . ONE } ; for ( int i = 1 ; i <= TURNS ; i ++ ) { ways [ i ] = new BigInteger [ i + 1 ] ; for ( int j = 0 ; j <= i ; j ++ ) { BigInteger temp = BigInteger . ZERO ; if ( j < i ) temp = ways [ i - 1 ] [ j ] . multiply ( BigInteger . valueOf ( i ) ) ; if ( j > 0 ) temp = temp . add ( ways [ i - 1 ] [ j - 1 ] ) ; ways [ i ] [ j ] = temp ; } } BigInteger numer = BigInteger . ZERO ; for ( int i = TURNS / 2 + 1 ; i <= TURNS ; i ++ ) numer = numer . add ( ways [ TURNS ] [ i ] ) ; BigInteger denom = Library . factorial ( TURNS + 1 ) ; return denom . divide ( numer ) . toString ( ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p121 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger [ ] [ ] ways = new BigInteger [ TURNS + 1 ] [ ] ; ways [ 0 ] = new BigInteger [ ] { BigInteger . ONE } ; for ( int i = 1 ; i <= TURNS ; i ++ ) { ways [ i ] = new BigInteger [ i + 1 ] ; for ( int j = 0 ; j <= i ; j ++ ) { BigInteger temp = BigInteger . ZERO ; if ( j < i ) temp = ways [ i - 1 ] [ j ] . multiply ( BigInteger . valueOf ( i ) ) ; if ( j > 0 ) temp = temp . add ( ways [ i - 1 ] [ j - 1 ] ) ; ways [ i ] [ j ] = temp ; } } BigInteger numer = BigInteger . ZERO ; for ( int i = TURNS / 2 + 1 ; i <= TURNS ; i ++ ) numer = numer . add ( ways [ TURNS ] [ i ] ) ; BigInteger denom = Library . factorial ( TURNS + 1 ) ; return denom . divide ( numer ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 1 ] ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] * i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT row . append ( temp ) NEW_LINE DEDENT ways . append ( row ) NEW_LINE DEDENT numer = sum ( ways [ TURNS ] [ i ] for i in range ( TURNS // 2 + 1 , TURNS + 1 ) ) NEW_LINE denom = math . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TURNS = 15 NEW_LINE ways = [ [ 1 ] ] NEW_LINE for i in range ( 1 , TURNS + 1 ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT temp = 0 NEW_LINE if j < i : NEW_LINE INDENT temp = ways [ i - 1 ] [ j ] * i NEW_LINE DEDENT if j > 0 : NEW_LINE INDENT temp += ways [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT row . append ( temp ) NEW_LINE DEDENT ways . append ( row ) NEW_LINE DEDENT numer = sum ( ways [ TURNS ] [ i ] for i in range ( TURNS // 2 + 1 , TURNS + 1 ) ) NEW_LINE denom = math . factorial ( TURNS + 1 ) NEW_LINE return str ( denom // numer ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p117_A", "java": [{"id": "1", "code": "public final class p117 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p117 ( ) . run ( ) ) ; } private static final int LENGTH = 50 ; public String run ( ) { long [ ] ways = new long [ LENGTH + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= LENGTH ; n ++ ) { for ( int k = 1 ; k <= 4 && k <= n ; k ++ ) ways [ n ] += ways [ n - k ] ; } return Long . toString ( ways [ LENGTH ] ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p117 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long [ ] ways = new long [ LENGTH + 1 ] ; ways [ 0 ] = 1 ; for ( int n = 1 ; n <= LENGTH ; n ++ ) { for ( int k = 1 ; k <= 4 && k <= n ; k ++ ) ways [ n ] += ways [ n - k ] ; } return Long . toString ( ways [ LENGTH ] ) ; }"]]}], "python": [{"id": "2", "code": "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LENGTH = 50 NEW_LINE ways = [ 1 ] + [ 0 ] * LENGTH NEW_LINE for n in range ( 1 , len ( ways ) ) : NEW_LINE INDENT ways [ n ] += sum ( ways [ max ( n - 4 , 0 ) : n ] ) NEW_LINE DEDENT return str ( ways [ - 1 ] ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p587_A", "java": [{"id": "1", "code": "public final class p587 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p587 ( ) . run ( ) ) ; } public String run ( ) { double lSectionArea = 1 - Math . PI / 4 ; for ( int i = 1 ; ; i ++ ) { double slope = 1.0 / i ; double a = slope * slope + 1 ; double b = - 2 * ( slope + 1 ) ; double c = 1 ; double x = ( 2 * c ) / ( - b + Math . sqrt ( b * b - 4 * a * c ) ) ; double concaveTriangleArea = ( x * x * slope / 2 ) + ( integral ( 1 ) - integral ( x ) ) ; if ( concaveTriangleArea / lSectionArea < 0.001 ) return Integer . toString ( i ) ; if ( i == Integer . MAX_VALUE ) throw new AssertionError ( ) ; } } private static double integral ( double x ) { double t = x - 1 ; return t - ( Math . sqrt ( x * ( 2 - x ) ) * t + Math . asin ( t ) ) / 2 ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p587 ( ) . run ( ) ) ; }"], ["integral", "private static double integral ( double x ) { double t = x - 1 ; return t - ( Math . sqrt ( x * ( 2 - x ) ) * t + Math . asin ( t ) ) / 2 ; }"]], "functions_class": [["run", "public String run ( ) { double lSectionArea = 1 - Math . PI / 4 ; for ( int i = 1 ; ; i ++ ) { double slope = 1.0 / i ; double a = slope * slope + 1 ; double b = - 2 * ( slope + 1 ) ; double c = 1 ; double x = ( 2 * c ) / ( - b + Math . sqrt ( b * b - 4 * a * c ) ) ; double concaveTriangleArea = ( x * x * slope / 2 ) + ( integral ( 1 ) - integral ( x ) ) ; if ( concaveTriangleArea / lSectionArea < 0.001 ) return Integer . toString ( i ) ; if ( i == Integer . MAX_VALUE ) throw new AssertionError ( ) ; } }"]]}], "python": [{"id": "2", "code": "import itertools , math NEW_LINE def compute ( ) : NEW_LINE INDENT def integral ( x ) : NEW_LINE INDENT t = x - 1.0 NEW_LINE return t - ( math . sqrt ( x * ( 2.0 - x ) ) * t + math . asin ( t ) ) / 2.0 NEW_LINE DEDENT lsectionarea = 1.0 - math . pi / 4.0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT slope = 1.0 / i NEW_LINE a = slope ** 2 + 1.0 NEW_LINE b = - 2.0 * ( slope + 1.0 ) NEW_LINE c = 1.0 NEW_LINE x = ( 2.0 * c ) / ( - b + math . sqrt ( b * b - 4 * a * c ) ) NEW_LINE concavetrianglearea = ( x ** 2 * slope / 2 ) + ( integral ( 1.0 ) - integral ( x ) ) NEW_LINE if concavetrianglearea / lsectionarea < 0.001 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT def integral ( x ) : NEW_LINE INDENT t = x - 1.0 NEW_LINE return t - ( math . sqrt ( x * ( 2.0 - x ) ) * t + math . asin ( t ) ) / 2.0 NEW_LINE DEDENT lsectionarea = 1.0 - math . pi / 4.0 NEW_LINE for i in itertools . count ( 1 ) : NEW_LINE INDENT slope = 1.0 / i NEW_LINE a = slope ** 2 + 1.0 NEW_LINE b = - 2.0 * ( slope + 1.0 ) NEW_LINE c = 1.0 NEW_LINE x = ( 2.0 * c ) / ( - b + math . sqrt ( b * b - 4 * a * c ) ) NEW_LINE concavetrianglearea = ( x ** 2 * slope / 2 ) + ( integral ( 1.0 ) - integral ( x ) ) NEW_LINE if concavetrianglearea / lsectionarea < 0.001 : NEW_LINE INDENT return str ( i ) NEW_LINE DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p128_A", "java": [{"id": "1", "code": "public final class p128 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p128 ( ) . run ( ) ) ; } private static final int TARGET = 2000 ; public String run ( ) { int count = 2 ; for ( int ring = 2 ; ; ring ++ ) { if ( ( long ) ring * 12 + 5 > Integer . MAX_VALUE ) throw new ArithmeticException ( ) ; if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 1 ) && Library . isPrime ( ring * 12 + 5 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring - 1 ) * 3 + 2 ) ; } if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 5 ) && Library . isPrime ( ring * 12 - 7 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring + 1 ) * 3 + 1 ) ; } } } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p128 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { int count = 2 ; for ( int ring = 2 ; ; ring ++ ) { if ( ( long ) ring * 12 + 5 > Integer . MAX_VALUE ) throw new ArithmeticException ( ) ; if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 1 ) && Library . isPrime ( ring * 12 + 5 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring - 1 ) * 3 + 2 ) ; } if ( Library . isPrime ( ring * 6 - 1 ) && Library . isPrime ( ring * 6 + 5 ) && Library . isPrime ( ring * 12 - 7 ) ) { count ++ ; if ( count == TARGET ) return Long . toString ( ( long ) ring * ( ring + 1 ) * 3 + 1 ) ; } } }"]]}], "python": [{"id": "2", "code": "import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT TARGET = 2000 NEW_LINE count = 2 NEW_LINE for ring in itertools . count ( 2 ) : NEW_LINE INDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT TARGET = 2000 NEW_LINE count = 2 NEW_LINE for ring in itertools . count ( 2 ) : NEW_LINE INDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 1 , ring * 12 + 5 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring - 1 ) * 3 + 2 ) NEW_LINE DEDENT DEDENT if all ( map ( eulerlib . is_prime , ( ring * 6 - 1 , ring * 6 + 5 , ring * 12 - 7 ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE if count == TARGET : NEW_LINE INDENT return str ( ring * ( ring + 1 ) * 3 + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p518_A", "java": [{"id": "1", "code": "public final class p518 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p518 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) ; public String run ( ) { long sum = 0 ; boolean [ ] isPrime = Library . listPrimality ( LIMIT - 1 ) ; for ( int x = 1 ; x < isPrime . length ; x ++ ) { for ( int y = 1 ; ; y ++ ) { long a = ( long ) x * y * y - 1 ; if ( a >= isPrime . length ) break ; if ( ! isPrime [ ( int ) a ] ) continue ; for ( int z = y + 1 ; ; z ++ ) { if ( Library . gcd ( y , z ) != 1 ) continue ; long b = ( long ) x * y * z - 1 ; long c = ( long ) x * z * z - 1 ; if ( c >= isPrime . length ) break ; if ( isPrime [ ( int ) b ] && isPrime [ ( int ) c ] ) { long addend = a + b + c ; if ( sum + addend < sum ) throw new ArithmeticException ( \" Overflow \" ) ; sum += addend ; } } } } return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p518 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { long sum = 0 ; boolean [ ] isPrime = Library . listPrimality ( LIMIT - 1 ) ; for ( int x = 1 ; x < isPrime . length ; x ++ ) { for ( int y = 1 ; ; y ++ ) { long a = ( long ) x * y * y - 1 ; if ( a >= isPrime . length ) break ; if ( ! isPrime [ ( int ) a ] ) continue ; for ( int z = y + 1 ; ; z ++ ) { if ( Library . gcd ( y , z ) != 1 ) continue ; long b = ( long ) x * y * z - 1 ; long c = ( long ) x * z * z - 1 ; if ( c >= isPrime . length ) break ; if ( isPrime [ ( int ) b ] && isPrime [ ( int ) c ] ) { long addend = a + b + c ; if ( sum + addend < sum ) throw new ArithmeticException ( \" Overflow \" ) ; sum += addend ; } } } } return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , fractions , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT // 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE ans = 0 NEW_LINE isprime = eulerlib . list_primality ( LIMIT - 1 ) NEW_LINE for x in range ( 1 , LIMIT // 4 + 1 ) : NEW_LINE INDENT for y in itertools . count ( 1 ) : NEW_LINE INDENT a = x * y * y - 1 NEW_LINE if a >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if not isprime [ a ] : NEW_LINE INDENT continue NEW_LINE DEDENT for z in itertools . count ( y + 1 ) : NEW_LINE INDENT if fractions . gcd ( y , z ) != 1 : NEW_LINE INDENT continue NEW_LINE DEDENT c = x * z * z - 1 NEW_LINE if c >= LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT if isprime [ c ] : NEW_LINE INDENT b = x * y * z - 1 NEW_LINE if isprime [ b ] : NEW_LINE INDENT ans += a + b + c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p188_A", "java": [{"id": "1", "code": "public final class p188 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p188 ( ) . run ( ) ) ; } public String run ( ) { return Integer . toString ( tetrationMod ( 1777 , 1855 , Library . pow ( 10 , 8 ) ) ) ; } private static int tetrationMod ( int x , int y , int m ) { if ( y == 1 ) return x % m ; else return Library . powMod ( x , tetrationMod ( x , y - 1 , Library . totient ( m ) ) , m ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p188 ( ) . run ( ) ) ; }"], ["tetrationMod", "private static int tetrationMod ( int x , int y , int m ) { if ( y == 1 ) return x % m ; else return Library . powMod ( x , tetrationMod ( x , y - 1 , Library . totient ( m ) ) , m ) ; }"]], "functions_class": [["run", "public String run ( ) { return Integer . toString ( tetrationMod ( 1777 , 1855 , Library . pow ( 10 , 8 ) ) ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n //= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n //= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT x , y , m = 1777 , 1855 , 10 ** 8 NEW_LINE sys . setrecursionlimit ( y + 30 ) NEW_LINE ans = tetration_mod ( x , y , m ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["tetration_mod", "def tetration_mod ( x , y , m ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return x % m NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( x , tetration_mod ( x , y - 1 , totient ( m ) ) , m ) NEW_LINE DEDENT DEDENT"], ["totient", "def totient ( n ) : NEW_LINE INDENT assert n > 0 NEW_LINE p = 1 NEW_LINE i = 2 NEW_LINE end = eulerlib . sqrt ( n ) NEW_LINE while i <= end : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT p *= i - 1 NEW_LINE n //= i NEW_LINE while n % i == 0 : NEW_LINE INDENT p *= i NEW_LINE n //= i NEW_LINE DEDENT end = eulerlib . sqrt ( n ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if n != 1 : NEW_LINE INDENT p *= n - 1 NEW_LINE DEDENT return p NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p347_A", "java": [{"id": "1", "code": "import java . util . HashSet ; import java . util . Set ; public final class p347 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p347 ( ) . run ( ) ) ; } private static final int LIMIT = 10000000 ; public String run ( ) { Set < Integer > possible = new HashSet < > ( ) ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; for ( int i = 0 , end = Library . sqrt ( LIMIT ) ; i < primes . length ; i ++ ) { int p = primes [ i ] ; if ( p > end ) break ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { int q = primes [ j ] ; int lcm = p * q ; if ( lcm > LIMIT ) break ; int multLimit = LIMIT / lcm ; int multiplier = 1 ; while ( multiplier * p <= multLimit ) multiplier *= p ; int maxMult = multiplier ; while ( multiplier % p == 0 ) { multiplier /= p ; while ( multiplier * q <= multLimit ) multiplier *= q ; maxMult = Math . max ( multiplier , maxMult ) ; } possible . add ( maxMult * lcm ) ; } } long sum = 0 ; for ( int x : possible ) sum += x ; return Long . toString ( sum ) ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p347 ( ) . run ( ) ) ; }"]], "functions_class": [["run", "public String run ( ) { Set < Integer > possible = new HashSet < > ( ) ; int [ ] primes = Library . listPrimes ( LIMIT / 2 ) ; for ( int i = 0 , end = Library . sqrt ( LIMIT ) ; i < primes . length ; i ++ ) { int p = primes [ i ] ; if ( p > end ) break ; for ( int j = i + 1 ; j < primes . length ; j ++ ) { int q = primes [ j ] ; int lcm = p * q ; if ( lcm > LIMIT ) break ; int multLimit = LIMIT / lcm ; int multiplier = 1 ; while ( multiplier * p <= multLimit ) multiplier *= p ; int maxMult = multiplier ; while ( multiplier % p == 0 ) { multiplier /= p ; while ( multiplier * q <= multLimit ) multiplier *= q ; maxMult = Math . max ( multiplier , maxMult ) ; } possible . add ( maxMult * lcm ) ; } } long sum = 0 ; for ( int x : possible ) sum += x ; return Long . toString ( sum ) ; }"]]}], "python": [{"id": "2", "code": "import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT // lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier //= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT LIMIT = 10000000 NEW_LINE possible = set ( ) NEW_LINE primes = eulerlib . list_primes ( LIMIT // 2 ) NEW_LINE end = eulerlib . sqrt ( LIMIT ) NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT p = primes [ i ] NEW_LINE if p > end : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i + 1 , len ( primes ) ) : NEW_LINE INDENT q = primes [ j ] NEW_LINE lcm = p * q NEW_LINE if lcm > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT multlimit = LIMIT // lcm NEW_LINE multiplier = 1 NEW_LINE while multiplier * p <= multlimit : NEW_LINE INDENT multiplier *= p NEW_LINE DEDENT maxmult = multiplier NEW_LINE while multiplier % p == 0 : NEW_LINE INDENT multiplier //= p NEW_LINE while multiplier * q <= multlimit : NEW_LINE INDENT multiplier *= q NEW_LINE DEDENT maxmult = max ( multiplier , maxmult ) NEW_LINE DEDENT possible . add ( maxmult * lcm ) NEW_LINE DEDENT DEDENT ans = sum ( possible ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"]], "functions_class": []}]}
{"id": "projecteuler_p172_A", "java": [{"id": "1", "code": "import java . math . BigInteger ; import java . util . ArrayList ; import java . util . List ; public final class p172 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p172 ( ) . run ( ) ) ; } private static final int LENGTH = 18 ; private static final int MAX_COUNT = 3 ; private static final int BASE = 10 ; public String run ( ) { BigInteger ways = partitionAndCount ( LENGTH , MAX_COUNT , new ArrayList < Integer > ( ) ) ; BigInteger BASE_BI = BigInteger . valueOf ( BASE ) ; ways = ways . multiply ( BASE_BI . subtract ( BigInteger . ONE ) ) ; ways = divideExactly ( ways , BASE_BI ) ; return ways . toString ( ) ; } private BigInteger partitionAndCount ( int sum , int max , List < Integer > terms ) { if ( terms . size ( ) == BASE ) { if ( sum == 0 ) return countWays ( terms ) ; else return BigInteger . ZERO ; } else { BigInteger result = BigInteger . ZERO ; for ( int i = Math . min ( max , sum ) ; i >= 0 ; i -- ) { terms . add ( i ) ; result = result . add ( partitionAndCount ( sum - i , i , terms ) ) ; terms . remove ( terms . size ( ) - 1 ) ; } return result ; } } private BigInteger countWays ( List < Integer > freqs ) { int [ ] histogram = new int [ MAX_COUNT + 1 ] ; for ( int x : freqs ) histogram [ x ] ++ ; BigInteger ways = Library . factorial ( BASE ) ; for ( int x : histogram ) ways = ways . divide ( Library . factorial ( x ) ) ; ways = ways . multiply ( Library . factorial ( LENGTH ) ) ; for ( int x : freqs ) ways = ways . divide ( Library . factorial ( x ) ) ; return ways ; } private static BigInteger divideExactly ( BigInteger x , BigInteger y ) { BigInteger [ ] temp = x . divideAndRemainder ( y ) ; if ( temp [ 1 ] . signum ( ) != 0 ) throw new IllegalArgumentException ( \" Not \u2581 divisible \" ) ; return temp [ 0 ] ; } }", "functions_standalone": [["main", "public static void main ( String [ ] args ) { System . out . println ( new p172 ( ) . run ( ) ) ; }"], ["divideExactly", "private static BigInteger divideExactly ( BigInteger x , BigInteger y ) { BigInteger [ ] temp = x . divideAndRemainder ( y ) ; if ( temp [ 1 ] . signum ( ) != 0 ) throw new IllegalArgumentException ( \" Not \u2581 divisible \" ) ; return temp [ 0 ] ; }"]], "functions_class": [["run", "public String run ( ) { BigInteger ways = partitionAndCount ( LENGTH , MAX_COUNT , new ArrayList < Integer > ( ) ) ; BigInteger BASE_BI = BigInteger . valueOf ( BASE ) ; ways = ways . multiply ( BASE_BI . subtract ( BigInteger . ONE ) ) ; ways = divideExactly ( ways , BASE_BI ) ; return ways . toString ( ) ; }"], ["partitionAndCount", "private BigInteger partitionAndCount ( int sum , int max , List < Integer > terms ) { if ( terms . size ( ) == BASE ) { if ( sum == 0 ) return countWays ( terms ) ; else return BigInteger . ZERO ; } else { BigInteger result = BigInteger . ZERO ; for ( int i = Math . min ( max , sum ) ; i >= 0 ; i -- ) { terms . add ( i ) ; result = result . add ( partitionAndCount ( sum - i , i , terms ) ) ; terms . remove ( terms . size ( ) - 1 ) ; } return result ; } }"], ["countWays", "private BigInteger countWays ( List < Integer > freqs ) { int [ ] histogram = new int [ MAX_COUNT + 1 ] ; for ( int x : freqs ) histogram [ x ] ++ ; BigInteger ways = Library . factorial ( BASE ) ; for ( int x : histogram ) ways = ways . divide ( Library . factorial ( x ) ) ; ways = ways . multiply ( Library . factorial ( LENGTH ) ) ; for ( int x : freqs ) ways = ways . divide ( Library . factorial ( x ) ) ; return ways ; }"]]}], "python": [{"id": "2", "code": "import math NEW_LINE LENGTH = 18 NEW_LINE MAX_COUNT = 3 NEW_LINE BASE = 10 NEW_LINE def compute ( ) : NEW_LINE INDENT ans = partition_and_count ( LENGTH , MAX_COUNT , [ ] ) NEW_LINE ans = divide_exactly ( ans * ( BASE - 1 ) , BASE ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def partition_and_count ( sum , max , terms ) : NEW_LINE INDENT if len ( terms ) == BASE : NEW_LINE INDENT return count_ways ( terms ) if ( sum == 0 ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE for i in reversed ( range ( min ( max , sum ) + 1 ) ) : NEW_LINE INDENT terms . append ( i ) NEW_LINE result += partition_and_count ( sum - i , i , terms ) NEW_LINE terms . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT def count_ways ( freqs ) : NEW_LINE INDENT histogram = [ 0 ] * ( MAX_COUNT + 1 ) NEW_LINE for x in freqs : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT ways = math . factorial ( BASE ) NEW_LINE for x in histogram : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT ways *= math . factorial ( LENGTH ) NEW_LINE for x in freqs : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT return ways NEW_LINE DEDENT def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT", "functions_standalone": [["compute", "def compute ( ) : NEW_LINE INDENT ans = partition_and_count ( LENGTH , MAX_COUNT , [ ] ) NEW_LINE ans = divide_exactly ( ans * ( BASE - 1 ) , BASE ) NEW_LINE return str ( ans ) NEW_LINE DEDENT"], ["partition_and_count", "def partition_and_count ( sum , max , terms ) : NEW_LINE INDENT if len ( terms ) == BASE : NEW_LINE INDENT return count_ways ( terms ) if ( sum == 0 ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE for i in reversed ( range ( min ( max , sum ) + 1 ) ) : NEW_LINE INDENT terms . append ( i ) NEW_LINE result += partition_and_count ( sum - i , i , terms ) NEW_LINE terms . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT"], ["count_ways", "def count_ways ( freqs ) : NEW_LINE INDENT histogram = [ 0 ] * ( MAX_COUNT + 1 ) NEW_LINE for x in freqs : NEW_LINE INDENT histogram [ x ] += 1 NEW_LINE DEDENT ways = math . factorial ( BASE ) NEW_LINE for x in histogram : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT ways *= math . factorial ( LENGTH ) NEW_LINE for x in freqs : NEW_LINE INDENT ways //= math . factorial ( x ) NEW_LINE DEDENT return ways NEW_LINE DEDENT"], ["divide_exactly", "def divide_exactly ( x , y ) : NEW_LINE INDENT if x % y != 0 : NEW_LINE INDENT raise ValueError ( \" Not \u2581 divisible \" ) NEW_LINE DEDENT return x // y NEW_LINE DEDENT"]], "functions_class": []}]}