{"id": "leetcode_560_A", "java": [{"id": "1", "code": "public class Solution { public int subarraySum ( int [ ] nums , int k ) { int count = 0 , sum = 0 ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; map . put ( 0 , 1 ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { sum += nums [ i ] ; if ( map . containsKey ( sum - k ) ) count += map . get ( sum - k ) ; map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ) ; } return count ; } }", "functions_standalone": [], "functions_class": [["subarraySum", "public int subarraySum ( int [ ] nums , int k ) { int count = 0 , sum = 0 ; HashMap < Integer , Integer > map = new HashMap < > ( ) ; map . put ( 0 , 1 ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { sum += nums [ i ] ; if ( map . containsKey ( sum - k ) ) count += map . get ( sum - k ) ; map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ) ; } return count ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def subarraySum ( self , nums , k ) : NEW_LINE INDENT sum_map = { } NEW_LINE sum_map [ 0 ] = 1 NEW_LINE count = curr_sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT curr_sum += num NEW_LINE count += sum_map . get ( curr_sum - k , 0 ) NEW_LINE sum_map [ curr_sum ] = sum_map . get ( curr_sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["subarraySum", "def subarraySum ( self , nums , k ) : NEW_LINE INDENT sum_map = { } NEW_LINE sum_map [ 0 ] = 1 NEW_LINE count = curr_sum = 0 NEW_LINE for num in nums : NEW_LINE INDENT curr_sum += num NEW_LINE count += sum_map . get ( curr_sum - k , 0 ) NEW_LINE sum_map [ curr_sum ] = sum_map . get ( curr_sum , 0 ) + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT"]]}]}
{"id": "leetcode_706_A", "java": [{"id": "1", "code": "class MyHashMap { final ListNode [ ] nodes = new ListNode [ 10000 ] ; public void put ( int key , int value ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) nodes [ i ] = new ListNode ( - 1 , - 1 ) ; ListNode prev = find ( nodes [ i ] , key ) ; if ( prev . next == null ) prev . next = new ListNode ( key , value ) ; else prev . next . val = value ; } public int get ( int key ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) return - 1 ; ListNode node = find ( nodes [ i ] , key ) ; return node . next == null ? - 1 : node . next . val ; } public void remove ( int key ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) return ; ListNode prev = find ( nodes [ i ] , key ) ; if ( prev . next == null ) return ; prev . next = prev . next . next ; } int idx ( int key ) { return Integer . hashCode ( key ) % nodes . length ; } ListNode find ( ListNode bucket , int key ) { ListNode node = bucket , prev = null ; while ( node != null && node . key != key ) { prev = node ; node = node . next ; } return prev ; } class ListNode { int key , val ; ListNode next ; ListNode ( int key , int val ) { this . key = key ; this . val = val ; } } }", "functions_standalone": [], "functions_class": [["put", "public void put ( int key , int value ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) nodes [ i ] = new ListNode ( - 1 , - 1 ) ; ListNode prev = find ( nodes [ i ] , key ) ; if ( prev . next == null ) prev . next = new ListNode ( key , value ) ; else prev . next . val = value ; }"], ["get", "public int get ( int key ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) return - 1 ; ListNode node = find ( nodes [ i ] , key ) ; return node . next == null ? - 1 : node . next . val ; }"], ["remove", "public void remove ( int key ) { int i = idx ( key ) ; if ( nodes [ i ] == null ) return ; ListNode prev = find ( nodes [ i ] , key ) ; if ( prev . next == null ) return ; prev . next = prev . next . next ; }"], ["idx", "int idx ( int key ) { return Integer . hashCode ( key ) % nodes . length ; }"], ["find", "ListNode find ( ListNode bucket , int key ) { ListNode node = bucket , prev = null ; while ( node != null && node . key != key ) { prev = node ; node = node . next ; } return prev ; }"], ["ListNode", "ListNode ( int key , int val ) { this . key = key ; this . val = val ; }"]]}], "python": [{"id": "2", "code": "class MyHashMap ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT DEDENT def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT class ListNode ( ) : NEW_LINE INDENT def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT DEDENT", "functions_standalone": [["find", "def find ( bucket , key ) : NEW_LINE INDENT node = bucket NEW_LINE prev = None NEW_LINE while node is not None and node . key != key : NEW_LINE INDENT prev = node NEW_LINE node = node . next NEW_LINE DEDENT return prev NEW_LINE DEDENT"]], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . size = 10000 NEW_LINE self . nodes = [ None ] * self . size NEW_LINE DEDENT"], ["put", "def put ( self , key , value ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT self . nodes [ index ] = ListNode ( - 1 , - 1 ) NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT prev . next = ListNode ( key , value ) NEW_LINE DEDENT else : NEW_LINE INDENT prev . next . val = value NEW_LINE DEDENT DEDENT"], ["get", "def get ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return prev . next . val NEW_LINE DEDENT DEDENT"], ["remove", "def remove ( self , key ) : NEW_LINE INDENT index = hash ( key ) % self . size NEW_LINE if self . nodes [ index ] is None : NEW_LINE INDENT return NEW_LINE DEDENT prev = find ( self . nodes [ index ] , key ) NEW_LINE if prev . next is None : NEW_LINE INDENT return NEW_LINE DEDENT prev . next = prev . next . next NEW_LINE DEDENT"], ["__init__", "def __init__ ( self , key , val ) : NEW_LINE INDENT self . key = key NEW_LINE self . val = val NEW_LINE self . next = None NEW_LINE NEW_LINE DEDENT"]]}]}
{"id": "leetcode_557_A", "java": [{"id": "1", "code": "public class Solution { public String reverseWords ( String s ) { String words [ ] = s . split ( \" \u2581 \" ) ; StringBuilder ans = new StringBuilder ( ) ; for ( String word : words ) ans . append ( new StringBuffer ( word ) . reverse ( ) . toString ( ) + \" \u2581 \" ) ; return ans . toString ( ) . trim ( ) ; } }", "functions_standalone": [], "functions_class": [["reverseWords", "public String reverseWords ( String s ) { String words [ ] = s . split ( \" \u2581 \" ) ; StringBuilder ans = new StringBuilder ( ) ; for ( String word : words ) ans . append ( new StringBuffer ( word ) . reverse ( ) . toString ( ) + \" \u2581 \" ) ; return ans . toString ( ) . trim ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def reverseWords ( self , s ) : NEW_LINE INDENT return ' \u2581 ' . join ( [ word [ : : - 1 ] for word in s . split ( ' \u2581 ' ) ] ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["reverseWords", "def reverseWords ( self , s ) : NEW_LINE INDENT return ' \u2581 ' . join ( [ word [ : : - 1 ] for word in s . split ( ' \u2581 ' ) ] ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_937_A", "java": [{"id": "1", "code": "import java . util . List ; class Solution { public String [ ] reorderLogFiles ( String [ ] logs ) { Arrays . sort ( logs , ( log1 , log2 ) -> { String [ ] split1 = log1 . split ( \" \u2581 \" , 2 ) ; String [ ] split2 = log2 . split ( \" \u2581 \" , 2 ) ; boolean isDigit1 = Character . isDigit ( split1 [ 1 ] . charAt ( 0 ) ) ; boolean isDigit2 = Character . isDigit ( split2 [ 1 ] . charAt ( 0 ) ) ; if ( ! isDigit1 && ! isDigit2 ) { int cmp = split1 [ 1 ] . compareTo ( split2 [ 1 ] ) ; if ( cmp != 0 ) return cmp ; return split1 [ 0 ] . compareTo ( split2 [ 0 ] ) ; } return isDigit1 ? ( isDigit2 ? 0 : 1 ) : - 1 ; } ) ; return logs ; } }", "functions_standalone": [], "functions_class": [["reorderLogFiles", "public String [ ] reorderLogFiles ( String [ ] logs ) { Arrays . sort ( logs , ( log1 , log2 ) -> { String [ ] split1 = log1 . split ( \" \u2581 \" , 2 ) ; String [ ] split2 = log2 . split ( \" \u2581 \" , 2 ) ; boolean isDigit1 = Character . isDigit ( split1 [ 1 ] . charAt ( 0 ) ) ; boolean isDigit2 = Character . isDigit ( split2 [ 1 ] . charAt ( 0 ) ) ; if ( ! isDigit1 && ! isDigit2 ) { int cmp = split1 [ 1 ] . compareTo ( split2 [ 1 ] ) ; if ( cmp != 0 ) return cmp ; return split1 [ 0 ] . compareTo ( split2 [ 0 ] ) ; } return isDigit1 ? ( isDigit2 ? 0 : 1 ) : - 1 ; } ) ; return logs ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def reorderLogFiles ( self , logs ) : NEW_LINE INDENT letter_logs = [ ] NEW_LINE digit_logs = [ ] NEW_LINE for log in logs : NEW_LINE INDENT if log . split ( ' \u2581 ' ) [ 1 ] . isnumeric ( ) : NEW_LINE INDENT digit_logs . append ( log ) NEW_LINE DEDENT else : NEW_LINE INDENT letter_logs . append ( log ) NEW_LINE DEDENT DEDENT return sorted ( letter_logs , key = lambda x : x . split ( ' \u2581 ' ) [ 1 : ] + x . split ( ' \u2581 ' ) [ 0 ] ) + digit_logs NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["reorderLogFiles", "def reorderLogFiles ( self , logs ) : NEW_LINE INDENT letter_logs = [ ] NEW_LINE digit_logs = [ ] NEW_LINE for log in logs : NEW_LINE INDENT if log . split ( ' \u2581 ' ) [ 1 ] . isnumeric ( ) : NEW_LINE INDENT digit_logs . append ( log ) NEW_LINE DEDENT else : NEW_LINE INDENT letter_logs . append ( log ) NEW_LINE DEDENT DEDENT return sorted ( letter_logs , key = lambda x : x . split ( ' \u2581 ' ) [ 1 : ] + x . split ( ' \u2581 ' ) [ 0 ] ) + digit_logs NEW_LINE DEDENT"]]}]}
{"id": "leetcode_709_A", "java": [{"id": "1", "code": "class Solution { public String toLowerCase ( String str ) { return str . toLowerCase ( ) ; } }", "functions_standalone": [], "functions_class": [["toLowerCase", "public String toLowerCase ( String str ) { return str . toLowerCase ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def toLowerCase ( self , str ) : NEW_LINE INDENT res = [ ] NEW_LINE gap = ord ( ' a ' ) - ord ( ' A ' ) NEW_LINE for c in str : NEW_LINE INDENT if ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' Z ' ) : NEW_LINE INDENT res . append ( chr ( ord ( c ) + gap ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( c ) NEW_LINE DEDENT DEDENT return ' ' . join ( res ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["toLowerCase", "def toLowerCase ( self , str ) : NEW_LINE INDENT res = [ ] NEW_LINE gap = ord ( ' a ' ) - ord ( ' A ' ) NEW_LINE for c in str : NEW_LINE INDENT if ord ( c ) >= ord ( ' A ' ) and ord ( c ) <= ord ( ' Z ' ) : NEW_LINE INDENT res . append ( chr ( ord ( c ) + gap ) ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( c ) NEW_LINE DEDENT DEDENT return ' ' . join ( res ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_700_A", "java": [{"id": "1", "code": "class Solution { public TreeNode searchBST ( TreeNode root , int val ) { while ( root != null && root . val != val ) { root = val < root . val ? root . left : root . right ; } return root ; } }", "functions_standalone": [], "functions_class": [["searchBST", "public TreeNode searchBST ( TreeNode root , int val ) { while ( root != null && root . val != val ) { root = val < root . val ? root . left : root . right ; } return root ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["searchBST", "def searchBST ( self , root , val ) : NEW_LINE INDENT while root : NEW_LINE INDENT if root . val == val : NEW_LINE INDENT return root NEW_LINE DEDENT elif root . val > val : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT root = root . right NEW_LINE DEDENT DEDENT return root NEW_LINE DEDENT"]]}]}
{"id": "leetcode_485_A", "java": [{"id": "1", "code": "class Solution { public int findMaxConsecutiveOnes ( int [ ] nums ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 1 ) { curr ++ ; if ( curr > ans ) ans = curr ; } else { curr = 0 ; } } return ans ; } }", "functions_standalone": [], "functions_class": [["findMaxConsecutiveOnes", "public int findMaxConsecutiveOnes ( int [ ] nums ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 1 ) { curr ++ ; if ( curr > ans ) ans = curr ; } else { curr = 0 ; } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findMaxConsecutiveOnes ( self , nums ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE for n in nums : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT curr += 1 NEW_LINE if curr > ans : NEW_LINE INDENT ans = curr NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findMaxConsecutiveOnes", "def findMaxConsecutiveOnes ( self , nums ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE for n in nums : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT curr += 1 NEW_LINE if curr > ans : NEW_LINE INDENT ans = curr NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_482_A", "java": [{"id": "1", "code": "class Solution { public String licenseKeyFormatting ( String s , int k ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) != ' - ' ) sb . append ( sb . length ( ) % ( k + 1 ) == k ? ' - ' : \" \" ) . append ( s . charAt ( i ) ) ; return sb . reverse ( ) . toString ( ) . toUpperCase ( ) ; } }", "functions_standalone": [], "functions_class": [["licenseKeyFormatting", "public String licenseKeyFormatting ( String s , int k ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) if ( s . charAt ( i ) != ' - ' ) sb . append ( sb . length ( ) % ( k + 1 ) == k ? ' - ' : \" \" ) . append ( s . charAt ( i ) ) ; return sb . reverse ( ) . toString ( ) . toUpperCase ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["licenseKeyFormatting", "def licenseKeyFormatting ( self , S , K ) : NEW_LINE INDENT S = S . upper ( ) . replace ( ' - ' , ' ' ) NEW_LINE ls = len ( S ) NEW_LINE if ls % K == 0 : NEW_LINE INDENT pos = K NEW_LINE DEDENT else : NEW_LINE INDENT pos = ls % K NEW_LINE DEDENT res = S [ : pos ] NEW_LINE while pos < ls : NEW_LINE INDENT res += ' - ' + S [ pos : pos + K ] NEW_LINE pos += K NEW_LINE DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_811_A", "java": [{"id": "1", "code": "class Solution { public List < String > subdomainVisits ( String [ ] cpdomains ) { Map < String , Integer > map = new HashMap ( ) ; for ( String cpdomain : cpdomains ) { int i = cpdomain . indexOf ( ' \u2581 ' ) ; int n = Integer . valueOf ( cpdomain . substring ( 0 , i ) ) ; String domain = cpdomain . substring ( i + 1 ) ; for ( i = 0 ; i < domain . length ( ) ; ++ i ) { if ( domain . charAt ( i ) == ' . ' ) { String d = domain . substring ( i + 1 ) ; map . put ( d , map . getOrDefault ( d , 0 ) + n ) ; } } map . put ( domain , map . getOrDefault ( domain , 0 ) + n ) ; } List < String > res = new ArrayList ( ) ; for ( String domain : map . keySet ( ) ) res . add ( map . get ( domain ) + \" \u2581 \" + domain ) ; return res ; } }", "functions_standalone": [], "functions_class": [["subdomainVisits", "public List < String > subdomainVisits ( String [ ] cpdomains ) { Map < String , Integer > map = new HashMap ( ) ; for ( String cpdomain : cpdomains ) { int i = cpdomain . indexOf ( ' \u2581 ' ) ; int n = Integer . valueOf ( cpdomain . substring ( 0 , i ) ) ; String domain = cpdomain . substring ( i + 1 ) ; for ( i = 0 ; i < domain . length ( ) ; ++ i ) { if ( domain . charAt ( i ) == ' . ' ) { String d = domain . substring ( i + 1 ) ; map . put ( d , map . getOrDefault ( d , 0 ) + n ) ; } } map . put ( domain , map . getOrDefault ( domain , 0 ) + n ) ; } List < String > res = new ArrayList ( ) ; for ( String domain : map . keySet ( ) ) res . add ( map . get ( domain ) + \" \u2581 \" + domain ) ; return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def subdomainVisits ( self , cpdomains ) : NEW_LINE INDENT domain_count = { } NEW_LINE for cpdomain in cpdomains : NEW_LINE INDENT count , domain = cpdomain . split ( ' \u2581 ' ) NEW_LINE sub_domain = domain . split ( ' . ' ) NEW_LINE for i in range ( len ( sub_domain ) ) : NEW_LINE INDENT curr = ' . ' . join ( sub_domain [ i : ] ) NEW_LINE domain_count [ curr ] = domain_count . get ( curr , 0 ) + int ( count ) NEW_LINE DEDENT DEDENT return [ str ( v ) + ' \u2581 ' + k for k , v in domain_count . items ( ) ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["subdomainVisits", "def subdomainVisits ( self , cpdomains ) : NEW_LINE INDENT domain_count = { } NEW_LINE for cpdomain in cpdomains : NEW_LINE INDENT count , domain = cpdomain . split ( ' \u2581 ' ) NEW_LINE sub_domain = domain . split ( ' . ' ) NEW_LINE for i in range ( len ( sub_domain ) ) : NEW_LINE INDENT curr = ' . ' . join ( sub_domain [ i : ] ) NEW_LINE domain_count [ curr ] = domain_count . get ( curr , 0 ) + int ( count ) NEW_LINE DEDENT DEDENT return [ str ( v ) + ' \u2581 ' + k for k , v in domain_count . items ( ) ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_628_A", "java": [{"id": "1", "code": "public class Solution { public int maximumProduct ( int [ ] nums ) { int min1 = Integer . MAX_VALUE , min2 = Integer . MAX_VALUE ; int max1 = Integer . MIN_VALUE , max2 = Integer . MIN_VALUE , max3 = Integer . MIN_VALUE ; for ( int n : nums ) { if ( n <= min1 ) { min2 = min1 ; min1 = n ; } else if ( n <= min2 ) { min2 = n ; } if ( n >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = n ; } else if ( n >= max2 ) { max3 = max2 ; max2 = n ; } else if ( n >= max3 ) { max3 = n ; } } return Math . max ( min1 * min2 * max1 , max1 * max2 * max3 ) ; } }", "functions_standalone": [], "functions_class": [["maximumProduct", "public int maximumProduct ( int [ ] nums ) { int min1 = Integer . MAX_VALUE , min2 = Integer . MAX_VALUE ; int max1 = Integer . MIN_VALUE , max2 = Integer . MIN_VALUE , max3 = Integer . MIN_VALUE ; for ( int n : nums ) { if ( n <= min1 ) { min2 = min1 ; min1 = n ; } else if ( n <= min2 ) { min2 = n ; } if ( n >= max1 ) { max3 = max2 ; max2 = max1 ; max1 = n ; } else if ( n >= max2 ) { max3 = max2 ; max2 = n ; } else if ( n >= max3 ) { max3 = n ; } } return Math . max ( min1 * min2 * max1 , max1 * max2 * max3 ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def maximumProduct ( self , nums ) : NEW_LINE INDENT min1 = min2 = float ( ' inf ' ) NEW_LINE max1 = max2 = max3 = float ( ' - inf ' ) NEW_LINE for num in nums : NEW_LINE INDENT if num <= min1 : NEW_LINE INDENT min2 = min1 NEW_LINE min1 = num NEW_LINE DEDENT elif num <= min2 : NEW_LINE INDENT min2 = num NEW_LINE DEDENT if num >= max1 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = max1 NEW_LINE max1 = num NEW_LINE DEDENT elif num >= max2 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = num NEW_LINE DEDENT elif num >= max3 : NEW_LINE INDENT max3 = num NEW_LINE DEDENT DEDENT return max ( min1 * min2 * max1 , max1 * max2 * max3 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["maximumProduct", "def maximumProduct ( self , nums ) : NEW_LINE INDENT min1 = min2 = float ( ' inf ' ) NEW_LINE max1 = max2 = max3 = float ( ' - inf ' ) NEW_LINE for num in nums : NEW_LINE INDENT if num <= min1 : NEW_LINE INDENT min2 = min1 NEW_LINE min1 = num NEW_LINE DEDENT elif num <= min2 : NEW_LINE INDENT min2 = num NEW_LINE DEDENT if num >= max1 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = max1 NEW_LINE max1 = num NEW_LINE DEDENT elif num >= max2 : NEW_LINE INDENT max3 = max2 NEW_LINE max2 = num NEW_LINE DEDENT elif num >= max3 : NEW_LINE INDENT max3 = num NEW_LINE DEDENT DEDENT return max ( min1 * min2 * max1 , max1 * max2 * max3 ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1310_A", "java": [{"id": "1", "code": "class Solution { public int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] res = new int [ queries . length ] , q ; for ( int i = 1 ; i < arr . length ; i ++ ) arr [ i ] ^= arr [ i - 1 ] ; for ( int i = 0 ; i < queries . length ; i ++ ) { q = queries [ i ] ; res [ i ] = q [ 0 ] > 0 ? arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] : arr [ q [ 1 ] ] ; } return res ; } }", "functions_standalone": [], "functions_class": [["xorQueries", "public int [ ] xorQueries ( int [ ] arr , int [ ] [ ] queries ) { int [ ] res = new int [ queries . length ] , q ; for ( int i = 1 ; i < arr . length ; i ++ ) arr [ i ] ^= arr [ i - 1 ] ; for ( int i = 0 ; i < queries . length ; i ++ ) { q = queries [ i ] ; res [ i ] = q [ 0 ] > 0 ? arr [ q [ 0 ] - 1 ] ^ arr [ q [ 1 ] ] : arr [ q [ 1 ] ] ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def xorQueries ( self , arr : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT pref = [ 0 ] NEW_LINE for e in arr : NEW_LINE INDENT pref . append ( e ^ pref [ - 1 ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for [ l , r ] in queries : NEW_LINE INDENT ans . append ( pref [ r + 1 ] ^ pref [ l ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["xorQueries", "def xorQueries ( self , arr : List [ int ] , queries : List [ List [ int ] ] ) -> List [ int ] : NEW_LINE INDENT pref = [ 0 ] NEW_LINE for e in arr : NEW_LINE INDENT pref . append ( e ^ pref [ - 1 ] ) NEW_LINE DEDENT ans = [ ] NEW_LINE for [ l , r ] in queries : NEW_LINE INDENT ans . append ( pref [ r + 1 ] ^ pref [ l ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_273_A", "java": [{"id": "1", "code": "class Solution { private final String [ ] LESS_THAN_20 = { \" \" , \" One \" , \" Two \" , \" Three \" , \" Four \" , \" Five \" , \" Six \" , \" Seven \" , \" Eight \" , \" Nine \" , \" Ten \" , \" Eleven \" , \" Twelve \" , \" Thirteen \" , \" Fourteen \" , \" Fifteen \" , \" Sixteen \" , \" Seventeen \" , \" Eighteen \" , \" Nineteen \" } ; private final String [ ] TENS = { \" \" , \" Ten \" , \" Twenty \" , \" Thirty \" , \" Forty \" , \" Fifty \" , \" Sixty \" , \" Seventy \" , \" Eighty \" , \" Ninety \" } ; private final String [ ] THOUSANDS = { \" \" , \" Thousand \" , \" Million \" , \" Billion \" } ; public String numberToWords ( int num ) { if ( num == 0 ) return \" Zero \" ; int i = 0 ; String words = \" \" ; while ( num > 0 ) { if ( num % 1000 != 0 ) words = helper ( num % 1000 ) + THOUSANDS [ i ] + \" \u2581 \" + words ; num /= 1000 ; i ++ ; } return words . trim ( ) ; } private String helper ( int num ) { if ( num == 0 ) return \" \" ; else if ( num < 20 ) return LESS_THAN_20 [ num ] + \" \u2581 \" ; else if ( num < 100 ) return TENS [ num / 10 ] + \" \u2581 \" + helper ( num % 10 ) ; else return LESS_THAN_20 [ num / 100 ] + \" \u2581 Hundred \u2581 \" + helper ( num % 100 ) ; } }", "functions_standalone": [], "functions_class": [["numberToWords", "public String numberToWords ( int num ) { if ( num == 0 ) return \" Zero \" ; int i = 0 ; String words = \" \" ; while ( num > 0 ) { if ( num % 1000 != 0 ) words = helper ( num % 1000 ) + THOUSANDS [ i ] + \" \u2581 \" + words ; num /= 1000 ; i ++ ; } return words . trim ( ) ; }"], ["helper", "private String helper ( int num ) { if ( num == 0 ) return \" \" ; else if ( num < 20 ) return LESS_THAN_20 [ num ] + \" \u2581 \" ; else if ( num < 100 ) return TENS [ num / 10 ] + \" \u2581 \" + helper ( num % 10 ) ; else return LESS_THAN_20 [ num / 100 ] + \" \u2581 Hundred \u2581 \" + helper ( num % 100 ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def numberToWords ( self , num ) : NEW_LINE INDENT to19 = ' One \u2581 Two \u2581 Three \u2581 Four \u2581 Five \u2581 Six \u2581 Seven \u2581 Eight \u2581 Nine \u2581 Ten \u2581 Eleven \u2581 Twelve \u2581 ' ' Thirteen \u2581 Fourteen \u2581 Fifteen \u2581 Sixteen \u2581 Seventeen \u2581 Eighteen \u2581 Nineteen ' . split ( ) NEW_LINE tens = ' Twenty \u2581 Thirty \u2581 Forty \u2581 Fifty \u2581 Sixty \u2581 Seventy \u2581 Eighty \u2581 Ninety ' . split ( ) NEW_LINE def words ( n ) : NEW_LINE INDENT if n < 20 : NEW_LINE INDENT return to19 [ n - 1 : n ] NEW_LINE DEDENT if n < 100 : NEW_LINE INDENT return [ tens [ n / 10 - 2 ] ] + words ( n % 10 ) NEW_LINE DEDENT if n < 1000 : NEW_LINE INDENT return [ to19 [ n / 100 - 1 ] ] + [ ' Hundred ' ] + words ( n % 100 ) NEW_LINE DEDENT for p , w in enumerate ( ( ' Thousand ' , ' Million ' , ' Billion ' ) , 1 ) : NEW_LINE INDENT if n < 1000 ** ( p + 1 ) : NEW_LINE INDENT return words ( n / 1000 ** p ) + [ w ] + words ( n % 1000 ** p ) NEW_LINE DEDENT DEDENT DEDENT return ' \u2581 ' . join ( words ( num ) ) or ' Zero ' NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["numberToWords", "def numberToWords ( self , num ) : NEW_LINE INDENT to19 = ' One \u2581 Two \u2581 Three \u2581 Four \u2581 Five \u2581 Six \u2581 Seven \u2581 Eight \u2581 Nine \u2581 Ten \u2581 Eleven \u2581 Twelve \u2581 ' ' Thirteen \u2581 Fourteen \u2581 Fifteen \u2581 Sixteen \u2581 Seventeen \u2581 Eighteen \u2581 Nineteen ' . split ( ) NEW_LINE tens = ' Twenty \u2581 Thirty \u2581 Forty \u2581 Fifty \u2581 Sixty \u2581 Seventy \u2581 Eighty \u2581 Ninety ' . split ( ) NEW_LINE def words ( n ) : NEW_LINE INDENT if n < 20 : NEW_LINE INDENT return to19 [ n - 1 : n ] NEW_LINE DEDENT if n < 100 : NEW_LINE INDENT return [ tens [ n / 10 - 2 ] ] + words ( n % 10 ) NEW_LINE DEDENT if n < 1000 : NEW_LINE INDENT return [ to19 [ n / 100 - 1 ] ] + [ ' Hundred ' ] + words ( n % 100 ) NEW_LINE DEDENT for p , w in enumerate ( ( ' Thousand ' , ' Million ' , ' Billion ' ) , 1 ) : NEW_LINE INDENT if n < 1000 ** ( p + 1 ) : NEW_LINE INDENT return words ( n / 1000 ** p ) + [ w ] + words ( n % 1000 ** p ) NEW_LINE DEDENT DEDENT DEDENT return ' \u2581 ' . join ( words ( num ) ) or ' Zero ' NEW_LINE DEDENT"]]}]}
{"id": "leetcode_617_A", "java": [{"id": "1", "code": "public class Solution { public TreeNode mergeTrees ( TreeNode t1 , TreeNode t2 ) { if ( t1 == null ) return t2 ; if ( t2 == null ) return t1 ; t1 . val += t2 . val ; t1 . left = mergeTrees ( t1 . left , t2 . left ) ; t1 . right = mergeTrees ( t1 . right , t2 . right ) ; return t1 ; } }", "functions_standalone": [], "functions_class": [["mergeTrees", "public TreeNode mergeTrees ( TreeNode t1 , TreeNode t2 ) { if ( t1 == null ) return t2 ; if ( t2 == null ) return t1 ; t1 . val += t2 . val ; t1 . left = mergeTrees ( t1 . left , t2 . left ) ; t1 . right = mergeTrees ( t1 . right , t2 . right ) ; return t1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def mergeTrees ( self , t1 , t2 ) : NEW_LINE INDENT if t1 is None : NEW_LINE INDENT return t2 NEW_LINE DEDENT if t2 is None : NEW_LINE INDENT return t1 NEW_LINE DEDENT t1 . val += t2 . val NEW_LINE t1 . left = self . mergeTrees ( t1 . left , t2 . left ) NEW_LINE t1 . right = self . mergeTrees ( t1 . right , t2 . right ) NEW_LINE return t1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["mergeTrees", "def mergeTrees ( self , t1 , t2 ) : NEW_LINE INDENT if t1 is None : NEW_LINE INDENT return t2 NEW_LINE DEDENT if t2 is None : NEW_LINE INDENT return t1 NEW_LINE DEDENT t1 . val += t2 . val NEW_LINE t1 . left = self . mergeTrees ( t1 . left , t2 . left ) NEW_LINE t1 . right = self . mergeTrees ( t1 . right , t2 . right ) NEW_LINE return t1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_414_A", "java": [{"id": "1", "code": "public class Solution { public int thirdMax ( int [ ] nums ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( 3 ) ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : nums ) { if ( set . contains ( i ) ) continue ; pq . offer ( i ) ; set . add ( i ) ; if ( pq . size ( ) > 3 ) set . remove ( pq . poll ( ) ) ; } while ( pq . size ( ) < 3 && pq . size ( ) > 1 ) { pq . poll ( ) ; } return pq . peek ( ) ; } }", "functions_standalone": [], "functions_class": [["thirdMax", "public int thirdMax ( int [ ] nums ) { PriorityQueue < Integer > pq = new PriorityQueue < > ( 3 ) ; Set < Integer > set = new HashSet < > ( ) ; for ( int i : nums ) { if ( set . contains ( i ) ) continue ; pq . offer ( i ) ; set . add ( i ) ; if ( pq . size ( ) > 3 ) set . remove ( pq . poll ( ) ) ; } while ( pq . size ( ) < 3 && pq . size ( ) > 1 ) { pq . poll ( ) ; } return pq . peek ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["thirdMax", "def thirdMax ( self , nums ) : NEW_LINE INDENT import Queue NEW_LINE pq = Queue . PriorityQueue ( 4 ) NEW_LINE check = set ( ) NEW_LINE for n in nums : NEW_LINE INDENT if n in check : NEW_LINE INDENT continue NEW_LINE DEDENT pq . put ( n ) NEW_LINE check . add ( n ) NEW_LINE if len ( check ) > 3 : NEW_LINE INDENT check . remove ( pq . get ( ) ) NEW_LINE DEDENT DEDENT total = len ( check ) NEW_LINE while total < 3 and total > 1 : NEW_LINE INDENT total -= 1 NEW_LINE DEDENT return pq . get ( ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_448_A", "java": [{"id": "1", "code": "class Solution { public List < Integer > findDisappearedNumbers ( int [ ] nums ) { List < Integer > ret = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int val = Math . abs ( nums [ i ] ) - 1 ; if ( nums [ val ] > 0 ) { nums [ val ] = - nums [ val ] ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { ret . add ( i + 1 ) ; } } return ret ; } }", "functions_standalone": [], "functions_class": [["findDisappearedNumbers", "public List < Integer > findDisappearedNumbers ( int [ ] nums ) { List < Integer > ret = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int val = Math . abs ( nums [ i ] ) - 1 ; if ( nums [ val ] > 0 ) { nums [ val ] = - nums [ val ] ; } } for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { ret . add ( i + 1 ) ; } } return ret ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findDisappearedNumbers", "def findDisappearedNumbers ( self , nums ) : NEW_LINE INDENT res = [ ] NEW_LINE if nums : NEW_LINE INDENT n = len ( nums ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = abs ( nums [ i ] ) - 1 NEW_LINE if nums [ val ] > 0 : NEW_LINE INDENT nums [ val ] = - nums [ val ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if nums [ i ] > 0 : NEW_LINE INDENT res . append ( i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_680_A", "java": [{"id": "1", "code": "class Solution { public boolean isPalindromeRange ( String s , int i , int j ) { for ( int k = i ; k <= i + ( j - i ) / 2 ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( j - k + i ) ) return false ; } return true ; } public boolean validPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - 1 - i ) ) { int j = s . length ( ) - 1 - i ; return ( isPalindromeRange ( s , i + 1 , j ) || isPalindromeRange ( s , i , j - 1 ) ) ; } } return true ; } }", "functions_standalone": [], "functions_class": [["isPalindromeRange", "public boolean isPalindromeRange ( String s , int i , int j ) { for ( int k = i ; k <= i + ( j - i ) / 2 ; k ++ ) { if ( s . charAt ( k ) != s . charAt ( j - k + i ) ) return false ; } return true ; }"], ["validPalindrome", "public boolean validPalindrome ( String s ) { for ( int i = 0 ; i < s . length ( ) / 2 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - 1 - i ) ) { int j = s . length ( ) - 1 - i ; return ( isPalindromeRange ( s , i + 1 , j ) || isPalindromeRange ( s , i , j - 1 ) ) ; } } return true ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def validPalindrome ( self , s ) : NEW_LINE INDENT return self . validPalindromeHelper ( s , 0 , len ( s ) - 1 , 1 ) NEW_LINE DEDENT def validPalindromeHelper ( self , s , left , right , budget ) : NEW_LINE INDENT while left < len ( s ) and right >= 0 and left <= right and s [ left ] == s [ right ] : NEW_LINE INDENT left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT if left >= len ( s ) or right < 0 or left >= right : NEW_LINE INDENT return True NEW_LINE DEDENT if budget == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT budget -= 1 NEW_LINE return self . validPalindromeHelper ( s , left + 1 , right , budget ) or self . validPalindromeHelper ( s , left , right - 1 , budget ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["validPalindrome", "def validPalindrome ( self , s ) : NEW_LINE INDENT return self . validPalindromeHelper ( s , 0 , len ( s ) - 1 , 1 ) NEW_LINE DEDENT"], ["validPalindromeHelper", "def validPalindromeHelper ( self , s , left , right , budget ) : NEW_LINE INDENT while left < len ( s ) and right >= 0 and left <= right and s [ left ] == s [ right ] : NEW_LINE INDENT left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT if left >= len ( s ) or right < 0 or left >= right : NEW_LINE INDENT return True NEW_LINE DEDENT if budget == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT budget -= 1 NEW_LINE return self . validPalindromeHelper ( s , left + 1 , right , budget ) or self . validPalindromeHelper ( s , left , right - 1 , budget ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_674_A", "java": [{"id": "1", "code": "class Solution { public int findLengthOfLCIS ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; int curr = 1 , ans = 1 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] < nums [ i + 1 ] ) { curr ++ ; if ( curr >= ans ) ans = curr ; } else { curr = 1 ; } } return ans ; } }", "functions_standalone": [], "functions_class": [["findLengthOfLCIS", "public int findLengthOfLCIS ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; int curr = 1 , ans = 1 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] < nums [ i + 1 ] ) { curr ++ ; if ( curr >= ans ) ans = curr ; } else { curr = 1 ; } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findLengthOfLCIS ( self , nums ) : NEW_LINE INDENT if not nums or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = curr = 1 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT curr += 1 NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT else : NEW_LINE INDENT curr = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findLengthOfLCIS", "def findLengthOfLCIS ( self , nums ) : NEW_LINE INDENT if not nums or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = curr = 1 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if nums [ i ] < nums [ i + 1 ] : NEW_LINE INDENT curr += 1 NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT else : NEW_LINE INDENT curr = 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_479_A", "java": [{"id": "1", "code": "class Solution { public int largestPalindrome ( int n ) { if ( n == 1 ) { return 9 ; } int upperBound = ( int ) Math . pow ( 10 , n ) - 1 , lowerBound = upperBound / 10 ; long maxNumber = ( long ) upperBound * ( long ) upperBound ; int firstHalf = ( int ) ( maxNumber / ( long ) Math . pow ( 10 , n ) ) ; boolean palindromFound = false ; long palindrom = 0 ; while ( ! palindromFound ) { palindrom = createPalindrom ( firstHalf ) ; for ( long i = upperBound ; upperBound > lowerBound ; i -- ) { if ( palindrom / i > maxNumber || i * i < palindrom ) { break ; } if ( palindrom % i == 0 ) { palindromFound = true ; break ; } } firstHalf -- ; } return ( int ) ( palindrom % 1337 ) ; } private long createPalindrom ( long num ) { String str = num + new StringBuilder ( ) . append ( num ) . reverse ( ) . toString ( ) ; return Long . parseLong ( str ) ; } }", "functions_standalone": [], "functions_class": [["largestPalindrome", "public int largestPalindrome ( int n ) { if ( n == 1 ) { return 9 ; } int upperBound = ( int ) Math . pow ( 10 , n ) - 1 , lowerBound = upperBound / 10 ; long maxNumber = ( long ) upperBound * ( long ) upperBound ; int firstHalf = ( int ) ( maxNumber / ( long ) Math . pow ( 10 , n ) ) ; boolean palindromFound = false ; long palindrom = 0 ; while ( ! palindromFound ) { palindrom = createPalindrom ( firstHalf ) ; for ( long i = upperBound ; upperBound > lowerBound ; i -- ) { if ( palindrom / i > maxNumber || i * i < palindrom ) { break ; } if ( palindrom % i == 0 ) { palindromFound = true ; break ; } } firstHalf -- ; } return ( int ) ( palindrom % 1337 ) ; }"], ["createPalindrom", "private long createPalindrom ( long num ) { String str = num + new StringBuilder ( ) . append ( num ) . reverse ( ) . toString ( ) ; return Long . parseLong ( str ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def largestPalindrome ( self , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 9 NEW_LINE DEDENT for a in xrange ( 2 , 9 * 10 ** ( n - 1 ) ) : NEW_LINE INDENT hi = ( 10 ** n ) - a NEW_LINE lo = int ( str ( hi ) [ : : - 1 ] ) NEW_LINE if a ** 2 - 4 * lo < 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a ** 2 - 4 * lo ) ** .5 == int ( ( a ** 2 - 4 * lo ) ** .5 ) : NEW_LINE INDENT return ( lo + 10 ** n * ( 10 ** n - a ) ) % 1337 NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_819_A", "java": [{"id": "1", "code": "class Solution { public String mostCommonWord ( String paragraph , String [ ] banned ) { paragraph += \" . \" ; Set < String > banset = new HashSet ( ) ; for ( String word : banned ) banset . add ( word ) ; Map < String , Integer > count = new HashMap ( ) ; String ans = \" \" ; int ansfreq = 0 ; StringBuilder word = new StringBuilder ( ) ; for ( char c : paragraph . toCharArray ( ) ) { if ( Character . isLetter ( c ) ) { word . append ( Character . toLowerCase ( c ) ) ; } else if ( word . length ( ) > 0 ) { String finalword = word . toString ( ) ; if ( ! banset . contains ( finalword ) ) { count . put ( finalword , count . getOrDefault ( finalword , 0 ) + 1 ) ; if ( count . get ( finalword ) > ansfreq ) { ans = finalword ; ansfreq = count . get ( finalword ) ; } } word = new StringBuilder ( ) ; } } return ans ; } }", "functions_standalone": [], "functions_class": [["mostCommonWord", "public String mostCommonWord ( String paragraph , String [ ] banned ) { paragraph += \" . \" ; Set < String > banset = new HashSet ( ) ; for ( String word : banned ) banset . add ( word ) ; Map < String , Integer > count = new HashMap ( ) ; String ans = \" \" ; int ansfreq = 0 ; StringBuilder word = new StringBuilder ( ) ; for ( char c : paragraph . toCharArray ( ) ) { if ( Character . isLetter ( c ) ) { word . append ( Character . toLowerCase ( c ) ) ; } else if ( word . length ( ) > 0 ) { String finalword = word . toString ( ) ; if ( ! banset . contains ( finalword ) ) { count . put ( finalword , count . getOrDefault ( finalword , 0 ) + 1 ) ; if ( count . get ( finalword ) > ansfreq ) { ans = finalword ; ansfreq = count . get ( finalword ) ; } } word = new StringBuilder ( ) ; } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def mostCommonWord ( self , paragraph , banned ) : NEW_LINE INDENT banned = set ( banned ) NEW_LINE count = collections . Counter ( word for word in re . split ( ' [ \u2581 ! ? \\ ' , ; . ] ' , paragraph . lower ( ) ) if word ) NEW_LINE return max ( ( item for item in count . items ( ) if item [ 0 ] not in banned ) , key = operator . itemgetter ( 1 ) ) [ 0 ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["mostCommonWord", "def mostCommonWord ( self , paragraph , banned ) : NEW_LINE INDENT banned = set ( banned ) NEW_LINE count = collections . Counter ( word for word in re . split ( ' [ \u2581 ! ? \\ ' , ; . ] ' , paragraph . lower ( ) ) if word ) NEW_LINE return max ( ( item for item in count . items ( ) if item [ 0 ] not in banned ) , key = operator . itemgetter ( 1 ) ) [ 0 ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_872_A", "java": [{"id": "1", "code": "class Solution { public boolean leafSimilar ( TreeNode root1 , TreeNode root2 ) { List < Integer > leaves1 = new ArrayList ( ) ; List < Integer > leaves2 = new ArrayList ( ) ; dfs ( root1 , leaves1 ) ; dfs ( root2 , leaves2 ) ; return leaves1 . equals ( leaves2 ) ; } public void dfs ( TreeNode node , List < Integer > leafValues ) { if ( node != null ) { if ( node . left == null && node . right == null ) leafValues . add ( node . val ) ; dfs ( node . left , leafValues ) ; dfs ( node . right , leafValues ) ; } } }", "functions_standalone": [], "functions_class": [["leafSimilar", "public boolean leafSimilar ( TreeNode root1 , TreeNode root2 ) { List < Integer > leaves1 = new ArrayList ( ) ; List < Integer > leaves2 = new ArrayList ( ) ; dfs ( root1 , leaves1 ) ; dfs ( root2 , leaves2 ) ; return leaves1 . equals ( leaves2 ) ; }"], ["dfs", "public void dfs ( TreeNode node , List < Integer > leafValues ) { if ( node != null ) { if ( node . left == null && node . right == null ) leafValues . add ( node . val ) ; dfs ( node . left , leafValues ) ; dfs ( node . right , leafValues ) ; } }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def leafSimilar ( self , root1 , root2 ) : NEW_LINE INDENT if not root1 and not root2 : NEW_LINE INDENT return True NEW_LINE DEDENT leaf1 = [ ] NEW_LINE leaf2 = [ ] NEW_LINE self . dfs ( root1 , leaf1 ) NEW_LINE self . dfs ( root2 , leaf2 ) NEW_LINE if leaf1 == leaf2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def dfs ( self , node , leavels ) : NEW_LINE INDENT if not node : NEW_LINE INDENT return NEW_LINE DEDENT if not node . left and not node . right : NEW_LINE INDENT leavels . append ( node . val ) NEW_LINE DEDENT self . dfs ( node . left , leavels ) NEW_LINE self . dfs ( node . right , leavels ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["leafSimilar", "def leafSimilar ( self , root1 , root2 ) : NEW_LINE INDENT if not root1 and not root2 : NEW_LINE INDENT return True NEW_LINE DEDENT leaf1 = [ ] NEW_LINE leaf2 = [ ] NEW_LINE self . dfs ( root1 , leaf1 ) NEW_LINE self . dfs ( root2 , leaf2 ) NEW_LINE if leaf1 == leaf2 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT"], ["dfs", "def dfs ( self , node , leavels ) : NEW_LINE INDENT if not node : NEW_LINE INDENT return NEW_LINE DEDENT if not node . left and not node . right : NEW_LINE INDENT leavels . append ( node . val ) NEW_LINE DEDENT self . dfs ( node . left , leavels ) NEW_LINE self . dfs ( node . right , leavels ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_415_A", "java": [{"id": "1", "code": "public class Solution { public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder ( ) ; int carry = 0 ; for ( int i = num1 . length ( ) - 1 , j = num2 . length ( ) - 1 ; i >= 0 || j >= 0 || carry == 1 ; i -- , j -- ) { int x = i < 0 ? 0 : num1 . charAt ( i ) - '0' ; int y = j < 0 ? 0 : num2 . charAt ( j ) - '0' ; sb . append ( ( x + y + carry ) % 10 ) ; carry = ( x + y + carry ) / 10 ; } return sb . reverse ( ) . toString ( ) ; } }", "functions_standalone": [], "functions_class": [["addStrings", "public String addStrings ( String num1 , String num2 ) { StringBuilder sb = new StringBuilder ( ) ; int carry = 0 ; for ( int i = num1 . length ( ) - 1 , j = num2 . length ( ) - 1 ; i >= 0 || j >= 0 || carry == 1 ; i -- , j -- ) { int x = i < 0 ? 0 : num1 . charAt ( i ) - '0' ; int y = j < 0 ? 0 : num2 . charAt ( j ) - '0' ; sb . append ( ( x + y + carry ) % 10 ) ; carry = ( x + y + carry ) / 10 ; } return sb . reverse ( ) . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT res = [ ] NEW_LINE pos1 = len ( num1 ) - 1 NEW_LINE pos2 = len ( num2 ) - 1 NEW_LINE carry = 0 NEW_LINE while pos1 >= 0 or pos2 >= 0 or carry == 1 : NEW_LINE INDENT digit1 = digit2 = 0 NEW_LINE if pos1 >= 0 : NEW_LINE INDENT digit1 = ord ( num1 [ pos1 ] ) - ord ( '0' ) NEW_LINE DEDENT if pos2 >= 0 : NEW_LINE INDENT digit2 = ord ( num2 [ pos2 ] ) - ord ( '0' ) NEW_LINE DEDENT res . append ( str ( ( digit1 + digit2 + carry ) % 10 ) ) NEW_LINE carry = ( digit1 + digit2 + carry ) / 10 NEW_LINE pos1 -= 1 NEW_LINE pos2 -= 1 NEW_LINE DEDENT return ' ' . join ( res [ : : - 1 ] ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["addStrings", "def addStrings ( self , num1 , num2 ) : NEW_LINE INDENT res = [ ] NEW_LINE pos1 = len ( num1 ) - 1 NEW_LINE pos2 = len ( num2 ) - 1 NEW_LINE carry = 0 NEW_LINE while pos1 >= 0 or pos2 >= 0 or carry == 1 : NEW_LINE INDENT digit1 = digit2 = 0 NEW_LINE if pos1 >= 0 : NEW_LINE INDENT digit1 = ord ( num1 [ pos1 ] ) - ord ( '0' ) NEW_LINE DEDENT if pos2 >= 0 : NEW_LINE INDENT digit2 = ord ( num2 [ pos2 ] ) - ord ( '0' ) NEW_LINE DEDENT res . append ( str ( ( digit1 + digit2 + carry ) % 10 ) ) NEW_LINE carry = ( digit1 + digit2 + carry ) / 10 NEW_LINE pos1 -= 1 NEW_LINE pos2 -= 1 NEW_LINE DEDENT return ' ' . join ( res [ : : - 1 ] ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_412_A", "java": [{"id": "1", "code": "import java . util . ArrayList ; import java . util . List ; class Solution { public List < String > fizzBuzz ( int n ) { List < String > res = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String tmp = \" \" ; if ( i % 3 == 0 ) tmp += \" Fizz \" ; if ( i % 5 == 0 ) tmp += \" Buzz \" ; if ( tmp . length ( ) == 0 ) tmp += String . valueOf ( i ) ; res . add ( tmp ) ; } return res ; } }", "functions_standalone": [], "functions_class": [["fizzBuzz", "public List < String > fizzBuzz ( int n ) { List < String > res = new ArrayList < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { String tmp = \" \" ; if ( i % 3 == 0 ) tmp += \" Fizz \" ; if ( i % 5 == 0 ) tmp += \" Buzz \" ; if ( tmp . length ( ) == 0 ) tmp += String . valueOf ( i ) ; res . add ( tmp ) ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def fizzBuzz ( self , n ) : NEW_LINE INDENT return [ str ( i ) * ( i % 3 != 0 and i % 5 != 0 ) + \" Fizz \" * ( i % 3 == 0 ) + \" Buzz \" * ( i % 5 == 0 ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["fizzBuzz", "def fizzBuzz ( self , n ) : NEW_LINE INDENT return [ str ( i ) * ( i % 3 != 0 and i % 5 != 0 ) + \" Fizz \" * ( i % 3 == 0 ) + \" Buzz \" * ( i % 5 == 0 ) for i in range ( 1 , n + 1 ) ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_844_A", "java": [{"id": "1", "code": "class Solution { public boolean backspaceCompare ( String S , String T ) { return trans ( S ) . equals ( trans ( T ) ) ; } private String trans ( String str ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : str . toCharArray ( ) ) { if ( c != ' # ' ) { sb . append ( c ) ; } else if ( sb . length ( ) > 0 ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } return sb . toString ( ) ; } }", "functions_standalone": [], "functions_class": [["backspaceCompare", "public boolean backspaceCompare ( String S , String T ) { return trans ( S ) . equals ( trans ( T ) ) ; }"], ["trans", "private String trans ( String str ) { StringBuilder sb = new StringBuilder ( ) ; for ( char c : str . toCharArray ( ) ) { if ( c != ' # ' ) { sb . append ( c ) ; } else if ( sb . length ( ) > 0 ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } } return sb . toString ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def backspaceCompare ( self , S , T ) : NEW_LINE INDENT if S == T : NEW_LINE INDENT return True NEW_LINE DEDENT s_stack = [ ] NEW_LINE t_stack = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT s_stack . append ( c ) NEW_LINE DEDENT elif len ( s_stack ) != 0 : NEW_LINE INDENT s_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT for c in T : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT t_stack . append ( c ) NEW_LINE DEDENT elif len ( t_stack ) != 0 : NEW_LINE INDENT t_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT return ' ' . join ( s_stack ) == ' ' . join ( t_stack ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["backspaceCompare", "def backspaceCompare ( self , S , T ) : NEW_LINE INDENT if S == T : NEW_LINE INDENT return True NEW_LINE DEDENT s_stack = [ ] NEW_LINE t_stack = [ ] NEW_LINE for c in S : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT s_stack . append ( c ) NEW_LINE DEDENT elif len ( s_stack ) != 0 : NEW_LINE INDENT s_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT for c in T : NEW_LINE INDENT if c != ' # ' : NEW_LINE INDENT t_stack . append ( c ) NEW_LINE DEDENT elif len ( t_stack ) != 0 : NEW_LINE INDENT t_stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT return ' ' . join ( s_stack ) == ' ' . join ( t_stack ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_401_A", "java": [{"id": "1", "code": "class Solution { public List < String > readBinaryWatch ( int num ) { List < String > times = new ArrayList < > ( ) ; for ( int h = 0 ; h < 12 ; h ++ ) for ( int m = 0 ; m < 60 ; m ++ ) if ( Integer . bitCount ( h * 64 + m ) == num ) times . add ( String . format ( \" % d : %02d \" , h , m ) ) ; return times ; } }", "functions_standalone": [], "functions_class": [["readBinaryWatch", "public List < String > readBinaryWatch ( int num ) { List < String > times = new ArrayList < > ( ) ; for ( int h = 0 ; h < 12 ; h ++ ) for ( int m = 0 ; m < 60 ; m ++ ) if ( Integer . bitCount ( h * 64 + m ) == num ) times . add ( String . format ( \" % d : %02d \" , h , m ) ) ; return times ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def readBinaryWatch ( self , num ) : NEW_LINE INDENT return [ ' % d : %02d ' % ( h , m ) for h in range ( 12 ) for m in range ( 60 ) if ( bin ( h ) + bin ( m ) ) . count ( '1' ) == num ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["readBinaryWatch", "def readBinaryWatch ( self , num ) : NEW_LINE INDENT return [ ' % d : %02d ' % ( h , m ) for h in range ( 12 ) for m in range ( 60 ) if ( bin ( h ) + bin ( m ) ) . count ( '1' ) == num ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_268_A", "java": [{"id": "1", "code": "class Solution { public int missingNumber ( int [ ] nums ) { int res = nums . length ; for ( int i = 0 ; i < nums . length ; i ++ ) { res ^= i ; res ^= nums [ i ] ; } return res ; } }", "functions_standalone": [], "functions_class": [["missingNumber", "public int missingNumber ( int [ ] nums ) { int res = nums . length ; for ( int i = 0 ; i < nums . length ; i ++ ) { res ^= i ; res ^= nums [ i ] ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def missingNumber ( self , nums ) : NEW_LINE INDENT res = len ( nums ) NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT res ^= i NEW_LINE res ^= v NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["missingNumber", "def missingNumber ( self , nums ) : NEW_LINE INDENT res = len ( nums ) NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT res ^= i NEW_LINE res ^= v NEW_LINE DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1108_A", "java": [{"id": "1", "code": "class Solution { public String defangIPaddr ( String address ) { return address . replace ( \" . \" , \" [ . ] \" ) ; } }", "functions_standalone": [], "functions_class": [["defangIPaddr", "public String defangIPaddr ( String address ) { return address . replace ( \" . \" , \" [ . ] \" ) ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["defangIPaddr", "def defangIPaddr ( self , address : str ) -> str : NEW_LINE INDENT return address . replace ( ' . ' , ' [ . ] ' ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_868_A", "java": [{"id": "1", "code": "class Solution { public int binaryGap ( int N ) { int last = - 1 , ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( ( N >> i ) & 1 ) > 0 ) { if ( last >= 0 ) ans = Math . max ( ans , i - last ) ; last = i ; } return ans ; } }", "functions_standalone": [], "functions_class": [["binaryGap", "public int binaryGap ( int N ) { int last = - 1 , ans = 0 ; for ( int i = 0 ; i < 32 ; ++ i ) if ( ( ( N >> i ) & 1 ) > 0 ) { if ( last >= 0 ) ans = Math . max ( ans , i - last ) ; last = i ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def binaryGap ( self , n : int ) -> int : NEW_LINE INDENT current = 1 NEW_LINE last1 = - 1 NEW_LINE out = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT if last1 >= 1 : NEW_LINE INDENT out = max ( out , current - last1 ) NEW_LINE DEDENT last1 = current NEW_LINE DEDENT current += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT return out NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["binaryGap", "def binaryGap ( self , n : int ) -> int : NEW_LINE INDENT current = 1 NEW_LINE last1 = - 1 NEW_LINE out = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT if last1 >= 1 : NEW_LINE INDENT out = max ( out , current - last1 ) NEW_LINE DEDENT last1 = current NEW_LINE DEDENT current += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT return out NEW_LINE DEDENT"]]}]}
{"id": "leetcode_437_A", "java": [{"id": "1", "code": "class Solution { private int result ; private HashMap < Integer , Integer > cache ; public int pathSum ( TreeNode root , int sum ) { result = 0 ; cache = new HashMap < Integer , Integer > ( ) ; cache . put ( 0 , 1 ) ; pathSumHelper ( root , sum , 0 ) ; return result ; } private void pathSumHelper ( TreeNode root , int target , int soFar ) { if ( root != null ) { int complement = soFar + root . val - target ; if ( cache . containsKey ( complement ) ) result += cache . get ( complement ) ; cache . put ( soFar + root . val , cache . getOrDefault ( soFar + root . val , 0 ) + 1 ) ; pathSumHelper ( root . left , target , soFar + root . val ) ; pathSumHelper ( root . right , target , soFar + root . val ) ; cache . put ( soFar + root . val , cache . get ( soFar + root . val ) - 1 ) ; } } }", "functions_standalone": [], "functions_class": [["pathSum", "public int pathSum ( TreeNode root , int sum ) { result = 0 ; cache = new HashMap < Integer , Integer > ( ) ; cache . put ( 0 , 1 ) ; pathSumHelper ( root , sum , 0 ) ; return result ; }"], ["pathSumHelper", "private void pathSumHelper ( TreeNode root , int target , int soFar ) { if ( root != null ) { int complement = soFar + root . val - target ; if ( cache . containsKey ( complement ) ) result += cache . get ( complement ) ; cache . put ( soFar + root . val , cache . getOrDefault ( soFar + root . val , 0 ) + 1 ) ; pathSumHelper ( root . left , target , soFar + root . val ) ; pathSumHelper ( root . right , target , soFar + root . val ) ; cache . put ( soFar + root . val , cache . get ( soFar + root . val ) - 1 ) ; } }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def pathSumHelper ( self , root , target , so_far , cache ) : NEW_LINE INDENT if root : NEW_LINE INDENT complement = so_far + root . val - target NEW_LINE if complement in cache : NEW_LINE INDENT self . result += cache [ complement ] NEW_LINE DEDENT cache [ so_far + root . val ] = cache . get ( so_far + root . val , 0 ) + 1 NEW_LINE self . pathSumHelper ( root . left , target , so_far + root . val , cache ) NEW_LINE self . pathSumHelper ( root . right , target , so_far + root . val , cache ) NEW_LINE cache [ so_far + root . val ] -= 1 NEW_LINE DEDENT return NEW_LINE DEDENT def pathSum ( self , root , sum ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . pathSumHelper ( root , sum , 0 , { 0 : 1 } ) NEW_LINE return self . result NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["pathSumHelper", "def pathSumHelper ( self , root , target , so_far , cache ) : NEW_LINE INDENT if root : NEW_LINE INDENT complement = so_far + root . val - target NEW_LINE if complement in cache : NEW_LINE INDENT self . result += cache [ complement ] NEW_LINE DEDENT cache [ so_far + root . val ] = cache . get ( so_far + root . val , 0 ) + 1 NEW_LINE self . pathSumHelper ( root . left , target , so_far + root . val , cache ) NEW_LINE self . pathSumHelper ( root . right , target , so_far + root . val , cache ) NEW_LINE cache [ so_far + root . val ] -= 1 NEW_LINE DEDENT return NEW_LINE DEDENT"], ["pathSum", "def pathSum ( self , root , sum ) : NEW_LINE INDENT self . result = 0 NEW_LINE self . pathSumHelper ( root , sum , 0 , { 0 : 1 } ) NEW_LINE return self . result NEW_LINE DEDENT"]]}]}
{"id": "leetcode_605_A", "java": [{"id": "1", "code": "public class Solution { public boolean canPlaceFlowers ( int [ ] flowerbed , int n ) { int count = 0 , curr ; for ( int i = 0 ; i < flowerbed . length ; i ++ ) { curr = flowerbed [ i ] ; if ( i - 1 >= 0 ) curr += flowerbed [ i - 1 ] ; if ( i + 1 < flowerbed . length ) curr += flowerbed [ i + 1 ] ; if ( curr == 0 ) { count ++ ; flowerbed [ i ] = 1 ; } if ( count >= n ) return true ; } return false ; } }", "functions_standalone": [], "functions_class": [["canPlaceFlowers", "public boolean canPlaceFlowers ( int [ ] flowerbed , int n ) { int count = 0 , curr ; for ( int i = 0 ; i < flowerbed . length ; i ++ ) { curr = flowerbed [ i ] ; if ( i - 1 >= 0 ) curr += flowerbed [ i - 1 ] ; if ( i + 1 < flowerbed . length ) curr += flowerbed [ i + 1 ] ; if ( curr == 0 ) { count ++ ; flowerbed [ i ] = 1 ; } if ( count >= n ) return true ; } return false ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def canPlaceFlowers ( self , flowerbed , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( flowerbed ) ) : NEW_LINE INDENT curr = flowerbed [ i ] NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT curr += flowerbed [ i - 1 ] NEW_LINE DEDENT if i + 1 < len ( flowerbed ) : NEW_LINE INDENT curr += flowerbed [ i + 1 ] NEW_LINE DEDENT if curr == 0 : NEW_LINE INDENT count += 1 NEW_LINE flowerbed [ i ] = 1 NEW_LINE if count >= n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["canPlaceFlowers", "def canPlaceFlowers ( self , flowerbed , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( flowerbed ) ) : NEW_LINE INDENT curr = flowerbed [ i ] NEW_LINE if i - 1 >= 0 : NEW_LINE INDENT curr += flowerbed [ i - 1 ] NEW_LINE DEDENT if i + 1 < len ( flowerbed ) : NEW_LINE INDENT curr += flowerbed [ i + 1 ] NEW_LINE DEDENT if curr == 0 : NEW_LINE INDENT count += 1 NEW_LINE flowerbed [ i ] = 1 NEW_LINE if count >= n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT"]]}]}
{"id": "leetcode_804_A", "java": [{"id": "1", "code": "class Solution { public int uniqueMorseRepresentations ( String [ ] words ) { String [ ] MORSE = new String [ ] { \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" } ; Set < String > seen = new HashSet ( ) ; for ( String word : words ) { StringBuilder code = new StringBuilder ( ) ; for ( char c : word . toCharArray ( ) ) code . append ( MORSE [ c - ' a ' ] ) ; seen . add ( code . toString ( ) ) ; } return seen . size ( ) ; } }", "functions_standalone": [], "functions_class": [["uniqueMorseRepresentations", "public int uniqueMorseRepresentations ( String [ ] words ) { String [ ] MORSE = new String [ ] { \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" } ; Set < String > seen = new HashSet ( ) ; for ( String word : words ) { StringBuilder code = new StringBuilder ( ) ; for ( char c : word . toCharArray ( ) ) code . append ( MORSE [ c - ' a ' ] ) ; seen . add ( code . toString ( ) ) ; } return seen . size ( ) ; }"]]}], "python": [{"id": "2", "code": "Morse_tab = [ \" . - \" , \" - . . . \" , \" - . - . \" , \" - . . \" , \" . \" , \" . . - . \" , \" - - . \" , \" . . . . \" , \" . . \" , \" . - - - \" , \" - . - \" , \" . - . . \" , \" - - \" , \" - . \" , \" - - - \" , \" . - - . \" , \" - - . - \" , \" . - . \" , \" . . . \" , \" - \" , \" . . - \" , \" . . . - \" , \" . - - \" , \" - . . - \" , \" - . - - \" , \" - - . . \" ] NEW_LINE class Solution ( object ) : NEW_LINE INDENT def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["uniqueMorseRepresentations", "def uniqueMorseRepresentations ( self , words ) : NEW_LINE INDENT if len ( words ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans_set = set ( ) NEW_LINE for word in words : NEW_LINE INDENT morsed = \" \" NEW_LINE for c in word : NEW_LINE INDENT morsed += Morse_tab [ ord ( c ) - ord ( ' a ' ) ] NEW_LINE DEDENT ans_set . add ( morsed ) NEW_LINE DEDENT return len ( ans_set ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_007_A", "java": [{"id": "1", "code": "class Solution { public int reverse ( int x ) { if ( x == 0 ) return 0 ; long res = 0 ; while ( x != 0 ) { res = res * 10 + x % 10 ; if ( res > Integer . MAX_VALUE || res < Integer . MIN_VALUE ) return 0 ; x /= 10 ; } return ( int ) res ; } }", "functions_standalone": [], "functions_class": [["reverse", "public int reverse ( int x ) { if ( x == 0 ) return 0 ; long res = 0 ; while ( x != 0 ) { res = res * 10 + x % 10 ; if ( res > Integer . MAX_VALUE || res < Integer . MIN_VALUE ) return 0 ; x /= 10 ; } return ( int ) res ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def reverse ( self , x ) : NEW_LINE INDENT res , isPos = 0 , 1 NEW_LINE if x < 0 : NEW_LINE INDENT isPos = - 1 NEW_LINE x = - 1 * x NEW_LINE DEDENT while x != 0 : NEW_LINE INDENT res = res * 10 + x % 10 NEW_LINE if res > 2147483647 : NEW_LINE INDENT return 0 NEW_LINE DEDENT x /= 10 NEW_LINE DEDENT return res * isPos NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["reverse", "def reverse ( self , x ) : NEW_LINE INDENT res , isPos = 0 , 1 NEW_LINE if x < 0 : NEW_LINE INDENT isPos = - 1 NEW_LINE x = - 1 * x NEW_LINE DEDENT while x != 0 : NEW_LINE INDENT res = res * 10 + x % 10 NEW_LINE if res > 2147483647 : NEW_LINE INDENT return 0 NEW_LINE DEDENT x /= 10 NEW_LINE DEDENT return res * isPos NEW_LINE DEDENT"]]}]}
{"id": "leetcode_204_A", "java": [{"id": "1", "code": "class Solution { public int countPrimes ( int n ) { boolean [ ] isPrime = new boolean [ n ] ; int count = 0 ; Arrays . fill ( isPrime , true ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( i * i >= n ) break ; if ( ! isPrime [ i ] ) continue ; for ( int j = i * i ; j < n ; j += i ) isPrime [ j ] = false ; } for ( int i = 2 ; i < n ; i ++ ) if ( isPrime [ i ] ) count ++ ; return count ; } }", "functions_standalone": [], "functions_class": [["countPrimes", "public int countPrimes ( int n ) { boolean [ ] isPrime = new boolean [ n ] ; int count = 0 ; Arrays . fill ( isPrime , true ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( i * i >= n ) break ; if ( ! isPrime [ i ] ) continue ; for ( int j = i * i ; j < n ; j += i ) isPrime [ j ] = false ; } for ( int i = 2 ; i < n ; i ++ ) if ( isPrime [ i ] ) count ++ ; return count ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def countPrimes ( self , n ) : NEW_LINE INDENT isPrime = [ True ] * n NEW_LINE for i in xrange ( 2 , n ) : NEW_LINE INDENT if i * i >= n : NEW_LINE INDENT break NEW_LINE DEDENT if not isPrime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for j in xrange ( i * i , n , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in xrange ( 2 , n ) : NEW_LINE INDENT if isPrime [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_832_A", "java": [{"id": "1", "code": "class Solution { public int [ ] [ ] flipAndInvertImage ( int [ ] [ ] A ) { int C = A [ 0 ] . length ; for ( int [ ] row : A ) for ( int i = 0 ; i < ( C + 1 ) / 2 ; ++ i ) { int tmp = row [ i ] ^ 1 ; row [ i ] = row [ C - 1 - i ] ^ 1 ; row [ C - 1 - i ] = tmp ; } return A ; } }", "functions_standalone": [], "functions_class": [["flipAndInvertImage", "public int [ ] [ ] flipAndInvertImage ( int [ ] [ ] A ) { int C = A [ 0 ] . length ; for ( int [ ] row : A ) for ( int i = 0 ; i < ( C + 1 ) / 2 ; ++ i ) { int tmp = row [ i ] ^ 1 ; row [ i ] = row [ C - 1 - i ] ^ 1 ; row [ C - 1 - i ] = tmp ; } return A ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def flipAndInvertImage ( self , A ) : NEW_LINE INDENT for row in A : NEW_LINE INDENT for i in xrange ( ( len ( row ) + 1 ) / 2 ) : NEW_LINE INDENT row [ i ] , row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_409_A", "java": [{"id": "1", "code": "class Solution { public int longestPalindrome ( String s ) { int [ ] count = new int [ 128 ] ; for ( char c : s . toCharArray ( ) ) count [ c ] ++ ; int ans = 0 ; for ( int v : count ) { ans += v / 2 * 2 ; if ( ans % 2 == 0 && v % 2 == 1 ) ans ++ ; } return ans ; } }", "functions_standalone": [], "functions_class": [["longestPalindrome", "public int longestPalindrome ( String s ) { int [ ] count = new int [ 128 ] ; for ( char c : s . toCharArray ( ) ) count [ c ] ++ ; int ans = 0 ; for ( int v : count ) { ans += v / 2 * 2 ; if ( ans % 2 == 0 && v % 2 == 1 ) ans ++ ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT ans = 0 NEW_LINE char_map = { } NEW_LINE for c in s : NEW_LINE INDENT char_map [ c ] = char_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for c in char_map . keys ( ) : NEW_LINE INDENT if char_map [ c ] % 2 == 0 : NEW_LINE INDENT ans += char_map . pop ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += char_map [ c ] / 2 * 2 NEW_LINE DEDENT DEDENT if len ( char_map ) != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["longestPalindrome", "def longestPalindrome ( self , s ) : NEW_LINE INDENT ans = 0 NEW_LINE char_map = { } NEW_LINE for c in s : NEW_LINE INDENT char_map [ c ] = char_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for c in char_map . keys ( ) : NEW_LINE INDENT if char_map [ c ] % 2 == 0 : NEW_LINE INDENT ans += char_map . pop ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += char_map [ c ] / 2 * 2 NEW_LINE DEDENT DEDENT if len ( char_map ) != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_438_A", "java": [{"id": "1", "code": "class Solution { public List < Integer > findAnagrams ( String s , String p ) { List < Integer > list = new ArrayList < > ( ) ; if ( s == null || s . length ( ) == 0 || p == null || p . length ( ) == 0 ) return list ; int [ ] hash = new int [ 256 ] ; for ( char c : p . toCharArray ( ) ) { hash [ c ] ++ ; } int left = 0 , right = 0 , count = p . length ( ) ; while ( right < s . length ( ) ) { if ( hash [ s . charAt ( right ++ ) ] -- >= 1 ) count -- ; if ( count == 0 ) list . add ( left ) ; if ( right - left == p . length ( ) && hash [ s . charAt ( left ++ ) ] ++ >= 0 ) count ++ ; } return list ; } }", "functions_standalone": [], "functions_class": [["findAnagrams", "public List < Integer > findAnagrams ( String s , String p ) { List < Integer > list = new ArrayList < > ( ) ; if ( s == null || s . length ( ) == 0 || p == null || p . length ( ) == 0 ) return list ; int [ ] hash = new int [ 256 ] ; for ( char c : p . toCharArray ( ) ) { hash [ c ] ++ ; } int left = 0 , right = 0 , count = p . length ( ) ; while ( right < s . length ( ) ) { if ( hash [ s . charAt ( right ++ ) ] -- >= 1 ) count -- ; if ( count == 0 ) list . add ( left ) ; if ( right - left == p . length ( ) && hash [ s . charAt ( left ++ ) ] ++ >= 0 ) count ++ ; } return list ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findAnagrams ( self , s , p ) : NEW_LINE INDENT res = [ ] NEW_LINE if s is None or p is None or len ( s ) == 0 or len ( p ) == 0 : NEW_LINE INDENT return res NEW_LINE DEDENT char_map = [ 0 ] * 256 NEW_LINE for c in p : NEW_LINE INDENT char_map [ ord ( c ) ] += 1 NEW_LINE DEDENT left , right , count = 0 , 0 , len ( p ) NEW_LINE while right < len ( s ) : NEW_LINE INDENT if char_map [ ord ( s [ right ] ) ] >= 1 : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT char_map [ ord ( s [ right ] ) ] -= 1 NEW_LINE right += 1 NEW_LINE if count == 0 : NEW_LINE INDENT res . append ( left ) NEW_LINE DEDENT if right - left == len ( p ) : NEW_LINE INDENT if char_map [ ord ( s [ left ] ) ] >= 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT char_map [ ord ( s [ left ] ) ] += 1 NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findAnagrams", "def findAnagrams ( self , s , p ) : NEW_LINE INDENT res = [ ] NEW_LINE if s is None or p is None or len ( s ) == 0 or len ( p ) == 0 : NEW_LINE INDENT return res NEW_LINE DEDENT char_map = [ 0 ] * 256 NEW_LINE for c in p : NEW_LINE INDENT char_map [ ord ( c ) ] += 1 NEW_LINE DEDENT left , right , count = 0 , 0 , len ( p ) NEW_LINE while right < len ( s ) : NEW_LINE INDENT if char_map [ ord ( s [ right ] ) ] >= 1 : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT char_map [ ord ( s [ right ] ) ] -= 1 NEW_LINE right += 1 NEW_LINE if count == 0 : NEW_LINE INDENT res . append ( left ) NEW_LINE DEDENT if right - left == len ( p ) : NEW_LINE INDENT if char_map [ ord ( s [ left ] ) ] >= 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT char_map [ ord ( s [ left ] ) ] += 1 NEW_LINE left += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_400_A", "java": [{"id": "1", "code": "class Solution { public int findNthDigit ( int n ) { int len = 1 ; long count = 9 ; int start = 1 ; while ( n > len * count ) { n -= len * count ; len += 1 ; count *= 10 ; start *= 10 ; } start += ( n - 1 ) / len ; String s = Integer . toString ( start ) ; return Character . getNumericValue ( s . charAt ( ( n - 1 ) % len ) ) ; } }", "functions_standalone": [], "functions_class": [["findNthDigit", "public int findNthDigit ( int n ) { int len = 1 ; long count = 9 ; int start = 1 ; while ( n > len * count ) { n -= len * count ; len += 1 ; count *= 10 ; start *= 10 ; } start += ( n - 1 ) / len ; String s = Integer . toString ( start ) ; return Character . getNumericValue ( s . charAt ( ( n - 1 ) % len ) ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findNthDigit ( self , n ) : NEW_LINE INDENT count = 9 NEW_LINE start = 1 NEW_LINE curr_len = 1 NEW_LINE while n > curr_len * count : NEW_LINE INDENT n -= curr_len * count NEW_LINE curr_len += 1 NEW_LINE count *= 10 NEW_LINE start *= 10 NEW_LINE DEDENT start += ( n - 1 ) / curr_len NEW_LINE s = str ( start ) NEW_LINE return int ( s [ ( n - 1 ) % curr_len ] ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findNthDigit", "def findNthDigit ( self , n ) : NEW_LINE INDENT count = 9 NEW_LINE start = 1 NEW_LINE curr_len = 1 NEW_LINE while n > curr_len * count : NEW_LINE INDENT n -= curr_len * count NEW_LINE curr_len += 1 NEW_LINE count *= 10 NEW_LINE start *= 10 NEW_LINE DEDENT start += ( n - 1 ) / curr_len NEW_LINE s = str ( start ) NEW_LINE return int ( s [ ( n - 1 ) % curr_len ] ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_867_A", "java": [{"id": "1", "code": "class Solution { public int [ ] [ ] transpose ( int [ ] [ ] A ) { int R = A . length , C = A [ 0 ] . length ; int [ ] [ ] ans = new int [ C ] [ R ] ; for ( int r = 0 ; r < R ; ++ r ) for ( int c = 0 ; c < C ; ++ c ) { ans [ c ] [ r ] = A [ r ] [ c ] ; } return ans ; } }", "functions_standalone": [], "functions_class": [["transpose", "public int [ ] [ ] transpose ( int [ ] [ ] A ) { int R = A . length , C = A [ 0 ] . length ; int [ ] [ ] ans = new int [ C ] [ R ] ; for ( int r = 0 ; r < R ; ++ r ) for ( int c = 0 ; c < C ; ++ c ) { ans [ c ] [ r ] = A [ r ] [ c ] ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def transpose ( self , A ) : NEW_LINE INDENT R , C = len ( A ) , len ( A [ 0 ] ) NEW_LINE ans = [ [ None ] * R for _ in xrange ( C ) ] NEW_LINE for r , row in enumerate ( A ) : NEW_LINE INDENT for c , val in enumerate ( row ) : NEW_LINE INDENT ans [ c ] [ r ] = val NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_692_A", "java": [{"id": "1", "code": "class Solution { public List < String > topKFrequent ( String [ ] words , int k ) { Map < String , Integer > count = new HashMap ( ) ; for ( String word : words ) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; } PriorityQueue < String > heap = new PriorityQueue < String > ( ( w1 , w2 ) -> count . get ( w1 ) . equals ( count . get ( w2 ) ) ? w2 . compareTo ( w1 ) : count . get ( w1 ) - count . get ( w2 ) ) ; for ( String word : count . keySet ( ) ) { heap . offer ( word ) ; if ( heap . size ( ) > k ) heap . poll ( ) ; } List < String > ans = new ArrayList ( ) ; while ( ! heap . isEmpty ( ) ) ans . add ( heap . poll ( ) ) ; Collections . reverse ( ans ) ; return ans ; } }", "functions_standalone": [], "functions_class": [["topKFrequent", "public List < String > topKFrequent ( String [ ] words , int k ) { Map < String , Integer > count = new HashMap ( ) ; for ( String word : words ) { count . put ( word , count . getOrDefault ( word , 0 ) + 1 ) ; } PriorityQueue < String > heap = new PriorityQueue < String > ( ( w1 , w2 ) -> count . get ( w1 ) . equals ( count . get ( w2 ) ) ? w2 . compareTo ( w1 ) : count . get ( w1 ) - count . get ( w2 ) ) ; for ( String word : count . keySet ( ) ) { heap . offer ( word ) ; if ( heap . size ( ) > k ) heap . poll ( ) ; } List < String > ans = new ArrayList ( ) ; while ( ! heap . isEmpty ( ) ) ans . add ( heap . poll ( ) ) ; Collections . reverse ( ans ) ; return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def topKFrequent ( self , words , k ) : NEW_LINE INDENT count = collections . Counter ( words ) NEW_LINE heap = [ ( - freq , word ) for word , freq in count . items ( ) ] NEW_LINE heapq . heapify ( heap ) NEW_LINE return [ heapq . heappop ( heap ) [ 1 ] for _ in xrange ( k ) ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_453_A", "java": [{"id": "1", "code": "import java . util . Arrays ; import java . util . Collections ; class Solution { public int minMoves ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; Arrays . sort ( nums ) ; int min_num = nums [ 0 ] ; int ans = 0 ; for ( int num : nums ) { ans += num - min_num ; } return ans ; } }", "functions_standalone": [], "functions_class": [["minMoves", "public int minMoves ( int [ ] nums ) { if ( nums . length == 0 ) return 0 ; Arrays . sort ( nums ) ; int min_num = nums [ 0 ] ; int ans = 0 ; for ( int num : nums ) { ans += num - min_num ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def minMoves ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT min_num = min ( nums ) NEW_LINE return sum ( [ i - min_num for i in nums ] ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["minMoves", "def minMoves ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT min_num = min ( nums ) NEW_LINE return sum ( [ i - min_num for i in nums ] ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_695_A", "java": [{"id": "1", "code": "class Solution { public int maxAreaOfIsland ( int [ ] [ ] grid ) { int [ ] dr = new int [ ] { 1 , - 1 , 0 , 0 } ; int [ ] dc = new int [ ] { 0 , 0 , 1 , - 1 } ; int ans = 0 ; for ( int r0 = 0 ; r0 < grid . length ; r0 ++ ) { for ( int c0 = 0 ; c0 < grid [ 0 ] . length ; c0 ++ ) { if ( grid [ r0 ] [ c0 ] == 1 ) { int shape = 0 ; Stack < int [ ] > stack = new Stack ( ) ; stack . push ( new int [ ] { r0 , c0 } ) ; grid [ r0 ] [ c0 ] = 0 ; while ( ! stack . empty ( ) ) { int [ ] node = stack . pop ( ) ; int r = node [ 0 ] , c = node [ 1 ] ; shape ++ ; for ( int k = 0 ; k < 4 ; k ++ ) { int nr = r + dr [ k ] ; int nc = c + dc [ k ] ; if ( 0 <= nr && nr < grid . length && 0 <= nc && nc < grid [ 0 ] . length && grid [ nr ] [ nc ] == 1 ) { stack . push ( new int [ ] { nr , nc } ) ; grid [ nr ] [ nc ] = 0 ; } } } ans = Math . max ( ans , shape ) ; } } } return ans ; } }", "functions_standalone": [], "functions_class": [["maxAreaOfIsland", "public int maxAreaOfIsland ( int [ ] [ ] grid ) { int [ ] dr = new int [ ] { 1 , - 1 , 0 , 0 } ; int [ ] dc = new int [ ] { 0 , 0 , 1 , - 1 } ; int ans = 0 ; for ( int r0 = 0 ; r0 < grid . length ; r0 ++ ) { for ( int c0 = 0 ; c0 < grid [ 0 ] . length ; c0 ++ ) { if ( grid [ r0 ] [ c0 ] == 1 ) { int shape = 0 ; Stack < int [ ] > stack = new Stack ( ) ; stack . push ( new int [ ] { r0 , c0 } ) ; grid [ r0 ] [ c0 ] = 0 ; while ( ! stack . empty ( ) ) { int [ ] node = stack . pop ( ) ; int r = node [ 0 ] , c = node [ 1 ] ; shape ++ ; for ( int k = 0 ; k < 4 ; k ++ ) { int nr = r + dr [ k ] ; int nc = c + dc [ k ] ; if ( 0 <= nr && nr < grid . length && 0 <= nc && nc < grid [ 0 ] . length && grid [ nr ] [ nc ] == 1 ) { stack . push ( new int [ ] { nr , nc } ) ; grid [ nr ] [ nc ] = 0 ; } } } ans = Math . max ( ans , shape ) ; } } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT grid [ i ] [ j ] = 0 NEW_LINE ans = max ( self . dfs ( grid , i , j ) , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def dfs ( self , grid , i , j ) : NEW_LINE INDENT stack = [ ( i , j ) ] NEW_LINE area = 0 NEW_LINE while stack : NEW_LINE INDENT r , c = stack . pop ( - 1 ) NEW_LINE area += 1 NEW_LINE for nr , nc in ( ( r - 1 , c ) , ( r + 1 , c ) , ( r , c - 1 ) , ( r , c + 1 ) ) : NEW_LINE INDENT if ( 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] ) : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["maxAreaOfIsland", "def maxAreaOfIsland ( self , grid ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( grid ) ) : NEW_LINE INDENT for j in range ( len ( grid [ 0 ] ) ) : NEW_LINE INDENT if grid [ i ] [ j ] == 1 : NEW_LINE INDENT grid [ i ] [ j ] = 0 NEW_LINE ans = max ( self . dfs ( grid , i , j ) , ans ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT"], ["dfs", "def dfs ( self , grid , i , j ) : NEW_LINE INDENT stack = [ ( i , j ) ] NEW_LINE area = 0 NEW_LINE while stack : NEW_LINE INDENT r , c = stack . pop ( - 1 ) NEW_LINE area += 1 NEW_LINE for nr , nc in ( ( r - 1 , c ) , ( r + 1 , c ) , ( r , c - 1 ) , ( r , c + 1 ) ) : NEW_LINE INDENT if ( 0 <= nr < len ( grid ) and 0 <= nc < len ( grid [ 0 ] ) and grid [ nr ] [ nc ] ) : NEW_LINE INDENT stack . append ( ( nr , nc ) ) NEW_LINE grid [ nr ] [ nc ] = 0 NEW_LINE DEDENT DEDENT DEDENT return area NEW_LINE DEDENT"]]}]}
{"id": "leetcode_668_A", "java": [{"id": "1", "code": "class Solution { public boolean enough ( int x , int m , int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { count += Math . min ( x / i , n ) ; } return count >= k ; } public int findKthNumber ( int m , int n , int k ) { int lo = 1 , hi = m * n ; while ( lo < hi ) { int mi = lo + ( hi - lo ) / 2 ; if ( ! enough ( mi , m , n , k ) ) lo = mi + 1 ; else hi = mi ; } return lo ; } }", "functions_standalone": [], "functions_class": [["enough", "public boolean enough ( int x , int m , int n , int k ) { int count = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { count += Math . min ( x / i , n ) ; } return count >= k ; }"], ["findKthNumber", "public int findKthNumber ( int m , int n , int k ) { int lo = 1 , hi = m * n ; while ( lo < hi ) { int mi = lo + ( hi - lo ) / 2 ; if ( ! enough ( mi , m , n , k ) ) lo = mi + 1 ; else hi = mi ; } return lo ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def findKthNumber ( self , m : int , n : int , k : int ) -> int : NEW_LINE INDENT def enough ( x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT count += min ( x // i , n ) NEW_LINE DEDENT return count >= k NEW_LINE DEDENT lo , hi = 1 , m * n NEW_LINE while lo < hi : NEW_LINE INDENT mi = ( lo + hi ) // 2 NEW_LINE if not enough ( mi ) : NEW_LINE INDENT lo = mi + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mi NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findKthNumber", "def findKthNumber ( self , m : int , n : int , k : int ) -> int : NEW_LINE INDENT def enough ( x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT count += min ( x // i , n ) NEW_LINE DEDENT return count >= k NEW_LINE DEDENT lo , hi = 1 , m * n NEW_LINE while lo < hi : NEW_LINE INDENT mi = ( lo + hi ) // 2 NEW_LINE if not enough ( mi ) : NEW_LINE INDENT lo = mi + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mi NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT"]]}]}
{"id": "leetcode_977_A", "java": [{"id": "1", "code": "class Solution { public int [ ] sortedSquares ( int [ ] A ) { int pos = 0 ; int [ ] res = new int [ A . length ] ; int curr = 0 ; while ( pos < A . length && A [ pos ] < 0 ) pos ++ ; int npos = pos - 1 ; while ( pos < A . length && npos >= 0 ) { if ( A [ pos ] * A [ pos ] < A [ npos ] * A [ npos ] ) { res [ curr ++ ] = A [ pos ] * A [ pos ] ; pos ++ ; } else { res [ curr ++ ] = A [ npos ] * A [ npos ] ; npos -- ; } } while ( npos >= 0 ) { res [ curr ++ ] = A [ npos ] * A [ npos ] ; npos -- ; } while ( pos < A . length ) { res [ curr ++ ] = A [ pos ] * A [ pos ] ; pos ++ ; } return res ; } }", "functions_standalone": [], "functions_class": [["sortedSquares", "public int [ ] sortedSquares ( int [ ] A ) { int pos = 0 ; int [ ] res = new int [ A . length ] ; int curr = 0 ; while ( pos < A . length && A [ pos ] < 0 ) pos ++ ; int npos = pos - 1 ; while ( pos < A . length && npos >= 0 ) { if ( A [ pos ] * A [ pos ] < A [ npos ] * A [ npos ] ) { res [ curr ++ ] = A [ pos ] * A [ pos ] ; pos ++ ; } else { res [ curr ++ ] = A [ npos ] * A [ npos ] ; npos -- ; } } while ( npos >= 0 ) { res [ curr ++ ] = A [ npos ] * A [ npos ] ; npos -- ; } while ( pos < A . length ) { res [ curr ++ ] = A [ pos ] * A [ pos ] ; pos ++ ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["sortedSquares", "def sortedSquares ( self , A ) : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( A ) and A [ pos ] < 0 : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT npos = pos - 1 NEW_LINE res = [ ] NEW_LINE while pos < len ( A ) and npos >= 0 : NEW_LINE INDENT if A [ npos ] ** 2 < A [ pos ] ** 2 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT DEDENT while npos >= 0 : NEW_LINE INDENT res . append ( A [ npos ] ** 2 ) NEW_LINE npos -= 1 NEW_LINE DEDENT while pos < len ( A ) : NEW_LINE INDENT res . append ( A [ pos ] ** 2 ) NEW_LINE pos += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1480_A", "java": [{"id": "1", "code": "class Solution { public int [ ] runningSum ( int [ ] nums ) { if ( nums . length <= 1 ) return nums ; for ( int i = 1 ; i < nums . length ; i ++ ) nums [ i ] += nums [ i - 1 ] ; return nums ; } }", "functions_standalone": [], "functions_class": [["runningSum", "public int [ ] runningSum ( int [ ] nums ) { if ( nums . length <= 1 ) return nums ; for ( int i = 1 ; i < nums . length ; i ++ ) nums [ i ] += nums [ i - 1 ] ; return nums ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["runningSum", "def runningSum ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return nums NEW_LINE DEDENT for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT nums [ i ] += nums [ i - 1 ] NEW_LINE DEDENT return nums NEW_LINE DEDENT"]]}]}
{"id": "leetcode_383_A", "java": [{"id": "1", "code": "class Solution { public boolean canConstruct ( String ransomNote , String magazine ) { int [ ] table = new int [ 128 ] ; for ( char c : magazine . toCharArray ( ) ) table [ c ] ++ ; for ( char c : ransomNote . toCharArray ( ) ) if ( -- table [ c ] < 0 ) return false ; return true ; } }", "functions_standalone": [], "functions_class": [["canConstruct", "public boolean canConstruct ( String ransomNote , String magazine ) { int [ ] table = new int [ 128 ] ; for ( char c : magazine . toCharArray ( ) ) table [ c ] ++ ; for ( char c : ransomNote . toCharArray ( ) ) if ( -- table [ c ] < 0 ) return false ; return true ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def canConstruct ( self , ransomNote , magazine ) : NEW_LINE INDENT letter_map = { } NEW_LINE for letter in magazine : NEW_LINE INDENT letter_map [ letter ] = letter_map . get ( letter , 0 ) + 1 NEW_LINE DEDENT for letter in ransomNote : NEW_LINE INDENT letter_map [ letter ] = letter_map . get ( letter , 0 ) - 1 NEW_LINE if letter_map [ letter ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["canConstruct", "def canConstruct ( self , ransomNote , magazine ) : NEW_LINE INDENT letter_map = { } NEW_LINE for letter in magazine : NEW_LINE INDENT letter_map [ letter ] = letter_map . get ( letter , 0 ) + 1 NEW_LINE DEDENT for letter in ransomNote : NEW_LINE INDENT letter_map [ letter ] = letter_map . get ( letter , 0 ) - 1 NEW_LINE if letter_map [ letter ] < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT"]]}]}
{"id": "leetcode_572_A", "java": [{"id": "1", "code": "public class Solution { HashSet < String > trees = new HashSet < > ( ) ; public boolean isSubtree ( TreeNode s , TreeNode t ) { String tree1 = preorder ( s , true ) ; String tree2 = preorder ( t , true ) ; return tree1 . indexOf ( tree2 ) >= 0 ; } public String preorder ( TreeNode t , boolean left ) { if ( t == null ) { if ( left ) return \" lnull \" ; else return \" rnull \" ; } return \" # \" + t . val + \" \u2581 \" + preorder ( t . left , true ) + \" \u2581 \" + preorder ( t . right , false ) ; } }", "functions_standalone": [], "functions_class": [["isSubtree", "public boolean isSubtree ( TreeNode s , TreeNode t ) { String tree1 = preorder ( s , true ) ; String tree2 = preorder ( t , true ) ; return tree1 . indexOf ( tree2 ) >= 0 ; }"], ["preorder", "public String preorder ( TreeNode t , boolean left ) { if ( t == null ) { if ( left ) return \" lnull \" ; else return \" rnull \" ; } return \" # \" + t . val + \" \u2581 \" + preorder ( t . left , true ) + \" \u2581 \" + preorder ( t . right , false ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def isSubtree ( self , s , t ) : NEW_LINE INDENT s_res = self . preorder ( s , True ) NEW_LINE t_res = self . preorder ( t , True ) NEW_LINE return t_res in s_res NEW_LINE DEDENT def preorder ( self , root , isLeft ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT if isLeft : NEW_LINE INDENT return \" lnull \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" rnull \" NEW_LINE DEDENT DEDENT return \" # \" + str ( root . val ) + \" \u2581 \" + self . preorder ( root . left , True ) + \" \u2581 \" + self . preorder ( root . right , False ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["isSubtree", "def isSubtree ( self , s , t ) : NEW_LINE INDENT s_res = self . preorder ( s , True ) NEW_LINE t_res = self . preorder ( t , True ) NEW_LINE return t_res in s_res NEW_LINE DEDENT"], ["preorder", "def preorder ( self , root , isLeft ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT if isLeft : NEW_LINE INDENT return \" lnull \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" rnull \" NEW_LINE DEDENT DEDENT return \" # \" + str ( root . val ) + \" \u2581 \" + self . preorder ( root . left , True ) + \" \u2581 \" + self . preorder ( root . right , False ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_581_A", "java": [{"id": "1", "code": "public class Solution { public int findUnsortedSubarray ( int [ ] nums ) { Stack < Integer > stack = new Stack < Integer > ( ) ; int l = nums . length , r = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] > nums [ i ] ) l = Math . min ( l , stack . pop ( ) ) ; stack . push ( i ) ; } stack . clear ( ) ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] < nums [ i ] ) r = Math . max ( r , stack . pop ( ) ) ; stack . push ( i ) ; } return r - l > 0 ? r - l + 1 : 0 ; } }", "functions_standalone": [], "functions_class": [["findUnsortedSubarray", "public int findUnsortedSubarray ( int [ ] nums ) { Stack < Integer > stack = new Stack < Integer > ( ) ; int l = nums . length , r = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) { while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] > nums [ i ] ) l = Math . min ( l , stack . pop ( ) ) ; stack . push ( i ) ; } stack . clear ( ) ; for ( int i = nums . length - 1 ; i >= 0 ; i -- ) { while ( ! stack . isEmpty ( ) && nums [ stack . peek ( ) ] < nums [ i ] ) r = Math . max ( r , stack . pop ( ) ) ; stack . push ( i ) ; } return r - l > 0 ? r - l + 1 : 0 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findUnsortedSubarray ( self , nums ) : NEW_LINE INDENT stack = [ ] NEW_LINE l , r = len ( nums ) , 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT while len ( stack ) != 0 and nums [ stack [ - 1 ] ] > nums [ i ] : NEW_LINE INDENT l = min ( l , stack . pop ( ) ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT stack = [ ] NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while len ( stack ) != 0 and nums [ stack [ - 1 ] ] < nums [ i ] : NEW_LINE INDENT r = max ( r , stack . pop ( ) ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT if r > l : NEW_LINE INDENT return r - l + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findUnsortedSubarray", "def findUnsortedSubarray ( self , nums ) : NEW_LINE INDENT stack = [ ] NEW_LINE l , r = len ( nums ) , 0 NEW_LINE for i in range ( len ( nums ) ) : NEW_LINE INDENT while len ( stack ) != 0 and nums [ stack [ - 1 ] ] > nums [ i ] : NEW_LINE INDENT l = min ( l , stack . pop ( ) ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT stack = [ ] NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while len ( stack ) != 0 and nums [ stack [ - 1 ] ] < nums [ i ] : NEW_LINE INDENT r = max ( r , stack . pop ( ) ) NEW_LINE DEDENT stack . append ( i ) NEW_LINE DEDENT if r > l : NEW_LINE INDENT return r - l + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_543_A", "java": [{"id": "1", "code": "class Solution { int ans ; public int diameterOfBinaryTree ( TreeNode root ) { ans = 1 ; depth ( root ) ; return ans - 1 ; } public int depth ( TreeNode node ) { if ( node == null ) return 0 ; int L = depth ( node . left ) ; int R = depth ( node . right ) ; ans = Math . max ( ans , L + R + 1 ) ; return Math . max ( L , R ) + 1 ; } }", "functions_standalone": [], "functions_class": [["diameterOfBinaryTree", "public int diameterOfBinaryTree ( TreeNode root ) { ans = 1 ; depth ( root ) ; return ans - 1 ; }"], ["depth", "public int depth ( TreeNode node ) { if ( node == null ) return 0 ; int L = depth ( node . left ) ; int R = depth ( node . right ) ; ans = Math . max ( ans , L + R + 1 ) ; return Math . max ( L , R ) + 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["diameterOfBinaryTree", "def diameterOfBinaryTree ( self , root ) : NEW_LINE INDENT self . ans = 1 NEW_LINE def depth ( node ) : NEW_LINE INDENT if not node : return 0 NEW_LINE L = depth ( node . left ) NEW_LINE R = depth ( node . right ) NEW_LINE self . ans = max ( self . ans , L + R + 1 ) NEW_LINE return max ( L , R ) + 1 NEW_LINE DEDENT depth ( root ) NEW_LINE return self . ans - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_771_A", "java": [{"id": "1", "code": "import java . util . HashSet ; class Solution { public int numJewelsInStones ( String J , String S ) { int result = 0 ; HashSet jHash = new HashSet < > ( ) ; for ( int j = 0 ; j < J . length ( ) ; j ++ ) { jHash . add ( J . charAt ( j ) ) ; } for ( int s = 0 ; s < S . length ( ) ; s ++ ) { if ( jHash . contains ( S . charAt ( s ) ) ) { result ++ ; } } return result ; } }", "functions_standalone": [], "functions_class": [["numJewelsInStones", "public int numJewelsInStones ( String J , String S ) { int result = 0 ; HashSet jHash = new HashSet < > ( ) ; for ( int j = 0 ; j < J . length ( ) ; j ++ ) { jHash . add ( J . charAt ( j ) ) ; } for ( int s = 0 ; s < S . length ( ) ; s ++ ) { if ( jHash . contains ( S . charAt ( s ) ) ) { result ++ ; } } return result ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT if len ( J ) == 0 or len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j_set = set ( J ) NEW_LINE ans = 0 NEW_LINE for c in S : NEW_LINE INDENT if c in j_set : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["numJewelsInStones", "def numJewelsInStones ( self , J , S ) : NEW_LINE INDENT if len ( J ) == 0 or len ( S ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT j_set = set ( J ) NEW_LINE ans = 0 NEW_LINE for c in S : NEW_LINE INDENT if c in j_set : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_724_A", "java": [{"id": "1", "code": "class Solution { public int pivotIndex ( int [ ] nums ) { int totalsum = 0 , leftsum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) totalsum += nums [ i ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( leftsum == totalsum - leftsum - nums [ i ] ) return i ; leftsum += nums [ i ] ; } return - 1 ; } }", "functions_standalone": [], "functions_class": [["pivotIndex", "public int pivotIndex ( int [ ] nums ) { int totalsum = 0 , leftsum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) totalsum += nums [ i ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( leftsum == totalsum - leftsum - nums [ i ] ) return i ; leftsum += nums [ i ] ; } return - 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def pivotIndex ( self , nums ) : NEW_LINE INDENT totalsum = sum ( nums ) NEW_LINE leftsum = 0 NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT if leftsum == totalsum - leftsum - v : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += v NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["pivotIndex", "def pivotIndex ( self , nums ) : NEW_LINE INDENT totalsum = sum ( nums ) NEW_LINE leftsum = 0 NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT if leftsum == totalsum - leftsum - v : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += v NEW_LINE DEDENT return - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_347_A", "java": [{"id": "1", "code": "class Solution { public List < Integer > topKFrequent ( int [ ] nums , int k ) { HashMap < Integer , Integer > count = new HashMap ( ) ; for ( int n : nums ) { count . put ( n , count . getOrDefault ( n , 0 ) + 1 ) ; } PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ( n1 , n2 ) -> count . get ( n1 ) - count . get ( n2 ) ) ; for ( int n : count . keySet ( ) ) { heap . add ( n ) ; if ( heap . size ( ) > k ) heap . poll ( ) ; } List < Integer > top_k = new LinkedList ( ) ; while ( ! heap . isEmpty ( ) ) top_k . add ( heap . poll ( ) ) ; Collections . reverse ( top_k ) ; return top_k ; } }", "functions_standalone": [], "functions_class": [["topKFrequent", "public List < Integer > topKFrequent ( int [ ] nums , int k ) { HashMap < Integer , Integer > count = new HashMap ( ) ; for ( int n : nums ) { count . put ( n , count . getOrDefault ( n , 0 ) + 1 ) ; } PriorityQueue < Integer > heap = new PriorityQueue < Integer > ( ( n1 , n2 ) -> count . get ( n1 ) - count . get ( n2 ) ) ; for ( int n : count . keySet ( ) ) { heap . add ( n ) ; if ( heap . size ( ) > k ) heap . poll ( ) ; } List < Integer > top_k = new LinkedList ( ) ; while ( ! heap . isEmpty ( ) ) top_k . add ( heap . poll ( ) ) ; Collections . reverse ( top_k ) ; return top_k ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def topKFrequent ( self , nums , k ) : NEW_LINE INDENT counter = collections . Counter ( nums ) NEW_LINE return [ k for k , v in counter . most_common ( k ) ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["topKFrequent", "def topKFrequent ( self , nums , k ) : NEW_LINE INDENT counter = collections . Counter ( nums ) NEW_LINE return [ k for k , v in counter . most_common ( k ) ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_922_A", "java": [{"id": "1", "code": "class Solution { public int [ ] sortArrayByParityII ( int [ ] A ) { int j = 1 ; for ( int i = 0 ; i < A . length ; i += 2 ) if ( A [ i ] % 2 == 1 ) { while ( A [ j ] % 2 == 1 ) j += 2 ; int tmp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = tmp ; } return A ; } }", "functions_standalone": [], "functions_class": [["sortArrayByParityII", "public int [ ] sortArrayByParityII ( int [ ] A ) { int j = 1 ; for ( int i = 0 ; i < A . length ; i += 2 ) if ( A [ i ] % 2 == 1 ) { while ( A [ j ] % 2 == 1 ) j += 2 ; int tmp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = tmp ; } return A ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def sortArrayByParityII ( self , A ) : NEW_LINE INDENT odd = 1 NEW_LINE for i in xrange ( 0 , len ( A ) , 2 ) : NEW_LINE INDENT if A [ i ] % 2 : NEW_LINE INDENT while A [ odd ] % 2 : NEW_LINE INDENT odd += 2 NEW_LINE DEDENT A [ i ] , A [ odd ] = A [ odd ] , A [ i ] NEW_LINE DEDENT DEDENT return A NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_1089_A", "java": [{"id": "1", "code": "class Solution { public void duplicateZeros ( int [ ] arr ) { int movePos = 0 ; int lastPos = arr . length - 1 ; for ( int i = 0 ; i <= lastPos - movePos ; i ++ ) { if ( arr [ i ] == 0 ) { if ( i == lastPos - movePos ) { arr [ lastPos ] = 0 ; lastPos -- ; break ; } movePos ++ ; } } lastPos = lastPos - movePos ; for ( int i = lastPos ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) { arr [ i + movePos ] = 0 ; movePos -- ; arr [ i + movePos ] = 0 ; } else { arr [ i + movePos ] = arr [ i ] ; } } } }", "functions_standalone": [], "functions_class": [["duplicateZeros", "public void duplicateZeros ( int [ ] arr ) { int movePos = 0 ; int lastPos = arr . length - 1 ; for ( int i = 0 ; i <= lastPos - movePos ; i ++ ) { if ( arr [ i ] == 0 ) { if ( i == lastPos - movePos ) { arr [ lastPos ] = 0 ; lastPos -- ; break ; } movePos ++ ; } } lastPos = lastPos - movePos ; for ( int i = lastPos ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) { arr [ i + movePos ] = 0 ; movePos -- ; arr [ i + movePos ] = 0 ; } else { arr [ i + movePos ] = arr [ i ] ; } } }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def duplicateZeros ( self , arr : List [ int ] ) -> None : NEW_LINE INDENT move_pos = 0 NEW_LINE last_pos = len ( arr ) - 1 NEW_LINE for i in range ( last_pos + 1 ) : NEW_LINE INDENT if i > last_pos - move_pos : NEW_LINE INDENT break NEW_LINE DEDENT if arr [ i ] == 0 : NEW_LINE INDENT if i == last_pos - move_pos : NEW_LINE INDENT arr [ last_pos ] = 0 NEW_LINE last_pos -= 1 NEW_LINE break NEW_LINE DEDENT move_pos += 1 NEW_LINE DEDENT DEDENT last_pos -= move_pos NEW_LINE for i in range ( last , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT arr [ i + move_pos ] = 0 NEW_LINE move_pos -= 1 NEW_LINE arr [ i + move_pos ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + move_pos ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": [["duplicateZeros", "def duplicateZeros ( self , arr : List [ int ] ) -> None : NEW_LINE INDENT move_pos = 0 NEW_LINE last_pos = len ( arr ) - 1 NEW_LINE for i in range ( last_pos + 1 ) : NEW_LINE INDENT if i > last_pos - move_pos : NEW_LINE INDENT break NEW_LINE DEDENT if arr [ i ] == 0 : NEW_LINE INDENT if i == last_pos - move_pos : NEW_LINE INDENT arr [ last_pos ] = 0 NEW_LINE last_pos -= 1 NEW_LINE break NEW_LINE DEDENT move_pos += 1 NEW_LINE DEDENT DEDENT last_pos -= move_pos NEW_LINE for i in range ( last , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] == 0 : NEW_LINE INDENT arr [ i + move_pos ] = 0 NEW_LINE move_pos -= 1 NEW_LINE arr [ i + move_pos ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i + move_pos ] = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT"]]}]}
{"id": "leetcode_784_A", "java": [{"id": "1", "code": "class Solution { public List < String > letterCasePermutation ( String S ) { List < StringBuilder > ans = new ArrayList ( ) ; ans . add ( new StringBuilder ( ) ) ; for ( char c : S . toCharArray ( ) ) { int n = ans . size ( ) ; if ( Character . isLetter ( c ) ) { for ( int i = 0 ; i < n ; ++ i ) { ans . add ( new StringBuilder ( ans . get ( i ) ) ) ; ans . get ( i ) . append ( Character . toLowerCase ( c ) ) ; ans . get ( n + i ) . append ( Character . toUpperCase ( c ) ) ; } } else { for ( int i = 0 ; i < n ; ++ i ) ans . get ( i ) . append ( c ) ; } } List < String > finalans = new ArrayList ( ) ; for ( StringBuilder sb : ans ) finalans . add ( sb . toString ( ) ) ; return finalans ; } }", "functions_standalone": [], "functions_class": [["letterCasePermutation", "public List < String > letterCasePermutation ( String S ) { List < StringBuilder > ans = new ArrayList ( ) ; ans . add ( new StringBuilder ( ) ) ; for ( char c : S . toCharArray ( ) ) { int n = ans . size ( ) ; if ( Character . isLetter ( c ) ) { for ( int i = 0 ; i < n ; ++ i ) { ans . add ( new StringBuilder ( ans . get ( i ) ) ) ; ans . get ( i ) . append ( Character . toLowerCase ( c ) ) ; ans . get ( n + i ) . append ( Character . toUpperCase ( c ) ) ; } } else { for ( int i = 0 ; i < n ; ++ i ) ans . get ( i ) . append ( c ) ; } } List < String > finalans = new ArrayList ( ) ; for ( StringBuilder sb : ans ) finalans . add ( sb . toString ( ) ) ; return finalans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def letterCasePermutation ( self , S ) : NEW_LINE INDENT B = sum ( letter . isalpha ( ) for letter in S ) NEW_LINE ans = [ ] NEW_LINE for bits in xrange ( 1 << B ) : NEW_LINE INDENT b = 0 NEW_LINE word = [ ] NEW_LINE for letter in S : NEW_LINE INDENT if letter . isalpha ( ) : NEW_LINE INDENT if ( bits >> b ) & 1 : NEW_LINE INDENT word . append ( letter . lower ( ) ) NEW_LINE DEDENT else : NEW_LINE INDENT word . append ( letter . upper ( ) ) NEW_LINE DEDENT b += 1 NEW_LINE DEDENT else : NEW_LINE INDENT word . append ( letter ) NEW_LINE DEDENT DEDENT ans . append ( \" \" . join ( word ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_733_A", "java": [{"id": "1", "code": "class Solution { public int [ ] [ ] floodFill ( int [ ] [ ] image , int sr , int sc , int newColor ) { Queue < Node > queue = new LinkedList < Node > ( ) ; int color = image [ sr ] [ sc ] ; if ( color == newColor ) return image ; queue . add ( new Node ( sr , sc ) ) ; while ( ! queue . isEmpty ( ) ) { Node curr = queue . remove ( ) ; int r = curr . r , c = curr . c ; if ( image [ r ] [ c ] == color ) { image [ r ] [ c ] = newColor ; if ( r - 1 >= 0 ) queue . add ( new Node ( r - 1 , c ) ) ; if ( r + 1 < image . length ) queue . add ( new Node ( r + 1 , c ) ) ; if ( c - 1 >= 0 ) queue . add ( new Node ( r , c - 1 ) ) ; if ( c + 1 < image [ 0 ] . length ) queue . add ( new Node ( r , c + 1 ) ) ; } } return image ; } class Node { int r ; int c ; public Node ( int r , int c ) { this . r = r ; this . c = c ; } } }", "functions_standalone": [], "functions_class": [["floodFill", "public int [ ] [ ] floodFill ( int [ ] [ ] image , int sr , int sc , int newColor ) { Queue < Node > queue = new LinkedList < Node > ( ) ; int color = image [ sr ] [ sc ] ; if ( color == newColor ) return image ; queue . add ( new Node ( sr , sc ) ) ; while ( ! queue . isEmpty ( ) ) { Node curr = queue . remove ( ) ; int r = curr . r , c = curr . c ; if ( image [ r ] [ c ] == color ) { image [ r ] [ c ] = newColor ; if ( r - 1 >= 0 ) queue . add ( new Node ( r - 1 , c ) ) ; if ( r + 1 < image . length ) queue . add ( new Node ( r + 1 , c ) ) ; if ( c - 1 >= 0 ) queue . add ( new Node ( r , c - 1 ) ) ; if ( c + 1 < image [ 0 ] . length ) queue . add ( new Node ( r , c + 1 ) ) ; } } return image ; }"], ["Node", "public Node ( int r , int c ) { this . r = r ; this . c = c ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["floodFill", "def floodFill ( self , image , sr , sc , newColor ) : NEW_LINE INDENT r_ls , c_ls = len ( image ) , len ( image [ 0 ] ) NEW_LINE color = image [ sr ] [ sc ] NEW_LINE if color == newColor : NEW_LINE INDENT return image NEW_LINE DEDENT queue = [ ( sr , sc ) ] NEW_LINE while len ( queue ) > 0 : NEW_LINE INDENT r , c = queue . pop ( 0 ) NEW_LINE if image [ r ] [ c ] == color : NEW_LINE INDENT image [ r ] [ c ] = newColor NEW_LINE if r - 1 >= 0 : queue . append ( ( r - 1 , c ) ) NEW_LINE if r + 1 < r_ls : queue . append ( ( r + 1 , c ) ) NEW_LINE if c - 1 >= 0 : queue . append ( ( r , c - 1 ) ) NEW_LINE if c + 1 < c_ls : queue . append ( ( r , c + 1 ) ) NEW_LINE DEDENT DEDENT return image NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1260_A", "java": [{"id": "1", "code": "class Solution { public List < List < Integer > > shiftGrid ( int [ ] [ ] grid , int k ) { int [ ] [ ] newGrid = new int [ grid . length ] [ grid [ 0 ] . length ] ; int m = grid . length ; int n = grid [ 0 ] . length ; int true_k = k % ( m * n ) ; int move_i = true_k / n ; int move_j = true_k % n ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) { int new_i = i + move_i ; int new_j = ( j + move_j ) % n ; if ( move_j + j >= n ) new_i ++ ; new_i %= m ; newGrid [ new_i ] [ new_j ] = grid [ i ] [ j ] ; } } List < List < Integer > > result = new ArrayList < > ( ) ; for ( int [ ] row : newGrid ) { List < Integer > listRow = new ArrayList < > ( ) ; result . add ( listRow ) ; for ( int v : row ) listRow . add ( v ) ; } return result ; } }", "functions_standalone": [], "functions_class": [["shiftGrid", "public List < List < Integer > > shiftGrid ( int [ ] [ ] grid , int k ) { int [ ] [ ] newGrid = new int [ grid . length ] [ grid [ 0 ] . length ] ; int m = grid . length ; int n = grid [ 0 ] . length ; int true_k = k % ( m * n ) ; int move_i = true_k / n ; int move_j = true_k % n ; for ( int i = 0 ; i < grid . length ; i ++ ) { for ( int j = 0 ; j < grid [ i ] . length ; j ++ ) { int new_i = i + move_i ; int new_j = ( j + move_j ) % n ; if ( move_j + j >= n ) new_i ++ ; new_i %= m ; newGrid [ new_i ] [ new_j ] = grid [ i ] [ j ] ; } } List < List < Integer > > result = new ArrayList < > ( ) ; for ( int [ ] row : newGrid ) { List < Integer > listRow = new ArrayList < > ( ) ; result . add ( listRow ) ; for ( int v : row ) listRow . add ( v ) ; } return result ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def shiftGrid ( self , grid , k ) : NEW_LINE INDENT new_grid = [ [ 0 ] * len ( grid [ 0 ] ) for _ in range ( len ( grid ) ) ] NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE true_k = k % ( m * n ) NEW_LINE move_i = true_k / n NEW_LINE move_j = true_k % n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT new_i = i + move_i NEW_LINE if move_j + j >= n : NEW_LINE INDENT new_i += 1 NEW_LINE DEDENT new_i %= m NEW_LINE new_j = ( j + move_j ) % n NEW_LINE new_grid [ new_i ] [ new_j ] = grid [ i ] [ j ] NEW_LINE DEDENT DEDENT return new_grid NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["shiftGrid", "def shiftGrid ( self , grid , k ) : NEW_LINE INDENT new_grid = [ [ 0 ] * len ( grid [ 0 ] ) for _ in range ( len ( grid ) ) ] NEW_LINE m = len ( grid ) NEW_LINE n = len ( grid [ 0 ] ) NEW_LINE true_k = k % ( m * n ) NEW_LINE move_i = true_k / n NEW_LINE move_j = true_k % n NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT new_i = i + move_i NEW_LINE if move_j + j >= n : NEW_LINE INDENT new_i += 1 NEW_LINE DEDENT new_i %= m NEW_LINE new_j = ( j + move_j ) % n NEW_LINE new_grid [ new_i ] [ new_j ] = grid [ i ] [ j ] NEW_LINE DEDENT DEDENT return new_grid NEW_LINE DEDENT"]]}]}
{"id": "leetcode_760_A", "java": [{"id": "1", "code": "class Solution { public int [ ] anagramMappings ( int [ ] A , int [ ] B ) { int [ ] ans = new int [ A . length ] ; HashMap < Integer , Integer > valIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < B . length ; i ++ ) valIndex . put ( B [ i ] , i ) ; for ( int i = 0 ; i < A . length ; i ++ ) ans [ i ] = valIndex . get ( A [ i ] ) ; return ans ; } }", "functions_standalone": [], "functions_class": [["anagramMappings", "public int [ ] anagramMappings ( int [ ] A , int [ ] B ) { int [ ] ans = new int [ A . length ] ; HashMap < Integer , Integer > valIndex = new HashMap < > ( ) ; for ( int i = 0 ; i < B . length ; i ++ ) valIndex . put ( B [ i ] , i ) ; for ( int i = 0 ; i < A . length ; i ++ ) ans [ i ] = valIndex . get ( A [ i ] ) ; return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def anagramMappings ( self , A , B ) : NEW_LINE INDENT val_index = { } NEW_LINE ans = [ ] NEW_LINE for i , n in enumerate ( B ) : NEW_LINE INDENT val_index [ n ] = i NEW_LINE DEDENT for n in A : NEW_LINE INDENT ans . append ( val_index [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["anagramMappings", "def anagramMappings ( self , A , B ) : NEW_LINE INDENT val_index = { } NEW_LINE ans = [ ] NEW_LINE for i , n in enumerate ( B ) : NEW_LINE INDENT val_index [ n ] = i NEW_LINE DEDENT for n in A : NEW_LINE INDENT ans . append ( val_index [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_751_A", "java": [{"id": "1", "code": "class Solution { public List < String > ipToCIDR ( String ip , int n ) { long start = ipToLong ( ip ) ; List < String > ans = new ArrayList ( ) ; while ( n > 0 ) { int mask = Math . max ( 33 - bitLength ( Long . lowestOneBit ( start ) ) , 33 - bitLength ( n ) ) ; ans . add ( longToIP ( start ) + \" / \" + mask ) ; start += 1 << ( 32 - mask ) ; n -= 1 << ( 32 - mask ) ; } return ans ; } private long ipToLong ( String ip ) { long ans = 0 ; for ( String x : ip . split ( \" \\\\ . \" ) ) { ans = 256 * ans + Integer . valueOf ( x ) ; } return ans ; } private String longToIP ( long x ) { return String . format ( \" % s . % s . % s . % s \" , x >> 24 , ( x >> 16 ) % 256 , ( x >> 8 ) % 256 , x % 256 ) ; } private int bitLength ( long x ) { if ( x == 0 ) return 1 ; int ans = 0 ; while ( x > 0 ) { x >>= 1 ; ans ++ ; } return ans ; } }", "functions_standalone": [], "functions_class": [["ipToCIDR", "public List < String > ipToCIDR ( String ip , int n ) { long start = ipToLong ( ip ) ; List < String > ans = new ArrayList ( ) ; while ( n > 0 ) { int mask = Math . max ( 33 - bitLength ( Long . lowestOneBit ( start ) ) , 33 - bitLength ( n ) ) ; ans . add ( longToIP ( start ) + \" / \" + mask ) ; start += 1 << ( 32 - mask ) ; n -= 1 << ( 32 - mask ) ; } return ans ; }"], ["ipToLong", "private long ipToLong ( String ip ) { long ans = 0 ; for ( String x : ip . split ( \" \\\\ . \" ) ) { ans = 256 * ans + Integer . valueOf ( x ) ; } return ans ; }"], ["longToIP", "private String longToIP ( long x ) { return String . format ( \" % s . % s . % s . % s \" , x >> 24 , ( x >> 16 ) % 256 , ( x >> 8 ) % 256 , x % 256 ) ; }"], ["bitLength", "private int bitLength ( long x ) { if ( x == 0 ) return 1 ; int ans = 0 ; while ( x > 0 ) { x >>= 1 ; ans ++ ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' / ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["ipToInt", "def ipToInt ( self , ip ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in ip . split ( ' . ' ) : NEW_LINE INDENT ans = 256 * ans + int ( x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"], ["intToIP", "def intToIP ( self , x ) : NEW_LINE INDENT return \" . \" . join ( str ( ( x >> i ) % 256 ) for i in ( 24 , 16 , 8 , 0 ) ) NEW_LINE DEDENT"], ["ipToCIDR", "def ipToCIDR ( self , ip , n ) : NEW_LINE INDENT start = self . ipToInt ( ip ) NEW_LINE ans = [ ] NEW_LINE while n : NEW_LINE INDENT mask = max ( 33 - ( start & - start ) . bit_length ( ) , 33 - n . bit_length ( ) ) NEW_LINE ans . append ( self . intToIP ( start ) + ' / ' + str ( mask ) ) NEW_LINE start += 1 << ( 32 - mask ) NEW_LINE n -= 1 << ( 32 - mask ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_904_A", "java": [{"id": "1", "code": "class Solution { public int totalFruit ( int [ ] tree ) { int ans = 0 , i = 0 ; Counter count = new Counter ( ) ; for ( int j = 0 ; j < tree . length ; ++ j ) { count . add ( tree [ j ] , 1 ) ; while ( count . size ( ) >= 3 ) { count . add ( tree [ i ] , - 1 ) ; if ( count . get ( tree [ i ] ) == 0 ) count . remove ( tree [ i ] ) ; i ++ ; } ans = Math . max ( ans , j - i + 1 ) ; } return ans ; } } class Counter extends HashMap < Integer , Integer > { public int get ( int k ) { return containsKey ( k ) ? super . get ( k ) : 0 ; } public void add ( int k , int v ) { put ( k , get ( k ) + v ) ; } }", "functions_standalone": [], "functions_class": [["totalFruit", "public int totalFruit ( int [ ] tree ) { int ans = 0 , i = 0 ; Counter count = new Counter ( ) ; for ( int j = 0 ; j < tree . length ; ++ j ) { count . add ( tree [ j ] , 1 ) ; while ( count . size ( ) >= 3 ) { count . add ( tree [ i ] , - 1 ) ; if ( count . get ( tree [ i ] ) == 0 ) count . remove ( tree [ i ] ) ; i ++ ; } ans = Math . max ( ans , j - i + 1 ) ; } return ans ; }"], ["get", "public int get ( int k ) { return containsKey ( k ) ? super . get ( k ) : 0 ; }"], ["add", "public void add ( int k , int v ) { put ( k , get ( k ) + v ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def totalFruit ( self , tree ) : NEW_LINE INDENT ans = i = 0 NEW_LINE count = collections . Counter ( ) NEW_LINE for j , x in enumerate ( tree ) : NEW_LINE INDENT count [ x ] += 1 NEW_LINE while len ( count ) >= 3 : NEW_LINE INDENT count [ tree [ i ] ] -= 1 NEW_LINE if count [ tree [ i ] ] == 0 : NEW_LINE INDENT del count [ tree [ i ] ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["totalFruit", "def totalFruit ( self , tree ) : NEW_LINE INDENT ans = i = 0 NEW_LINE count = collections . Counter ( ) NEW_LINE for j , x in enumerate ( tree ) : NEW_LINE INDENT count [ x ] += 1 NEW_LINE while len ( count ) >= 3 : NEW_LINE INDENT count [ tree [ i ] ] -= 1 NEW_LINE if count [ tree [ i ] ] == 0 : NEW_LINE INDENT del count [ tree [ i ] ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT ans = max ( ans , j - i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1064_A", "java": [{"id": "1", "code": "class Solution { public int fixedPoint ( int [ ] A ) { int l = 0 ; int h = A . length ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( A [ mid ] > mid ) h = mid - 1 ; else if ( A [ mid ] < mid ) l = mid + 1 ; else return mid ; } return - 1 ; } }", "functions_standalone": [], "functions_class": [["fixedPoint", "public int fixedPoint ( int [ ] A ) { int l = 0 ; int h = A . length ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( A [ mid ] > mid ) h = mid - 1 ; else if ( A [ mid ] < mid ) l = mid + 1 ; else return mid ; } return - 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def fixedPoint ( self , A ) : NEW_LINE INDENT l , h = 0 , len ( A ) - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if A [ mid ] < mid : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT elif A [ mid ] > mid : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["fixedPoint", "def fixedPoint ( self , A ) : NEW_LINE INDENT l , h = 0 , len ( A ) - 1 NEW_LINE while l <= h : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if A [ mid ] < mid : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT elif A [ mid ] > mid : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_538_A", "java": [{"id": "1", "code": "class Solution { public TreeNode convertBST ( TreeNode root ) { int sum = 0 ; TreeNode node = root ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; while ( ! stack . isEmpty ( ) || node != null ) { while ( node != null ) { stack . add ( node ) ; node = node . right ; } node = stack . pop ( ) ; sum += node . val ; node . val = sum ; node = node . left ; } return root ; } }", "functions_standalone": [], "functions_class": [["convertBST", "public TreeNode convertBST ( TreeNode root ) { int sum = 0 ; TreeNode node = root ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; while ( ! stack . isEmpty ( ) || node != null ) { while ( node != null ) { stack . add ( node ) ; node = node . right ; } node = stack . pop ( ) ; sum += node . val ; node . val = sum ; node = node . left ; } return root ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def convertBST ( self , root ) : NEW_LINE INDENT total = 0 NEW_LINE node = root NEW_LINE stack = [ ] NEW_LINE while stack or node is not None : NEW_LINE INDENT while node is not None : NEW_LINE INDENT stack . append ( node ) NEW_LINE node = node . right NEW_LINE DEDENT node = stack . pop ( ) NEW_LINE total += node . val NEW_LINE node . val = total NEW_LINE node = node . left NEW_LINE DEDENT return root NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["convertBST", "def convertBST ( self , root ) : NEW_LINE INDENT total = 0 NEW_LINE node = root NEW_LINE stack = [ ] NEW_LINE while stack or node is not None : NEW_LINE INDENT while node is not None : NEW_LINE INDENT stack . append ( node ) NEW_LINE node = node . right NEW_LINE DEDENT node = stack . pop ( ) NEW_LINE total += node . val NEW_LINE node . val = total NEW_LINE node = node . left NEW_LINE DEDENT return root NEW_LINE DEDENT"]]}]}
{"id": "leetcode_703_A", "java": [{"id": "1", "code": "class KthLargest { final PriorityQueue < Integer > q ; final int k ; public KthLargest ( int k , int [ ] nums ) { this . k = k ; q = new PriorityQueue < > ( k ) ; for ( int val : nums ) add ( val ) ; } public int add ( int val ) { if ( q . size ( ) < k ) q . offer ( val ) ; else if ( q . peek ( ) < val ) { q . poll ( ) ; q . offer ( val ) ; } return q . peek ( ) ; } }", "functions_standalone": [], "functions_class": [["KthLargest", "public KthLargest ( int k , int [ ] nums ) { this . k = k ; q = new PriorityQueue < > ( k ) ; for ( int val : nums ) add ( val ) ; }"], ["add", "public int add ( int val ) { if ( q . size ( ) < k ) q . offer ( val ) ; else if ( q . peek ( ) < val ) { q . poll ( ) ; q . offer ( val ) ; } return q . peek ( ) ; }"]]}], "python": [{"id": "2", "code": "class KthLargest ( object ) : NEW_LINE INDENT def __init__ ( self , k , nums ) : NEW_LINE INDENT self . nums = nums NEW_LINE self . k = k NEW_LINE heapq . heapify ( self . nums ) NEW_LINE while len ( self . nums ) > k : NEW_LINE INDENT heapq . heappop ( self . nums ) NEW_LINE DEDENT DEDENT def add ( self , val ) : NEW_LINE INDENT if len ( self . nums ) < self . k : NEW_LINE INDENT heapq . heappush ( self . nums , val ) NEW_LINE DEDENT elif val > self . nums [ 0 ] : NEW_LINE INDENT heapq . heapreplace ( self . nums , val ) NEW_LINE DEDENT return self . nums [ 0 ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self , k , nums ) : NEW_LINE INDENT self . nums = nums NEW_LINE self . k = k NEW_LINE heapq . heapify ( self . nums ) NEW_LINE while len ( self . nums ) > k : NEW_LINE INDENT heapq . heappop ( self . nums ) NEW_LINE DEDENT DEDENT"], ["add", "def add ( self , val ) : NEW_LINE INDENT if len ( self . nums ) < self . k : NEW_LINE INDENT heapq . heappush ( self . nums , val ) NEW_LINE DEDENT elif val > self . nums [ 0 ] : NEW_LINE INDENT heapq . heapreplace ( self . nums , val ) NEW_LINE DEDENT return self . nums [ 0 ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_367_A", "java": [{"id": "1", "code": "class Solution { public boolean isPerfectSquare ( int num ) { int low = 1 ; int high = num ; while ( low <= high ) { long mid = ( low + high ) >>> 1 ; if ( mid * mid == num ) { return true ; } else if ( mid * mid < num ) { low = ( int ) mid + 1 ; } else { high = ( int ) mid - 1 ; } } return false ; } }", "functions_standalone": [], "functions_class": [["isPerfectSquare", "public boolean isPerfectSquare ( int num ) { int low = 1 ; int high = num ; while ( low <= high ) { long mid = ( low + high ) >>> 1 ; if ( mid * mid == num ) { return true ; } else if ( mid * mid < num ) { low = ( int ) mid + 1 ; } else { high = ( int ) mid - 1 ; } } return false ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low , high = 1 , num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE mid_square = mid * mid NEW_LINE if mid_square == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid_square < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["isPerfectSquare", "def isPerfectSquare ( self , num ) : NEW_LINE INDENT low , high = 1 , num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE mid_square = mid * mid NEW_LINE if mid_square == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid_square < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT"]]}]}
{"id": "leetcode_155_A", "java": [{"id": "1", "code": "import java . util . ArrayList ; import java . util . List ; class MinStack { private Stack < Integer > stack ; private Stack < Integer > minStack ; public MinStack ( ) { stack = new Stack < > ( ) ; minStack = new Stack < > ( ) ; } public void push ( int x ) { stack . push ( x ) ; if ( minStack . size ( ) == 0 || x <= minStack . peek ( ) ) minStack . push ( x ) ; else minStack . push ( minStack . peek ( ) ) ; } public void pop ( ) { stack . pop ( ) ; minStack . pop ( ) ; } public int top ( ) { return stack . peek ( ) ; } public int getMin ( ) { return minStack . peek ( ) ; } }", "functions_standalone": [], "functions_class": [["MinStack", "public MinStack ( ) { stack = new Stack < > ( ) ; minStack = new Stack < > ( ) ; }"], ["push", "public void push ( int x ) { stack . push ( x ) ; if ( minStack . size ( ) == 0 || x <= minStack . peek ( ) ) minStack . push ( x ) ; else minStack . push ( minStack . peek ( ) ) ; }"], ["pop", "public void pop ( ) { stack . pop ( ) ; minStack . pop ( ) ; }"], ["top", "public int top ( ) { return stack . peek ( ) ; }"], ["getMin", "public int getMin ( ) { return minStack . peek ( ) ; }"]]}], "python": [{"id": "2", "code": "class MinStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . min_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . min_stack ) == 0 : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if x <= self . min_stack [ - 1 ] : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . min_stack . append ( self . min_stack [ - 1 ] ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT self . min_stack . pop ( ) NEW_LINE self . stack . pop ( ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT def getMin ( self ) : NEW_LINE INDENT if len ( self . min_stack ) > 0 : NEW_LINE INDENT return self . min_stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . min_stack = [ ] NEW_LINE DEDENT"], ["push", "def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . min_stack ) == 0 : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if x <= self . min_stack [ - 1 ] : NEW_LINE INDENT self . min_stack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . min_stack . append ( self . min_stack [ - 1 ] ) NEW_LINE DEDENT DEDENT"], ["pop", "def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT self . min_stack . pop ( ) NEW_LINE self . stack . pop ( ) NEW_LINE DEDENT DEDENT"], ["top", "def top ( self ) : NEW_LINE INDENT if len ( self . stack ) > 0 : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT"], ["getMin", "def getMin ( self ) : NEW_LINE INDENT if len ( self . min_stack ) > 0 : NEW_LINE INDENT return self . min_stack [ - 1 ] NEW_LINE DEDENT return None NEW_LINE DEDENT"]]}]}
{"id": "leetcode_509_A", "java": [{"id": "1", "code": "class Solution { private List < Integer > memo ; public Solution ( ) { memo = new ArrayList ( ) ; memo . add ( 0 ) ; memo . add ( 1 ) ; } public int fib ( int N ) { if ( N < memo . size ( ) ) return memo . get ( N ) ; for ( int i = memo . size ( ) ; i <= N ; i ++ ) { memo . add ( memo . get ( i - 1 ) + memo . get ( i - 2 ) ) ; } return memo . get ( N ) ; } }", "functions_standalone": [], "functions_class": [["Solution", "public Solution ( ) { memo = new ArrayList ( ) ; memo . add ( 0 ) ; memo . add ( 1 ) ; }"], ["fib", "public int fib ( int N ) { if ( N < memo . size ( ) ) return memo . get ( N ) ; for ( int i = memo . size ( ) ; i <= N ; i ++ ) { memo . add ( memo . get ( i - 1 ) + memo . get ( i - 2 ) ) ; } return memo . get ( N ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . memo = [ ] NEW_LINE self . memo . append ( 0 ) NEW_LINE self . memo . append ( 1 ) NEW_LINE DEDENT def fib ( self , N ) : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo . append ( self . memo [ i - 1 ] + self . memo [ i - 2 ] ) NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . memo = [ ] NEW_LINE self . memo . append ( 0 ) NEW_LINE self . memo . append ( 1 ) NEW_LINE DEDENT"], ["fib", "def fib ( self , N ) : NEW_LINE INDENT if N < len ( self . memo ) : NEW_LINE INDENT return self . memo [ N ] NEW_LINE DEDENT for i in range ( len ( self . memo ) , N + 1 ) : NEW_LINE INDENT self . memo . append ( self . memo [ i - 1 ] + self . memo [ i - 2 ] ) NEW_LINE DEDENT return self . memo [ N ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_905_A", "java": [{"id": "1", "code": "class Solution { public int [ ] sortArrayByParity ( int [ ] A ) { int lo = 0 , hi = A . length - 1 ; while ( lo < hi ) { if ( A [ lo ] % 2 > A [ hi ] % 2 ) { int tmp = A [ hi ] ; A [ hi ] = A [ lo ] ; A [ lo ] = tmp ; } if ( A [ lo ] % 2 == 0 ) lo ++ ; if ( A [ hi ] % 2 == 1 ) hi -- ; } return A ; } }", "functions_standalone": [], "functions_class": [["sortArrayByParity", "public int [ ] sortArrayByParity ( int [ ] A ) { int lo = 0 , hi = A . length - 1 ; while ( lo < hi ) { if ( A [ lo ] % 2 > A [ hi ] % 2 ) { int tmp = A [ hi ] ; A [ hi ] = A [ lo ] ; A [ lo ] = tmp ; } if ( A [ lo ] % 2 == 0 ) lo ++ ; if ( A [ hi ] % 2 == 1 ) hi -- ; } return A ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def sortArrayByParity ( self , A ) : NEW_LINE INDENT lo , hi = 0 , len ( A ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT if A [ lo ] % 2 > A [ hi ] % 2 : NEW_LINE INDENT A [ lo ] , A [ hi ] = A [ hi ] , A [ lo ] NEW_LINE DEDENT if A [ lo ] % 2 == 0 : lo += 1 NEW_LINE if A [ hi ] % 2 == 1 : hi -= 1 NEW_LINE DEDENT return A NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["sortArrayByParity", "def sortArrayByParity ( self , A ) : NEW_LINE INDENT lo , hi = 0 , len ( A ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT if A [ lo ] % 2 > A [ hi ] % 2 : NEW_LINE INDENT A [ lo ] , A [ hi ] = A [ hi ] , A [ lo ] NEW_LINE DEDENT if A [ lo ] % 2 == 0 : lo += 1 NEW_LINE if A [ hi ] % 2 == 1 : hi -= 1 NEW_LINE DEDENT return A NEW_LINE DEDENT"]]}]}
{"id": "leetcode_766_A", "java": [{"id": "1", "code": "class Solution { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 1 ; r < matrix . length ; ++ r ) for ( int c = 1 ; c < matrix [ 0 ] . length ; ++ c ) if ( matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] ) return false ; return true ; } }", "functions_standalone": [], "functions_class": [["isToeplitzMatrix", "public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 1 ; r < matrix . length ; ++ r ) for ( int c = 1 ; c < matrix [ 0 ] . length ; ++ c ) if ( matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] ) return false ; return true ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["isToeplitzMatrix", "def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"]]}]}
{"id": "leetcode_933_A", "java": [{"id": "1", "code": "class RecentCounter { Queue < Integer > q ; public RecentCounter ( ) { q = new LinkedList ( ) ; } public int ping ( int t ) { q . add ( t ) ; while ( q . peek ( ) < t - 3000 ) q . poll ( ) ; return q . size ( ) ; } }", "functions_standalone": [], "functions_class": [["RecentCounter", "public RecentCounter ( ) { q = new LinkedList ( ) ; }"], ["ping", "public int ping ( int t ) { q . add ( t ) ; while ( q . peek ( ) < t - 3000 ) q . poll ( ) ; return q . size ( ) ; }"]]}], "python": [{"id": "2", "code": "class RecentCounter ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . queue = [ ] NEW_LINE DEDENT"], ["ping", "def ping ( self , t ) : NEW_LINE INDENT self . queue . append ( t ) NEW_LINE while self . queue and self . queue [ 0 ] < t - 3000 : NEW_LINE INDENT self . queue . pop ( 0 ) NEW_LINE DEDENT return len ( self . queue ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_215_A", "java": [{"id": "1", "code": "class Solution { public int findKthLargest ( int [ ] nums , int k ) { shuffle ( nums ) ; k = nums . length - k ; int lo = 0 ; int hi = nums . length - 1 ; while ( lo < hi ) { final int j = partition ( nums , lo , hi ) ; if ( j < k ) { lo = j + 1 ; } else if ( j > k ) { hi = j - 1 ; } else { break ; } } return nums [ k ] ; } private int partition ( int [ ] a , int lo , int hi ) { int i = lo ; int j = hi + 1 ; while ( true ) { while ( i < hi && less ( a [ ++ i ] , a [ lo ] ) ) ; while ( j > lo && less ( a [ lo ] , a [ -- j ] ) ) ; if ( i >= j ) { break ; } exch ( a , i , j ) ; } exch ( a , lo , j ) ; return j ; } private void exch ( int [ ] a , int i , int j ) { final int tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } private boolean less ( int v , int w ) { return v < w ; } private void shuffle ( int a [ ] ) { final Random random = new Random ( ) ; for ( int ind = 1 ; ind < a . length ; ind ++ ) { final int r = random . nextInt ( ind + 1 ) ; exch ( a , ind , r ) ; } } }", "functions_standalone": [], "functions_class": [["findKthLargest", "public int findKthLargest ( int [ ] nums , int k ) { shuffle ( nums ) ; k = nums . length - k ; int lo = 0 ; int hi = nums . length - 1 ; while ( lo < hi ) { final int j = partition ( nums , lo , hi ) ; if ( j < k ) { lo = j + 1 ; } else if ( j > k ) { hi = j - 1 ; } else { break ; } } return nums [ k ] ; }"], ["partition", "private int partition ( int [ ] a , int lo , int hi ) { int i = lo ; int j = hi + 1 ; while ( true ) { while ( i < hi && less ( a [ ++ i ] , a [ lo ] ) ) ; while ( j > lo && less ( a [ lo ] , a [ -- j ] ) ) ; if ( i >= j ) { break ; } exch ( a , i , j ) ; } exch ( a , lo , j ) ; return j ; }"], ["exch", "private void exch ( int [ ] a , int i , int j ) { final int tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; }"], ["less", "private boolean less ( int v , int w ) { return v < w ; }"], ["shuffle", "private void shuffle ( int a [ ] ) { final Random random = new Random ( ) ; for ( int ind = 1 ; ind < a . length ; ind ++ ) { final int r = random . nextInt ( ind + 1 ) ; exch ( a , ind , r ) ; } }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT random . shuffle ( nums ) NEW_LINE return self . quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k ) NEW_LINE DEDENT def quickSelection ( self , nums , start , end , k ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT pivot = nums [ end ] NEW_LINE left = start NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if nums [ i ] <= pivot : NEW_LINE INDENT nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ] NEW_LINE left += 1 NEW_LINE DEDENT DEDENT nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ] NEW_LINE if left == k : NEW_LINE INDENT return nums [ left ] NEW_LINE DEDENT elif left < k : NEW_LINE INDENT return self . quickSelection ( nums , left + 1 , end , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . quickSelection ( nums , start , left - 1 , k ) NEW_LINE DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findKthLargest", "def findKthLargest ( self , nums , k ) : NEW_LINE INDENT random . shuffle ( nums ) NEW_LINE return self . quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k ) NEW_LINE DEDENT"], ["quickSelection", "def quickSelection ( self , nums , start , end , k ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT pivot = nums [ end ] NEW_LINE left = start NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if nums [ i ] <= pivot : NEW_LINE INDENT nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ] NEW_LINE left += 1 NEW_LINE DEDENT DEDENT nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ] NEW_LINE if left == k : NEW_LINE INDENT return nums [ left ] NEW_LINE DEDENT elif left < k : NEW_LINE INDENT return self . quickSelection ( nums , left + 1 , end , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . quickSelection ( nums , start , left - 1 , k ) NEW_LINE DEDENT DEDENT"]]}]}
{"id": "leetcode_443_A", "java": [{"id": "1", "code": "class Solution { public int compress ( char [ ] chars ) { int anchor = 0 , write = 0 ; for ( int read = 0 ; read < chars . length ; read ++ ) { if ( read + 1 == chars . length || chars [ read + 1 ] != chars [ read ] ) { chars [ write ++ ] = chars [ anchor ] ; if ( read > anchor ) { for ( char c : ( \" \" + ( read - anchor + 1 ) ) . toCharArray ( ) ) { chars [ write ++ ] = c ; } } anchor = read + 1 ; } } return write ; } }", "functions_standalone": [], "functions_class": [["compress", "public int compress ( char [ ] chars ) { int anchor = 0 , write = 0 ; for ( int read = 0 ; read < chars . length ; read ++ ) { if ( read + 1 == chars . length || chars [ read + 1 ] != chars [ read ] ) { chars [ write ++ ] = chars [ anchor ] ; if ( read > anchor ) { for ( char c : ( \" \" + ( read - anchor + 1 ) ) . toCharArray ( ) ) { chars [ write ++ ] = c ; } } anchor = read + 1 ; } } return write ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["compress", "def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT"]]}]}
{"id": "leetcode_671_A", "java": [{"id": "1", "code": "class Solution { public int findSecondMinimumValue ( TreeNode root ) { if ( root == null ) return - 1 ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; int min_val = root . val ; int ans = Integer . MAX_VALUE ; stack . push ( root ) ; while ( ! stack . empty ( ) ) { TreeNode node = stack . pop ( ) ; if ( node == null ) continue ; if ( node . val < ans && node . val > min_val ) { ans = node . val ; } else if ( node . val == min_val ) { stack . push ( node . left ) ; stack . push ( node . right ) ; } } return ans < Integer . MAX_VALUE ? ans : - 1 ; } }", "functions_standalone": [], "functions_class": [["findSecondMinimumValue", "public int findSecondMinimumValue ( TreeNode root ) { if ( root == null ) return - 1 ; Stack < TreeNode > stack = new Stack < TreeNode > ( ) ; int min_val = root . val ; int ans = Integer . MAX_VALUE ; stack . push ( root ) ; while ( ! stack . empty ( ) ) { TreeNode node = stack . pop ( ) ; if ( node == null ) continue ; if ( node . val < ans && node . val > min_val ) { ans = node . val ; } else if ( node . val == min_val ) { stack . push ( node . left ) ; stack . push ( node . right ) ; } } return ans < Integer . MAX_VALUE ? ans : - 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findSecondMinimumValue", "def findSecondMinimumValue ( self , root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = float ( ' inf ' ) NEW_LINE min_val = root . val NEW_LINE stack = [ root ] NEW_LINE while stack : NEW_LINE INDENT curr = stack . pop ( ) NEW_LINE if not curr : NEW_LINE INDENT continue NEW_LINE DEDENT if min_val < curr . val < ans : NEW_LINE INDENT ans = curr . val NEW_LINE DEDENT elif curr . val == min_val : NEW_LINE INDENT stack . append ( curr . left ) NEW_LINE stack . append ( curr . right ) NEW_LINE DEDENT DEDENT return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_475_A", "java": [{"id": "1", "code": "public class Solution { public int findRadius ( int [ ] houses , int [ ] heaters ) { Arrays . sort ( heaters ) ; int result = Integer . MIN_VALUE ; for ( int house : houses ) { int index = Arrays . binarySearch ( heaters , house ) ; if ( index < 0 ) index = - ( index + 1 ) ; int dist1 = index - 1 >= 0 ? house - heaters [ index - 1 ] : Integer . MAX_VALUE ; int dist2 = index < heaters . length ? heaters [ index ] - house : Integer . MAX_VALUE ; result = Math . max ( result , Math . min ( dist1 , dist2 ) ) ; } return result ; } }", "functions_standalone": [], "functions_class": [["findRadius", "public int findRadius ( int [ ] houses , int [ ] heaters ) { Arrays . sort ( heaters ) ; int result = Integer . MIN_VALUE ; for ( int house : houses ) { int index = Arrays . binarySearch ( heaters , house ) ; if ( index < 0 ) index = - ( index + 1 ) ; int dist1 = index - 1 >= 0 ? house - heaters [ index - 1 ] : Integer . MAX_VALUE ; int dist2 = index < heaters . length ? heaters [ index ] - house : Integer . MAX_VALUE ; result = Math . max ( result , Math . min ( dist1 , dist2 ) ) ; } return result ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters = sorted ( heaters ) + [ float ( ' inf ' ) ] NEW_LINE i = r = 0 NEW_LINE for x in sorted ( houses ) : NEW_LINE INDENT while x >= sum ( heaters [ i : i + 2 ] ) / 2. : NEW_LINE INDENT i += 1 NEW_LINE DEDENT r = max ( r , abs ( heaters [ i ] - x ) ) NEW_LINE DEDENT return r NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findRadius", "def findRadius ( self , houses , heaters ) : NEW_LINE INDENT heaters = sorted ( heaters ) + [ float ( ' inf ' ) ] NEW_LINE i = r = 0 NEW_LINE for x in sorted ( houses ) : NEW_LINE INDENT while x >= sum ( heaters [ i : i + 2 ] ) / 2. : NEW_LINE INDENT i += 1 NEW_LINE DEDENT r = max ( r , abs ( heaters [ i ] - x ) ) NEW_LINE DEDENT return r NEW_LINE DEDENT"]]}]}
{"id": "leetcode_011_A", "java": [{"id": "1", "code": "class Solution { public int maxArea ( int [ ] height ) { int maxArea = 0 ; int left = 0 ; int right = height . length - 1 ; while ( left < right ) { maxArea = Math . max ( maxArea , ( right - left ) * Math . min ( height [ left ] , height [ right ] ) ) ; if ( height [ left ] < height [ right ] ) left ++ ; else right -- ; } return maxArea ; } }", "functions_standalone": [], "functions_class": [["maxArea", "public int maxArea ( int [ ] height ) { int maxArea = 0 ; int left = 0 ; int right = height . length - 1 ; while ( left < right ) { maxArea = Math . max ( maxArea , ( right - left ) * Math . min ( height [ left ] , height [ right ] ) ) ; if ( height [ left ] < height [ right ] ) left ++ ; else right -- ; } return maxArea ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def maxArea ( self , height : List [ int ] ) -> int : NEW_LINE INDENT left , right = 0 , len ( height ) - 1 NEW_LINE result = 0 NEW_LINE while left < right : NEW_LINE INDENT result = max ( min ( height [ left ] , height [ right ] ) * ( right - left ) , result ) NEW_LINE if height [ left ] > height [ right ] : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["maxArea", "def maxArea ( self , height : List [ int ] ) -> int : NEW_LINE INDENT left , right = 0 , len ( height ) - 1 NEW_LINE result = 0 NEW_LINE while left < right : NEW_LINE INDENT result = max ( min ( height [ left ] , height [ right ] ) * ( right - left ) , result ) NEW_LINE if height [ left ] > height [ right ] : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT left += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT"]]}]}
{"id": "leetcode_876_A", "java": [{"id": "1", "code": "class Solution { public ListNode middleNode ( ListNode head ) { ListNode fast , slow ; fast = slow = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; } }", "functions_standalone": [], "functions_class": [["middleNode", "public ListNode middleNode ( ListNode head ) { ListNode fast , slow ; fast = slow = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; } return slow ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def middleNode ( self , head ) : NEW_LINE INDENT fast = slow = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT return slow NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["middleNode", "def middleNode ( self , head ) : NEW_LINE INDENT fast = slow = head NEW_LINE while fast and fast . next : NEW_LINE INDENT slow = slow . next NEW_LINE fast = fast . next . next NEW_LINE DEDENT return slow NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1323_A", "java": [{"id": "1", "code": "class Solution { public int maximum69Number ( int num ) { return Integer . valueOf ( String . valueOf ( num ) . replaceFirst ( \"6\" , \"9\" ) ) ; } }", "functions_standalone": [], "functions_class": [["maximum69Number", "public int maximum69Number ( int num ) { return Integer . valueOf ( String . valueOf ( num ) . replaceFirst ( \"6\" , \"9\" ) ) ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def maximum69Number ( self , num : int ) -> int : NEW_LINE INDENT return ( str ( num ) . replace ( '6' , '9' , 1 ) ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["maximum69Number", "def maximum69Number ( self , num : int ) -> int : NEW_LINE INDENT return ( str ( num ) . replace ( '6' , '9' , 1 ) ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_019_A", "java": [{"id": "1", "code": "class Solution { public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow , fast , curr ; slow = head ; fast = head ; for ( int i = 0 ; i < n ; i ++ ) fast = fast . next ; if ( fast == null ) { head = head . next ; return head ; } while ( fast . next != null ) { fast = fast . next ; slow = slow . next ; } curr = slow . next ; slow . next = curr . next ; return head ; } }", "functions_standalone": [], "functions_class": [["removeNthFromEnd", "public ListNode removeNthFromEnd ( ListNode head , int n ) { ListNode slow , fast , curr ; slow = head ; fast = head ; for ( int i = 0 ; i < n ; i ++ ) fast = fast . next ; if ( fast == null ) { head = head . next ; return head ; } while ( fast . next != null ) { fast = fast . next ; slow = slow . next ; } curr = slow . next ; slow . next = curr . next ; return head ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["removeNthFromEnd", "def removeNthFromEnd ( self , head , n ) : NEW_LINE INDENT if head is None : NEW_LINE INDENT return None NEW_LINE DEDENT slow = fast = head NEW_LINE for i in range ( n ) : NEW_LINE INDENT fast = fast . next NEW_LINE DEDENT if fast is None : NEW_LINE INDENT head = head . next NEW_LINE return head NEW_LINE DEDENT while fast . next is not None : NEW_LINE INDENT fast = fast . next NEW_LINE slow = slow . next NEW_LINE DEDENT curr = slow . next NEW_LINE slow . next = curr . next NEW_LINE return head NEW_LINE DEDENT"]]}]}
{"id": "leetcode_458_A", "java": [{"id": "1", "code": "class Solution { public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { int n = minutesToTest / minutesToDie + 1 ; int pigs = 0 ; while ( Math . pow ( n , pigs ) < buckets ) pigs ++ ; return pigs ; } }", "functions_standalone": [], "functions_class": [["poorPigs", "public int poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { int n = minutesToTest / minutesToDie + 1 ; int pigs = 0 ; while ( Math . pow ( n , pigs ) < buckets ) pigs ++ ; return pigs ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def poorPigs ( self , buckets , minutesToDie , minutesToTest ) : NEW_LINE INDENT pigs = 0 NEW_LINE while ( minutesToTest / minutesToDie + 1 ) ** pigs < buckets : NEW_LINE INDENT pigs += 1 NEW_LINE DEDENT return pigs NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["poorPigs", "def poorPigs ( self , buckets , minutesToDie , minutesToTest ) : NEW_LINE INDENT pigs = 0 NEW_LINE while ( minutesToTest / minutesToDie + 1 ) ** pigs < buckets : NEW_LINE INDENT pigs += 1 NEW_LINE DEDENT return pigs NEW_LINE DEDENT"]]}]}
{"id": "leetcode_003_A", "java": [{"id": "1", "code": "public class Solution { public int lengthOfLongestSubstring ( String s ) { int [ ] charMap = new int [ 256 ] ; Arrays . fill ( charMap , - 1 ) ; int i = 0 , maxLen = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( charMap [ s . charAt ( j ) ] >= i ) { i = charMap [ s . charAt ( j ) ] + 1 ; } charMap [ s . charAt ( j ) ] = j ; maxLen = Math . max ( j - i + 1 , maxLen ) ; } return maxLen ; } }", "functions_standalone": [], "functions_class": [["lengthOfLongestSubstring", "public int lengthOfLongestSubstring ( String s ) { int [ ] charMap = new int [ 256 ] ; Arrays . fill ( charMap , - 1 ) ; int i = 0 , maxLen = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( charMap [ s . charAt ( j ) ] >= i ) { i = charMap [ s . charAt ( j ) ] + 1 ; } charMap [ s . charAt ( j ) ] = j ; maxLen = Math . max ( j - i + 1 , maxLen ) ; } return maxLen ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def lengthOfLongestSubstring ( self , s ) : NEW_LINE INDENT charMap = { } NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT charMap [ i ] = - 1 NEW_LINE DEDENT ls = len ( s ) NEW_LINE i = max_len = 0 NEW_LINE for j in range ( ls ) : NEW_LINE INDENT if charMap [ ord ( s [ j ] ) ] >= i : NEW_LINE INDENT i = charMap [ ord ( s [ j ] ) ] + 1 NEW_LINE DEDENT charMap [ ord ( s [ j ] ) ] = j NEW_LINE max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["lengthOfLongestSubstring", "def lengthOfLongestSubstring ( self , s ) : NEW_LINE INDENT charMap = { } NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT charMap [ i ] = - 1 NEW_LINE DEDENT ls = len ( s ) NEW_LINE i = max_len = 0 NEW_LINE for j in range ( ls ) : NEW_LINE INDENT if charMap [ ord ( s [ j ] ) ] >= i : NEW_LINE INDENT i = charMap [ ord ( s [ j ] ) ] + 1 NEW_LINE DEDENT charMap [ ord ( s [ j ] ) ] = j NEW_LINE max_len = max ( max_len , j - i + 1 ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT"]]}]}
{"id": "leetcode_236_A", "java": [{"id": "1", "code": "class Solution { private TreeNode ans ; public Solution ( ) { this . ans = null ; } private boolean recurseTree ( TreeNode currentNode , TreeNode p , TreeNode q ) { if ( currentNode == null ) { return false ; } int left = this . recurseTree ( currentNode . left , p , q ) ? 1 : 0 ; int right = this . recurseTree ( currentNode . right , p , q ) ? 1 : 0 ; int mid = ( currentNode == p || currentNode == q ) ? 1 : 0 ; if ( mid + left + right >= 2 ) { this . ans = currentNode ; } return ( mid + left + right > 0 ) ; } public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { this . recurseTree ( root , p , q ) ; return this . ans ; } }", "functions_standalone": [], "functions_class": [["Solution", "public Solution ( ) { this . ans = null ; }"], ["recurseTree", "private boolean recurseTree ( TreeNode currentNode , TreeNode p , TreeNode q ) { if ( currentNode == null ) { return false ; } int left = this . recurseTree ( currentNode . left , p , q ) ? 1 : 0 ; int right = this . recurseTree ( currentNode . right , p , q ) ? 1 : 0 ; int mid = ( currentNode == p || currentNode == q ) ? 1 : 0 ; if ( mid + left + right >= 2 ) { this . ans = currentNode ; } return ( mid + left + right > 0 ) ; }"], ["lowestCommonAncestor", "public TreeNode lowestCommonAncestor ( TreeNode root , TreeNode p , TreeNode q ) { this . recurseTree ( root , p , q ) ; return this . ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def lowestCommonAncestor ( self , root , p , q ) : NEW_LINE INDENT stack = [ root ] NEW_LINE parent = { root : None } NEW_LINE while p not in parent or q not in parent : NEW_LINE INDENT node = stack . pop ( ) NEW_LINE if node . left : NEW_LINE INDENT parent [ node . left ] = node NEW_LINE stack . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT parent [ node . right ] = node NEW_LINE stack . append ( node . right ) NEW_LINE DEDENT DEDENT ancestors = set ( ) NEW_LINE while p : NEW_LINE INDENT ancestors . add ( p ) NEW_LINE p = parent [ p ] NEW_LINE DEDENT while q not in ancestors : NEW_LINE INDENT q = parent [ q ] NEW_LINE DEDENT return q NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["lowestCommonAncestor", "def lowestCommonAncestor ( self , root , p , q ) : NEW_LINE INDENT stack = [ root ] NEW_LINE parent = { root : None } NEW_LINE while p not in parent or q not in parent : NEW_LINE INDENT node = stack . pop ( ) NEW_LINE if node . left : NEW_LINE INDENT parent [ node . left ] = node NEW_LINE stack . append ( node . left ) NEW_LINE DEDENT if node . right : NEW_LINE INDENT parent [ node . right ] = node NEW_LINE stack . append ( node . right ) NEW_LINE DEDENT DEDENT ancestors = set ( ) NEW_LINE while p : NEW_LINE INDENT ancestors . add ( p ) NEW_LINE p = parent [ p ] NEW_LINE DEDENT while q not in ancestors : NEW_LINE INDENT q = parent [ q ] NEW_LINE DEDENT return q NEW_LINE DEDENT"]]}]}
{"id": "leetcode_238_A", "java": [{"id": "1", "code": "public class Solution { public int [ ] productExceptSelf ( int [ ] nums ) { int n = nums . length ; int [ ] res = new int [ n ] ; res [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res [ i ] = res [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { res [ i ] *= right ; right *= nums [ i ] ; } return res ; } }", "functions_standalone": [], "functions_class": [["productExceptSelf", "public int [ ] productExceptSelf ( int [ ] nums ) { int n = nums . length ; int [ ] res = new int [ n ] ; res [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res [ i ] = res [ i - 1 ] * nums [ i - 1 ] ; } int right = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { res [ i ] *= right ; right *= nums [ i ] ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def productExceptSelf ( self , nums ) : NEW_LINE INDENT ans = [ 1 ] * len ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["productExceptSelf", "def productExceptSelf ( self , nums ) : NEW_LINE INDENT ans = [ 1 ] * len ( nums ) NEW_LINE for i in range ( 1 , len ( nums ) ) : NEW_LINE INDENT ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] NEW_LINE DEDENT right = 1 NEW_LINE for i in range ( len ( nums ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans [ i ] *= right NEW_LINE right *= nums [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_836_A", "java": [{"id": "1", "code": "class Solution { public boolean isRectangleOverlap ( int [ ] rec1 , int [ ] rec2 ) { return ( Math . min ( rec1 [ 2 ] , rec2 [ 2 ] ) > Math . max ( rec1 [ 0 ] , rec2 [ 0 ] ) && Math . min ( rec1 [ 3 ] , rec2 [ 3 ] ) > Math . max ( rec1 [ 1 ] , rec2 [ 1 ] ) ) ; } }", "functions_standalone": [], "functions_class": [["isRectangleOverlap", "public boolean isRectangleOverlap ( int [ ] rec1 , int [ ] rec2 ) { return ( Math . min ( rec1 [ 2 ] , rec2 [ 2 ] ) > Math . max ( rec1 [ 0 ] , rec2 [ 0 ] ) && Math . min ( rec1 [ 3 ] , rec2 [ 3 ] ) > Math . max ( rec1 [ 1 ] , rec2 [ 1 ] ) ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def isRectangleOverlap ( self , rec1 , rec2 ) : NEW_LINE INDENT return not ( rec1 [ 2 ] <= rec2 [ 0 ] or rec1 [ 3 ] <= rec2 [ 1 ] or rec1 [ 0 ] >= rec2 [ 2 ] or rec1 [ 1 ] >= rec2 [ 3 ] ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["isRectangleOverlap", "def isRectangleOverlap ( self , rec1 , rec2 ) : NEW_LINE INDENT return not ( rec1 [ 2 ] <= rec2 [ 0 ] or rec1 [ 3 ] <= rec2 [ 1 ] or rec1 [ 0 ] >= rec2 [ 2 ] or rec1 [ 1 ] >= rec2 [ 3 ] ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_697_A", "java": [{"id": "1", "code": "class Solution { public int findShortestSubArray ( int [ ] nums ) { Map < Integer , Integer > left = new HashMap ( ) , right = new HashMap ( ) , count = new HashMap ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int x = nums [ i ] ; if ( left . get ( x ) == null ) left . put ( x , i ) ; right . put ( x , i ) ; count . put ( x , count . getOrDefault ( x , 0 ) + 1 ) ; } int ans = nums . length ; int degree = Collections . max ( count . values ( ) ) ; for ( int x : count . keySet ( ) ) { if ( count . get ( x ) == degree ) { ans = Math . min ( ans , right . get ( x ) - left . get ( x ) + 1 ) ; } } return ans ; } }", "functions_standalone": [], "functions_class": [["findShortestSubArray", "public int findShortestSubArray ( int [ ] nums ) { Map < Integer , Integer > left = new HashMap ( ) , right = new HashMap ( ) , count = new HashMap ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { int x = nums [ i ] ; if ( left . get ( x ) == null ) left . put ( x , i ) ; right . put ( x , i ) ; count . put ( x , count . getOrDefault ( x , 0 ) + 1 ) ; } int ans = nums . length ; int degree = Collections . max ( count . values ( ) ) ; for ( int x : count . keySet ( ) ) { if ( count . get ( x ) == degree ) { ans = Math . min ( ans , right . get ( x ) - left . get ( x ) + 1 ) ; } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findShortestSubArray ( self , nums ) : NEW_LINE INDENT left , right , count = { } , { } , { } NEW_LINE for i , x in enumerate ( nums ) : NEW_LINE INDENT if x not in left : left [ x ] = i NEW_LINE right [ x ] = i NEW_LINE count [ x ] = count . get ( x , 0 ) + 1 NEW_LINE DEDENT ans = len ( nums ) NEW_LINE degree = max ( count . values ( ) ) NEW_LINE for x in count : NEW_LINE INDENT if count [ x ] == degree : NEW_LINE INDENT ans = min ( ans , right [ x ] - left [ x ] + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findShortestSubArray", "def findShortestSubArray ( self , nums ) : NEW_LINE INDENT left , right , count = { } , { } , { } NEW_LINE for i , x in enumerate ( nums ) : NEW_LINE INDENT if x not in left : left [ x ] = i NEW_LINE right [ x ] = i NEW_LINE count [ x ] = count . get ( x , 0 ) + 1 NEW_LINE DEDENT ans = len ( nums ) NEW_LINE degree = max ( count . values ( ) ) NEW_LINE for x in count : NEW_LINE INDENT if count [ x ] == degree : NEW_LINE INDENT ans = min ( ans , right [ x ] - left [ x ] + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_405_A", "java": [{"id": "1", "code": "import com . sun . corba . se . spi . orbutil . fsm . Guard . Result ; class Solution { public String toHex ( int num ) { String hex_map = \"0123456789abcdef \" ; if ( num == 0 ) return \"0\" ; String res = \" \" ; while ( num != 0 && res . length ( ) < 8 ) { res = hex_map . charAt ( num & 15 ) + res ; num = num >> 4 ; } return res ; } }", "functions_standalone": [], "functions_class": [["toHex", "public String toHex ( int num ) { String hex_map = \"0123456789abcdef \" ; if ( num == 0 ) return \"0\" ; String res = \" \" ; while ( num != 0 && res . length ( ) < 8 ) { res = hex_map . charAt ( num & 15 ) + res ; num = num >> 4 ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["toHex", "def toHex ( self , num ) : NEW_LINE INDENT if num == 0 : NEW_LINE INDENT return '0' NEW_LINE DEDENT mp = '0123456789abcdef ' NEW_LINE ans = ' ' NEW_LINE for _ in range ( 8 ) : NEW_LINE INDENT n = num & 15 NEW_LINE c = mp [ n ] NEW_LINE ans = c + ans NEW_LINE num = num >> 4 NEW_LINE DEDENT return ans . lstrip ( '0' ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_253_A", "java": [{"id": "1", "code": "class Solution { public int minMeetingRooms ( Interval [ ] intervals ) { int ans = 0 , curr = 0 ; List < TimePoint > timeline = new ArrayList < > ( ) ; for ( Interval interval : intervals ) { timeline . add ( new TimePoint ( interval . start , 1 ) ) ; timeline . add ( new TimePoint ( interval . end , - 1 ) ) ; } timeline . sort ( new Comparator < TimePoint > ( ) { public int compare ( TimePoint a , TimePoint b ) { if ( a . time != b . time ) return a . time - b . time ; else return a . room - b . room ; } } ) ; for ( TimePoint t : timeline ) { curr += t . room ; if ( curr >= ans ) ans = curr ; } return ans ; } private class TimePoint { int time ; int room ; TimePoint ( int time , int room ) { this . time = time ; this . room = room ; } } }", "functions_standalone": [], "functions_class": [["minMeetingRooms", "public int minMeetingRooms ( Interval [ ] intervals ) { int ans = 0 , curr = 0 ; List < TimePoint > timeline = new ArrayList < > ( ) ; for ( Interval interval : intervals ) { timeline . add ( new TimePoint ( interval . start , 1 ) ) ; timeline . add ( new TimePoint ( interval . end , - 1 ) ) ; } timeline . sort ( new Comparator < TimePoint > ( ) { public int compare ( TimePoint a , TimePoint b ) { if ( a . time != b . time ) return a . time - b . time ; else return a . room - b . room ; } } ) ; for ( TimePoint t : timeline ) { curr += t . room ; if ( curr >= ans ) ans = curr ; } return ans ; }"], ["TimePoint", "TimePoint ( int time , int room ) { this . time = time ; this . room = room ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def minMeetingRooms ( self , intervals ) : NEW_LINE INDENT timeline = [ ] NEW_LINE for interval in intervals : NEW_LINE INDENT timeline . append ( ( interval . start , 1 ) ) NEW_LINE timeline . append ( ( interval . end , - 1 ) ) NEW_LINE DEDENT timeline . sort ( ) NEW_LINE ans = curr = 0 NEW_LINE for _ , v in timeline : NEW_LINE INDENT curr += v NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["minMeetingRooms", "def minMeetingRooms ( self , intervals ) : NEW_LINE INDENT timeline = [ ] NEW_LINE for interval in intervals : NEW_LINE INDENT timeline . append ( ( interval . start , 1 ) ) NEW_LINE timeline . append ( ( interval . end , - 1 ) ) NEW_LINE DEDENT timeline . sort ( ) NEW_LINE ans = curr = 0 NEW_LINE for _ , v in timeline : NEW_LINE INDENT curr += v NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_066_A", "java": [{"id": "1", "code": "class Solution { public int [ ] plusOne ( int [ ] digits ) { return addToDigit ( digits , digits . length - 1 ) ; } private int [ ] addToDigit ( int [ ] digits , int index ) { if ( index == - 1 ) { int [ ] newDigits = new int [ digits . length + 1 ] ; newDigits [ 0 ] = 1 ; for ( int i = 0 ; i < digits . length ; i ++ ) { newDigits [ i + 1 ] = digits [ i ] ; } return newDigits ; } if ( digits [ index ] == 9 ) { digits [ index ] = 0 ; return addToDigit ( digits , index - 1 ) ; } else { digits [ index ] ++ ; return digits ; } } }", "functions_standalone": [], "functions_class": [["plusOne", "public int [ ] plusOne ( int [ ] digits ) { return addToDigit ( digits , digits . length - 1 ) ; }"], ["addToDigit", "private int [ ] addToDigit ( int [ ] digits , int index ) { if ( index == - 1 ) { int [ ] newDigits = new int [ digits . length + 1 ] ; newDigits [ 0 ] = 1 ; for ( int i = 0 ; i < digits . length ; i ++ ) { newDigits [ i + 1 ] = digits [ i ] ; } return newDigits ; } if ( digits [ index ] == 9 ) { digits [ index ] = 0 ; return addToDigit ( digits , index - 1 ) ; } else { digits [ index ] ++ ; return digits ; } }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def plusOne ( self , digits ) : NEW_LINE INDENT ls = len ( digits ) NEW_LINE for index in reversed ( range ( ls ) ) : NEW_LINE INDENT if digits [ index ] < 9 : NEW_LINE INDENT digits [ index ] += 1 NEW_LINE return digits NEW_LINE DEDENT else : NEW_LINE INDENT digits [ index ] = 0 NEW_LINE DEDENT DEDENT digits . insert ( 0 , 1 ) NEW_LINE return digits NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["plusOne", "def plusOne ( self , digits ) : NEW_LINE INDENT ls = len ( digits ) NEW_LINE for index in reversed ( range ( ls ) ) : NEW_LINE INDENT if digits [ index ] < 9 : NEW_LINE INDENT digits [ index ] += 1 NEW_LINE return digits NEW_LINE DEDENT else : NEW_LINE INDENT digits [ index ] = 0 NEW_LINE DEDENT DEDENT digits . insert ( 0 , 1 ) NEW_LINE return digits NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1337_A", "java": [{"id": "1", "code": "class Solution { public int [ ] kWeakestRows ( int [ ] [ ] mat , int k ) { List < Integer > res = new ArrayList < > ( ) ; int col = 0 ; boolean flag = true ; while ( col < mat [ 0 ] . length && flag ) { for ( int i = 0 ; i < mat . length ; i ++ ) { if ( res . contains ( i ) ) continue ; if ( mat [ i ] [ col ] == 0 ) res . add ( i ) ; if ( res . size ( ) == k ) { flag = false ; break ; } } col += 1 ; } if ( flag ) { for ( int i = 0 ; i < mat . length ; i ++ ) { if ( res . contains ( i ) ) continue ; res . add ( i ) ; if ( res . size ( ) == k ) break ; } } int [ ] ret = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) ret [ i ] = res . get ( i ) ; return ret ; } }", "functions_standalone": [], "functions_class": [["kWeakestRows", "public int [ ] kWeakestRows ( int [ ] [ ] mat , int k ) { List < Integer > res = new ArrayList < > ( ) ; int col = 0 ; boolean flag = true ; while ( col < mat [ 0 ] . length && flag ) { for ( int i = 0 ; i < mat . length ; i ++ ) { if ( res . contains ( i ) ) continue ; if ( mat [ i ] [ col ] == 0 ) res . add ( i ) ; if ( res . size ( ) == k ) { flag = false ; break ; } } col += 1 ; } if ( flag ) { for ( int i = 0 ; i < mat . length ; i ++ ) { if ( res . contains ( i ) ) continue ; res . add ( i ) ; if ( res . size ( ) == k ) break ; } } int [ ] ret = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) ret [ i ] = res . get ( i ) ; return ret ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["kWeakestRows", "def kWeakestRows ( self , mat , k ) : NEW_LINE INDENT res = [ ] NEW_LINE num_row = len ( mat ) NEW_LINE num_col = len ( mat [ 0 ] ) NEW_LINE col = 0 NEW_LINE flag = 1 NEW_LINE while col < num_col and flag : NEW_LINE INDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT if mat [ i ] [ col ] == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT col += 1 NEW_LINE DEDENT if len ( res ) == k : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( num_row ) : NEW_LINE INDENT if i in res : NEW_LINE INDENT continue NEW_LINE DEDENT res . append ( i ) NEW_LINE if len ( res ) == k : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_434_A", "java": [{"id": "1", "code": "class Solution { public int countSegments ( String s ) { int segmentCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( i == 0 || s . charAt ( i - 1 ) == ' \u2581 ' ) && s . charAt ( i ) != ' \u2581 ' ) { segmentCount ++ ; } } return segmentCount ; } }", "functions_standalone": [], "functions_class": [["countSegments", "public int countSegments ( String s ) { int segmentCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( i == 0 || s . charAt ( i - 1 ) == ' \u2581 ' ) && s . charAt ( i ) != ' \u2581 ' ) { segmentCount ++ ; } } return segmentCount ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def countSegments ( self , s ) : NEW_LINE INDENT segment_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i == 0 or s [ i - 1 ] == ' \u2581 ' ) and s [ i ] != ' \u2581 ' : NEW_LINE INDENT segment_count += 1 NEW_LINE DEDENT DEDENT return segment_count NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["countSegments", "def countSegments ( self , s ) : NEW_LINE INDENT segment_count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i == 0 or s [ i - 1 ] == ' \u2581 ' ) and s [ i ] != ' \u2581 ' : NEW_LINE INDENT segment_count += 1 NEW_LINE DEDENT DEDENT return segment_count NEW_LINE DEDENT"]]}]}
{"id": "leetcode_1365_A", "java": [{"id": "1", "code": "import java . util . Map ; class Solution { public int [ ] smallerNumbersThanCurrent ( int [ ] nums ) { int [ ] countList = new int [ 101 ] ; int [ ] res = new int [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) countList [ nums [ i ] ] ++ ; for ( int i = 1 ; i < 101 ; i ++ ) countList [ i ] += countList [ i - 1 ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 0 ) res [ i ] = 0 ; else res [ i ] = countList [ nums [ i ] - 1 ] ; } return res ; } }", "functions_standalone": [], "functions_class": [["smallerNumbersThanCurrent", "public int [ ] smallerNumbersThanCurrent ( int [ ] nums ) { int [ ] countList = new int [ 101 ] ; int [ ] res = new int [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) countList [ nums [ i ] ] ++ ; for ( int i = 1 ; i < 101 ; i ++ ) countList [ i ] += countList [ i - 1 ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] == 0 ) res [ i ] = 0 ; else res [ i ] = countList [ nums [ i ] - 1 ] ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["smallerNumbersThanCurrent", "def smallerNumbersThanCurrent ( self , nums : List [ int ] ) -> List [ int ] : NEW_LINE INDENT count_list = [ 0 ] * 101 NEW_LINE for v in nums : NEW_LINE INDENT count_list [ v ] += 1 NEW_LINE DEDENT for i in range ( 1 , 101 ) : NEW_LINE INDENT count_list [ i ] += count_list [ i - 1 ] NEW_LINE DEDENT res = [ ] NEW_LINE for v in nums : NEW_LINE INDENT if v == 0 : NEW_LINE INDENT res . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( count_list [ v - 1 ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_206_A", "java": [{"id": "1", "code": "class Solution { public ListNode reverseList ( ListNode head ) { ListNode newHead = null ; while ( head != null ) { ListNode next = head . next ; head . next = newHead ; newHead = head ; head = next ; } return newHead ; } }", "functions_standalone": [], "functions_class": [["reverseList", "public ListNode reverseList ( ListNode head ) { ListNode newHead = null ; while ( head != null ) { ListNode next = head . next ; head . next = newHead ; newHead = head ; head = next ; } return newHead ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def reverseList ( self , head ) : NEW_LINE INDENT if head is None or head . next is None : NEW_LINE INDENT return head NEW_LINE DEDENT p = self . reverseList ( head . next ) NEW_LINE head . next . next = head NEW_LINE head . next = None NEW_LINE return p NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["reverseList", "def reverseList ( self , head ) : NEW_LINE INDENT if head is None or head . next is None : NEW_LINE INDENT return head NEW_LINE DEDENT p = self . reverseList ( head . next ) NEW_LINE head . next . next = head NEW_LINE head . next = None NEW_LINE return p NEW_LINE DEDENT"]]}]}
{"id": "leetcode_665_A", "java": [{"id": "1", "code": "class Solution { public boolean checkPossibility ( int [ ] nums ) { int brokenPoint = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] > nums [ i + 1 ] ) { brokenPoint ++ ; if ( brokenPoint >= 2 ) return false ; if ( i - 1 < 0 || nums [ i - 1 ] <= nums [ i + 1 ] ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } return true ; } }", "functions_standalone": [], "functions_class": [["checkPossibility", "public boolean checkPossibility ( int [ ] nums ) { int brokenPoint = 0 ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { if ( nums [ i ] > nums [ i + 1 ] ) { brokenPoint ++ ; if ( brokenPoint >= 2 ) return false ; if ( i - 1 < 0 || nums [ i - 1 ] <= nums [ i + 1 ] ) nums [ i ] = nums [ i + 1 ] ; else nums [ i + 1 ] = nums [ i ] ; } } return true ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def checkPossibility ( self , nums ) : NEW_LINE INDENT broken_num = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if ( nums [ i ] > nums [ i + 1 ] ) : NEW_LINE INDENT broken_num += 1 NEW_LINE if broken_num >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["checkPossibility", "def checkPossibility ( self , nums ) : NEW_LINE INDENT broken_num = 0 NEW_LINE for i in range ( len ( nums ) - 1 ) : NEW_LINE INDENT if ( nums [ i ] > nums [ i + 1 ] ) : NEW_LINE INDENT broken_num += 1 NEW_LINE if broken_num >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i - 1 < 0 or nums [ i - 1 ] <= nums [ i + 1 ] ) : NEW_LINE INDENT nums [ i ] = nums [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nums [ i + 1 ] = nums [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT"]]}]}
{"id": "leetcode_461_A", "java": [{"id": "1", "code": "class Solution { public int hammingDistance ( int x , int y ) { return Integer . bitCount ( x ^ y ) ; } }", "functions_standalone": [], "functions_class": [["hammingDistance", "public int hammingDistance ( int x , int y ) { return Integer . bitCount ( x ^ y ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def hammingDistance ( self , x , y ) : NEW_LINE INDENT return bin ( x ^ y ) . count ( '1' ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["hammingDistance", "def hammingDistance ( self , x , y ) : NEW_LINE INDENT return bin ( x ^ y ) . count ( '1' ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_002_A", "java": [{"id": "1", "code": "public class Solution { public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummyHead = new ListNode ( 0 ) ; ListNode p = l1 , q = l2 , curr = dummyHead ; int carry = 0 ; while ( p != null || q != null ) { int x = ( p != null ) ? p . val : 0 ; int y = ( q != null ) ? q . val : 0 ; int digit = carry + x + y ; carry = digit / 10 ; curr . next = new ListNode ( digit % 10 ) ; curr = curr . next ; if ( p != null ) p = p . next ; if ( q != null ) q = q . next ; } if ( carry > 0 ) { curr . next = new ListNode ( carry ) ; } return dummyHead . next ; } }", "functions_standalone": [], "functions_class": [["addTwoNumbers", "public ListNode addTwoNumbers ( ListNode l1 , ListNode l2 ) { ListNode dummyHead = new ListNode ( 0 ) ; ListNode p = l1 , q = l2 , curr = dummyHead ; int carry = 0 ; while ( p != null || q != null ) { int x = ( p != null ) ? p . val : 0 ; int y = ( q != null ) ? q . val : 0 ; int digit = carry + x + y ; carry = digit / 10 ; curr . next = new ListNode ( digit % 10 ) ; curr = curr . next ; if ( p != null ) p = p . next ; if ( q != null ) q = q . next ; } if ( carry > 0 ) { curr . next = new ListNode ( carry ) ; } return dummyHead . next ; }"]]}], "python": [{"id": "2", "code": "class ListNode ( object ) : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . val = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def addTwoNumbers ( self , l1 , l2 ) : NEW_LINE INDENT carry = 0 NEW_LINE head = curr = ListNode ( 0 ) NEW_LINE while l1 or l2 : NEW_LINE INDENT val = carry NEW_LINE if l1 : NEW_LINE INDENT val += l1 . val NEW_LINE l1 = l1 . next NEW_LINE DEDENT if l2 : NEW_LINE INDENT val += l2 . val NEW_LINE l2 = l2 . next NEW_LINE DEDENT curr . next = ListNode ( val % 10 ) NEW_LINE curr = curr . next NEW_LINE carry = val / 10 NEW_LINE DEDENT if carry > 0 : NEW_LINE INDENT curr . next = ListNode ( carry ) NEW_LINE DEDENT return head . next NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self , x ) : NEW_LINE INDENT self . val = x NEW_LINE self . next = None NEW_LINE DEDENT"], ["addTwoNumbers", "def addTwoNumbers ( self , l1 , l2 ) : NEW_LINE INDENT carry = 0 NEW_LINE head = curr = ListNode ( 0 ) NEW_LINE while l1 or l2 : NEW_LINE INDENT val = carry NEW_LINE if l1 : NEW_LINE INDENT val += l1 . val NEW_LINE l1 = l1 . next NEW_LINE DEDENT if l2 : NEW_LINE INDENT val += l2 . val NEW_LINE l2 = l2 . next NEW_LINE DEDENT curr . next = ListNode ( val % 10 ) NEW_LINE curr = curr . next NEW_LINE carry = val / 10 NEW_LINE DEDENT if carry > 0 : NEW_LINE INDENT curr . next = ListNode ( carry ) NEW_LINE DEDENT return head . next NEW_LINE DEDENT"]]}]}
{"id": "leetcode_654_A", "java": [{"id": "1", "code": "public class Solution { public TreeNode constructMaximumBinaryTree ( int [ ] nums ) { return construct ( nums , 0 , nums . length ) ; } public TreeNode construct ( int [ ] nums , int l , int r ) { if ( l == r ) return null ; int max_i = max ( nums , l , r ) ; TreeNode root = new TreeNode ( nums [ max_i ] ) ; root . left = construct ( nums , l , max_i ) ; root . right = construct ( nums , max_i + 1 , r ) ; return root ; } public int max ( int [ ] nums , int l , int r ) { int max_i = l ; for ( int i = l ; i < r ; i ++ ) { if ( nums [ max_i ] < nums [ i ] ) max_i = i ; } return max_i ; } }", "functions_standalone": [], "functions_class": [["constructMaximumBinaryTree", "public TreeNode constructMaximumBinaryTree ( int [ ] nums ) { return construct ( nums , 0 , nums . length ) ; }"], ["construct", "public TreeNode construct ( int [ ] nums , int l , int r ) { if ( l == r ) return null ; int max_i = max ( nums , l , r ) ; TreeNode root = new TreeNode ( nums [ max_i ] ) ; root . left = construct ( nums , l , max_i ) ; root . right = construct ( nums , max_i + 1 , r ) ; return root ; }"], ["max", "public int max ( int [ ] nums , int l , int r ) { int max_i = l ; for ( int i = l ; i < r ; i ++ ) { if ( nums [ max_i ] < nums [ i ] ) max_i = i ; } return max_i ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def constructMaximumBinaryTree ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT max_index , max_value = 0 , 0 NEW_LINE for i , value in enumerate ( nums ) : NEW_LINE INDENT if value >= max_value : NEW_LINE INDENT max_value = value NEW_LINE max_index = i NEW_LINE DEDENT DEDENT root = TreeNode ( max_value ) NEW_LINE root . left = self . constructMaximumBinaryTree ( nums [ : max_index ] ) NEW_LINE root . right = self . constructMaximumBinaryTree ( nums [ max_index + 1 : ] ) NEW_LINE return root NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["constructMaximumBinaryTree", "def constructMaximumBinaryTree ( self , nums ) : NEW_LINE INDENT if nums is None or len ( nums ) == 0 : NEW_LINE INDENT return None NEW_LINE DEDENT max_index , max_value = 0 , 0 NEW_LINE for i , value in enumerate ( nums ) : NEW_LINE INDENT if value >= max_value : NEW_LINE INDENT max_value = value NEW_LINE max_index = i NEW_LINE DEDENT DEDENT root = TreeNode ( max_value ) NEW_LINE root . left = self . constructMaximumBinaryTree ( nums [ : max_index ] ) NEW_LINE root . right = self . constructMaximumBinaryTree ( nums [ max_index + 1 : ] ) NEW_LINE return root NEW_LINE DEDENT"]]}]}
{"id": "leetcode_852_A", "java": [{"id": "1", "code": "class Solution { public int peakIndexInMountainArray ( int [ ] A ) { int lo = 0 , hi = A . length - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( A [ mid ] < A [ mid + 1 ] ) lo = mid + 1 ; else hi = mid ; } return lo ; } }", "functions_standalone": [], "functions_class": [["peakIndexInMountainArray", "public int peakIndexInMountainArray ( int [ ] A ) { int lo = 0 , hi = A . length - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( A [ mid ] < A [ mid + 1 ] ) lo = mid + 1 ; else hi = mid ; } return lo ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def peakIndexInMountainArray ( self , A ) : NEW_LINE INDENT lo , hi = 0 , len ( A ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if A [ mid ] < A [ mid + 1 ] : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["peakIndexInMountainArray", "def peakIndexInMountainArray ( self , A ) : NEW_LINE INDENT lo , hi = 0 , len ( A ) - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if A [ mid ] < A [ mid + 1 ] : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE DEDENT"]]}]}
{"id": "leetcode_404_A", "java": [{"id": "1", "code": "import java . util . Stack ; import javax . swing . tree . TreeNode ; class Solution { public int sumOfLeftLeaves ( TreeNode root ) { int res = 0 ; Stack < TreeNode > stack = new Stack < > ( ) ; stack . push ( root ) ; while ( ! stack . isEmpty ( ) ) { TreeNode node = stack . pop ( ) ; if ( node != null ) { if ( node . left != null && node . left . left == null && node . left . right == null ) res += node . left . val ; stack . push ( node . right ) ; stack . push ( node . left ) ; } } return res ; } }", "functions_standalone": [], "functions_class": [["sumOfLeftLeaves", "public int sumOfLeftLeaves ( TreeNode root ) { int res = 0 ; Stack < TreeNode > stack = new Stack < > ( ) ; stack . push ( root ) ; while ( ! stack . isEmpty ( ) ) { TreeNode node = stack . pop ( ) ; if ( node != null ) { if ( node . left != null && node . left . left == null && node . left . right == null ) res += node . left . val ; stack . push ( node . right ) ; stack . push ( node . left ) ; } } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def sumOfLeftLeaves ( self , root ) : NEW_LINE INDENT stack = [ root ] NEW_LINE res = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT curr = stack . pop ( 0 ) NEW_LINE if curr is not None : NEW_LINE INDENT if curr . left is not None : NEW_LINE INDENT if curr . left . left is None and curr . left . right is None : NEW_LINE INDENT res += curr . left . val NEW_LINE DEDENT DEDENT stack . insert ( 0 , curr . right ) NEW_LINE stack . insert ( 0 , curr . left ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["sumOfLeftLeaves", "def sumOfLeftLeaves ( self , root ) : NEW_LINE INDENT stack = [ root ] NEW_LINE res = 0 NEW_LINE while len ( stack ) > 0 : NEW_LINE INDENT curr = stack . pop ( 0 ) NEW_LINE if curr is not None : NEW_LINE INDENT if curr . left is not None : NEW_LINE INDENT if curr . left . left is None and curr . left . right is None : NEW_LINE INDENT res += curr . left . val NEW_LINE DEDENT DEDENT stack . insert ( 0 , curr . right ) NEW_LINE stack . insert ( 0 , curr . left ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_743_A", "java": [{"id": "1", "code": "class Solution { Map < Integer , Integer > dist ; public int networkDelayTime ( int [ ] [ ] times , int N , int K ) { Map < Integer , List < int [ ] > > graph = new HashMap ( ) ; for ( int [ ] edge : times ) { if ( ! graph . containsKey ( edge [ 0 ] ) ) graph . put ( edge [ 0 ] , new ArrayList < int [ ] > ( ) ) ; graph . get ( edge [ 0 ] ) . add ( new int [ ] { edge [ 1 ] , edge [ 2 ] } ) ; } dist = new HashMap ( ) ; for ( int node = 1 ; node <= N ; ++ node ) dist . put ( node , Integer . MAX_VALUE ) ; dist . put ( K , 0 ) ; boolean [ ] seen = new boolean [ N + 1 ] ; while ( true ) { int candNode = - 1 ; int candDist = Integer . MAX_VALUE ; for ( int i = 1 ; i <= N ; ++ i ) { if ( ! seen [ i ] && dist . get ( i ) < candDist ) { candDist = dist . get ( i ) ; candNode = i ; } } if ( candNode < 0 ) break ; seen [ candNode ] = true ; if ( graph . containsKey ( candNode ) ) for ( int [ ] info : graph . get ( candNode ) ) dist . put ( info [ 0 ] , Math . min ( dist . get ( info [ 0 ] ) , dist . get ( candNode ) + info [ 1 ] ) ) ; } int ans = 0 ; for ( int cand : dist . values ( ) ) { if ( cand == Integer . MAX_VALUE ) return - 1 ; ans = Math . max ( ans , cand ) ; } return ans ; } }", "functions_standalone": [], "functions_class": [["networkDelayTime", "public int networkDelayTime ( int [ ] [ ] times , int N , int K ) { Map < Integer , List < int [ ] > > graph = new HashMap ( ) ; for ( int [ ] edge : times ) { if ( ! graph . containsKey ( edge [ 0 ] ) ) graph . put ( edge [ 0 ] , new ArrayList < int [ ] > ( ) ) ; graph . get ( edge [ 0 ] ) . add ( new int [ ] { edge [ 1 ] , edge [ 2 ] } ) ; } dist = new HashMap ( ) ; for ( int node = 1 ; node <= N ; ++ node ) dist . put ( node , Integer . MAX_VALUE ) ; dist . put ( K , 0 ) ; boolean [ ] seen = new boolean [ N + 1 ] ; while ( true ) { int candNode = - 1 ; int candDist = Integer . MAX_VALUE ; for ( int i = 1 ; i <= N ; ++ i ) { if ( ! seen [ i ] && dist . get ( i ) < candDist ) { candDist = dist . get ( i ) ; candNode = i ; } } if ( candNode < 0 ) break ; seen [ candNode ] = true ; if ( graph . containsKey ( candNode ) ) for ( int [ ] info : graph . get ( candNode ) ) dist . put ( info [ 0 ] , Math . min ( dist . get ( info [ 0 ] ) , dist . get ( candNode ) + info [ 1 ] ) ) ; } int ans = 0 ; for ( int cand : dist . values ( ) ) { if ( cand == Integer . MAX_VALUE ) return - 1 ; ans = Math . max ( ans , cand ) ; } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def networkDelayTime ( self , times , N , K ) : NEW_LINE INDENT graph = collections . defaultdict ( list ) NEW_LINE for u , v , w in times : NEW_LINE INDENT graph [ u ] . append ( ( v , w ) ) NEW_LINE DEDENT dist = { node : float ( ' inf ' ) for node in xrange ( 1 , N + 1 ) } NEW_LINE seen = [ False ] * ( N + 1 ) NEW_LINE dist [ K ] = 0 NEW_LINE while True : NEW_LINE INDENT cand_node = - 1 NEW_LINE cand_dist = float ( ' inf ' ) NEW_LINE for i in xrange ( 1 , N + 1 ) : NEW_LINE INDENT if not seen [ i ] and dist [ i ] < cand_dist : NEW_LINE INDENT cand_dist = dist [ i ] NEW_LINE cand_node = i NEW_LINE DEDENT DEDENT if cand_node < 0 : break NEW_LINE seen [ cand_node ] = True NEW_LINE for nei , d in graph [ cand_node ] : NEW_LINE INDENT dist [ nei ] = min ( dist [ nei ] , dist [ cand_node ] + d ) NEW_LINE DEDENT DEDENT ans = max ( dist . values ( ) ) NEW_LINE return ans if ans < float ( ' inf ' ) else - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": []}]}
{"id": "leetcode_929_A", "java": [{"id": "1", "code": "import java . util . HashSet ; class Solution { public int numUniqueEmails ( String [ ] emails ) { HashSet < String > emailSet = new HashSet < > ( ) ; for ( String email : emails ) { String firstSplit [ ] = email . split ( \" @ \" ) ; String secondSplit [ ] = firstSplit [ 0 ] . replaceAll ( \" . \" , \" \" ) . split ( \" [ + ] \" ) ; emailSet . add ( secondSplit [ 0 ] + firstSplit [ 1 ] ) ; } return emailSet . size ( ) ; } }", "functions_standalone": [], "functions_class": [["numUniqueEmails", "public int numUniqueEmails ( String [ ] emails ) { HashSet < String > emailSet = new HashSet < > ( ) ; for ( String email : emails ) { String firstSplit [ ] = email . split ( \" @ \" ) ; String secondSplit [ ] = firstSplit [ 0 ] . replaceAll ( \" . \" , \" \" ) . split ( \" [ + ] \" ) ; emailSet . add ( secondSplit [ 0 ] + firstSplit [ 1 ] ) ; } return emailSet . size ( ) ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def numUniqueEmails ( self , emails ) : NEW_LINE INDENT email_set = set ( ) NEW_LINE for email in emails : NEW_LINE INDENT elements = email . split ( ' @ ' ) NEW_LINE email_set . add ( elements [ 0 ] . split ( ' + ' ) [ 0 ] . replace ( ' . ' , ' ' ) + elements [ 1 ] ) NEW_LINE DEDENT return len ( email_set ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["numUniqueEmails", "def numUniqueEmails ( self , emails ) : NEW_LINE INDENT email_set = set ( ) NEW_LINE for email in emails : NEW_LINE INDENT elements = email . split ( ' @ ' ) NEW_LINE email_set . add ( elements [ 0 ] . split ( ' + ' ) [ 0 ] . replace ( ' . ' , ' ' ) + elements [ 1 ] ) NEW_LINE DEDENT return len ( email_set ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_547_A", "java": [{"id": "1", "code": "public class Solution { public void dfs ( int [ ] [ ] M , int [ ] visited , int i ) { for ( int j = 0 ; j < M . length ; j ++ ) { if ( M [ i ] [ j ] == 1 && visited [ j ] == 0 ) { visited [ j ] = 1 ; dfs ( M , visited , j ) ; } } } public int findCircleNum ( int [ ] [ ] M ) { int [ ] visited = new int [ M . length ] ; int count = 0 ; for ( int i = 0 ; i < M . length ; i ++ ) { if ( visited [ i ] == 0 ) { dfs ( M , visited , i ) ; count ++ ; } } return count ; } }", "functions_standalone": [], "functions_class": [["dfs", "public void dfs ( int [ ] [ ] M , int [ ] visited , int i ) { for ( int j = 0 ; j < M . length ; j ++ ) { if ( M [ i ] [ j ] == 1 && visited [ j ] == 0 ) { visited [ j ] = 1 ; dfs ( M , visited , j ) ; } } }"], ["findCircleNum", "public int findCircleNum ( int [ ] [ ] M ) { int [ ] visited = new int [ M . length ] ; int count = 0 ; for ( int i = 0 ; i < M . length ; i ++ ) { if ( visited [ i ] == 0 ) { dfs ( M , visited , i ) ; count ++ ; } } return count ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findCircleNum ( self , M ) : NEW_LINE INDENT visited = [ 0 ] * len ( M ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( M ) ) : NEW_LINE INDENT if visited [ i ] == 0 : NEW_LINE INDENT self . dfs ( M , visited , i ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def dfs ( self , M , visited , i ) : NEW_LINE INDENT for j in range ( len ( M ) ) : NEW_LINE INDENT if M [ i ] [ j ] == 1 and visited [ j ] == 0 : NEW_LINE INDENT visited [ j ] = 1 NEW_LINE self . dfs ( M , visited , j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findCircleNum", "def findCircleNum ( self , M ) : NEW_LINE INDENT visited = [ 0 ] * len ( M ) NEW_LINE count = 0 NEW_LINE for i in range ( len ( M ) ) : NEW_LINE INDENT if visited [ i ] == 0 : NEW_LINE INDENT self . dfs ( M , visited , i ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT"], ["dfs", "def dfs ( self , M , visited , i ) : NEW_LINE INDENT for j in range ( len ( M ) ) : NEW_LINE INDENT if M [ i ] [ j ] == 1 and visited [ j ] == 0 : NEW_LINE INDENT visited [ j ] = 1 NEW_LINE self . dfs ( M , visited , j ) NEW_LINE DEDENT DEDENT DEDENT"]]}]}
{"id": "leetcode_389_A", "java": [{"id": "1", "code": "class Solution { public char findTheDifference ( String s , String t ) { int total = t . charAt ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) total += ( t . charAt ( i ) - s . charAt ( i ) ) ; return ( char ) total ; } }", "functions_standalone": [], "functions_class": [["findTheDifference", "public char findTheDifference ( String s , String t ) { int total = t . charAt ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) total += ( t . charAt ( i ) - s . charAt ( i ) ) ; return ( char ) total ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def findTheDifference ( self , s , t ) : NEW_LINE INDENT res = ord ( t [ - 1 ] ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT res += ord ( t [ i ] ) NEW_LINE res -= ord ( s [ i ] ) NEW_LINE DEDENT return chr ( res ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["findTheDifference", "def findTheDifference ( self , s , t ) : NEW_LINE INDENT res = ord ( t [ - 1 ] ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT res += ord ( t [ i ] ) NEW_LINE res -= ord ( s [ i ] ) NEW_LINE DEDENT return chr ( res ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_973_A", "java": [{"id": "1", "code": "class Solution { private int dist ( int [ ] point ) { return point [ 0 ] * point [ 0 ] + point [ 1 ] * point [ 1 ] ; } public int [ ] [ ] kClosest ( int [ ] [ ] points , int K ) { PriorityQueue < int [ ] > pq = new PriorityQueue < int [ ] > ( ( p1 , p2 ) -> dist ( p2 ) - dist ( p1 ) ) ; for ( int [ ] p : points ) { pq . offer ( p ) ; if ( pq . size ( ) > K ) { pq . poll ( ) ; } } int [ ] [ ] res = new int [ K ] [ 2 ] ; while ( K > 0 ) { res [ -- K ] = pq . poll ( ) ; } return res ; } }", "functions_standalone": [], "functions_class": [["dist", "private int dist ( int [ ] point ) { return point [ 0 ] * point [ 0 ] + point [ 1 ] * point [ 1 ] ; }"], ["kClosest", "public int [ ] [ ] kClosest ( int [ ] [ ] points , int K ) { PriorityQueue < int [ ] > pq = new PriorityQueue < int [ ] > ( ( p1 , p2 ) -> dist ( p2 ) - dist ( p1 ) ) ; for ( int [ ] p : points ) { pq . offer ( p ) ; if ( pq . size ( ) > K ) { pq . poll ( ) ; } } int [ ] [ ] res = new int [ K ] [ 2 ] ; while ( K > 0 ) { res [ -- K ] = pq . poll ( ) ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def kClosest ( self , points , K ) : NEW_LINE INDENT return heapq . nsmallest ( K , points , key = lambda x : x [ 0 ] ** 2 + x [ 1 ] ** 2 ) NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["kClosest", "def kClosest ( self , points , K ) : NEW_LINE INDENT return heapq . nsmallest ( K , points , key = lambda x : x [ 0 ] ** 2 + x [ 1 ] ** 2 ) NEW_LINE DEDENT"]]}]}
{"id": "leetcode_717_A", "java": [{"id": "1", "code": "class Solution { public boolean isOneBitCharacter ( int [ ] bits ) { int pos = 0 ; while ( pos < bits . length - 1 ) { pos += bits [ pos ] + 1 ; } return pos == bits . length - 1 ; } }", "functions_standalone": [], "functions_class": [["isOneBitCharacter", "public boolean isOneBitCharacter ( int [ ] bits ) { int pos = 0 ; while ( pos < bits . length - 1 ) { pos += bits [ pos ] + 1 ; } return pos == bits . length - 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def isOneBitCharacter ( self , bits : List [ int ] ) -> bool : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( bits ) - 1 : NEW_LINE INDENT pos += bits [ pos ] + 1 NEW_LINE DEDENT return pos == len ( bits ) - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["isOneBitCharacter", "def isOneBitCharacter ( self , bits : List [ int ] ) -> bool : NEW_LINE INDENT pos = 0 NEW_LINE while pos < len ( bits ) - 1 : NEW_LINE INDENT pos += bits [ pos ] + 1 NEW_LINE DEDENT return pos == len ( bits ) - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_387_A", "java": [{"id": "1", "code": "class Solution { public int firstUniqChar ( String s ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( freq [ s . charAt ( i ) - ' a ' ] == 1 ) return i ; return - 1 ; } }", "functions_standalone": [], "functions_class": [["firstUniqChar", "public int firstUniqChar ( String s ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( freq [ s . charAt ( i ) - ' a ' ] == 1 ) return i ; return - 1 ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def firstUniqChar ( self , s ) : NEW_LINE INDENT count_map = { } NEW_LINE for c in s : NEW_LINE INDENT count_map [ c ] = count_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT if count_map [ c ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["firstUniqChar", "def firstUniqChar ( self , s ) : NEW_LINE INDENT count_map = { } NEW_LINE for c in s : NEW_LINE INDENT count_map [ c ] = count_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for i , c in enumerate ( s ) : NEW_LINE INDENT if count_map [ c ] == 1 : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT"]]}]}
{"id": "leetcode_728_A", "java": [{"id": "1", "code": "class Solution { public List < Integer > selfDividingNumbers ( int left , int right ) { LinkedList list = new LinkedList ( ) ; for ( int i = left ; i <= right ; i ++ ) { if ( isSelfDiving ( i ) ) list . add ( i ) ; } return list ; } public boolean isSelfDiving ( int num ) { int digit = num % 10 ; int temp = num ; boolean isTrue = true ; while ( temp != 0 ) { if ( digit == 0 || num % digit != 0 ) { isTrue = false ; break ; } else { temp /= 10 ; digit = temp % 10 ; } } return isTrue ; } }", "functions_standalone": [], "functions_class": [["selfDividingNumbers", "public List < Integer > selfDividingNumbers ( int left , int right ) { LinkedList list = new LinkedList ( ) ; for ( int i = left ; i <= right ; i ++ ) { if ( isSelfDiving ( i ) ) list . add ( i ) ; } return list ; }"], ["isSelfDiving", "public boolean isSelfDiving ( int num ) { int digit = num % 10 ; int temp = num ; boolean isTrue = true ; while ( temp != 0 ) { if ( digit == 0 || num % digit != 0 ) { isTrue = false ; break ; } else { temp /= 10 ; digit = temp % 10 ; } } return isTrue ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ] : NEW_LINE INDENT return [ x for x in range ( left , right + 1 ) if all ( [ int ( i ) != 0 and x % int ( i ) == 0 for i in str ( x ) ] ) ] NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["selfDividingNumbers", "def selfDividingNumbers ( self , left : int , right : int ) -> List [ int ] : NEW_LINE INDENT return [ x for x in range ( left , right + 1 ) if all ( [ int ( i ) != 0 and x % int ( i ) == 0 for i in str ( x ) ] ) ] NEW_LINE DEDENT"]]}]}
{"id": "leetcode_945_A", "java": [{"id": "1", "code": "class Solution { public int minIncrementForUnique ( int [ ] A ) { if ( A . length == 0 ) return 0 ; HashSet < Integer > numSet = new HashSet < > ( ) ; List < Integer > duplicated = new ArrayList < > ( ) ; int res = 0 ; Arrays . sort ( A ) ; int left = A [ 0 ] ; int right = A [ A . length - 1 ] ; int holes = right - left + 1 ; for ( int v : A ) { if ( numSet . contains ( v ) ) duplicated . add ( v ) ; else numSet . add ( v ) ; } holes -= numSet . size ( ) ; for ( int i = left + 1 ; i < right ; i ++ ) { if ( holes == 0 || duplicated . size ( ) == 0 ) break ; if ( ! numSet . contains ( i ) && i > duplicated . get ( 0 ) ) { res += i - duplicated . get ( 0 ) ; holes -- ; duplicated . remove ( 0 ) ; } } if ( duplicated . size ( ) == 0 ) return res ; while ( duplicated . size ( ) != 0 ) { right += 1 ; res += right - duplicated . get ( 0 ) ; duplicated . remove ( 0 ) ; } return res ; } }", "functions_standalone": [], "functions_class": [["minIncrementForUnique", "public int minIncrementForUnique ( int [ ] A ) { if ( A . length == 0 ) return 0 ; HashSet < Integer > numSet = new HashSet < > ( ) ; List < Integer > duplicated = new ArrayList < > ( ) ; int res = 0 ; Arrays . sort ( A ) ; int left = A [ 0 ] ; int right = A [ A . length - 1 ] ; int holes = right - left + 1 ; for ( int v : A ) { if ( numSet . contains ( v ) ) duplicated . add ( v ) ; else numSet . add ( v ) ; } holes -= numSet . size ( ) ; for ( int i = left + 1 ; i < right ; i ++ ) { if ( holes == 0 || duplicated . size ( ) == 0 ) break ; if ( ! numSet . contains ( i ) && i > duplicated . get ( 0 ) ) { res += i - duplicated . get ( 0 ) ; holes -- ; duplicated . remove ( 0 ) ; } } if ( duplicated . size ( ) == 0 ) return res ; while ( duplicated . size ( ) != 0 ) { right += 1 ; res += right - duplicated . get ( 0 ) ; duplicated . remove ( 0 ) ; } return res ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def minIncrementForUnique ( self , A ) : NEW_LINE INDENT if A is None or len ( A ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE num_set = set ( ) NEW_LINE duplicate = [ ] NEW_LINE A . sort ( ) NEW_LINE left , right = A [ 0 ] , A [ - 1 ] NEW_LINE holes = right - left + 1 NEW_LINE for v in A : NEW_LINE INDENT if v in num_set : NEW_LINE INDENT duplicate . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT num_set . add ( v ) NEW_LINE DEDENT DEDENT holes = holes - len ( num_set ) NEW_LINE for hole in range ( left + 1 , right ) : NEW_LINE INDENT if holes == 0 or len ( duplicate ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if hole not in num_set and hole > duplicate [ 0 ] : NEW_LINE INDENT res += hole - duplicate . pop ( 0 ) NEW_LINE holes -= 1 NEW_LINE DEDENT DEDENT while len ( duplicate ) != 0 : NEW_LINE INDENT right += 1 NEW_LINE res += right - duplicate . pop ( 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = Solution ( ) NEW_LINE DEDENT", "functions_standalone": [], "functions_class": [["minIncrementForUnique", "def minIncrementForUnique ( self , A ) : NEW_LINE INDENT if A is None or len ( A ) == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE num_set = set ( ) NEW_LINE duplicate = [ ] NEW_LINE A . sort ( ) NEW_LINE left , right = A [ 0 ] , A [ - 1 ] NEW_LINE holes = right - left + 1 NEW_LINE for v in A : NEW_LINE INDENT if v in num_set : NEW_LINE INDENT duplicate . append ( v ) NEW_LINE DEDENT else : NEW_LINE INDENT num_set . add ( v ) NEW_LINE DEDENT DEDENT holes = holes - len ( num_set ) NEW_LINE for hole in range ( left + 1 , right ) : NEW_LINE INDENT if holes == 0 or len ( duplicate ) == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if hole not in num_set and hole > duplicate [ 0 ] : NEW_LINE INDENT res += hole - duplicate . pop ( 0 ) NEW_LINE holes -= 1 NEW_LINE DEDENT DEDENT while len ( duplicate ) != 0 : NEW_LINE INDENT right += 1 NEW_LINE res += right - duplicate . pop ( 0 ) NEW_LINE DEDENT return res NEW_LINE DEDENT"]]}]}
{"id": "leetcode_179_A", "java": [{"id": "1", "code": "class Solution { private class LargerNumberComparator implements Comparator < String > { @ Override public int compare ( String a , String b ) { String order1 = a + b ; String order2 = b + a ; return order2 . compareTo ( order1 ) ; } } public String largestNumber ( int [ ] nums ) { String [ ] asStrs = new String [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { asStrs [ i ] = String . valueOf ( nums [ i ] ) ; } Arrays . sort ( asStrs , new LargerNumberComparator ( ) ) ; if ( asStrs [ 0 ] . equals ( \"0\" ) ) { return \"0\" ; } String largestNumberStr = new String ( ) ; for ( String numAsStr : asStrs ) { largestNumberStr += numAsStr ; } return largestNumberStr ; } }", "functions_standalone": [], "functions_class": [["compare", "public int compare ( String a , String b ) { String order1 = a + b ; String order2 = b + a ; return order2 . compareTo ( order1 ) ; }"], ["largestNumber", "public String largestNumber ( int [ ] nums ) { String [ ] asStrs = new String [ nums . length ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { asStrs [ i ] = String . valueOf ( nums [ i ] ) ; } Arrays . sort ( asStrs , new LargerNumberComparator ( ) ) ; if ( asStrs [ 0 ] . equals ( \"0\" ) ) { return \"0\" ; } String largestNumberStr = new String ( ) ; for ( String numAsStr : asStrs ) { largestNumberStr += numAsStr ; } return largestNumberStr ; }"]]}], "python": [{"id": "2", "code": "class LargerNumKey ( str ) : NEW_LINE INDENT def __lt__ ( x , y ) : NEW_LINE INDENT return x + y > y + x NEW_LINE DEDENT DEDENT class Solution : NEW_LINE INDENT def largestNumber ( self , nums ) : NEW_LINE INDENT largest_num = ' ' . join ( sorted ( map ( str , nums ) , key = LargerNumKey ) ) NEW_LINE return '0' if largest_num [ 0 ] == '0' else largest_num NEW_LINE DEDENT DEDENT", "functions_standalone": [["__lt__", "def __lt__ ( x , y ) : NEW_LINE INDENT return x + y > y + x NEW_LINE DEDENT"]], "functions_class": [["largestNumber", "def largestNumber ( self , nums ) : NEW_LINE INDENT largest_num = ' ' . join ( sorted ( map ( str , nums ) , key = LargerNumKey ) ) NEW_LINE return '0' if largest_num [ 0 ] == '0' else largest_num NEW_LINE DEDENT"]]}]}
{"id": "leetcode_541_A", "java": [{"id": "1", "code": "class Solution { public String reverseStr ( String s , int k ) { char [ ] a = s . toCharArray ( ) ; for ( int start = 0 ; start < a . length ; start += 2 * k ) { int i = start , j = Math . min ( start + k - 1 , a . length - 1 ) ; while ( i < j ) { char tmp = a [ i ] ; a [ i ++ ] = a [ j ] ; a [ j -- ] = tmp ; } } return new String ( a ) ; } }", "functions_standalone": [], "functions_class": [["reverseStr", "public String reverseStr ( String s , int k ) { char [ ] a = s . toCharArray ( ) ; for ( int start = 0 ; start < a . length ; start += 2 * k ) { int i = start , j = Math . min ( start + k - 1 , a . length - 1 ) ; while ( i < j ) { char tmp = a [ i ] ; a [ i ++ ] = a [ j ] ; a [ j -- ] = tmp ; } } return new String ( a ) ; }"]]}], "python": [{"id": "2", "code": "class Solution : NEW_LINE INDENT def reverseStr ( self , s : str , k : int ) -> str : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = \" \" NEW_LINE position = 0 NEW_LINE while position < N : NEW_LINE INDENT nx = s [ position : position + k ] NEW_LINE ans = ans + nx [ : : - 1 ] + s [ position + k : position + 2 * k ] NEW_LINE position += 2 * k NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT s1 = Solution ( ) NEW_LINE s = \" abcdefg \" NEW_LINE k = 2 NEW_LINE print ( s1 . reverseStr ( s , k ) ) NEW_LINE", "functions_standalone": [], "functions_class": [["reverseStr", "def reverseStr ( self , s : str , k : int ) -> str : NEW_LINE INDENT N = len ( s ) NEW_LINE ans = \" \" NEW_LINE position = 0 NEW_LINE while position < N : NEW_LINE INDENT nx = s [ position : position + k ] NEW_LINE ans = ans + nx [ : : - 1 ] + s [ position + k : position + 2 * k ] NEW_LINE position += 2 * k NEW_LINE DEDENT return ans NEW_LINE DEDENT"]]}]}
{"id": "leetcode_716_A", "java": [{"id": "1", "code": "class MaxStack { TreeMap < Integer , List < Node > > map ; DoubleLinkedList dll ; public MaxStack ( ) { map = new TreeMap ( ) ; dll = new DoubleLinkedList ( ) ; } public void push ( int x ) { Node node = dll . add ( x ) ; if ( ! map . containsKey ( x ) ) map . put ( x , new ArrayList < Node > ( ) ) ; map . get ( x ) . add ( node ) ; } public int pop ( ) { int val = dll . pop ( ) ; List < Node > L = map . get ( val ) ; L . remove ( L . size ( ) - 1 ) ; if ( L . isEmpty ( ) ) map . remove ( val ) ; return val ; } public int top ( ) { return dll . peek ( ) ; } public int peekMax ( ) { return map . lastKey ( ) ; } public int popMax ( ) { int max = peekMax ( ) ; List < Node > L = map . get ( max ) ; Node node = L . remove ( L . size ( ) - 1 ) ; dll . unlink ( node ) ; if ( L . isEmpty ( ) ) map . remove ( max ) ; return max ; } } class DoubleLinkedList { Node head , tail ; public DoubleLinkedList ( ) { head = new Node ( 0 ) ; tail = new Node ( 0 ) ; head . next = tail ; tail . prev = head ; } public Node add ( int val ) { Node x = new Node ( val ) ; x . next = tail ; x . prev = tail . prev ; tail . prev = tail . prev . next = x ; return x ; } public int pop ( ) { return unlink ( tail . prev ) . val ; } public int peek ( ) { return tail . prev . val ; } public Node unlink ( Node node ) { node . prev . next = node . next ; node . next . prev = node . prev ; return node ; } } class Node { int val ; Node prev , next ; public Node ( int v ) { val = v ; } }", "functions_standalone": [], "functions_class": [["MaxStack", "public MaxStack ( ) { map = new TreeMap ( ) ; dll = new DoubleLinkedList ( ) ; }"], ["push", "public void push ( int x ) { Node node = dll . add ( x ) ; if ( ! map . containsKey ( x ) ) map . put ( x , new ArrayList < Node > ( ) ) ; map . get ( x ) . add ( node ) ; }"], ["pop", "public int pop ( ) { int val = dll . pop ( ) ; List < Node > L = map . get ( val ) ; L . remove ( L . size ( ) - 1 ) ; if ( L . isEmpty ( ) ) map . remove ( val ) ; return val ; }"], ["top", "public int top ( ) { return dll . peek ( ) ; }"], ["peekMax", "public int peekMax ( ) { return map . lastKey ( ) ; }"], ["popMax", "public int popMax ( ) { int max = peekMax ( ) ; List < Node > L = map . get ( max ) ; Node node = L . remove ( L . size ( ) - 1 ) ; dll . unlink ( node ) ; if ( L . isEmpty ( ) ) map . remove ( max ) ; return max ; }"], ["DoubleLinkedList", "public DoubleLinkedList ( ) { head = new Node ( 0 ) ; tail = new Node ( 0 ) ; head . next = tail ; tail . prev = head ; }"], ["add", "public Node add ( int val ) { Node x = new Node ( val ) ; x . next = tail ; x . prev = tail . prev ; tail . prev = tail . prev . next = x ; return x ; }"], ["pop", "public int pop ( ) { return unlink ( tail . prev ) . val ; }"], ["peek", "public int peek ( ) { return tail . prev . val ; }"], ["unlink", "public Node unlink ( Node node ) { node . prev . next = node . next ; node . next . prev = node . prev ; return node ; }"], ["Node", "public Node ( int v ) { val = v ; }"]]}], "python": [{"id": "2", "code": "class MaxStack ( object ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["__init__", "def __init__ ( self ) : NEW_LINE INDENT self . stack = [ ] NEW_LINE self . max_stack = [ ] NEW_LINE DEDENT"], ["push", "def push ( self , x ) : NEW_LINE INDENT self . stack . append ( x ) NEW_LINE if len ( self . max_stack ) == 0 : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE return NEW_LINE DEDENT if self . max_stack [ - 1 ] > x : NEW_LINE INDENT self . max_stack . append ( self . max_stack [ - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT self . max_stack . append ( x ) NEW_LINE DEDENT DEDENT"], ["pop", "def pop ( self ) : NEW_LINE INDENT if len ( self . stack ) != 0 : NEW_LINE INDENT self . max_stack . pop ( - 1 ) NEW_LINE return self . stack . pop ( - 1 ) NEW_LINE DEDENT DEDENT"], ["top", "def top ( self ) : NEW_LINE INDENT return self . stack [ - 1 ] NEW_LINE DEDENT"], ["peekMax", "def peekMax ( self ) : NEW_LINE INDENT if len ( self . max_stack ) != 0 : NEW_LINE INDENT return self . max_stack [ - 1 ] NEW_LINE DEDENT DEDENT"], ["popMax", "def popMax ( self ) : NEW_LINE INDENT val = self . peekMax ( ) NEW_LINE buff = [ ] NEW_LINE while self . top ( ) != val : NEW_LINE INDENT buff . append ( self . pop ( ) ) NEW_LINE DEDENT self . pop ( ) NEW_LINE while len ( buff ) != 0 : NEW_LINE INDENT self . push ( buff . pop ( - 1 ) ) NEW_LINE DEDENT return val NEW_LINE DEDENT"]]}]}
{"id": "leetcode_720_A", "java": [{"id": "1", "code": "class Solution { public String longestWord ( String [ ] words ) { Trie trie = new Trie ( ) ; int index = 0 ; for ( String word : words ) { trie . insert ( word , ++ index ) ; } trie . words = words ; return trie . dfs ( ) ; } } class Node { char c ; HashMap < Character , Node > children = new HashMap ( ) ; int end ; public Node ( char c ) { this . c = c ; } } class Trie { Node root ; String [ ] words ; public Trie ( ) { root = new Node ( '0' ) ; } public void insert ( String word , int index ) { Node cur = root ; for ( char c : word . toCharArray ( ) ) { cur . children . putIfAbsent ( c , new Node ( c ) ) ; cur = cur . children . get ( c ) ; } cur . end = index ; } public String dfs ( ) { String ans = \" \" ; Stack < Node > stack = new Stack ( ) ; stack . push ( root ) ; while ( ! stack . empty ( ) ) { Node node = stack . pop ( ) ; if ( node . end > 0 || node == root ) { if ( node != root ) { String word = words [ node . end - 1 ] ; if ( word . length ( ) > ans . length ( ) || word . length ( ) == ans . length ( ) && word . compareTo ( ans ) < 0 ) { ans = word ; } } for ( Node nei : node . children . values ( ) ) { stack . push ( nei ) ; } } } return ans ; } }", "functions_standalone": [], "functions_class": [["longestWord", "public String longestWord ( String [ ] words ) { Trie trie = new Trie ( ) ; int index = 0 ; for ( String word : words ) { trie . insert ( word , ++ index ) ; } trie . words = words ; return trie . dfs ( ) ; }"], ["Node", "public Node ( char c ) { this . c = c ; }"], ["Trie", "public Trie ( ) { root = new Node ( '0' ) ; }"], ["insert", "public void insert ( String word , int index ) { Node cur = root ; for ( char c : word . toCharArray ( ) ) { cur . children . putIfAbsent ( c , new Node ( c ) ) ; cur = cur . children . get ( c ) ; } cur . end = index ; }"], ["dfs", "public String dfs ( ) { String ans = \" \" ; Stack < Node > stack = new Stack ( ) ; stack . push ( root ) ; while ( ! stack . empty ( ) ) { Node node = stack . pop ( ) ; if ( node . end > 0 || node == root ) { if ( node != root ) { String word = words [ node . end - 1 ] ; if ( word . length ( ) > ans . length ( ) || word . length ( ) == ans . length ( ) && word . compareTo ( ans ) < 0 ) { ans = word ; } } for ( Node nei : node . children . values ( ) ) { stack . push ( nei ) ; } } } return ans ; }"]]}], "python": [{"id": "2", "code": "class Solution ( object ) : NEW_LINE INDENT def longestWord ( self , words ) : NEW_LINE INDENT Trie = lambda : collections . defaultdict ( Trie ) NEW_LINE trie = Trie ( ) NEW_LINE END = True NEW_LINE for i , word in enumerate ( words ) : NEW_LINE INDENT reduce ( dict . __getitem__ , word , trie ) [ END ] = i NEW_LINE DEDENT stack = trie . values ( ) NEW_LINE ans = \" \" NEW_LINE while stack : NEW_LINE INDENT cur = stack . pop ( ) NEW_LINE if END in cur : NEW_LINE INDENT word = words [ cur [ END ] ] NEW_LINE if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : NEW_LINE INDENT ans = word NEW_LINE DEDENT stack . extend ( [ cur [ letter ] for letter in cur if letter != END ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT", "functions_standalone": [], "functions_class": [["longestWord", "def longestWord ( self , words ) : NEW_LINE INDENT Trie = lambda : collections . defaultdict ( Trie ) NEW_LINE trie = Trie ( ) NEW_LINE END = True NEW_LINE for i , word in enumerate ( words ) : NEW_LINE INDENT reduce ( dict . __getitem__ , word , trie ) [ END ] = i NEW_LINE DEDENT stack = trie . values ( ) NEW_LINE ans = \" \" NEW_LINE while stack : NEW_LINE INDENT cur = stack . pop ( ) NEW_LINE if END in cur : NEW_LINE INDENT word = words [ cur [ END ] ] NEW_LINE if len ( word ) > len ( ans ) or len ( word ) == len ( ans ) and word < ans : NEW_LINE INDENT ans = word NEW_LINE DEDENT stack . extend ( [ cur [ letter ] for letter in cur if letter != END ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT"]]}]}