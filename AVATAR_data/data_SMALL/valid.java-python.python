def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) ; NEW_LINE
start , end , k = input ( ) , input ( ) , int ( input ( ) ) NEW_LINE n , mod = len ( end ) , 10 ** 9 + 7 NEW_LINE dp = [ 1 , 0 ] NEW_LINE psum = 1 NEW_LINE for i in range ( k ) : NEW_LINE INDENT dp [ 0 ] = psum - dp [ 0 ] NEW_LINE dp [ 1 ] = psum - dp [ 1 ] NEW_LINE psum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if start [ i : ] + start [ : i ] == end : NEW_LINE INDENT if i == 0 : ans += dp [ 0 ] NEW_LINE else : ans += dp [ 1 ] NEW_LINE DEDENT DEDENT print ( ans % mod ) NEW_LINE
import sys NEW_LINE from operator import itemgetter NEW_LINE def solve ( data ) : NEW_LINE INDENT result = [ ] NEW_LINE for name , win , lose , draw in data : NEW_LINE INDENT score = win * 3 + draw * 1 NEW_LINE result . append ( [ name , score ] ) NEW_LINE DEDENT result . sort ( key = itemgetter ( 1 ) , reverse = True ) NEW_LINE return result NEW_LINE DEDENT def main ( args ) : NEW_LINE INDENT first_data_set = True NEW_LINE while True : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT data = [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT name , win , lose , draw = input ( ) . split ( ) NEW_LINE data . append ( [ name , int ( win ) , int ( lose ) , int ( draw ) ] ) NEW_LINE DEDENT result = solve ( data ) NEW_LINE if first_data_set : NEW_LINE INDENT first_data_set = False NEW_LINE DEDENT else : NEW_LINE INDENT print ( ) NEW_LINE DEDENT for r in result : NEW_LINE INDENT print ( ' , ' . join ( map ( str , r ) ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( sys . argv [ 1 : ] ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE lights = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if lights [ i - 1 ] == 1 and lights [ i ] == 0 and lights [ i + 1 ] == 1 : NEW_LINE INDENT lights [ i + 1 ] = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - ' A ' + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( strr , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 37 ) : NEW_LINE INDENT if ( toDeci ( strr [ i ] , j ) == x ) : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( counter == n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT x = 16 NEW_LINE strr = [ "10000" , "20" , "16" ] NEW_LINE checkCorrespond ( strr , x ) NEW_LINE
n = int ( input ( ) ) NEW_LINE li = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE res = [ n ] NEW_LINE p = n // 10 NEW_LINE i = 1 NEW_LINE while p > 0 : NEW_LINE INDENT rem = p % 10 NEW_LINE p //= 10 NEW_LINE j = li . index ( rem ) NEW_LINE if j == 0 : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT j = li [ j - 1 ] NEW_LINE res . append ( p * 10 ** ( i + 1 ) + j * 10 ** i + int ( '9' * i ) ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT maxsum = 0 NEW_LINE maxi = 0 NEW_LINE def getsum ( n ) : NEW_LINE INDENT res = 0 NEW_LINE while n > 0 : NEW_LINE INDENT res += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT for i in res : NEW_LINE INDENT if getsum ( i ) > maxsum : NEW_LINE INDENT maxsum = getsum ( i ) NEW_LINE maxi = i NEW_LINE DEDENT DEDENT print ( maxi ) NEW_LINE
def solve ( ) : NEW_LINE INDENT n , m , k = input ( ) . split ( " ▁ " ) NEW_LINE a = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE b = [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE ans = " NO " NEW_LINE i = len ( a ) - 1 NEW_LINE j = len ( b ) - 1 NEW_LINE while ( i >= 0 and j >= 0 ) : NEW_LINE INDENT if a [ i ] > b [ j ] : NEW_LINE INDENT ans = " YES " NEW_LINE print ( ans ) NEW_LINE return NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT if len ( a ) > len ( b ) : NEW_LINE INDENT ans = " YES " NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT solve ( ) NEW_LINE DEDENT main ( ) NEW_LINE
import heapq NEW_LINE tbl = [ ] NEW_LINE N = int ( input ( ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE tbl . append ( ( a , b ) ) NEW_LINE DEDENT tbl . sort ( ) NEW_LINE Q = [ ] NEW_LINE ans = s = sz = 0 NEW_LINE for t in tbl : NEW_LINE INDENT s += t [ 0 ] NEW_LINE heapq . heappush ( Q , ( t [ 1 ] , t [ 0 ] ) ) NEW_LINE sz += 1 NEW_LINE while sz and sz * Q [ 0 ] [ 0 ] < s : NEW_LINE INDENT s -= Q [ 0 ] [ 1 ] NEW_LINE heapq . heappop ( Q ) NEW_LINE sz -= 1 NEW_LINE DEDENT if sz > ans : ans = sz NEW_LINE DEDENT print ( ans ) NEW_LINE