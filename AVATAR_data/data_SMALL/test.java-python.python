import math NEW_LINE def sieve_of_erastosthenes ( num ) : NEW_LINE INDENT input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] NEW_LINE input_list [ 0 ] = input_list [ 1 ] = False NEW_LINE input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True NEW_LINE sqrt = math . sqrt ( num ) NEW_LINE for serial in range ( 3 , num , 2 ) : NEW_LINE INDENT if serial >= sqrt : NEW_LINE INDENT return input_list NEW_LINE DEDENT for s in range ( serial ** 2 , num , serial ) : NEW_LINE INDENT input_list [ s ] = False NEW_LINE DEDENT DEDENT DEDENT primeTable = sieve_of_erastosthenes ( 13 * ( 10 ** 5 ) ) NEW_LINE while True : NEW_LINE INDENT k = int ( input ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT break NEW_LINE DEDENT if primeTable [ k ] : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT i = k NEW_LINE while primeTable [ i ] is False : i += 1 NEW_LINE j = i - 1 NEW_LINE while primeTable [ j ] is False : j -= 1 NEW_LINE print ( i - j ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 ; NEW_LINE def countFreq ( str1 , freq , len1 ) : NEW_LINE INDENT for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len1 ) : NEW_LINE INDENT count_odd = 0 ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT if ( len1 % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 ; NEW_LINE odd_str += chr ( i + ord ( ' a ' ) ) ; NEW_LINE return odd_str ; NEW_LINE DEDENT DEDENT return odd_str ; NEW_LINE DEDENT def findPalindromicString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE freq = [ 0 ] * MAX_CHAR ; NEW_LINE countFreq ( str1 , freq , len1 ) ; NEW_LINE if ( canMakePalindrome ( freq , len1 ) == False ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " ; NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) ; NEW_LINE front_str = " " ; NEW_LINE rear_str = " ▁ " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " ; NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) ; NEW_LINE for j in range ( 1 , int ( freq [ i ] / 2 ) + 1 ) : NEW_LINE INDENT temp += ch ; NEW_LINE DEDENT front_str += temp ; NEW_LINE rear_str = temp + rear_str ; NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) ; NEW_LINE DEDENT str1 = " malayalam " ; NEW_LINE print ( findPalindromicString ( str1 ) ) ; NEW_LINE
import math NEW_LINE def cross ( a , b ) : NEW_LINE INDENT return a . real * b . imag - a . imag * b . real NEW_LINE DEDENT def dot ( a , b ) : NEW_LINE INDENT return a . real * b . real + a . imag * b . imag NEW_LINE DEDENT def norm2 ( a , b ) : NEW_LINE INDENT return ( b . real - a . real ) ** 2 + ( b . imag - a . imag ) ** 2 NEW_LINE DEDENT def is_intersect ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT ta = cross ( p1 - p0 , p2 - p0 ) NEW_LINE tb = cross ( p1 - p0 , p3 - p0 ) NEW_LINE tc = cross ( p3 - p2 , p0 - p2 ) NEW_LINE td = cross ( p3 - p2 , p1 - p2 ) NEW_LINE if ta * tb < 0 and tc * td < 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def distance_option ( p0 , p1 , p2 ) : NEW_LINE INDENT nn = norm2 ( p0 , p1 ) NEW_LINE if 0 <= dot ( p1 - p0 , p2 - p0 ) <= nn : NEW_LINE INDENT return abs ( cross ( p1 - p0 , p2 - p0 ) ) / math . sqrt ( nn ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . sqrt ( min ( norm2 ( p0 , p2 ) , norm2 ( p1 , p2 ) ) ) NEW_LINE DEDENT DEDENT def distance ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT if is_intersect ( p0 , p1 , p2 , p3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return min ( distance_option ( p0 , p1 , p2 ) , distance_option ( p0 , p1 , p3 ) , distance_option ( p2 , p3 , p0 ) , distance_option ( p2 , p3 , p1 ) ) NEW_LINE DEDENT DEDENT q = int ( input ( ) ) NEW_LINE for _ in [ 0 ] * q : NEW_LINE INDENT x_y = map ( int , input ( ) . split ( ) ) NEW_LINE p0 , p1 , p2 , p3 = [ x + y * 1j for x , y in zip ( * [ x_y ] * 2 ) ] NEW_LINE print ( " { : . 10f } " . format ( distance ( p0 , p1 , p2 , p3 ) ) ) NEW_LINE DEDENT
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE d = [ 0 for i in range ( 9 ) ] NEW_LINE d [ 0 ] = 1 NEW_LINE result = 0 NEW_LINE mod_sum = 0 NEW_LINE continuous_zero = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( number [ i ] ) - ord ( '0' ) == 0 ) : NEW_LINE INDENT continuous_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continuous_zero = 0 NEW_LINE DEDENT mod_sum += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE mod_sum %= 9 NEW_LINE result += d [ mod_sum ] NEW_LINE d [ mod_sum ] += 1 NEW_LINE result -= continuous_zero NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( count9s ( "01809" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE print ( count9s ( "4189" ) ) NEW_LINE DEDENT
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = fastPow ( N , int ( K / 2 ) ) ; NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp ; NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( countWays ( N , K ) ) ; NEW_LINE
NUM = ( 0b0111111 , 0b0000110 , 0b1011011 , 0b1001111 , 0b1100110 , 0b1101101 , 0b1111101 , 0b0100111 , 0b1111111 , 0b1101111 , ) NEW_LINE while 1 : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE if n == - 1 : break NEW_LINE current = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = NUM [ int ( input ( ) ) ] NEW_LINE print ( format ( current ^ num , ' b ' ) . zfill ( 7 ) ) NEW_LINE current = num NEW_LINE DEDENT DEDENT
MAX = 10000 NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 42 NEW_LINE if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE MAX = 100000 NEW_LINE prime = [ True ] * MAX NEW_LINE arr = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT def isPrimorialPrime ( n ) : NEW_LINE INDENT if not prime [ n ] : NEW_LINE INDENT return False NEW_LINE DEDENT product , i = 1 , 0 NEW_LINE while product < n : NEW_LINE INDENT product *= arr [ i ] NEW_LINE if product + 1 == n or product - 1 == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 31 NEW_LINE if ( isPrimorialPrime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def mul_table ( N , i ) : NEW_LINE INDENT if ( i > 10 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( N , " * " , i , " = " , N * i ) NEW_LINE return mul_table ( N , i + 1 ) NEW_LINE DEDENT N = 8 NEW_LINE mul_table ( N , 1 ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT n = 13 ; m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 ; m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 ; m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 ; m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE
def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = Len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT s = " fixprefixsuffix " NEW_LINE Longestsubstring ( s ) NEW_LINE
import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ minIndex - 1 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE
a = input ( ) . split ( ) NEW_LINE n = int ( a [ 0 ] ) NEW_LINE d = int ( a [ 1 ] ) NEW_LINE array = input ( ) . split ( ) NEW_LINE a = 0 NEW_LINE while a < n : NEW_LINE INDENT array [ a ] = int ( array [ a ] ) NEW_LINE a += 1 NEW_LINE DEDENT a = 0 NEW_LINE i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if array [ i ] >= array [ i + 1 ] : NEW_LINE INDENT a += ( array [ i ] - array [ i + 1 ] ) // d + 1 NEW_LINE array [ i + 1 ] += ( ( array [ i ] - array [ i + 1 ] ) // d + 1 ) * d NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( a ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input1 = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( 0 , len ( factor ) ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i ; NEW_LINE DEDENT DEDENT if ( product == input1 ) : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT DEDENT checkIfPowerIsolated ( 12 ) ; NEW_LINE checkIfPowerIsolated ( 18 ) ; NEW_LINE checkIfPowerIsolated ( 35 ) ; NEW_LINE
s , a , c = list ( input ( ) ) , 1 , 0 NEW_LINE for x in s : NEW_LINE INDENT if x == ' A ' and a : a = 0 NEW_LINE elif x == ' Z ' and not a : a , c = 1 , c + 1 NEW_LINE DEDENT print ( ' AZ ' * c if c else - 1 ) NEW_LINE