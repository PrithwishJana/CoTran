class TreeNode : NEW_LINE INDENT def __init__ ( self , rootData ) : NEW_LINE INDENT self . val = rootData NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Solution ( object ) : NEW_LINE INDENT def convertBST ( self , root ) : NEW_LINE INDENT total = 0 NEW_LINE node = root NEW_LINE stack = [ ] NEW_LINE while stack or node is not None : NEW_LINE INDENT while node is not None : NEW_LINE INDENT stack . append ( node ) NEW_LINE node = node . right NEW_LINE DEDENT node = stack . pop ( ) NEW_LINE total += node . val NEW_LINE node . val = total NEW_LINE node = node . left NEW_LINE DEDENT return root NEW_LINE DEDENT def printTree_vLR ( self , node , arr ) : NEW_LINE INDENT if node != None : NEW_LINE INDENT arr . append ( node . val ) NEW_LINE arr = self . printTree_vLR ( node . left , arr ) NEW_LINE arr = self . printTree_vLR ( node . right , arr ) NEW_LINE DEDENT return arr NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sObj = Solution ( ) NEW_LINE root1 = TreeNode ( 4 ) NEW_LINE root1 . left = TreeNode ( 1 ) NEW_LINE root1 . right = TreeNode ( 6 ) NEW_LINE root1 . left . left = TreeNode ( 0 ) NEW_LINE root1 . left . right = TreeNode ( 2 ) NEW_LINE root1 . right . left = TreeNode ( 5 ) NEW_LINE root1 . right . right = TreeNode ( 7 ) NEW_LINE root1 . left . right . right = TreeNode ( 3 ) NEW_LINE root1 . right . right . right = TreeNode ( 8 ) NEW_LINE out = sObj . convertBST ( root1 ) NEW_LINE arr = sObj . printTree_vLR ( out , [ ] ) NEW_LINE print ( arr ) NEW_LINE DEDENT
def countTriplets ( n , points ) : NEW_LINE INDENT pts = [ ] NEW_LINE ct = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pts . append ( points [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] + points [ j ] [ 0 ] ; NEW_LINE y = points [ i ] [ 1 ] + points [ j ] [ 1 ] ; NEW_LINE if ( x % 2 == 0 and y % 2 == 0 ) : NEW_LINE INDENT if [ x // 2 , y // 2 ] in pts : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] NEW_LINE n = len ( points ) NEW_LINE print ( countTriplets ( n , points ) ) NEW_LINE DEDENT
def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT
import sys , math , os , datetime NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT DAY = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if m == d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( DAY [ datetime . date ( 2004 , m , d ) . weekday ( ) ] ) NEW_LINE DEDENT
from datetime import * NEW_LINE for e in iter ( input , '0 ▁ 0' ) : print ( date ( 2004 , * map ( int , e . split ( ) ) ) . strftime ( ' % A ' ) ) NEW_LINE
import datetime NEW_LINE def main ( a , b ) : NEW_LINE INDENT dt = datetime . datetime ( 2004 , a , b ) NEW_LINE week_num = dt . weekday ( ) NEW_LINE if week_num == 0 : NEW_LINE INDENT print ( ' Monday ' ) NEW_LINE DEDENT elif week_num == 1 : NEW_LINE INDENT print ( ' Tuesday ' ) NEW_LINE DEDENT elif week_num == 2 : NEW_LINE INDENT print ( ' Wednesday ' ) NEW_LINE DEDENT elif week_num == 3 : NEW_LINE INDENT print ( ' Thursday ' ) NEW_LINE DEDENT elif week_num == 4 : NEW_LINE INDENT print ( ' Friday ' ) NEW_LINE DEDENT elif week_num == 5 : NEW_LINE INDENT print ( ' Saturday ' ) NEW_LINE DEDENT elif week_num == 6 : NEW_LINE INDENT print ( ' Sunday ' ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE DoD = [ " Thursday " , " Friday " , " Saturday " , " Sunday " , " Monday " , " Tuesday " , " Wednesday " ] NEW_LINE def getPNoD ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 29 + getPNoD ( n - 1 ) NEW_LINE DEDENT elif ( n % 2 == 0 and n <= 8 ) or ( n % 2 != 0 and n > 8 ) : NEW_LINE INDENT return 31 + getPNoD ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 30 + getPNoD ( n - 1 ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT m , d = [ int ( i ) for i in line . split ( ) ] NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = getPNoD ( m ) + d - 1 NEW_LINE print ( DoD [ n % 7 ] ) NEW_LINE DEDENT
days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT
import sys , math , os , datetime NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT DAY = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if m == d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( DAY [ datetime . date ( 2004 , m , d ) . weekday ( ) ] ) NEW_LINE DEDENT
from datetime import * NEW_LINE for e in iter ( input , '0 ▁ 0' ) : print ( date ( 2004 , * map ( int , e . split ( ) ) ) . strftime ( ' % A ' ) ) NEW_LINE
import datetime NEW_LINE def main ( a , b ) : NEW_LINE INDENT dt = datetime . datetime ( 2004 , a , b ) NEW_LINE week_num = dt . weekday ( ) NEW_LINE if week_num == 0 : NEW_LINE INDENT print ( ' Monday ' ) NEW_LINE DEDENT elif week_num == 1 : NEW_LINE INDENT print ( ' Tuesday ' ) NEW_LINE DEDENT elif week_num == 2 : NEW_LINE INDENT print ( ' Wednesday ' ) NEW_LINE DEDENT elif week_num == 3 : NEW_LINE INDENT print ( ' Thursday ' ) NEW_LINE DEDENT elif week_num == 4 : NEW_LINE INDENT print ( ' Friday ' ) NEW_LINE DEDENT elif week_num == 5 : NEW_LINE INDENT print ( ' Saturday ' ) NEW_LINE DEDENT elif week_num == 6 : NEW_LINE INDENT print ( ' Sunday ' ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE DoD = [ " Thursday " , " Friday " , " Saturday " , " Sunday " , " Monday " , " Tuesday " , " Wednesday " ] NEW_LINE def getPNoD ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 29 + getPNoD ( n - 1 ) NEW_LINE DEDENT elif ( n % 2 == 0 and n <= 8 ) or ( n % 2 != 0 and n > 8 ) : NEW_LINE INDENT return 31 + getPNoD ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 30 + getPNoD ( n - 1 ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT m , d = [ int ( i ) for i in line . split ( ) ] NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = getPNoD ( m ) + d - 1 NEW_LINE print ( DoD [ n % 7 ] ) NEW_LINE DEDENT
days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT
import sys , math , os , datetime NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT DAY = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if m == d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( DAY [ datetime . date ( 2004 , m , d ) . weekday ( ) ] ) NEW_LINE DEDENT
from datetime import * NEW_LINE for e in iter ( input , '0 ▁ 0' ) : print ( date ( 2004 , * map ( int , e . split ( ) ) ) . strftime ( ' % A ' ) ) NEW_LINE
import datetime NEW_LINE def main ( a , b ) : NEW_LINE INDENT dt = datetime . datetime ( 2004 , a , b ) NEW_LINE week_num = dt . weekday ( ) NEW_LINE if week_num == 0 : NEW_LINE INDENT print ( ' Monday ' ) NEW_LINE DEDENT elif week_num == 1 : NEW_LINE INDENT print ( ' Tuesday ' ) NEW_LINE DEDENT elif week_num == 2 : NEW_LINE INDENT print ( ' Wednesday ' ) NEW_LINE DEDENT elif week_num == 3 : NEW_LINE INDENT print ( ' Thursday ' ) NEW_LINE DEDENT elif week_num == 4 : NEW_LINE INDENT print ( ' Friday ' ) NEW_LINE DEDENT elif week_num == 5 : NEW_LINE INDENT print ( ' Saturday ' ) NEW_LINE DEDENT elif week_num == 6 : NEW_LINE INDENT print ( ' Sunday ' ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE DoD = [ " Thursday " , " Friday " , " Saturday " , " Sunday " , " Monday " , " Tuesday " , " Wednesday " ] NEW_LINE def getPNoD ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 29 + getPNoD ( n - 1 ) NEW_LINE DEDENT elif ( n % 2 == 0 and n <= 8 ) or ( n % 2 != 0 and n > 8 ) : NEW_LINE INDENT return 31 + getPNoD ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 30 + getPNoD ( n - 1 ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT m , d = [ int ( i ) for i in line . split ( ) ] NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = getPNoD ( m ) + d - 1 NEW_LINE print ( DoD [ n % 7 ] ) NEW_LINE DEDENT
days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT
import sys , math , os , datetime NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT DAY = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if m == d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( DAY [ datetime . date ( 2004 , m , d ) . weekday ( ) ] ) NEW_LINE DEDENT
from datetime import * NEW_LINE for e in iter ( input , '0 ▁ 0' ) : print ( date ( 2004 , * map ( int , e . split ( ) ) ) . strftime ( ' % A ' ) ) NEW_LINE
import datetime NEW_LINE def main ( a , b ) : NEW_LINE INDENT dt = datetime . datetime ( 2004 , a , b ) NEW_LINE week_num = dt . weekday ( ) NEW_LINE if week_num == 0 : NEW_LINE INDENT print ( ' Monday ' ) NEW_LINE DEDENT elif week_num == 1 : NEW_LINE INDENT print ( ' Tuesday ' ) NEW_LINE DEDENT elif week_num == 2 : NEW_LINE INDENT print ( ' Wednesday ' ) NEW_LINE DEDENT elif week_num == 3 : NEW_LINE INDENT print ( ' Thursday ' ) NEW_LINE DEDENT elif week_num == 4 : NEW_LINE INDENT print ( ' Friday ' ) NEW_LINE DEDENT elif week_num == 5 : NEW_LINE INDENT print ( ' Saturday ' ) NEW_LINE DEDENT elif week_num == 6 : NEW_LINE INDENT print ( ' Sunday ' ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE DoD = [ " Thursday " , " Friday " , " Saturday " , " Sunday " , " Monday " , " Tuesday " , " Wednesday " ] NEW_LINE def getPNoD ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 29 + getPNoD ( n - 1 ) NEW_LINE DEDENT elif ( n % 2 == 0 and n <= 8 ) or ( n % 2 != 0 and n > 8 ) : NEW_LINE INDENT return 31 + getPNoD ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 30 + getPNoD ( n - 1 ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT m , d = [ int ( i ) for i in line . split ( ) ] NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = getPNoD ( m ) + d - 1 NEW_LINE print ( DoD [ n % 7 ] ) NEW_LINE DEDENT
days = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE ans = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT idx = 3 NEW_LINE m , d = map ( int , input ( ) . split ( ) ) NEW_LINE if m == 0 : break NEW_LINE print ( ans [ ( idx + sum ( days [ : m - 1 ] ) + d - 1 ) % 7 ] ) NEW_LINE DEDENT
import sys , math , os , datetime NEW_LINE PYDEV = os . environ . get ( ' PYDEV ' ) NEW_LINE if PYDEV == " True " : NEW_LINE INDENT sys . stdin = open ( " sample - input . txt " , " rt " ) NEW_LINE DEDENT DAY = [ " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " ] NEW_LINE while True : NEW_LINE INDENT m , d = [ int ( _ ) for _ in input ( ) . split ( ) ] NEW_LINE if m == d == 0 : NEW_LINE INDENT break NEW_LINE DEDENT print ( DAY [ datetime . date ( 2004 , m , d ) . weekday ( ) ] ) NEW_LINE DEDENT
from datetime import * NEW_LINE for e in iter ( input , '0 ▁ 0' ) : print ( date ( 2004 , * map ( int , e . split ( ) ) ) . strftime ( ' % A ' ) ) NEW_LINE
import datetime NEW_LINE def main ( a , b ) : NEW_LINE INDENT dt = datetime . datetime ( 2004 , a , b ) NEW_LINE week_num = dt . weekday ( ) NEW_LINE if week_num == 0 : NEW_LINE INDENT print ( ' Monday ' ) NEW_LINE DEDENT elif week_num == 1 : NEW_LINE INDENT print ( ' Tuesday ' ) NEW_LINE DEDENT elif week_num == 2 : NEW_LINE INDENT print ( ' Wednesday ' ) NEW_LINE DEDENT elif week_num == 3 : NEW_LINE INDENT print ( ' Thursday ' ) NEW_LINE DEDENT elif week_num == 4 : NEW_LINE INDENT print ( ' Friday ' ) NEW_LINE DEDENT elif week_num == 5 : NEW_LINE INDENT print ( ' Saturday ' ) NEW_LINE DEDENT elif week_num == 6 : NEW_LINE INDENT print ( ' Sunday ' ) NEW_LINE DEDENT DEDENT while True : NEW_LINE INDENT a , b = [ int ( e ) for e in input ( ) . split ( ) ] NEW_LINE if a == 0 and b == 0 : NEW_LINE INDENT break NEW_LINE DEDENT main ( a , b ) NEW_LINE DEDENT
import sys NEW_LINE DoD = [ " Thursday " , " Friday " , " Saturday " , " Sunday " , " Monday " , " Tuesday " , " Wednesday " ] NEW_LINE def getPNoD ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 3 : NEW_LINE INDENT return 29 + getPNoD ( n - 1 ) NEW_LINE DEDENT elif ( n % 2 == 0 and n <= 8 ) or ( n % 2 != 0 and n > 8 ) : NEW_LINE INDENT return 31 + getPNoD ( n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 30 + getPNoD ( n - 1 ) NEW_LINE DEDENT DEDENT for line in sys . stdin : NEW_LINE INDENT m , d = [ int ( i ) for i in line . split ( ) ] NEW_LINE if m == 0 : NEW_LINE INDENT break NEW_LINE DEDENT n = getPNoD ( m ) + d - 1 NEW_LINE print ( DoD [ n % 7 ] ) NEW_LINE DEDENT
s = input ( ) NEW_LINE n = len ( s ) - 1 NEW_LINE sum = 0 NEW_LINE co1 = 1 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT sum += co1 NEW_LINE DEDENT co1 *= 2 NEW_LINE DEDENT co1 = 1 NEW_LINE l = 0 NEW_LINE while sum > co1 : NEW_LINE INDENT co1 *= 4 NEW_LINE l += 1 NEW_LINE DEDENT print ( l ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT x = int ( input ( ) . strip ( ) , 2 ) NEW_LINE n = 1 NEW_LINE z = 1 NEW_LINE while z < x : NEW_LINE INDENT z = 4 ** n NEW_LINE n += 1 NEW_LINE DEDENT print ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
x = int ( input ( ) , 2 ) NEW_LINE c = 1 NEW_LINE if c >= x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 100000000 ) : NEW_LINE INDENT c = 4 ** i NEW_LINE if c >= x : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = input ( ) NEW_LINE if ( n == "0" ) or ( n == "1" ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( n [ 0 ] == '1' ) and ( n [ 1 : ] == '0' * ( len ( n ) - 1 ) ) : NEW_LINE INDENT print ( ( len ( n ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( len ( n ) - 1 ) // 2 ) + 1 ) NEW_LINE DEDENT
n = int ( input ( ) , 2 ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT s = 4 ** i NEW_LINE if s >= n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) - 1 NEW_LINE sum = 0 NEW_LINE co1 = 1 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT sum += co1 NEW_LINE DEDENT co1 *= 2 NEW_LINE DEDENT co1 = 1 NEW_LINE l = 0 NEW_LINE while sum > co1 : NEW_LINE INDENT co1 *= 4 NEW_LINE l += 1 NEW_LINE DEDENT print ( l ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT x = int ( input ( ) . strip ( ) , 2 ) NEW_LINE n = 1 NEW_LINE z = 1 NEW_LINE while z < x : NEW_LINE INDENT z = 4 ** n NEW_LINE n += 1 NEW_LINE DEDENT print ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
x = int ( input ( ) , 2 ) NEW_LINE c = 1 NEW_LINE if c >= x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 100000000 ) : NEW_LINE INDENT c = 4 ** i NEW_LINE if c >= x : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = input ( ) NEW_LINE if ( n == "0" ) or ( n == "1" ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( n [ 0 ] == '1' ) and ( n [ 1 : ] == '0' * ( len ( n ) - 1 ) ) : NEW_LINE INDENT print ( ( len ( n ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( len ( n ) - 1 ) // 2 ) + 1 ) NEW_LINE DEDENT
n = int ( input ( ) , 2 ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT s = 4 ** i NEW_LINE if s >= n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) - 1 NEW_LINE sum = 0 NEW_LINE co1 = 1 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT sum += co1 NEW_LINE DEDENT co1 *= 2 NEW_LINE DEDENT co1 = 1 NEW_LINE l = 0 NEW_LINE while sum > co1 : NEW_LINE INDENT co1 *= 4 NEW_LINE l += 1 NEW_LINE DEDENT print ( l ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT x = int ( input ( ) . strip ( ) , 2 ) NEW_LINE n = 1 NEW_LINE z = 1 NEW_LINE while z < x : NEW_LINE INDENT z = 4 ** n NEW_LINE n += 1 NEW_LINE DEDENT print ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
x = int ( input ( ) , 2 ) NEW_LINE c = 1 NEW_LINE if c >= x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 100000000 ) : NEW_LINE INDENT c = 4 ** i NEW_LINE if c >= x : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = input ( ) NEW_LINE if ( n == "0" ) or ( n == "1" ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( n [ 0 ] == '1' ) and ( n [ 1 : ] == '0' * ( len ( n ) - 1 ) ) : NEW_LINE INDENT print ( ( len ( n ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( len ( n ) - 1 ) // 2 ) + 1 ) NEW_LINE DEDENT
n = int ( input ( ) , 2 ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT s = 4 ** i NEW_LINE if s >= n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
s = input ( ) NEW_LINE n = len ( s ) - 1 NEW_LINE sum = 0 NEW_LINE co1 = 1 NEW_LINE for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] == '1' : NEW_LINE INDENT sum += co1 NEW_LINE DEDENT co1 *= 2 NEW_LINE DEDENT co1 = 1 NEW_LINE l = 0 NEW_LINE while sum > co1 : NEW_LINE INDENT co1 *= 4 NEW_LINE l += 1 NEW_LINE DEDENT print ( l ) NEW_LINE
import sys NEW_LINE input = sys . stdin . readline NEW_LINE def print ( * args , end = ' \n ' , sep = ' ▁ ' ) -> None : NEW_LINE INDENT sys . stdout . write ( sep . join ( map ( str , args ) ) + end ) NEW_LINE DEDENT def Solve ( ) : NEW_LINE INDENT x = int ( input ( ) . strip ( ) , 2 ) NEW_LINE n = 1 NEW_LINE z = 1 NEW_LINE while z < x : NEW_LINE INDENT z = 4 ** n NEW_LINE n += 1 NEW_LINE DEDENT print ( n - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Solve ( ) NEW_LINE DEDENT
x = int ( input ( ) , 2 ) NEW_LINE c = 1 NEW_LINE if c >= x : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , 100000000 ) : NEW_LINE INDENT c = 4 ** i NEW_LINE if c >= x : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT
n = input ( ) NEW_LINE if ( n == "0" ) or ( n == "1" ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( n [ 0 ] == '1' ) and ( n [ 1 : ] == '0' * ( len ( n ) - 1 ) ) : NEW_LINE INDENT print ( ( len ( n ) ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( len ( n ) - 1 ) // 2 ) + 1 ) NEW_LINE DEDENT
n = int ( input ( ) , 2 ) NEW_LINE i = 0 NEW_LINE while True : NEW_LINE INDENT s = 4 ** i NEW_LINE if s >= n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( i ) NEW_LINE
def isBinary ( number ) : NEW_LINE INDENT while ( number > 0 ) : NEW_LINE INDENT digit = number % 10 NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT number //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000111 NEW_LINE if ( isBinary ( n ) == 1 ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT DEDENT
__author__ = ' Tianren ▁ Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( Choose , Target , p , dis ) : NEW_LINE INDENT if len ( dis ) - 1 + Choose < Target : NEW_LINE INDENT return 0. NEW_LINE DEDENT if Choose == 0 : NEW_LINE INDENT return dis [ Target ] NEW_LINE DEDENT if Choose > len ( p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ndis = np . zeros ( len ( dis ) + 1 ) NEW_LINE ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] ) NEW_LINE ndis [ 1 : ] += dis * p [ 0 ] NEW_LINE res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE p = [ float ( f ) for f in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( " Case ▁ # { } : ▁ { } " . format ( t + 1 , solve ( K , K // 2 , p , np . array ( [ 1. ] ) ) ) ) NEW_LINE DEDENT DEDENT
from multiprocessing import Pool NEW_LINE from pprint import pprint NEW_LINE import sys NEW_LINE def calcprob ( p ) : NEW_LINE INDENT prob = { } NEW_LINE k = len ( p ) NEW_LINE assert k % 2 == 0 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT prob [ ( 0 , j ) ] = 0 NEW_LINE DEDENT prob [ ( 0 , 0 ) ] = 1 NEW_LINE i = 0 NEW_LINE for pp in p : NEW_LINE INDENT i += 1 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT res = prob [ ( i - 1 , j ) ] * ( 1 - pp ) NEW_LINE if j > 0 : NEW_LINE INDENT res = res + prob [ ( i - 1 , j - 1 ) ] * pp NEW_LINE DEDENT prob [ ( i , j ) ] = res NEW_LINE DEDENT DEDENT return prob [ ( i , k // 2 ) ] NEW_LINE DEDENT def solve_test ( data ) : NEW_LINE INDENT n , k , p = data NEW_LINE p = sorted ( p ) NEW_LINE ans = - 1 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT left = i NEW_LINE right = k - i NEW_LINE pp = p [ : i ] + p [ n - right : ] NEW_LINE assert len ( pp ) == k NEW_LINE prob = calcprob ( pp ) NEW_LINE if prob > ans : NEW_LINE INDENT ans = prob NEW_LINE DEDENT DEDENT sys . stderr . write ( ' . ' ) NEW_LINE return ans NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for test in range ( tests ) : NEW_LINE INDENT sys . stderr . write ( str ( test ) ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE data . append ( ( n , k , p ) ) NEW_LINE DEDENT with Pool ( 6 ) as p : NEW_LINE INDENT res = p . map ( solve_test , data ) NEW_LINE DEDENT for test in range ( tests ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % 0.8f " % ( test + 1 , res [ test ] ) ) NEW_LINE DEDENT
def m ( p ) : NEW_LINE INDENT return lambda x : x * p NEW_LINE DEDENT def aa ( u , v ) : NEW_LINE INDENT for x , y in zip ( u , v ) : NEW_LINE INDENT yield x + y NEW_LINE DEDENT DEDENT def get_p ( a ) : NEW_LINE INDENT u = [ 1 ] NEW_LINE for x in a : NEW_LINE INDENT u = list ( aa ( [ 0 , 0 ] + list ( map ( m ( x ) , u ) ) , list ( map ( m ( 1 - x ) , u ) ) + [ 0 , 0 ] ) ) NEW_LINE DEDENT return u [ len ( u ) >> 1 ] NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = sorted ( list ( map ( float , input ( ) . split ( ) ) ) ) NEW_LINE r = 0 NEW_LINE for j in range ( k + 1 ) : NEW_LINE INDENT v = p [ : j ] + p [ : : - 1 ] [ : k - j ] NEW_LINE assert ( len ( v ) == k ) NEW_LINE r = max ( r , get_p ( v ) ) NEW_LINE DEDENT print ( " Case ▁ # % d : ▁ % .12f " % ( i + 1 , r ) ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import combinations NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = list ( map ( int , fin . readline ( ) . split ( ) ) ) NEW_LINE P = list ( map ( float , fin . readline ( ) . split ( ) ) ) NEW_LINE P . sort ( ) NEW_LINE M = K // 2 + 1 NEW_LINE best = ( 0 , [ ] ) NEW_LINE for c in range ( K + 1 ) : NEW_LINE INDENT combination = P [ : c ] NEW_LINE if c < K : NEW_LINE INDENT combination += P [ - ( K - c ) : ] NEW_LINE DEDENT s = [ 0 ] * M NEW_LINE s [ 0 ] = 1 NEW_LINE for a1 in combination : NEW_LINE INDENT a0 = 1 - a1 NEW_LINE ss = [ 0 ] * M NEW_LINE ss [ 0 ] = s [ 0 ] * a0 NEW_LINE for k in range ( M ) : NEW_LINE INDENT ss [ k ] = s [ k - 1 ] * a1 + s [ k ] * a0 NEW_LINE DEDENT s = ss NEW_LINE DEDENT best = max ( best , ( s [ - 1 ] , combination ) ) NEW_LINE DEDENT print ( " Case ▁ # % d : ▁ % s " % ( case , best [ 0 ] ) ) NEW_LINE DEDENT
__author__ = ' Tianren ▁ Liu ' NEW_LINE import sys NEW_LINE import numpy as np NEW_LINE def solve ( Choose , Target , p , dis ) : NEW_LINE INDENT if len ( dis ) - 1 + Choose < Target : NEW_LINE INDENT return 0. NEW_LINE DEDENT if Choose == 0 : NEW_LINE INDENT return dis [ Target ] NEW_LINE DEDENT if Choose > len ( p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ndis = np . zeros ( len ( dis ) + 1 ) NEW_LINE ndis [ : len ( dis ) ] += dis * ( 1 - p [ 0 ] ) NEW_LINE ndis [ 1 : ] += dis * p [ 0 ] NEW_LINE res = max ( solve ( Choose - 1 , Target , p [ 1 : ] , ndis ) , solve ( Choose , Target , p [ 1 : ] , dis ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) ) NEW_LINE for t in range ( T ) : NEW_LINE INDENT N , K = map ( int , sys . stdin . readline ( ) . split ( ) ) NEW_LINE p = [ float ( f ) for f in sys . stdin . readline ( ) . split ( ) ] NEW_LINE print ( " Case ▁ # { } : ▁ { } " . format ( t + 1 , solve ( K , K // 2 , p , np . array ( [ 1. ] ) ) ) ) NEW_LINE DEDENT DEDENT
from multiprocessing import Pool NEW_LINE from pprint import pprint NEW_LINE import sys NEW_LINE def calcprob ( p ) : NEW_LINE INDENT prob = { } NEW_LINE k = len ( p ) NEW_LINE assert k % 2 == 0 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT prob [ ( 0 , j ) ] = 0 NEW_LINE DEDENT prob [ ( 0 , 0 ) ] = 1 NEW_LINE i = 0 NEW_LINE for pp in p : NEW_LINE INDENT i += 1 NEW_LINE for j in range ( k // 2 + 1 ) : NEW_LINE INDENT res = prob [ ( i - 1 , j ) ] * ( 1 - pp ) NEW_LINE if j > 0 : NEW_LINE INDENT res = res + prob [ ( i - 1 , j - 1 ) ] * pp NEW_LINE DEDENT prob [ ( i , j ) ] = res NEW_LINE DEDENT DEDENT return prob [ ( i , k // 2 ) ] NEW_LINE DEDENT def solve_test ( data ) : NEW_LINE INDENT n , k , p = data NEW_LINE p = sorted ( p ) NEW_LINE ans = - 1 NEW_LINE for i in range ( k + 1 ) : NEW_LINE INDENT left = i NEW_LINE right = k - i NEW_LINE pp = p [ : i ] + p [ n - right : ] NEW_LINE assert len ( pp ) == k NEW_LINE prob = calcprob ( pp ) NEW_LINE if prob > ans : NEW_LINE INDENT ans = prob NEW_LINE DEDENT DEDENT sys . stderr . write ( ' . ' ) NEW_LINE return ans NEW_LINE DEDENT tests = int ( input ( ) ) NEW_LINE data = [ ] NEW_LINE for test in range ( tests ) : NEW_LINE INDENT sys . stderr . write ( str ( test ) ) NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = list ( map ( float , input ( ) . split ( ) ) ) NEW_LINE data . append ( ( n , k , p ) ) NEW_LINE DEDENT with Pool ( 6 ) as p : NEW_LINE INDENT res = p . map ( solve_test , data ) NEW_LINE DEDENT for test in range ( tests ) : NEW_LINE INDENT print ( " Case ▁ # % d : ▁ % 0.8f " % ( test + 1 , res [ test ] ) ) NEW_LINE DEDENT
def m ( p ) : NEW_LINE INDENT return lambda x : x * p NEW_LINE DEDENT def aa ( u , v ) : NEW_LINE INDENT for x , y in zip ( u , v ) : NEW_LINE INDENT yield x + y NEW_LINE DEDENT DEDENT def get_p ( a ) : NEW_LINE INDENT u = [ 1 ] NEW_LINE for x in a : NEW_LINE INDENT u = list ( aa ( [ 0 , 0 ] + list ( map ( m ( x ) , u ) ) , list ( map ( m ( 1 - x ) , u ) ) + [ 0 , 0 ] ) ) NEW_LINE DEDENT return u [ len ( u ) >> 1 ] NEW_LINE DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE p = sorted ( list ( map ( float , input ( ) . split ( ) ) ) ) NEW_LINE r = 0 NEW_LINE for j in range ( k + 1 ) : NEW_LINE INDENT v = p [ : j ] + p [ : : - 1 ] [ : k - j ] NEW_LINE assert ( len ( v ) == k ) NEW_LINE r = max ( r , get_p ( v ) ) NEW_LINE DEDENT print ( " Case ▁ # % d : ▁ % .12f " % ( i + 1 , r ) ) NEW_LINE DEDENT
import sys NEW_LINE from itertools import combinations NEW_LINE def debug ( * args ) : NEW_LINE INDENT print ( * args , file = sys . stderr ) NEW_LINE DEDENT fin = sys . stdin NEW_LINE T = int ( fin . readline ( ) ) NEW_LINE for case in range ( 1 , T + 1 ) : NEW_LINE INDENT N , K = list ( map ( int , fin . readline ( ) . split ( ) ) ) NEW_LINE P = list ( map ( float , fin . readline ( ) . split ( ) ) ) NEW_LINE P . sort ( ) NEW_LINE M = K // 2 + 1 NEW_LINE best = ( 0 , [ ] ) NEW_LINE for c in range ( K + 1 ) : NEW_LINE INDENT combination = P [ : c ] NEW_LINE if c < K : NEW_LINE INDENT combination += P [ - ( K - c ) : ] NEW_LINE DEDENT s = [ 0 ] * M NEW_LINE s [ 0 ] = 1 NEW_LINE for a1 in combination : NEW_LINE INDENT a0 = 1 - a1 NEW_LINE ss = [ 0 ] * M NEW_LINE ss [ 0 ] = s [ 0 ] * a0 NEW_LINE for k in range ( M ) : NEW_LINE INDENT ss [ k ] = s [ k - 1 ] * a1 + s [ k ] * a0 NEW_LINE DEDENT s = ss NEW_LINE DEDENT best = max ( best , ( s [ - 1 ] , combination ) ) NEW_LINE DEDENT print ( " Case ▁ # % d : ▁ % s " % ( case , best [ 0 ] ) ) NEW_LINE DEDENT
def findElement ( arr , size ) : NEW_LINE INDENT right_mul = 1 ; NEW_LINE left_mul = 1 ; NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT right_mul = right_mul * arr [ i ] ; NEW_LINE DEDENT for i , j in zip ( range ( 0 , size ) , range ( 1 , size , 1 ) ) : NEW_LINE INDENT right_mul = right_mul / arr [ j ] ; NEW_LINE left_mul = left_mul * arr [ i ] ; NEW_LINE if ( left_mul == right_mul ) : NEW_LINE INDENT return arr [ i + 1 ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 4 , 6 , ] ; NEW_LINE size = len ( arr ) ; NEW_LINE print ( findElement ( arr , size ) ) ; NEW_LINE
def NumberOfSolutions ( x , y , z , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT temp = n - i - j NEW_LINE if temp >= 0 : NEW_LINE INDENT temp = min ( temp , z ) NEW_LINE ans += temp + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z , n = 1 , 2 , 3 , 4 NEW_LINE print ( NumberOfSolutions ( x , y , z , n ) ) NEW_LINE DEDENT
num = int ( input ( ) ) NEW_LINE minimo = [ ] NEW_LINE maximo = [ ] NEW_LINE cresc = 0 NEW_LINE decr = 0 NEW_LINE for a in range ( num ) : NEW_LINE INDENT seq = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE seq . reverse ( ) NEW_LINE seq . pop ( ) NEW_LINE seq . reverse ( ) NEW_LINE for b in range ( len ( seq ) ) : NEW_LINE INDENT if b > 0 and seq [ b ] > seq [ b - 1 ] : NEW_LINE INDENT cresc += 1 NEW_LINE break NEW_LINE DEDENT elif b == len ( seq ) - 1 : NEW_LINE INDENT decr += 1 NEW_LINE minimo . append ( min ( seq ) ) NEW_LINE maximo . append ( max ( seq ) ) NEW_LINE DEDENT DEDENT DEDENT res = ( cresc * cresc ) + ( 2 * ( cresc * decr ) ) NEW_LINE minimo . sort ( ) NEW_LINE maximo . sort ( ) NEW_LINE i = 0 NEW_LINE for c in maximo : NEW_LINE INDENT while i < decr and minimo [ i ] < c : NEW_LINE INDENT i += 1 NEW_LINE DEDENT res += i NEW_LINE DEDENT print ( res ) NEW_LINE
n = int ( input ( ) ) NEW_LINE first = [ ] NEW_LINE last = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT line = [ int ( i ) for i in input ( ) . split ( ) [ 1 : ] ] NEW_LINE if line == sorted ( line , key = lambda x : - x ) : NEW_LINE INDENT first . append ( line [ 0 ] ) NEW_LINE last . append ( line [ - 1 ] ) NEW_LINE DEDENT DEDENT first . sort ( ) NEW_LINE last . sort ( ) NEW_LINE ans = n * n NEW_LINE ptr = 0 NEW_LINE for i in range ( len ( last ) ) : NEW_LINE INDENT while ptr < len ( first ) and last [ i ] >= first [ ptr ] : NEW_LINE INDENT ptr += 1 NEW_LINE DEDENT ans -= ptr NEW_LINE DEDENT print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE menores , maiores , asc , nasc = [ ] , [ ] , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i > 0 and s [ i ] > s [ i - 1 ] : NEW_LINE INDENT asc += 1 NEW_LINE break NEW_LINE DEDENT elif i == len ( s ) - 1 : NEW_LINE INDENT nasc += 1 NEW_LINE menores . append ( min ( s ) ) NEW_LINE maiores . append ( max ( s ) ) NEW_LINE DEDENT DEDENT DEDENT resposta = asc * asc + 2 * asc * nasc NEW_LINE menores . sort ( ) NEW_LINE maiores . sort ( ) NEW_LINE i = 0 NEW_LINE for x in maiores : NEW_LINE INDENT while i < nasc and menores [ i ] < x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT resposta += i NEW_LINE DEDENT print ( resposta ) NEW_LINE
n = int ( input ( ) ) NEW_LINE menores , maiores , asc , nasc = [ ] , [ ] , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s = list ( map ( int , input ( ) . split ( ) ) ) [ 1 : ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if i > 0 and s [ i ] > s [ i - 1 ] : NEW_LINE INDENT asc += 1 NEW_LINE break NEW_LINE DEDENT elif i == len ( s ) - 1 : NEW_LINE INDENT nasc += 1 NEW_LINE menores . append ( min ( s ) ) NEW_LINE maiores . append ( max ( s ) ) NEW_LINE DEDENT DEDENT DEDENT resposta = asc * asc + 2 * asc * nasc NEW_LINE menores . sort ( ) NEW_LINE maiores . sort ( ) NEW_LINE i = 0 NEW_LINE for x in maiores : NEW_LINE INDENT while i < nasc and menores [ i ] < x : NEW_LINE INDENT i += 1 NEW_LINE DEDENT resposta += i NEW_LINE DEDENT print ( resposta ) NEW_LINE