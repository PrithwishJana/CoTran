import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) throws NumberFormatException , IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrimeNumberGenerator pg = new PrimeNumberGenerator ( ) ; while ( true ) { int n = Integer . parseInt ( br . readLine ( ) ) ; if ( n == 0 ) { break ; } if ( pg . isPrime ( n ) ) { System . out . println ( 0 ) ; continue ; } int begin = - 1 ; int end = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( pg . isPrime ( i ) ) { begin = i ; break ; } } for ( int i = n + 1 ; i < 2000000 ; i ++ ) { if ( pg . isPrime ( i ) ) { end = i ; break ; } } System . out . println ( end - begin ) ; } } } class PrimeNumberGenerator { private final int N = 2000000 ; private boolean [ ] isPrime = new boolean [ N + 1 ] ; public PrimeNumberGenerator ( ) { Arrays . fill ( isPrime , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; int limit = ( int ) Math . sqrt ( N ) ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( isPrime [ i ] == false ) { continue ; } for ( int j = i * 2 ; j <= N ; j += i ) { isPrime [ j ] = false ; } } } public boolean isPrime ( int index ) { return isPrime [ index ] ; } }
public class GFG { static char MAX_CHAR = 26 ; static void countFreq ( String str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static boolean canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { count_odd ++ ; } } if ( len % 2 == 0 ) { if ( count_odd > 0 ) { return false ; } else { return true ; } } if ( count_odd != 1 ) { return false ; } return true ; } static String findOddAndRemoveItsFreq ( int freq [ ] ) { String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static String findPalindromicString ( String str ) { int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) { return " No ▁ Palindromic ▁ String " ; } String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) { temp = temp + ch ; } front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } public static void main ( String [ ] args ) { String str = " malayalam " ; System . out . println ( findPalindromicString ( str ) ) ; } }
import java . awt . geom . Line2D ; import java . util . * ; public class Main { Scanner in = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { new Main ( ) ; } public Main ( ) { int q = in . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) new CGL_2B ( ) . doIt ( ) ; } class CGL_2B { double segSegDist ( Line2D l1 , Line2D l2 ) { return l1 . intersectsLine ( l2 ) ? 0 : Math . min ( Math . min ( l1 . ptSegDist ( l2 . getP1 ( ) ) , l1 . ptSegDist ( l2 . getP2 ( ) ) ) , Math . min ( l2 . ptSegDist ( l1 . getP1 ( ) ) , l2 . ptSegDist ( l1 . getP2 ( ) ) ) ) ; } void doIt ( ) { Line2D l1 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; Line2D l2 = new Line2D . Double ( in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) , in . nextDouble ( ) ) ; ; System . out . printf ( " % .10f \n " , segSegDist ( l1 , l2 ) ) ; } } }
public class GFG { static int count9s ( char number [ ] ) { int n = number . length ; int d [ ] = new int [ 9 ] ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( number [ i ] - '0' ) == 0 ) { continuous_zero ++ ; } else { continuous_zero = 0 ; } mod_sum += ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( count9s ( "01809" . toCharArray ( ) ) ) ; System . out . println ( count9s ( "1809" . toCharArray ( ) ) ) ; System . out . println ( count9s ( "4189" . toCharArray ( ) ) ) ; } }
import java . io . * ; public class GFG { static int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } static int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; System . out . println ( countWays ( N , K ) ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] [ ] s = { { 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 0 , 0 , 0 , 0 , 1 , 1 , 0 } , { 1 , 0 , 1 , 1 , 0 , 1 , 1 } , { 1 , 0 , 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 1 , 0 } , { 1 , 1 , 0 , 1 , 1 , 0 , 1 } , { 1 , 1 , 1 , 1 , 1 , 0 , 1 } , { 0 , 1 , 0 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 , 1 , 1 , 1 } } ; for ( ; ; ) { int n = sc . nextInt ( ) ; int [ ] a = new int [ 7 ] ; if ( n == - 1 ) { break ; } while ( n -- > 0 ) { int m = sc . nextInt ( ) ; for ( int i = 0 ; i < 7 ; i ++ ) { System . out . print ( ( a [ i ] ^ s [ m ] [ i ] ) + ( i == 6 ? " \n " : " " ) ) ; } a = s [ m ] . clone ( ) ; } } } }
import java . util . * ; public class GFG { static final int MAX = 10000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isEuclid ( long n ) { long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class GFG { static final int MAX = 1000000 ; static Vector < Integer > arr = new Vector < Integer > ( ) ; static boolean [ ] prime = new boolean [ MAX ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . add ( p ) ; } static boolean isPrimorialPrime ( int n ) { if ( ! prime [ n ] ) return false ; long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr . get ( i ) ; if ( product + 1 == n || product - 1 == n ) return true ; i ++ ; } return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isPrimorialPrime ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
public class GFG { static void mul_table ( int N , int i ) { if ( i > 10 ) return ; System . out . println ( N + " ▁ * ▁ " + i + " ▁ = ▁ " + N * i ) ; mul_table ( N , i + 1 ) ; } public static void main ( String [ ] args ) { int N = 8 ; mul_table ( N , 1 ) ; } }
public class close_to_n_divisible_m { static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; } public static void main ( String args [ ] ) { int n = 13 , m = 4 ; System . out . println ( closestNumber ( n , m ) ) ; n = - 15 ; m = 6 ; System . out . println ( closestNumber ( n , m ) ) ; n = 0 ; m = 8 ; System . out . println ( closestNumber ( n , m ) ) ; n = 18 ; m = - 7 ; System . out . println ( closestNumber ( n , m ) ) ; } }
public class GFG { static int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } public static void main ( String [ ] args ) { int ang = 90 , n = 4 ; System . out . println ( solve ( ang , n ) ) ; } }
public class GFG { static int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } static void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } public static void main ( String [ ] args ) { String s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
import java . io . * ; public class GFG { static void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = Integer . MAX_VALUE ; int maxEle = Integer . MIN_VALUE ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } boolean flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } boolean flag2 = true ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( minIndex == 0 ) { System . out . print ( " NO " ) ; return ; } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ minIndex - 1 ] ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . length ; checkIfSortRotated ( arr , n ) ; } }
import java . util . Scanner ; public class IS { public static void main ( String [ ] args ) { new IS ( ) . runapp ( ) ; } void runapp ( ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int d = scan . nextInt ( ) ; int [ ] sequence = new int [ n ] ; int step = 0 ; int store ; for ( int x = 0 ; x < n ; x ++ ) { sequence [ x ] = scan . nextInt ( ) ; } for ( int y = 0 ; y < n - 1 ; y ++ ) { while ( sequence [ y + 1 ] <= sequence [ y ] ) { int diff = sequence [ y + 1 ] - sequence [ y ] ; if ( sequence [ y + 1 ] == sequence [ y ] ) { sequence [ y + 1 ] = sequence [ y + 1 ] + d ; step = step + 1 ; } else { diff = - diff ; store = ( diff / d ) + 1 ; step = step + store ; sequence [ y + 1 ] = sequence [ y + 1 ] + ( d * store ) ; } } } System . out . printf ( " % d " , step ) ; } }
public class GFG { static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) System . out . print ( " Power - isolated ▁ Integer \n " ) ; else System . out . print ( " Not ▁ a ▁ Power - isolated ▁ Integer \n " ) ; } public static void main ( String [ ] args ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] s = sc . next ( ) . toCharArray ( ) ; int len = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( len % 2 == 0 && s [ i ] == ' A ' || len % 2 == 1 && s [ i ] == ' Z ' ) { len ++ ; } } len /= 2 ; if ( len == 0 ) { System . out . println ( - 1 ) ; } else { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i ++ ) { sb . append ( " AZ " ) ; } System . out . println ( sb . toString ( ) ) ; } } }